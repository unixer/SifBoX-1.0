diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
index a6b8912..aecfb74 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
@@ -78,6 +78,8 @@
 
 #ifdef HAS_IMXVPU
 #include "windowing/egl/EGLWrapper.h"
+#include "DVDCodecs/Video/DVDVideoCodecIMX.h"
+
 #define GL_VIV_NV12 0x8FC1
 typedef void (GL_APIENTRYP PFNGLTEXDIRECTVIVMAPPROC) (GLenum Target, GLsizei Width, GLsizei Height, GLenum Format, GLvoid ** Logical, const GLuint * Physical);
 typedef void (GL_APIENTRYP PFNGLTEXDIRECTINVALIDATEVIVPROC) (GLenum Target);
@@ -1638,7 +1640,15 @@ void CLinuxRendererGLES::RenderIMXMAPTexture(int index, int field)
   YUVPLANE &plane = m_buffers[index].fields[field][0];
   CDVDVideoCodecBuffer* codecinfo = m_buffers[index].codecinfo;
 
-  if((codecinfo == NULL) || !codecinfo->IsValid()) return;
+  if(codecinfo == NULL) return;
+
+  CDVDVideoCodecIMX::Enter();
+
+  if(!codecinfo->IsValid())
+  {
+    CDVDVideoCodecIMX::Leave();
+    return;
+  }
 
   glDisable(GL_DEPTH_TEST);
 
@@ -1691,6 +1701,8 @@ void CLinuxRendererGLES::RenderIMXMAPTexture(int index, int field)
   glBindTexture(m_textureTarget, 0);
   VerifyGLState();
 
+  CDVDVideoCodecIMX::Leave();
+
 #ifdef DEBUG_VERBOSE
   CLog::Log(LOGDEBUG, "RenderIMXMAPTexture %d: tm:%d\n", index, XbmcThreads::SystemClockMillis() - time);
 #endif
@@ -2711,12 +2723,40 @@ void CLinuxRendererGLES::SetTextureFilter(GLenum method)
 void CLinuxRendererGLES::UploadIMXMAPTexture(int index)
 {
 #ifdef HAS_IMXVPU
-  YUVBUFFER& buf    =  m_buffers[index];
+  YUVBUFFER& buf =  m_buffers[index];
   CDVDVideoCodecBuffer* codecinfo = buf.codecinfo;
 
-  if(codecinfo && codecinfo->IsValid())
+  if(codecinfo)
   {
+    CDVDVideoCodecIMX::Enter();
+
+    if(!codecinfo->IsValid())
+    {
+      CDVDVideoCodecIMX::Leave();
+      return;
+    }
+
     YUVPLANE &plane = m_buffers[index].fields[0][0];
+    CDVDVideoCodecIPUBuffers *deinterlacer = (CDVDVideoCodecIPUBuffers*)codecinfo->data[2];
+
+    if (deinterlacer)
+    {
+      EDEINTERLACEMODE deinterlacemode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+
+      if (deinterlacemode != VS_DEINTERLACEMODE_OFF)
+      {
+        CDVDVideoCodecBuffer *deint;
+        EINTERLACEMETHOD interlacemethod = CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod;
+        deint = deinterlacer->Process(codecinfo, interlacemethod == VS_INTERLACEMETHOD_DEINTERLACE, buf.doubled);
+        if (deint)
+        {
+          SAFE_RELEASE(buf.codecinfo);
+          buf.codecinfo = deint;
+          buf.codecinfo->Lock();
+          codecinfo = buf.codecinfo;
+        }
+      }
+    }
 
     glActiveTexture(GL_TEXTURE0);
     glBindTexture(m_textureTarget, plane.id);
@@ -2734,6 +2774,8 @@ void CLinuxRendererGLES::UploadIMXMAPTexture(int index)
     plane.texheight = codecinfo->iHeight;
 
     CalculateTextureSourceRects(index, 1);
+
+    CDVDVideoCodecIMX::Leave();
   }
 
 #endif
@@ -2848,9 +2890,14 @@ bool CLinuxRendererGLES::Supports(EDEINTERLACEMODE mode)
   if(m_renderMethod & RENDER_CVREF)
     return false;
 
+#ifdef HAS_IMXVPU
+  if(mode == VS_DEINTERLACEMODE_AUTO)
+    return true;
+#else
   if(mode == VS_DEINTERLACEMODE_AUTO
   || mode == VS_DEINTERLACEMODE_FORCE)
     return true;
+#endif
 
   return false;
 }
@@ -2879,6 +2926,15 @@ bool CLinuxRendererGLES::Supports(EINTERLACEMETHOD method)
   if(method == VS_INTERLACEMETHOD_AUTO)
     return true;
 
+  if(m_renderMethod & RENDER_IMXMAP)
+  {
+    if(method == VS_INTERLACEMETHOD_DEINTERLACE
+    || method == VS_INTERLACEMETHOD_DEINTERLACE_HALF)
+      return true;
+    else
+      return false;
+  }
+
 #if defined(__i386__) || defined(__x86_64__)
   if(method == VS_INTERLACEMETHOD_DEINTERLACE
   || method == VS_INTERLACEMETHOD_DEINTERLACE_HALF
@@ -2927,6 +2983,9 @@ EINTERLACEMETHOD CLinuxRendererGLES::AutoInterlaceMethod()
   if(m_renderMethod & RENDER_CVREF)
     return VS_INTERLACEMETHOD_NONE;
 
+  if(m_renderMethod & RENDER_IMXMAP)
+    return VS_INTERLACEMETHOD_DEINTERLACE_HALF;
+
 #if defined(__i386__) || defined(__x86_64__)
   return VS_INTERLACEMETHOD_DEINTERLACE_HALF;
 #else
@@ -3011,13 +3070,15 @@ void CLinuxRendererGLES::AddProcessor(CDVDMediaCodecInfo *mediacodec, int index)
 }
 #endif
 
-void CLinuxRendererGLES::AddProcessor(CDVDVideoCodecBuffer *codecinfo, int index)
+void CLinuxRendererGLES::AddProcessor(CDVDVideoCodecBuffer *codecinfo, bool doubled, int index)
 {
   YUVBUFFER &buf = m_buffers[index];
 
   SAFE_RELEASE(buf.codecinfo);
   buf.codecinfo = codecinfo;
-
+#ifdef HAS_IMXVPU
+  buf.doubled = doubled;
+#endif
   if (codecinfo)
     codecinfo->Lock();
 }
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
index 8630d9b..990bb2b 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
@@ -175,7 +175,7 @@ class CLinuxRendererGLES : public CBaseRenderer
   // mediaCodec
   virtual void         AddProcessor(CDVDMediaCodecInfo *mediacodec, int index);
 #endif
-  virtual void         AddProcessor(CDVDVideoCodecBuffer *codecinfo, int index);
+  virtual void         AddProcessor(CDVDVideoCodecBuffer *codecinfo, bool doubled, int index);
 
 protected:
   virtual void Render(DWORD flags, int index);
@@ -299,6 +299,9 @@ class CLinuxRendererGLES : public CBaseRenderer
     CDVDMediaCodecInfo *mediacodec;
 #endif
     CDVDVideoCodecBuffer *codecinfo;
+#ifdef HAS_IMXVPU
+    bool doubled;
+#endif
   };
 
   typedef YUVBUFFER          YUVBUFFERS[NUM_BUFFERS];
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 9a630b8..a78f33b 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -930,7 +930,7 @@ int CXBMCRenderManager::AddVideoPicture(DVDVideoPicture& pic)
 #endif
 #ifdef HAS_IMXVPU
   else if(pic.format == RENDER_FMT_YV12_BUFFER || pic.format == RENDER_FMT_IMXMAP)
-    m_pRenderer->AddProcessor(pic.codecinfo, index);
+    m_pRenderer->AddProcessor(pic.codecinfo, pic.doubled, index);
 #endif
 
   m_pRenderer->ReleaseImage(index, false);
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
index 2ee8211..68ffe97 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -29,7 +29,7 @@
 #include "cores/VideoRenderers/RenderFormats.h"
 #include "DVDVideoCodecInfo.h"
 
-struct DVDCodecAvailableType 
+struct DVDCodecAvailableType
 {
   AVCodecID codec;
   const char* setting;
@@ -92,9 +92,10 @@ struct DVDVideoPicture
     struct {
       CDVDMediaCodecInfo *mediacodec;
     };
-  
+
     struct {
       CDVDVideoCodecBuffer *codecinfo;
+      bool doubled;
     };
 
   };
@@ -194,7 +195,7 @@ class CDVDVideoCodec
   /*
    * returns true if successfull
    * the data is cleared to zero
-   */ 
+   */
   virtual bool ClearPicture(DVDVideoPicture* pDvdVideoPicture)
   {
     memset(pDvdVideoPicture, 0, sizeof(DVDVideoPicture));
@@ -280,7 +281,7 @@ class CDVDVideoCodec
   virtual unsigned GetAllowedReferences() { return 0; }
 
   /**
-   * Hide or Show Settings depending on the currently running hardware 
+   * Hide or Show Settings depending on the currently running hardware
    *
    */
    static bool IsSettingVisible(const std::string &condition, const std::string &value, const std::string &settingId);
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
index a6f3712..7bb2282 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.cpp
@@ -43,6 +43,7 @@
 // Extrace physical and virtual addresses from CDVDVideoCodecBuffer pointers
 #define GET_PHYS_ADDR(buf) (buf)->data[1]
 #define GET_VIRT_ADDR(buf) (buf)->data[0]
+#define GET_DEINTERLACER(buf) (buf)->data[2]
 
 // Experiments show that we need at least one more (+1) V4L buffer than the min value returned by the VPU
 const int CDVDVideoCodecIMX::m_extraVpuBuffers = 6;
@@ -232,6 +233,7 @@ bool CDVDVideoCodecIMX::VpuAllocFrameBuffers(void)
   unsigned char* ptrVirt;
   int nAlign;
 
+  m_doubleRateInit = 0;
   m_vpuFrameBufferNum =  m_initInfo.nMinFrameBufferCount + m_extraVpuBuffers;
   m_vpuFrameBuffers = new VpuFrameBuffer[m_vpuFrameBufferNum];
 
@@ -319,25 +321,22 @@ bool CDVDVideoCodecIMX::VpuAllocFrameBuffers(void)
 #endif
   }
 
-  if (m_initInfo.nInterlace && (m_modeDeinterlace>0))
+  if (m_initInfo.nInterlace)
   {
-    if ((m_initInfo.nPicWidth>1024) || (m_initInfo.nPicHeight>1024))
+    CLog::Log(LOGNOTICE, "IMX: Enable hardware deinterlacing\n");
+    if (!m_deinterlacer.Init(m_initInfo.nPicWidth, m_initInfo.nPicHeight, GetAllowedReferences()+1, nAlign))
     {
-      CLog::Log(LOGNOTICE, "IMX: Disable hardware deinterlacing for HD playback\n");
-      m_modeDeinterlace = 0;
+      CLog::Log(LOGWARNING, "IMX: Failed to initialize IPU buffers: deinterlacing disabled\n");
     }
     else
     {
-      CLog::Log(LOGNOTICE, "IMX: Enable hardware deinterlacing\n");
-      if (!m_deinterlacer.Init(m_initInfo.nPicWidth, m_initInfo.nPicHeight, GetAllowedReferences()+1, nAlign))
-      {
-        CLog::Log(LOGWARNING, "IMX: Failed to initialize IPU buffers: deinterlacing disabled\n");
-        m_modeDeinterlace = 0;
-      }
+      for (int i=0; i<m_vpuFrameBufferNum; i++)
+        GET_DEINTERLACER(m_outputBuffers[i]) = (uint8_t*)&m_deinterlacer;
+
+      if (m_initInfo.nPicWidth<1024 && m_initInfo.nPicHeight<1024)
+        m_doubleRateInit = 1;
     }
   }
-  else
-    m_modeDeinterlace = 0;
 
   return true;
 }
@@ -348,24 +347,17 @@ bool CDVDVideoCodecIMX::VpuAllocFrameBuffers(void)
   m_vpuHandle = 0;
   m_vpuFrameBuffers = NULL;
   m_outputBuffers = NULL;
+  m_lastBuffer = NULL;
   m_extraMem = NULL;
   m_vpuFrameBufferNum = 0;
   m_dropState = false;
   m_convert_bitstream = false;
   m_frameCounter = 0;
-  m_usePTS = true;
-  if (getenv("IMX_NOPTS") != NULL)
-  {
-    m_usePTS = false;
-  }
-  m_modeDeinterlace = 1; // Default is high motion if requested
-  const char *deintEntry = getenv("IMX_DEINT_MOTION");
-  if (deintEntry != NULL)
-    m_modeDeinterlace = atoi(deintEntry);
   m_converter = NULL;
   m_convert_bitstream = false;
   m_bytesToBeConsumed = 0;
   m_previousPts = DVD_NOPTS_VALUE;
+  m_doubleRateCnt = 0;
 }
 
 CDVDVideoCodecIMX::~CDVDVideoCodecIMX()
@@ -496,6 +488,8 @@ bool CDVDVideoCodecIMX::Open(CDVDStreamInfo &hints, CDVDCodecOptions &options)
     return false;
   }
 
+  m_doubleRateCnt = 0;
+
   return true;
 }
 
@@ -504,6 +498,13 @@ void CDVDVideoCodecIMX::Dispose(void)
   VpuDecRetCode  ret;
   bool VPU_loaded = m_vpuHandle;
 
+  // Block render thread from using that framebuffers
+  Enter();
+
+  // Release last buffer
+  if(m_lastBuffer)
+    SAFE_RELEASE(m_lastBuffer);
+
   // Invalidate output buffers to prevent the renderer from mapping this memory
   for (int i=0; i<m_vpuFrameBufferNum; i++)
   {
@@ -511,6 +512,8 @@ void CDVDVideoCodecIMX::Dispose(void)
     SAFE_RELEASE(m_outputBuffers[i]);
   }
 
+  Leave();
+
   if (m_vpuHandle)
   {
     ret = VPU_DecFlushAll(m_vpuHandle);
@@ -580,6 +583,11 @@ int CDVDVideoCodecIMX::Decode(BYTE *pData, int iSize, double dts, double pts)
   unsigned long long before_dec;
 #endif
 
+  // If double rate is enabled and a last buffer is there, send an intermediate
+  // picture
+  if (m_doubleRateCnt && m_lastBuffer)
+    return VC_PICTURE;
+
   if (!m_vpuHandle)
   {
     VpuOpen();
@@ -823,12 +831,6 @@ int CDVDVideoCodecIMX::Decode(BYTE *pData, int iSize, double dts, double pts)
     // This pts is related to the frame that will be consumed
     // at next call...
     m_previousPts = pts;
-    if (retStatus & VC_PICTURE)
-      // If a picture was produced and some data are still to
-      // be consumed, do not ask for additional buffer as
-      // we likely already have enough data to produce a
-      // new output frame at next call
-      retStatus &= (~VC_BUFFER);
   }
 
 #ifdef IMX_PROFILE
@@ -846,6 +848,10 @@ void CDVDVideoCodecIMX::Reset()
 
   CLog::Log(LOGDEBUG, "%s - called\n", __FUNCTION__);
 
+  // Release last buffer
+  if(m_lastBuffer)
+    SAFE_RELEASE(m_lastBuffer);
+
   // Invalidate all buffers
   for(int i=0; i < m_vpuFrameBufferNum; i++)
     m_outputBuffers[i]->ReleaseFramebuffer(&m_vpuHandle);
@@ -854,6 +860,7 @@ void CDVDVideoCodecIMX::Reset()
   m_deinterlacer.Reset();
   m_bytesToBeConsumed = 0;
   m_previousPts = DVD_NOPTS_VALUE;
+  m_doubleRateCnt = 0;
 
   // Flush VPU
   ret = VPU_DecFlushAll(m_vpuHandle);
@@ -881,7 +888,17 @@ bool CDVDVideoCodecIMX::ClearPicture(DVDVideoPicture* pDvdVideoPicture)
 
 bool CDVDVideoCodecIMX::GetPicture(DVDVideoPicture* pDvdVideoPicture)
 {
+#ifdef IMX_PROFILE
+  static unsigned int previous = 0;
+  unsigned int current;
+
+  current = XbmcThreads::SystemClockMillis();
+  CLog::Log(LOGDEBUG, "%s  tm:%03d\n", __FUNCTION__, current - previous);
+  previous = current;
+#endif
+
   m_frameCounter++;
+
   pDvdVideoPicture->iFlags = DVP_FLAG_ALLOCATED;
   if (m_dropState)
     pDvdVideoPicture->iFlags |= DVP_FLAG_DROPPED;
@@ -900,28 +917,47 @@ bool CDVDVideoCodecIMX::GetPicture(DVDVideoPicture* pDvdVideoPicture)
   if (idx != -1)
   {
     CDVDVideoCodecIMXBuffer *buffer = m_outputBuffers[idx];
-    CDVDVideoCodecIPUBuffer *ipuBuffer = NULL;
 
-    pDvdVideoPicture->pts = buffer->GetPts();
-    if (!m_usePTS)
+    if (m_doubleRateCnt)
     {
-      pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
+      // Interpolate pts and send the last buffer again
+      pDvdVideoPicture->pts = (buffer->GetPts() + m_lastBuffer->GetPts())*0.5;
+      pDvdVideoPicture->doubled = true;
+      pDvdVideoPicture->codecinfo = m_lastBuffer;
+      pDvdVideoPicture->codecinfo->Lock();
+      m_doubleRateCnt--;
+      return true;
     }
 
-    buffer->Queue(&m_frameInfo);
+    pDvdVideoPicture->pts = buffer->GetPts();
+
+    buffer->Queue(&m_frameInfo, m_lastBuffer);
 
 #ifdef TRACE_FRAMES
     CLog::Log(LOGDEBUG, "+  %02d  pts %f  (VPU)\n", idx, pDvdVideoPicture->pts);
 #endif
 
-    ipuBuffer = m_deinterlacer.Process(buffer, m_frameInfo.eFieldType, m_modeDeinterlace > 1);
-
-    if (ipuBuffer)
-      pDvdVideoPicture->codecinfo = ipuBuffer;
+    /*
+    // This does not work reliably since some streams do not report
+    // correctly if a frame is interlaced.
+    if (m_frameInfo.eFieldType != VPU_FIELD_NONE)
+      GET_DEINTERLACER(buffer) = (uint8_t*)&m_deinterlacer;
     else
-      pDvdVideoPicture->codecinfo = buffer;
+      GET_DEINTERLACER(buffer) = NULL;
+    */
 
+    pDvdVideoPicture->doubled = false;
+    pDvdVideoPicture->codecinfo = buffer;
     pDvdVideoPicture->codecinfo->Lock();
+
+    // Save last buffer
+    if (m_lastBuffer)
+      SAFE_RELEASE(m_lastBuffer);
+
+    m_lastBuffer = buffer;
+    m_lastBuffer->Lock();
+
+    m_doubleRateCnt = m_doubleRateInit;
   }
   else
   {
@@ -947,6 +983,16 @@ void CDVDVideoCodecIMX::SetDropState(bool bDrop)
   }
 }
 
+void CDVDVideoCodecIMX::Enter()
+{
+  m_codecBufferLock.lock();
+}
+
+void CDVDVideoCodecIMX::Leave()
+{
+  m_codecBufferLock.unlock();
+}
+
 /*******************************************/
 
 #ifdef TRACE_FRAMES
@@ -960,7 +1006,9 @@ void CDVDVideoCodecIMX::SetDropState(bool bDrop)
   , m_frameBuffer(NULL)
   , m_rendered(false)
   , m_pts(DVD_NOPTS_VALUE)
+  , m_previousBuffer(NULL)
 {
+  GET_DEINTERLACER(this) = NULL;
 }
 
 void CDVDVideoCodecIMXBuffer::Lock()
@@ -979,6 +1027,11 @@ long CDVDVideoCodecIMXBuffer::Release()
 #ifdef TRACE_FRAMES
   CLog::Log(LOGDEBUG, "R- %02d  -  ref : %d  (VPU)\n", m_idx, count);
 #endif
+  if (count == 2)
+  {
+    // Only referenced by the coded and its next frame, release the previous
+    SAFE_RELEASE(m_previousBuffer);
+  }
   if (count == 1)
   {
     // If count drops to 1 then the only reference is being held by the codec
@@ -986,6 +1039,7 @@ long CDVDVideoCodecIMXBuffer::Release()
     if(m_frameBuffer != NULL)
     {
       m_rendered = true;
+      SAFE_RELEASE(m_previousBuffer);
 #ifdef TRACE_FRAMES
       CLog::Log(LOGDEBUG, "R  %02d  (VPU)\n", m_idx);
 #endif
@@ -1001,7 +1055,6 @@ long CDVDVideoCodecIMXBuffer::Release()
 
 bool CDVDVideoCodecIMXBuffer::IsValid()
 {
-  CSingleLock lock(CDVDVideoCodecIMX::m_codecBufferLock);
   return m_frameBuffer != NULL;
 }
 
@@ -1010,21 +1063,28 @@ bool CDVDVideoCodecIMXBuffer::Rendered() const
   return m_rendered;
 }
 
-void CDVDVideoCodecIMXBuffer::Queue(VpuDecOutFrameInfo *frameInfo)
+void CDVDVideoCodecIMXBuffer::Queue(VpuDecOutFrameInfo *frameInfo,
+                                    CDVDVideoCodecIMXBuffer *previous)
 {
-  CSingleLock lock(CDVDVideoCodecIMX::m_codecBufferLock);
+  // No lock necessary because at this time there is definitely no
+  // thread still holding a reference
   m_frameBuffer = frameInfo->pDisplayFrameBuf;
   m_rendered = false;
+  m_previousBuffer = previous;
+  if (m_previousBuffer)
+    m_previousBuffer->Lock();
 
-  iWidth  = frameInfo->pExtInfo->nFrmWidth;
-  iHeight = frameInfo->pExtInfo->nFrmHeight;
+  iWidth              = frameInfo->pExtInfo->nFrmWidth;
+  iHeight             = frameInfo->pExtInfo->nFrmHeight;
+  m_fieldType         = frameInfo->eFieldType;
   GET_VIRT_ADDR(this) = m_frameBuffer->pbufVirtY;
   GET_PHYS_ADDR(this) = m_frameBuffer->pbufY;
 }
 
 VpuDecRetCode CDVDVideoCodecIMXBuffer::ReleaseFramebuffer(VpuDecHandle *handle)
 {
-  CSingleLock lock(CDVDVideoCodecIMX::m_codecBufferLock);
+  // Again no lock required because this is only issued after the last
+  // external reference was released
   VpuDecRetCode ret = VPU_DEC_RET_FAILURE;
 
   if((m_frameBuffer != NULL) && *handle)
@@ -1039,6 +1099,8 @@ VpuDecRetCode CDVDVideoCodecIMXBuffer::ReleaseFramebuffer(VpuDecHandle *handle)
   m_rendered = false;
   m_frameBuffer = NULL;
   m_pts = DVD_NOPTS_VALUE;
+  SAFE_RELEASE(m_previousBuffer);
+
   return ret;
 }
 
@@ -1052,6 +1114,16 @@ double CDVDVideoCodecIMXBuffer::GetPts(void) const
   return m_pts;
 }
 
+CDVDVideoCodecIMXBuffer *CDVDVideoCodecIMXBuffer::GetPreviousBuffer() const
+{
+  return m_previousBuffer;
+}
+
+VpuFieldType CDVDVideoCodecIMXBuffer::GetFieldType() const
+{
+  return m_fieldType;
+}
+
 CDVDVideoCodecIMXBuffer::~CDVDVideoCodecIMXBuffer()
 {
   assert(m_refs == 0);
@@ -1114,78 +1186,95 @@ long CDVDVideoCodecIPUBuffer::Release()
 
 bool CDVDVideoCodecIPUBuffer::IsValid()
 {
-  CSingleLock lock(CDVDVideoCodecIMX::m_codecBufferLock);
-  return (m_source != NULL) && m_pPhyAddr;
+  return m_source && m_source->IsValid() && m_pPhyAddr;
 }
 
-bool CDVDVideoCodecIPUBuffer::Process(int fd, CDVDVideoCodecBuffer *currentBuffer,
-                                      CDVDVideoCodecBuffer *previousBuffer, VpuFieldType fieldType)
+bool CDVDVideoCodecIPUBuffer::Process(int fd, CDVDVideoCodecIMXBuffer *buffer,
+                                      bool lowMotion, bool doubledFrame)
 {
+  CDVDVideoCodecIMXBuffer *previousBuffer;
   struct ipu_task task;
   memset(&task, 0, sizeof(task));
   task.priority = IPU_TASK_PRIORITY_HIGH;
 
+  if (lowMotion)
+    previousBuffer = buffer->GetPreviousBuffer();
+  else
+    previousBuffer = NULL;
+
   SAFE_RELEASE(m_source);
 
-  iWidth                 = currentBuffer->iWidth;
-  iHeight                = currentBuffer->iHeight;
+  iWidth             = buffer->iWidth;
+  iHeight            = buffer->iHeight;
 
   // Input is the VPU decoded frame
-  task.input.width       = iWidth;
-  task.input.height      = iHeight;
-  task.input.format      = IPU_PIX_FMT_NV12;
-  task.input.paddr       = (int)GET_PHYS_ADDR(currentBuffer);
+  task.input.width   = iWidth;
+  task.input.height  = iHeight;
+  task.input.format  = IPU_PIX_FMT_NV12;
 
   // Output is our IPU buffer
-  task.output.width      = iWidth;
-  task.output.height     = iHeight;
-  task.output.format     = IPU_PIX_FMT_NV12;
-  task.output.paddr      = (int)GET_PHYS_ADDR(this);
+  task.output.width  = iWidth;
+  task.output.height = iHeight;
+  task.output.format = IPU_PIX_FMT_NV12;
+  task.output.paddr  = (int)GET_PHYS_ADDR(this);
 
-  // Fill previous buffer address
-  if (previousBuffer)
-    task.input.paddr_n = (int)GET_PHYS_ADDR(previousBuffer);
+  // Fill current and next buffer address
+  if (lowMotion && previousBuffer && previousBuffer->IsValid())
+  {
+    task.input.paddr              = (int)GET_PHYS_ADDR(previousBuffer);
+    task.input.paddr_n            = (int)GET_PHYS_ADDR(buffer);
+    task.input.deinterlace.motion = LOW_MOTION;
+  }
+  else
+  {
+    task.input.paddr              = (int)GET_PHYS_ADDR(buffer);
+    task.input.deinterlace.motion = HIGH_MOTION;
+  }
 
-  task.input.deinterlace.enable    = 1;
-  task.input.deinterlace.motion    = task.input.paddr_n?LOW_MOTION:HIGH_MOTION;
+  task.input.deinterlace.enable = 1;
 
-  switch (fieldType)
+  switch (buffer->GetFieldType())
   {
   case VPU_FIELD_TOP:
-    task.input.deinterlace.field_fmt = IPU_DEINTERLACE_FIELD_TOP;
-    break;
-  case VPU_FIELD_BOTTOM:
-    task.input.deinterlace.field_fmt = IPU_DEINTERLACE_FIELD_BOTTOM;
-    break;
-  /*
   case VPU_FIELD_TB:
     task.input.deinterlace.field_fmt = IPU_DEINTERLACE_FIELD_TOP;
     break;
+  case VPU_FIELD_BOTTOM:
   case VPU_FIELD_BT:
     task.input.deinterlace.field_fmt = IPU_DEINTERLACE_FIELD_BOTTOM;
     break;
-  */
   default:
     break;
   }
 
+  if (doubledFrame)
+  {
+    task.input.deinterlace.field_fmt |= (IPU_DEINTERLACE_RATE_EN|IPU_DEINTERLACE_RATE_FRAME1);
+  }
+
+#ifdef IMX_PROFILE
+  unsigned int time = XbmcThreads::SystemClockMillis();
+#endif
   int ret = ioctl(fd, IPU_QUEUE_TASK, &task);
+#ifdef IMX_PROFILE
+  CLog::Log(LOGDEBUG, "DEINT: tm:%d\n", XbmcThreads::SystemClockMillis() - time);
+#endif
   if (ret < 0)
   {
     CLog::Log(LOGERROR, "IPU task failed: %s\n", strerror(errno));
     return false;
   }
 
-  currentBuffer->Lock();
+  buffer->Lock();
 
   // Remember the source buffer. This is actually not necessary since the output
   // buffer is the one that is used by the renderer. But keep it bound for now
   // since this state is used in IsValid which then needs to become a flag in
   // this class.
-  m_source = currentBuffer;
+  m_source = buffer;
   m_source->Lock();
 
-  currentBuffer->Release();
+  buffer->Release();
 
   return true;
 }
@@ -1240,6 +1329,8 @@ bool CDVDVideoCodecIPUBuffer::Allocate(int fd, int width, int height, int nAlign
     GET_VIRT_ADDR(this) = (uint8_t*)m_pVirtAddr;
   }
 
+  GET_DEINTERLACER(this) = NULL;
+
   return true;
 }
 
@@ -1283,7 +1374,6 @@ bool CDVDVideoCodecIPUBuffer::Free(int fd)
   : m_ipuHandle(0)
   , m_bufferNum(0)
   , m_buffers(NULL)
-  , m_lastBuffer(NULL)
 {
 }
 
@@ -1312,7 +1402,7 @@ bool CDVDVideoCodecIPUBuffers::Init(int width, int height, int numBuffers, int n
   m_bufferNum = numBuffers;
   m_buffers = new CDVDVideoCodecIPUBuffer*[m_bufferNum];
 
-  for (int i=0; i < m_bufferNum; i++ )
+  for (int i=0; i < m_bufferNum; i++)
   {
 #ifdef TRACE_FRAMES
     m_buffers[i] = new CDVDVideoCodecIPUBuffer(i);
@@ -1331,7 +1421,6 @@ bool CDVDVideoCodecIPUBuffers::Init(int width, int height, int numBuffers, int n
 
 bool CDVDVideoCodecIPUBuffers::Reset()
 {
-  SAFE_RELEASE(m_lastBuffer);
   for (int i=0; i < m_bufferNum; i++)
     m_buffers[i]->ReleaseFrameBuffer();
 }
@@ -1369,18 +1458,19 @@ bool CDVDVideoCodecIPUBuffers::Close()
   }
 
   m_bufferNum = 0;
-  SAFE_RELEASE(m_lastBuffer);
   return true;
 }
 
 CDVDVideoCodecIPUBuffer *
-CDVDVideoCodecIPUBuffers::Process(CDVDVideoCodecBuffer *sourceBuffer,
-                                  VpuFieldType fieldType, bool lowMotion)
+CDVDVideoCodecIPUBuffers::Process(CDVDVideoCodecBuffer *sourceBuffer, bool lowMotion,
+                                  bool doubledFrame)
 {
   CDVDVideoCodecIPUBuffer *target = NULL;
   bool ret = true;
 
-  if (!m_bufferNum || (fieldType==VPU_FIELD_NONE)) return NULL;
+  // TODO: Needs further checks on real streams
+  if (!m_bufferNum /*|| (fieldType == VPU_FIELD_NONE)*/)
+    return NULL;
 
   for (int i=0; i < m_bufferNum; i++ )
   {
@@ -1389,8 +1479,8 @@ bool CDVDVideoCodecIPUBuffers::Close()
     // IPU process:
     // SRC: Current VPU physical buffer address + last VPU buffer address
     // DST: IPU buffer[i]
-    CDVDVideoCodecBuffer *last = lowMotion?m_lastBuffer:NULL;
-    ret = m_buffers[i]->Process(m_ipuHandle, sourceBuffer, last, fieldType);
+    CDVDVideoCodecIMXBuffer *imxBuffer = (CDVDVideoCodecIMXBuffer*)sourceBuffer;
+    ret = m_buffers[i]->Process(m_ipuHandle, imxBuffer, lowMotion, doubledFrame);
     if (ret)
     {
 #ifdef TRACE_FRAMES
@@ -1408,10 +1498,5 @@ bool CDVDVideoCodecIPUBuffers::Close()
     CLog::Log(LOGERROR, "Deinterlacing: did not find free buffer, forward unprocessed frame\n");
   }
 
-  SAFE_RELEASE(m_lastBuffer);
-  m_lastBuffer = sourceBuffer;
-  if (m_lastBuffer != NULL)
-    m_lastBuffer->Lock();
-
   return target;
 }
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h
index 1cfb2a4..8948fbe 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecIMX.h
@@ -66,22 +66,29 @@ class CDVDVideoCodecIMXBuffer : public CDVDVideoCodecBuffer
   virtual bool             IsValid();
 
   bool                     Rendered() const;
-  void                     Queue(VpuDecOutFrameInfo *frameInfo);
+  void                     Queue(VpuDecOutFrameInfo *frameInfo,
+                                 CDVDVideoCodecIMXBuffer *previous);
   VpuDecRetCode            ReleaseFramebuffer(VpuDecHandle *handle);
   void                     SetPts(double pts);
   double                   GetPts(void) const;
+  CDVDVideoCodecIMXBuffer *GetPreviousBuffer() const;
+  VpuFieldType             GetFieldType() const;
 
-protected:
+private:
   // private because we are reference counted
   virtual                  ~CDVDVideoCodecIMXBuffer();
 
+private:
 #ifdef TRACE_FRAMES
   int                      m_idx;
 #endif
   long                     m_refs;
   VpuFrameBuffer          *m_frameBuffer;
+  VpuFieldType             m_fieldType;
   bool                     m_rendered;
   double                   m_pts;
+  CDVDVideoCodecIMXBuffer *m_previousBuffer; // Holds a the reference counted
+                                             // previous buffer
 };
 
 // Shared buffer that holds an IPU allocated memory block and serves as target
@@ -102,8 +109,8 @@ class CDVDVideoCodecIPUBuffer : public CDVDVideoCodecBuffer
 
   // Returns whether the buffer is ready to be used
   bool                     Rendered() const { return m_source == NULL; }
-  bool                     Process(int fd, CDVDVideoCodecBuffer *currentBuffer,
-                                   CDVDVideoCodecBuffer *previousBuffer, VpuFieldType fieldType);
+  bool                     Process(int fd, CDVDVideoCodecIMXBuffer *buffer,
+                                   bool lowMotion, bool doubledFrame);
   void                     ReleaseFrameBuffer();
 
   bool                     Allocate(int fd, int width, int height, int nAlign);
@@ -139,13 +146,12 @@ class CDVDVideoCodecIPUBuffers
     bool Close();
 
     CDVDVideoCodecIPUBuffer *Process(CDVDVideoCodecBuffer *sourceBuffer,
-                                     VpuFieldType fieldType, bool lowMotion);
+                                     bool lowMotion, bool doubledFrame);
 
   private:
     int                       m_ipuHandle;
     int                       m_bufferNum;
     CDVDVideoCodecIPUBuffer **m_buffers;
-    CDVDVideoCodecBuffer     *m_lastBuffer;
 };
 
 
@@ -169,6 +175,9 @@ class CDVDVideoCodecIMX : public CDVDVideoCodec
   virtual const char* GetName(void) { return (const char*)m_pFormatName; }
   virtual unsigned GetAllowedReferences();
 
+  static void Enter();
+  static void Leave();
+
 protected:
 
   bool VpuOpen();
@@ -177,28 +186,28 @@ class CDVDVideoCodecIMX : public CDVDVideoCodec
   bool VpuAllocFrameBuffers();
   int  VpuFindBuffer(void *frameAddr);
 
-  static const int    m_extraVpuBuffers;   // Number of additional buffers for VPU
-  static CCriticalSection m_codecBufferLock;
-
-  CDVDStreamInfo      m_hints;             // Hints from demuxer at stream opening
-  const char         *m_pFormatName;       // Current decoder format name
-  VpuDecOpenParam     m_decOpenParam;      // Parameters required to call VPU_DecOpen
-  CDecMemInfo         m_decMemInfo;        // VPU dedicated memory description
-  VpuDecHandle        m_vpuHandle;         // Handle for VPU library calls
-  VpuDecInitInfo      m_initInfo;          // Initial info returned from VPU at decoding start
-  bool                m_dropState;         // Current drop state
-  int                 m_vpuFrameBufferNum; // Total number of allocated frame buffers
-  VpuFrameBuffer     *m_vpuFrameBuffers;   // Table of VPU frame buffers description
+  static const int          m_extraVpuBuffers;   // Number of additional buffers for VPU
+  static CCriticalSection   m_codecBufferLock;
+
+  CDVDStreamInfo            m_hints;             // Hints from demuxer at stream opening
+  const char               *m_pFormatName;       // Current decoder format name
+  VpuDecOpenParam           m_decOpenParam;      // Parameters required to call VPU_DecOpen
+  CDecMemInfo               m_decMemInfo;        // VPU dedicated memory description
+  VpuDecHandle              m_vpuHandle;         // Handle for VPU library calls
+  VpuDecInitInfo            m_initInfo;          // Initial info returned from VPU at decoding start
+  bool                      m_dropState;         // Current drop state
+  int                       m_vpuFrameBufferNum; // Total number of allocated frame buffers
+  VpuFrameBuffer           *m_vpuFrameBuffers;   // Table of VPU frame buffers description
   CDVDVideoCodecIPUBuffers  m_deinterlacer;
   CDVDVideoCodecIMXBuffer **m_outputBuffers;
-  VpuMemDesc         *m_extraMem;          // Table of allocated extra Memory
-//  VpuMemDesc         *m_outputBuffers;     // Table of buffers out of VPU (used to call properly VPU_DecOutFrameDisplayed)
-  int                 m_frameCounter;      // Decoded frames counter
-  bool                m_usePTS;            // State whether pts out of decoding process should be used
-  int                 m_modeDeinterlace;   // Deinterlacer mode: 0=off, 1=high, 2..=low
-  VpuDecOutFrameInfo  m_frameInfo;
-  CBitstreamConverter *m_converter;
-  bool                m_convert_bitstream;
-  int                 m_bytesToBeConsumed; // Remaining bytes in VPU
-  double              m_previousPts;       // Enable to keep pts when needed
+  CDVDVideoCodecIMXBuffer  *m_lastBuffer;
+  VpuMemDesc               *m_extraMem;          // Table of allocated extra Memory
+  int                       m_frameCounter;      // Decoded frames counter
+  VpuDecOutFrameInfo        m_frameInfo;
+  CBitstreamConverter      *m_converter;
+  bool                      m_convert_bitstream;
+  int                       m_bytesToBeConsumed; // Remaining bytes in VPU
+  double                    m_previousPts;       // Enable to keep pts when needed
+  int                       m_doubleRateCnt;
+  int                       m_doubleRateInit;
 };
