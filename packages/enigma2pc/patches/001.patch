diff -uNr enigma2pc-20130727.orig/lib/dvb/dvb.cpp enigma2pc-20130727/lib/dvb/dvb.cpp
--- enigma2pc-20130727.orig/lib/dvb/dvb.cpp	2013-07-28 16:43:53.000000000 +0800
+++ enigma2pc-20130727/lib/dvb/dvb.cpp	2013-10-20 16:10:10.743014870 +0800
@@ -4,7 +4,6 @@
 
 #include <lib/base/eerror.h>
 #include <lib/base/filepush.h>
-#include <lib/base/eenv.h>
 #include <lib/base/wrappers.h>
 #include <lib/dvb/cahandler.h>
 #include <lib/dvb/idvb.h>
@@ -86,26 +85,19 @@
 		if (eDVBAdapterLinux::isusb(num_adapter))
 		{
 			eDVBAdapterLinux *adapter = new eDVBUsbAdapter(num_adapter);
-			adapter->scanDevices();
-			addAdapter(adapter, true);
-		}
-		else
-		{
-			eDVBAdapterLinux *adapter = new eDVBAdapterLinux(num_adapter);
-			adapter->scanDevices();
-			addAdapter(adapter, true);
+			addAdapter(adapter);
 		}
 		num_adapter++;
 	}
 
 	if (eDVBAdapterLinux::exist(0))
 	{
-			eDVBAdapterLinux *adapter = new eDVBAdapterLinux(0);
-			adapter->scanDevices();
-			addAdapter(adapter, true);
+		eDVBAdapterLinux *adapter = new eDVBAdapterLinux(0);
+		adapter->scanDevices();
+		addAdapter(adapter, true);
 	}
 
-	int fd = open(eEnv::resolve("${sysconfdir}/stb/info/model").c_str(), O_RDONLY);
+	int fd = open("/proc/stb/info/model", O_RDONLY);
 	char tmp[16];
 	int rd = fd >= 0 ? read(fd, tmp, sizeof(tmp)) : 0;
 	if (fd >= 0)
@@ -124,8 +116,7 @@
 	else if (!strncmp(tmp, "dm7020hd\n", rd))
 		m_boxtype = DM7020HD;
 	else {
-		std::string info= "boxtype detection via " + eEnv::resolve("${sysconfdir}/stb/info") + " not possible... use fallback via demux count!\n";
-		eDebug(info.c_str());
+		eDebug("boxtype detection via /proc/stb/info not possible... use fallback via demux count!\n");
 		if (m_demux.size() == 3)
 			m_boxtype = DM800;
 		else if (m_demux.size() < 5)
@@ -164,11 +155,16 @@
 	eDebug("scanning for frontends..");
 	while (1)
 	{
-		struct stat s;
+		/*
+		 * Some frontend devices might have been just created, if
+		 * they are virtual (vtuner) frontends.
+		 * In that case, we cannot be sure the devicenodes are available yet.
+		 * So it is safer to scan for sys entries, than for device nodes
+		 */
 		char filename[128];
-		sprintf(filename, "/dev/dvb/adapter%d/frontend%d", m_nr, num_fe);
-		if (stat(filename, &s))
-			break;
+		snprintf(filename, sizeof(filename), "/sys/class/dvb/dvb%d.frontend%d", m_nr, num_fe);
+		if (::access(filename, X_OK) < 0) break;
+		snprintf(filename, sizeof(filename), "/dev/dvb/adapter%d/frontend%d", m_nr, num_fe);
 		eDVBFrontend *fe;
 		std::string name = filename;
 		std::map<std::string, std::string>::iterator it = mappedFrontendName.find(name);
@@ -281,10 +277,17 @@
 	int num_fe = 0;
 	while (1)
 	{
-		snprintf(filename, sizeof(filename), "/dev/dvb/adapter0/frontend%d", num_fe);
-		if (::access(filename, R_OK) < 0) break;
+		/*
+		 * Some frontend devices might have been just created, if
+		 * they are virtual (vtuner) frontends.
+		 * In that case, we cannot be sure the devicenodes are available yet.
+		 * So it is safer to scan for sys entries, than for device nodes
+		 */
+		snprintf(filename, sizeof(filename), "/sys/class/dvb/dvb0.frontend%d", num_fe);
+		if (::access(filename, X_OK) < 0) break;
 		num_fe++;
 	}
+	snprintf(filename, sizeof(filename), "/dev/dvb/adapter0/frontend%d", num_fe);
 	virtualFrontendName = filename;
 
 	demuxFd = vtunerFd = pipeFd[0] = pipeFd[1] = -1;
@@ -477,6 +480,32 @@
 #define DEMUX_BUFFER_SIZE (8 * ((188 / 4) * 4096)) /* 1.5MB */
 	ioctl(demuxFd, DMX_SET_BUFFER_SIZE, DEMUX_BUFFER_SIZE);
 
+#if DVB_API_VERSION < 5 || DVB_API_VERSION == 5 && DVB_API_VERSION_MINOR < 5
+	/*
+	 * HACK: several stb's with older DVB API versions do not handle the
+	 * constant starting / stopping of PES filters on their vtuner interface
+	 * very well, eventually they will stop feeding any data.
+	 * In order to work around this problem, we always start a filter, making sure
+	 * 'pidcount' never drops to zero, so the filter is never stopped.
+	 *
+	 * Note that this isn't allowed for recent DVB API versions, because they
+	 * refuse to start filters while the frontend is sleeping (e.g. not tuned).
+	 */
+	{
+		struct dmx_pes_filter_params filter;
+		filter.input = DMX_IN_FRONTEND;
+		filter.flags = 0;
+		filter.pid = 0;
+		filter.output = DMX_OUT_TSDEMUX_TAP;
+		filter.pes_type = DMX_PES_OTHER;
+		if (ioctl(demuxFd, DMX_SET_PES_FILTER, &filter) >= 0
+				&& ioctl(demuxFd, DMX_START) >= 0)
+		{
+			pidcount = 1;
+		}
+	}
+#endif
+
 	while (running)
 	{
 		fd_set rset, xset;
@@ -692,9 +721,9 @@
 			break;
 		}
 	}
-	if (assigned != PyList_Size(list)) {
-		eDebug("eDVBResourceManager::setFrontendSlotInformations .. assigned %d socket informations, but %zd configured !",
-			assigned,PyList_Size(list));
+	if (assigned != m_frontend.size()) {
+		eDebug("eDVBResourceManager::setFrontendSlotInformations .. assigned %zd socket informations, but %d registered frontends!",
+			m_frontend.size(), assigned);
 	}
 	for (eSmartPtrList<eDVBRegisteredFrontend>::iterator i(m_simulate_frontend.begin()); i != m_simulate_frontend.end(); ++i)
 	{
@@ -743,7 +772,7 @@
 			}
 			else if (!strcmp(type, "DVB-C"))
 			{
-#ifdef SYS_DVBC_ANNEX_A
+#if DVB_API_VERSION > 5 || DVB_API_VERSION == 5 && DVB_API_VERSION_MINOR >= 6
 				return i->m_frontend->supportsDeliverySystem(SYS_DVBC_ANNEX_A, false) || i->m_frontend->supportsDeliverySystem(SYS_DVBC_ANNEX_C, false);
 #else
 				return i->m_frontend->supportsDeliverySystem(SYS_DVBC_ANNEX_AC, false);
@@ -778,7 +807,7 @@
 			}
 			else if (!strcmp(type, "DVB-C"))
 			{
-#ifdef SYS_DVBC_ANNEX_A
+#if DVB_API_VERSION > 5 || DVB_API_VERSION == 5 && DVB_API_VERSION_MINOR >= 6
 				whitelist.push_back(SYS_DVBC_ANNEX_A);
 				whitelist.push_back(SYS_DVBC_ANNEX_C);
 #else
@@ -1557,7 +1586,7 @@
 	switch (event)
 	{
 	case eCueSheet::evtSeek:
-		eDebug("seek.");fflush(stdout);
+		eDebug("seek.");
 		flushPVR(m_cue->m_decoding_demux);
 		break;
 	case eCueSheet::evtSkipmode:
@@ -2006,7 +2035,7 @@
 
 RESULT eDVBChannel::getDemux(ePtr<iDVBDemux> &demux, int cap)
 {
-	ePtr<eDVBAllocatedDemux> &our_demux = m_demux; // openpliPC
+	ePtr<eDVBAllocatedDemux> &our_demux = (cap & capDecode) ? m_decoder_demux : m_demux;
 
 	if (!m_frontend)
 	{
@@ -2096,13 +2125,6 @@
 
 	if (m_pvr_fd_dst < 0)
 	{
-		m_pvr_fd_dst = ::open("/tmp/ENIGMA_FIFO", O_RDWR);
-		if (m_pvr_fd_dst < 0)
-		{
-			eDebug("can't open DVR device - FIFO file (%m)");
-			return -ENODEV;
-		}
-
 		/* (this codepath needs to be improved anyway.) */
 #ifdef HAVE_OLDPVR
 		m_pvr_fd_dst = open("/dev/misc/pvr", O_WRONLY);
@@ -2112,7 +2134,6 @@
 			return -ENODEV;
 		}
 #else
-	/* OpenPliPC
 		ePtr<eDVBAllocatedDemux> &demux = m_demux ? m_demux : m_decoder_demux;
 		if (demux)
 		{
@@ -2127,7 +2148,7 @@
 		{
 			eDebug("no demux allocated yet.. so its not possible to open the dvr device!!");
 			return -ENODEV;
-		}*/
+		}
 #endif
 	}
 
diff -uNr enigma2pc-20130727.orig/lib/python/Plugins/SystemPlugins/Satfinder/plugin.py enigma2pc-20130727/lib/python/Plugins/SystemPlugins/Satfinder/plugin.py
--- enigma2pc-20130727.orig/lib/python/Plugins/SystemPlugins/Satfinder/plugin.py	2013-06-18 00:03:16.000000000 +0800
+++ enigma2pc-20130727/lib/python/Plugins/SystemPlugins/Satfinder/plugin.py	2013-10-20 16:12:19.699017612 +0800
@@ -229,6 +229,7 @@
 		self.updateSatList()
 
 		self.scan_satselection = [ self.tuning_sat ]
+		self.satfindNim = self.feid
 
 		self.scan_sat.frequency.setValue(self.transponder[0])
 		self.scan_sat.symbolrate.setValue(self.transponder[1])
diff -uNr enigma2pc-20130727.orig/lib/python/Screens/ScanSetup.py enigma2pc-20130727/lib/python/Screens/ScanSetup.py
--- enigma2pc-20130727.orig/lib/python/Screens/ScanSetup.py	2013-06-18 00:03:16.000000000 +0800
+++ enigma2pc-20130727/lib/python/Screens/ScanSetup.py	2013-10-20 16:10:54.279015795 +0800
@@ -310,6 +310,7 @@
 		self.updateSatList()
 		self.service = session.nav.getCurrentService()
 		self.feinfo = None
+		self.satfindNim = None
 		self.networkid = 0
 		frontendData = None
 		if self.service is not None:
@@ -794,13 +795,13 @@
 		flags = None
 		startScan = True
 		removeAll = True
-		index_to_scan = int(self.scan_nims.value)
+		index_to_scan = self.satfindNim and 0 or int(self.scan_nims.value)
 		
 		if self.scan_nims == [ ]:
 			self.session.open(MessageBox, _("No tuner is enabled!\nPlease setup your tuner settings before you start a service scan."), MessageBox.TYPE_ERROR)
 			return
 
-		nim = nimmanager.nim_slots[index_to_scan]
+		nim = self.satfindNim and nimmanager.nim_slots[self.satfindNim] or nimmanager.nim_slots[index_to_scan]
 		print "nim", nim.slot
 		if nim.isCompatible("DVB-S"):
 			print "is compatible with DVB-S"
@@ -809,7 +810,7 @@
 				assert len(self.satList) > index_to_scan
 				assert len(self.scan_satselection) > index_to_scan
 				
-				nimsats = self.satList[index_to_scan]
+				nimsats = self.satList[self.satfindNim or index_to_scan]
 				selsatidx = self.scan_satselection[index_to_scan].index
 
 				# however, the satList itself could be empty. in that case, "index" is 0 (for "None").
