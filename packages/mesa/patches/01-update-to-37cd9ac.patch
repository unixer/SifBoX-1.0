diff --git a/VERSION b/VERSION
index b260649..8e92e83 100644
--- a/VERSION
+++ b/VERSION
@@ -1 +1 @@
-9.3.0-devel
+10.0.0-devel
diff --git a/configure.ac b/configure.ac
index e7c8223..08344c5 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1025,8 +1025,6 @@ if test "x$enable_dri" = xyes; then
         if test "x$have_libdrm" != xyes; then
             AC_MSG_ERROR([DRI drivers requires libdrm >= $LIBDRM_REQUIRED])
         fi
-        # ... and build dricommon
-        HAVE_COMMON_DRI=yes
     fi
 
     # put all the necessary libs together
@@ -1256,19 +1254,7 @@ dnl
 dnl XA configuration
 dnl
 if test "x$enable_xa" = xyes; then
-AC_PROG_AWK
-AC_PROG_GREP
-AC_CHECK_PROG(NM, nm, "nm")
-if test "x$AWK" = x || test "x$GREP" = x || test "x$NM" = x; then
-AC_MSG_WARN([Missing one of nm, grep or awk. Disabling xa.])
-enable_xa=no
-fi
-fi
-if test "x$enable_xa" = xyes; then
     GALLIUM_STATE_TRACKERS_DIRS="xa $GALLIUM_STATE_TRACKERS_DIRS"
-    AC_SUBST(AWK)
-    AC_SUBST(GREP)
-    AC_SUBST(NM)
 fi
 AM_CONDITIONAL(HAVE_ST_XA, test "x$enable_xa" = xyes)
 
@@ -1532,8 +1518,9 @@ AC_ARG_WITH([llvm-shared-libs],
     [with_llvm_shared_libs=no])
 AS_IF([test x$enable_opencl = xyes],
     [
-        AC_MSG_WARN([OpenCL required, forcing LLVM shared libraries])
-        with_llvm_shared_libs=yes
+        if test "x$with_llvm_shared_libs" != xyes; then
+            AC_MSG_ERROR([OpenCL requires LLVM shared libraries])
+        fi
     ])
 
 AC_ARG_WITH([llvm-prefix],
@@ -1680,7 +1667,6 @@ gallium_check_st() {
     fi
     if test "x$enable_dri" = xyes && test "x$2" != x; then
          GALLIUM_TARGET_DIRS="$GALLIUM_TARGET_DIRS $2"
-         HAVE_COMMON_DRI=yes
     fi
     if test "x$enable_xorg" = xyes && test "x$3" != x; then
          GALLIUM_TARGET_DIRS="$GALLIUM_TARGET_DIRS $3"
@@ -1926,7 +1912,6 @@ AM_CONDITIONAL(HAVE_NOUVEAU_DRI, test x$HAVE_NOUVEAU_DRI = xyes)
 AM_CONDITIONAL(HAVE_R200_DRI, test x$HAVE_R200_DRI = xyes)
 AM_CONDITIONAL(HAVE_RADEON_DRI, test x$HAVE_RADEON_DRI = xyes)
 AM_CONDITIONAL(HAVE_SWRAST_DRI, test x$HAVE_SWRAST_DRI = xyes)
-AM_CONDITIONAL(HAVE_COMMON_DRI, test x$HAVE_COMMON_DRI = xyes)
 
 AM_CONDITIONAL(NEED_RADEON_DRM_WINSYS, test "x$NEED_NONNULL_WINSYS" = xyes -a \
                                             "x$HAVE_GALLIUM_R300" = xyes -o \
@@ -1941,7 +1926,6 @@ AM_CONDITIONAL(HAVE_LOADER_GALLIUM, test x$enable_gallium_loader = xyes)
 AM_CONDITIONAL(HAVE_DRM_LOADER_GALLIUM, test x$enable_gallium_drm_loader = xyes)
 AM_CONDITIONAL(HAVE_GALLIUM_COMPUTE, test x$enable_opencl = xyes)
 AM_CONDITIONAL(HAVE_MESA_LLVM, test x$MESA_LLVM = x1)
-AM_CONDITIONAL(LLVM_NEEDS_FNORTTI, test $LLVM_VERSION_INT -ge 302)
 
 AC_SUBST([ELF_LIB])
 
@@ -1957,8 +1941,6 @@ AM_CONDITIONAL(HAVE_X86_ASM, echo "$DEFINES" | grep 'X86_ASM' >/dev/null 2>&1)
 AM_CONDITIONAL(HAVE_X86_64_ASM, echo "$DEFINES" | grep 'X86_64_ASM' >/dev/null 2>&1)
 AM_CONDITIONAL(HAVE_SPARC_ASM, echo "$DEFINES" | grep 'SPARC_ASM' >/dev/null 2>&1)
 
-AM_CONDITIONAL(CROSS_COMPILING, test "x$cross_compiling" = xyes)
-
 AC_SUBST([VDPAU_MAJOR], 1)
 AC_SUBST([VDPAU_MINOR], 0)
 
diff --git a/docs/GL3.txt b/docs/GL3.txt
index b16ec6f..c269f19 100644
--- a/docs/GL3.txt
+++ b/docs/GL3.txt
@@ -100,7 +100,7 @@ GL_ARB_draw_buffers_blend                            DONE (i965, r600, softpipe)
 GL_ARB_draw_indirect                                 started (Christoph)
 GL_ARB_gpu_shader5                                   started
 GL_ARB_gpu_shader_fp64                               not started
-GL_ARB_sample_shading                                not started
+GL_ARB_sample_shading                                started (Anuj)
 GL_ARB_shader_subroutine                             not started
 GL_ARB_tessellation_shader                           not started
 GL_ARB_texture_buffer_object_rgb32                   DONE (i965, softpipe)
@@ -126,12 +126,12 @@ GL 4.2:
 GLSL 4.2                                             not started
 GL_ARB_texture_compression_bptc                      not started
 GL_ARB_compressed_texture_pixel_storage              not started
-GL_ARB_shader_atomic_counters                        not started
+GL_ARB_shader_atomic_counters                        in progress (Curro)
 GL_ARB_texture_storage                               DONE (i965, r300, r600, swrast, gallium)
 GL_ARB_transform_feedback_instanced                  DONE
 GL_ARB_base_instance                                 DONE (i965, nv50, nvc0, r600, radeonsi)
 GL_ARB_shader_image_load_store                       not started
-GL_ARB_conservative_depth                            DONE (softpipe)
+GL_ARB_conservative_depth                            DONE (i965, softpipe)
 GL_ARB_shading_language_420pack                      DONE (i965, gallium)
 GL_ARB_internalformat_query                          DONE (i965, gallium)
 GL_ARB_map_buffer_alignment                          DONE (r300, r600, radeonsi)
@@ -145,7 +145,7 @@ ARB_ES3_compatibility                                DONE (i965)
 ARB_clear_buffer_object                              not started
 ARB_compute_shader                                   started (gallium)
 ARB_copy_image                                       not started
-KHR_debug                                            some work done (ARB_debug_output)
+KHR_debug                                            DONE
 ARB_explicit_uniform_location                        not started
 ARB_fragment_layer_viewport                          not started
 ARB_framebuffer_no_attachments                       not started
@@ -158,7 +158,7 @@ ARB_shader_image_size                                not started
 ARB_shader_storage_buffer_object                     not started
 ARB_stencil_texturing                                not started
 ARB_texture_buffer_range                             DONE (nv50, nvc0)
-ARB_texture_query_levels                             not started
+ARB_texture_query_levels                             DONE (i965)
 ARB_texture_storage_multisample                      DONE (i965)
 ARB_texture_view                                     not started
 ARB_vertex_attrib_binding                            started (Fredrik)
diff --git a/docs/index.html b/docs/index.html
index 2f04335..9907022 100644
--- a/docs/index.html
+++ b/docs/index.html
@@ -16,6 +16,19 @@
 
 <h1>News</h1>
 
+<h2>October 18, 2013</h2>
+<p>
+<a href="relnotes/9.2.2.html">Mesa 9.2.2</a> is released.
+This is a bug fix release.
+</p>
+
+<h2>October 4, 2013</h2>
+<p>
+<a href="relnotes/9.2.1.html">Mesa 9.2.1</a> and
+<a href="relnotes/9.1.7.html">Mesa 9.1.7</a> are released,
+both bug-fix releases.
+</p>
+
 <h2>August 27, 2013</h2>
 <p>
 <a href="relnotes/9.2.html">Mesa 9.2</a> is released.
diff --git a/docs/relnotes.html b/docs/relnotes.html
index 7d6865a..35cef80 100644
--- a/docs/relnotes.html
+++ b/docs/relnotes.html
@@ -21,8 +21,11 @@ The release notes summarize what's new or changed in each Mesa release.
 </p>
 
 <ul>
-<li><a href="relnotes/9.3.html">9.3 release notes</a>
+<li><a href="relnotes/10.0.html">10.0 release notes</a>
+<li><a href="relnotes/9.2.2.html">9.2.2 release notes</a>
+<li><a href="relnotes/9.2.1.html">9.2.1 release notes</a>
 <li><a href="relnotes/9.2.html">9.2 release notes</a>
+<li><a href="relnotes/9.1.7.html">9.1.7 release notes</a>
 <li><a href="relnotes/9.1.6.html">9.1.6 release notes</a>
 <li><a href="relnotes/9.1.5.html">9.1.5 release notes</a>
 <li><a href="relnotes/9.1.4.html">9.1.4 release notes</a>
diff --git a/docs/relnotes/10.0.html b/docs/relnotes/10.0.html
new file mode 100644
index 0000000..0b25f49
--- /dev/null
+++ b/docs/relnotes/10.0.html
@@ -0,0 +1,65 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<html lang="en">
+<head>
+  <meta http-equiv="content-type" content="text/html; charset=utf-8">
+  <title>Mesa Release Notes</title>
+  <link rel="stylesheet" type="text/css" href="../mesa.css">
+</head>
+<body>
+
+<div class="header">
+  <h1>The Mesa 3D Graphics Library</h1>
+</div>
+
+<iframe src="../contents.html"></iframe>
+<div class="content">
+
+<h1>Mesa 10.0 Release Notes / TBD</h1>
+
+<p>
+Mesa 10.0 is a new development release.
+People who are concerned with stability and reliability should stick
+with a previous release or wait for Mesa 10.0.1.
+</p>
+<p>
+Mesa 10.0 implements the OpenGL 3.3 API, but the version reported by
+glGetString(GL_VERSION) or glGetIntegerv(GL_MAJOR_VERSION) /
+glGetIntegerv(GL_MINOR_VERSION) depends on the particular driver being used.
+Some drivers don't support all the features required in OpenGL 3.3.  OpenGL
+3.3 is <strong>only</strong> available if requested at context creation
+because compatibility contexts are not supported.
+</p>
+
+
+<h2>MD5 checksums</h2>
+<pre>
+TBD.
+</pre>
+
+
+<h2>New features</h2>
+
+<p>
+Note: some of the new features are only available with certain drivers.
+</p>
+
+<ul>
+<li>GL_AMD_seamless_cubemap_per_texture on i965.</li>
+<li>GL_ARB_conservative_depth on i965.</li>
+<li>GL_ARB_texture_gather on i965.</li>
+<li>GL_ARB_texture_query_levels on i965.</li>
+<li>GL_KHR_debug</li>
+</ul>
+
+
+<h2>Bug fixes</h2>
+
+TBD.
+
+<h2>Changes</h2>
+
+TBD.
+
+</div>
+</body>
+</html>
diff --git a/docs/relnotes/9.1.7.html b/docs/relnotes/9.1.7.html
new file mode 100644
index 0000000..3647697
--- /dev/null
+++ b/docs/relnotes/9.1.7.html
@@ -0,0 +1,168 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<html lang="en">
+<head>
+  <meta http-equiv="content-type" content="text/html; charset=utf-8">
+  <title>Mesa Release Notes</title>
+  <link rel="stylesheet" type="text/css" href="../mesa.css">
+</head>
+<body>
+
+<div class="header">
+  <h1>The Mesa 3D Graphics Library</h1>
+</div>
+
+<iframe src="../contents.html"></iframe>
+<div class="content">
+
+<h1>Mesa 9.1.7 Release Notes / October 4, 2013</h1>
+
+<p>
+Mesa 9.1.7 is a bug fix release which fixes bugs found since the 9.1.6 release.
+</p>
+<p>
+Mesa 9.1 implements the OpenGL 3.1 API, but the version reported by
+glGetString(GL_VERSION) or glGetIntegerv(GL_MAJOR_VERSION) /
+glGetIntegerv(GL_MINOR_VERSION) depends on the particular driver being used.
+Some drivers don't support all the features required in OpenGL 3.1.  OpenGL
+3.1 is <strong>only</strong> available if requested at context creation
+because GL_ARB_compatibility is not supported.
+</p>
+
+<h2>MD5 checksums</h2>
+<pre>
+9e4abf7b7a6db762012c3c9917a8e8c7  MesaLib-9.1.7.tar.bz2
+f1d4d479d6ce12b9566fdb379960a912  MesaLib-9.1.7.tar.gz
+abd612bfc5dd478d04fcc630dd7672f2  MesaLib-9.1.7.zip
+</pre>
+
+<h2>New features</h2>
+<p>None.</p>
+
+<h2>Bug fixes</h2>
+
+<p>This list is likely incomplete.</p>
+
+<ul>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=55503">Bug 55503</a> - Constant vertex attributes broken</li>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=61635">Bug 61635</a> - glVertexAttribPointer(id, GL_UNSIGNED_BYTE, GL_FALSE,...) does not work</li>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=65958">Bug 65958</a> - GPU Lockup on Trinity 7500G</li>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=66292">Bug 66292</a> - [SNB/IVB/HSW Bisected]Ogles3conform GL3Tests_depth24_depth24_basic.test fail</li>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=67548">Bug 67548</a> - glGetAttribLocation seems to be broken</li>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=68195">Bug 68195</a> - piglit tests vs-struct-pad and fs-struct-pad both fail</li>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=68250">Bug 68250</a> - Automatic mipmap generation with texture compression produces borders that fade to black</li>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=69525">Bug 69525</a> - [GM45, bisected] Piglit tex-shadow2drect fails</li>
+
+</ul>
+
+
+<h2>Changes</h2>
+
+<p>Alex Deucher (2):</p>
+<ul>
+  <li>r600g: disable GPUVM by default</li>
+  <li>radeon/winsys: pad IBs to a multiple of 8 DWs</li>
+</ul>
+
+<p>Andreas Boll (2):</p>
+<ul>
+  <li>docs: Fix a typo in the 9.1.6 release notes</li>
+  <li>mesa: Fix MESA_PATCH version</li>
+</ul>
+
+<p>Anuj Phogat (1):</p>
+<ul>
+  <li>meta: Fix blitting a framebuffer with renderbuffer attachment</li>
+</ul>
+
+<p>Carl Worth (5):</p>
+<ul>
+  <li>docs: Add 9.1.6 release md5sums</li>
+  <li>Use -Bsymbolic when linking libEGL.so</li>
+  <li>Update get-pick-list to look specifically for "9.1" in NOTE</li>
+  <li>cherry-ignore: Ignore last two patches in current get-pick-list output</li>
+  <li>Bump version to 9.1.7</li>
+</ul>
+
+<p>Chris Forbes (1):</p>
+<ul>
+  <li>i965/fs: Gen4: Zero out extra coordinates when using shadow compare</li>
+</ul>
+
+<p>Emil Velikov (2):</p>
+<ul>
+  <li>nv50: handle pure integer vertex attributes</li>
+  <li>nouveau: initialise the nouveau_transfer maps</li>
+</ul>
+
+<p>Eric Anholt (1):</p>
+<ul>
+  <li>i965/gen4: Fix fragment program rectangle texture shadow compares.</li>
+</ul>
+
+<p>Ian Romanick (11):</p>
+<ul>
+  <li>mesa: Remove stray debug printfs in attachment completeness code</li>
+  <li>mesa: Validate the layer selection of an array texture too</li>
+  <li>mesa/vbo: Fix handling of attribute 0 in non-compatibilty contexts</li>
+  <li>glsl: Add new overload of program_resource_visitor::visit_field method</li>
+  <li>glsl: Use alignment of container record for its first field</li>
+  <li>mesa: Remove all traces of GL_OES_matrix_get</li>
+  <li>mesa: Don't call driver RenderTexture for really broken textures</li>
+  <li>mesa: Don't call driver RenderTexture for invalid zoffset</li>
+  <li>mesa: Generate a renderbuffer wrapper even if the texture has no image</li>
+  <li>glsl: Move and refine test for unsized arrays in GLSL ES</li>
+  <li>mesa: Don't return any data for GL_SHADER_BINARY_FORMATS</li>
+</ul>
+
+<p>Ilia Mirkin (2):</p>
+<ul>
+  <li>nv30: U8_USCALED only works for size 4</li>
+  <li>nv30: remove no-longer-used formats from table</li>
+</ul>
+
+<p>Joakim Sindholt (1):</p>
+<ul>
+  <li>nvc0: fix blitctx memory leak</li>
+</ul>
+
+<p>Johannes Obermayr (1):</p>
+<ul>
+  <li>st/gbm: Add $(WAYLAND_CFLAGS) for HAVE_EGL_PLATFORM_WAYLAND.</li>
+</ul>
+
+<p>Kenneth Graunke (1):</p>
+<ul>
+  <li>meta: Set correct viewport and projection in decompress_texture_image.</li>
+</ul>
+
+<p>Maarten Lankhorst (1):</p>
+<ul>
+  <li>nvc0: restore viewport after blit</li>
+</ul>
+
+<p>Rico Schüller (1):</p>
+<ul>
+  <li>glx: Initialize OpenGL version to 1.0</li>
+</ul>
+
+<p>Tiziano Bacocco (1):</p>
+<ul>
+  <li>nvc0/ir: fix use after free in texture barrier insertion pass</li>
+</ul>
+
+<p>Torsten Duwe (1):</p>
+<ul>
+  <li>wayland-egl.pc requires wayland-client.pc.</li>
+</ul>
+
+</div>
+</body>
+</html>
diff --git a/docs/relnotes/9.2.1.html b/docs/relnotes/9.2.1.html
new file mode 100644
index 0000000..f9909dd
--- /dev/null
+++ b/docs/relnotes/9.2.1.html
@@ -0,0 +1,206 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<html lang="en">
+<head>
+  <meta http-equiv="content-type" content="text/html; charset=utf-8">
+  <title>Mesa Release Notes</title>
+  <link rel="stylesheet" type="text/css" href="../mesa.css">
+</head>
+<body>
+
+<div class="header">
+  <h1>The Mesa 3D Graphics Library</h1>
+</div>
+
+<iframe src="../contents.html"></iframe>
+<div class="content">
+
+<h1>Mesa 9.2.1 Release Notes / (October 4, 2013)</h1>
+
+<p>
+Mesa 9.2.1 is a bug fix release which fixes bugs found since the 9.2 release.
+</p>
+<p>
+Mesa 9.2 implements the OpenGL 3.1 API, but the version reported by
+glGetString(GL_VERSION) or glGetIntegerv(GL_MAJOR_VERSION) /
+glGetIntegerv(GL_MINOR_VERSION) depends on the particular driver being used.
+Some drivers don't support all the features required in OpenGL 3.1.  OpenGL
+3.1 is <strong>only</strong> available if requested at context creation
+because GL_ARB_compatibility is not supported.
+</p>
+
+
+<h2>MD5 checksums</h2>
+<pre>
+e6cdfa84dfddd86e3d36ec7ff4b6478a  MesaLib-9.2.1.tar.gz
+dd4c82667d9c19c28a553b12eba3f8a0  MesaLib-9.2.1.tar.bz2
+d9af0f5607f7d275793d293057ca9ac6  MesaLib-9.2.1.zip
+</pre>
+
+
+<h2>New features</h2>
+<p>None</p>
+
+<h2>Bug fixes</h2>
+
+<p>This list is likely incomplete.</p>
+
+<ul>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=66779">Bug 66779</a> - Use of uninitialized stack variable with brw_search_cache()</li>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=68233">Bug 68233</a> - Valgrind errors in mesa</li>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=68250">Bug 68250</a> - Automatic mipmap generation with texture compression produces borders that fade to black</li>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=68637">Bug 68637</a> - [Bisected IVB/HSW]Unigine demo crash</li>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=68753">Bug 68753</a> - [regression bisected] GLSL ES: structs members can't have precision qualifiers anymore in 9.2</li>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=69525">Bug 69525</a> - [GM45, bisected] Piglit tex-shadow2drect fails</li>
+
+</ul>
+
+<h2>Changes</h2>
+
+<p>The full set of changes can be viewed by using the following GIT command:</p>
+
+<pre>
+  git log mesa-9.2..mesa-9.2.1
+</pre>
+
+
+<p>Alex Deucher (1):</p>
+<ul>
+  <li>radeon/winsys: pad IBs to a multiple of 8 DWs</li>
+</ul>
+
+<p>Andreas Boll (1):</p>
+<ul>
+  <li>os: First check for __GLIBC__ and then for PIPE_OS_BSD</li>
+</ul>
+
+<p>Anuj Phogat (1):</p>
+<ul>
+  <li>glsl: Allow precision qualifiers for sampler types</li>
+</ul>
+
+<p>Brian Paul (2):</p>
+<ul>
+  <li>docs: minor fixes for 9.2 release notes</li>
+  <li>mesa: check for bufSize &gt; 0 in _mesa_GetSynciv()</li>
+</ul>
+
+<p>Carl Worth (3):</p>
+<ul>
+  <li>cherry-ignore: Ignore a commit which appeared twice on master</li>
+  <li>Use -Bsymbolic when linking libEGL.so</li>
+  <li>mesa: Bump version to 9.2.1</li>
+</ul>
+
+<p>Chris Forbes (3):</p>
+<ul>
+  <li>i965/fs: Gen4: Zero out extra coordinates when using shadow compare</li>
+  <li>i965: Fix cube array coordinate normalization</li>
+  <li>i965: fix bogus swizzle in brw_cubemap_normalize</li>
+</ul>
+
+<p>Christoph Bumiller (2):</p>
+<ul>
+  <li>nvc0/ir: add f32 long immediate cannot saturate</li>
+  <li>nvc0: delete compute object on screen destruction</li>
+</ul>
+
+<p>Dave Airlie (1):</p>
+<ul>
+  <li>st/mesa: don't dereference stObj-&gt;pt if NULL</li>
+</ul>
+
+<p>Dominik Behr (1):</p>
+<ul>
+  <li>glsl: propagate max_array_access through function calls</li>
+</ul>
+
+<p>Emil Velikov (1):</p>
+<ul>
+  <li>nouveau: initialise the nouveau_transfer maps</li>
+</ul>
+
+<p>Eric Anholt (4):</p>
+<ul>
+  <li>mesa: Rip out more extension checking from texformat.c.</li>
+  <li>mesa: Don't choose S3TC for generic compression if we can't compress.</li>
+  <li>i965/gen4: Fix fragment program rectangle texture shadow compares.</li>
+  <li>i965: Reenable glBitmap() after the sRGB winsys enabling.</li>
+</ul>
+
+<p>Ian Romanick (7):</p>
+<ul>
+  <li>docs: Add 9.2 release md5sums</li>
+  <li>Add .cherry-ignore file</li>
+  <li>mesa: Note that 89a665e should not be picked</li>
+  <li>glsl: Reallow precision qualifiers on structure members</li>
+  <li>mesa: Support GL_MAX_VERTEX_OUTPUT_COMPONENTS query with ES3</li>
+  <li>mesa: Remove all traces of GL_OES_matrix_get</li>
+  <li>mesa: Don't return any data for GL_SHADER_BINARY_FORMATS</li>
+</ul>
+
+<p>Ilia Mirkin (2):</p>
+<ul>
+  <li>nv30: find first unused texcoord rather than bailing if first is used</li>
+  <li>nv30: fix inconsistent setting of push-&gt;user_priv</li>
+</ul>
+
+<p>Joakim Sindholt (1):</p>
+<ul>
+  <li>nvc0: fix blitctx memory leak</li>
+</ul>
+
+<p>Johannes Obermayr (1):</p>
+<ul>
+  <li>st/gbm: Add $(WAYLAND_CFLAGS) for HAVE_EGL_PLATFORM_WAYLAND.</li>
+</ul>
+
+<p>Kenneth Graunke (5):</p>
+<ul>
+  <li>i965/vs: Detect GRF sources in split_virtual_grfs send-from-GRF code.</li>
+  <li>i965/fs: Detect GRF sources in split_virtual_grfs send-from-GRF code.</li>
+  <li>i965/vec4: Only zero out unused message components when there are any.</li>
+  <li>i965: Fix brw_vs_prog_data_compare to actually check field members.</li>
+  <li>meta: Set correct viewport and projection in decompress_texture_image.</li>
+</ul>
+
+<p>Maarten Lankhorst (2):</p>
+<ul>
+  <li>st/dri: do not create a new context for msaa copy</li>
+  <li>nvc0: restore viewport after blit</li>
+</ul>
+
+<p>Marek Olšák (2):</p>
+<ul>
+  <li>r600g: fix constant buffer cache flushing</li>
+  <li>r600g: fix texture buffer object cache flushing</li>
+</ul>
+
+<p>Paul Berry (1):</p>
+<ul>
+  <li>i965: Initialize inout_offset parameter to brw_search_cache().</li>
+</ul>
+
+<p>Rico Schüller (1):</p>
+<ul>
+  <li>glx: Initialize OpenGL version to 1.0</li>
+</ul>
+
+<p>Tiziano Bacocco (1):</p>
+<ul>
+  <li>nvc0/ir: fix use after free in texture barrier insertion pass</li>
+</ul>
+
+<p>Torsten Duwe (1):</p>
+<ul>
+  <li>wayland-egl.pc requires wayland-client.pc.</li>
+</ul>
+
+</div>
+</body>
+</html>
diff --git a/docs/relnotes/9.2.2.html b/docs/relnotes/9.2.2.html
new file mode 100644
index 0000000..c2666a4
--- /dev/null
+++ b/docs/relnotes/9.2.2.html
@@ -0,0 +1,97 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<html lang="en">
+<head>
+  <meta http-equiv="content-type" content="text/html; charset=utf-8">
+  <title>Mesa Release Notes</title>
+  <link rel="stylesheet" type="text/css" href="../mesa.css">
+</head>
+<body>
+
+<div class="header">
+  <h1>The Mesa 3D Graphics Library</h1>
+</div>
+
+<iframe src="../contents.html"></iframe>
+<div class="content">
+
+<h1>Mesa 9.2.2 Release Notes / (October 18, 2013)</h1>
+
+<p>
+Mesa 9.2.2 is a bug fix release which fixes bugs found since the 9.2.1 release.
+</p>
+<p>
+Mesa 9.2 implements the OpenGL 3.1 API, but the version reported by
+glGetString(GL_VERSION) or glGetIntegerv(GL_MAJOR_VERSION) /
+glGetIntegerv(GL_MINOR_VERSION) depends on the particular driver being used.
+Some drivers don't support all the features required in OpenGL 3.1.  OpenGL
+3.1 is <strong>only</strong> available if requested at context creation
+because GL_ARB_compatibility is not supported.
+</p>
+
+
+<h2>MD5 checksums</h2>
+<pre>
+</pre>
+
+
+<h2>New features</h2>
+<p>None</p>
+
+<h2>Bug fixes</h2>
+
+<p>This list is likely incomplete.</p>
+
+<ul>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=69449">Bug 69449</a> - Valgrind error in program_resource_visitor::recursion</li>
+
+<li><a href="https://bugs.freedesktop.org/show_bug.cgi?id=70411">Bug 70411</a> - glInvalidateFramebuffer fails with GL_INVALID_ENUM</li>
+
+</ul>
+
+<h2>Changes</h2>
+
+<p>The full set of changes can be viewed by using the following GIT command:</p>
+
+<pre>
+  git log mesa-9.2.1..mesa-9.2.2
+</pre>
+
+<p>Brian Paul (3):</p>
+<ul>
+  <li>docs: add missing &lt;pre&gt; tag</li>
+  <li>svga: fix incorrect memcpy src in svga_buffer_upload_piecewise()</li>
+  <li>mesa: consolidate cube width=height error checking</li>
+</ul>
+
+<p>Carl Worth (3):</p>
+<ul>
+  <li>docs: Add md5sums for 9.2.1 release</li>
+  <li>Bump version to 9.2.2</li>
+</ul>
+
+<p>Constantin Baranov (1):</p>
+<ul>
+  <li>mesa: Add missing switch break in invalidate_framebuffer_storage()</li>
+</ul>
+
+<p>Eric Anholt (3):</p>
+<ul>
+  <li>i965: Don't forget the cube map padding on gen5+.</li>
+  <li>mesa: Fix compiler warnings when ALIGN's alignment is "1 &lt;&lt; value".</li>
+  <li>i965: Fix 3D texture layout by more literally copying from the spec.</li>
+</ul>
+
+<p>Francisco Jerez (1):</p>
+<ul>
+  <li>glsl: Fix usage of the wrong union member in program_resource_visitor::recursion.</li>
+</ul>
+
+<p>Tom Stellard (1):</p>
+<ul>
+  <li>radeonsi: Use 'SI' as the LLVM processor for CIK on LLVM &lt;= 3.3</li>
+</ul>
+
+</div>
+</body>
+</html>
diff --git a/docs/relnotes/9.3.html b/docs/relnotes/9.3.html
deleted file mode 100644
index 1b34a9a..0000000
--- a/docs/relnotes/9.3.html
+++ /dev/null
@@ -1,61 +0,0 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
-<html lang="en">
-<head>
-  <meta http-equiv="content-type" content="text/html; charset=utf-8">
-  <title>Mesa Release Notes</title>
-  <link rel="stylesheet" type="text/css" href="../mesa.css">
-</head>
-<body>
-
-<div class="header">
-  <h1>The Mesa 3D Graphics Library</h1>
-</div>
-
-<iframe src="../contents.html"></iframe>
-<div class="content">
-
-<h1>Mesa 9.3 Release Notes / TBD</h1>
-
-<p>
-Mesa 9.3 is a new development release.
-People who are concerned with stability and reliability should stick
-with a previous release or wait for Mesa 9.3.1.
-</p>
-<p>
-Mesa 9.3 implements the OpenGL 3.1 API, but the version reported by
-glGetString(GL_VERSION) or glGetIntegerv(GL_MAJOR_VERSION) /
-glGetIntegerv(GL_MINOR_VERSION) depends on the particular driver being used.
-Some drivers don't support all the features required in OpenGL 3.1.  OpenGL
-3.1 is <strong>only</strong> available if requested at context creation
-because GL_ARB_compatibility is not supported.
-</p>
-
-
-<h2>MD5 checksums</h2>
-<pre>
-TBD.
-</pre>
-
-
-<h2>New features</h2>
-
-<p>
-Note: some of the new features are only available with certain drivers.
-</p>
-
-<ul>
-<li>GL_AMD_seamless_cubemap_per_texture on i965.</li>
-</ul>
-
-
-<h2>Bug fixes</h2>
-
-TBD.
-
-<h2>Changes</h2>
-
-TBD.
-
-</div>
-</body>
-</html>
diff --git a/doxygen/.gitignore b/doxygen/.gitignore
index 02d0730..abf56ac 100644
--- a/doxygen/.gitignore
+++ b/doxygen/.gitignore
@@ -8,6 +8,7 @@ gallium
 gbm
 glapi
 glsl
+i965
 main
 math
 math_subset
diff --git a/doxygen/Makefile b/doxygen/Makefile
index 2bea0b3..0a95a35 100644
--- a/doxygen/Makefile
+++ b/doxygen/Makefile
@@ -17,7 +17,8 @@ FULL = \
 	swrast_setup.doxy \
 	tnl.doxy \
 	tnl_dd.doxy \
-	gbm.doxy
+	gbm.doxy \
+	i965.doxy
 
 full: $(FULL:.doxy=.tag)
 	$(foreach FILE,$(FULL),doxygen $(FILE);)
diff --git a/doxygen/header.html b/doxygen/header.html
index 3127da2..abd736f 100644
--- a/doxygen/header.html
+++ b/doxygen/header.html
@@ -15,5 +15,6 @@
 <a class="qindex" href="../swrast_setup/index.html">swrast_setup</a> |
 <a class="qindex" href="../tnl/index.html">tnl</a> |
 <a class="qindex" href="../tnl_dd/index.html">tnl_dd</a> |
-<a class="qindex" href="../gbm/index.html">gbm</a>
+<a class="qindex" href="../gbm/index.html">gbm</a> |
+<a class="qindex" href="../i965/index.html">i965</a>
 </div>
diff --git a/doxygen/i965.doxy b/doxygen/i965.doxy
new file mode 100644
index 0000000..a3aa2b6
--- /dev/null
+++ b/doxygen/i965.doxy
@@ -0,0 +1,50 @@
+# Doxyfile 0.1
+
+@INCLUDE               = common.doxy
+
+#---------------------------------------------------------------------------
+# General configuration options
+#---------------------------------------------------------------------------
+PROJECT_NAME           = "Intel i965 Driver"
+#---------------------------------------------------------------------------
+# Configuration options related to the input files
+#---------------------------------------------------------------------------
+INPUT                  = ../src/mesa/drivers/dri/i965
+FILE_PATTERNS          = *.c *.cpp *.h
+RECURSIVE              = NO
+EXCLUDE                =
+EXCLUDE_PATTERNS       =
+EXAMPLE_PATH           =
+EXAMPLE_PATTERNS       =
+EXAMPLE_RECURSIVE      = NO
+IMAGE_PATH             =
+INPUT_FILTER           =
+FILTER_SOURCE_FILES    = NO
+#---------------------------------------------------------------------------
+# Configuration options related to the HTML output
+#---------------------------------------------------------------------------
+HTML_OUTPUT            = i965
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+ENABLE_PREPROCESSING   = YES
+MACRO_EXPANSION        = NO
+EXPAND_ONLY_PREDEF     = NO
+SEARCH_INCLUDES        = YES
+INCLUDE_PATH           = ../include/
+INCLUDE_FILE_PATTERNS  =
+PREDEFINED             =
+EXPAND_AS_DEFINED      =
+SKIP_FUNCTION_MACROS   = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references
+#---------------------------------------------------------------------------
+TAGFILES               = glsl.tag=../glsl \
+                         main.tag=../main \
+                         math.tag=../math \
+                         swrast.tag=../swrast \
+                         swrast_setup.tag=../swrast_setup \
+                         tnl.tag=../tnl \
+                         tnl_dd.tag=../tnl_dd \
+                         vbo.tag=vbo
+GENERATE_TAGFILE       = i965.tag
diff --git a/include/GL/gl.h b/include/GL/gl.h
index 975cfe8..babb746 100644
--- a/include/GL/gl.h
+++ b/include/GL/gl.h
@@ -1736,8 +1736,6 @@ GLAPI void GLAPIENTRY glSeparableFilter2D( GLenum target,
 GLAPI void GLAPIENTRY glGetSeparableFilter( GLenum target, GLenum format,
 	GLenum type, GLvoid *row, GLvoid *column, GLvoid *span );
 
-typedef void (APIENTRYP PFNGLBLENDCOLORPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
-typedef void (APIENTRYP PFNGLBLENDEQUATIONPROC) (GLenum mode);
 
 
 
diff --git a/include/GL/glext.h b/include/GL/glext.h
index 0c2c946..fea9e1f 100644
--- a/include/GL/glext.h
+++ b/include/GL/glext.h
@@ -33,7 +33,7 @@ extern "C" {
 ** used to make the header, and the header can be found at
 **   http://www.opengl.org/registry/
 **
-** Khronos $Revision$ on $Date$
+** Khronos $Revision: 23422 $ on $Date: 2013-10-08 15:40:45 -0700 (Tue, 08 Oct 2013) $
 */
 
 #if defined(_WIN32) && !defined(APIENTRY) && !defined(__CYGWIN__) && !defined(__SCITECH_SNAP__)
@@ -53,7 +53,7 @@ extern "C" {
 #define GLAPI extern
 #endif
 
-#define GL_GLEXT_VERSION 20130708
+#define GL_GLEXT_VERSION 20131008
 
 /* Generated C header for:
  * API: gl
@@ -108,18 +108,14 @@ extern "C" {
 #define GL_SINGLE_COLOR                   0x81F9
 #define GL_SEPARATE_SPECULAR_COLOR        0x81FA
 #define GL_ALIASED_POINT_SIZE_RANGE       0x846D
-typedef void (APIENTRYP PFNGLBLENDCOLORPROC) (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
-typedef void (APIENTRYP PFNGLBLENDEQUATIONPROC) (GLenum mode);
-typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
-typedef void (APIENTRYP PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-typedef void (APIENTRYP PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
+typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
+typedef void (APIENTRYP PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
+typedef void (APIENTRYP PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
 typedef void (APIENTRYP PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glBlendColor (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
-GLAPI void APIENTRY glBlendEquation (GLenum mode);
-GLAPI void APIENTRY glDrawRangeElements (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
-GLAPI void APIENTRY glTexImage3D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-GLAPI void APIENTRY glTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
+GLAPI void APIENTRY glDrawRangeElements (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
+GLAPI void APIENTRY glTexImage3D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
+GLAPI void APIENTRY glTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
 GLAPI void APIENTRY glCopyTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
 #endif
 #endif /* GL_VERSION_1_2 */
@@ -224,13 +220,13 @@ GLAPI void APIENTRY glCopyTexSubImage3D (GLenum target, GLint level, GLint xoffs
 #define GL_DOT3_RGBA                      0x86AF
 typedef void (APIENTRYP PFNGLACTIVETEXTUREPROC) (GLenum texture);
 typedef void (APIENTRYP PFNGLSAMPLECOVERAGEPROC) (GLfloat value, GLboolean invert);
-typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
-typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
-typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
-typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
-typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
-typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
-typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint level, GLvoid *img);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
+typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint level, void *img);
 typedef void (APIENTRYP PFNGLCLIENTACTIVETEXTUREPROC) (GLenum texture);
 typedef void (APIENTRYP PFNGLMULTITEXCOORD1DPROC) (GLenum target, GLdouble s);
 typedef void (APIENTRYP PFNGLMULTITEXCOORD1DVPROC) (GLenum target, const GLdouble *v);
@@ -271,13 +267,13 @@ typedef void (APIENTRYP PFNGLMULTTRANSPOSEMATRIXDPROC) (const GLdouble *m);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glActiveTexture (GLenum texture);
 GLAPI void APIENTRY glSampleCoverage (GLfloat value, GLboolean invert);
-GLAPI void APIENTRY glCompressedTexImage3D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
-GLAPI void APIENTRY glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
-GLAPI void APIENTRY glCompressedTexImage1D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
-GLAPI void APIENTRY glCompressedTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
-GLAPI void APIENTRY glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
-GLAPI void APIENTRY glCompressedTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
-GLAPI void APIENTRY glGetCompressedTexImage (GLenum target, GLint level, GLvoid *img);
+GLAPI void APIENTRY glCompressedTexImage3D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
+GLAPI void APIENTRY glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
+GLAPI void APIENTRY glCompressedTexImage1D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
+GLAPI void APIENTRY glCompressedTexSubImage3D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
+GLAPI void APIENTRY glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
+GLAPI void APIENTRY glCompressedTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
+GLAPI void APIENTRY glGetCompressedTexImage (GLenum target, GLint level, void *img);
 GLAPI void APIENTRY glClientActiveTexture (GLenum texture);
 GLAPI void APIENTRY glMultiTexCoord1d (GLenum target, GLdouble s);
 GLAPI void APIENTRY glMultiTexCoord1dv (GLenum target, const GLdouble *v);
@@ -359,9 +355,18 @@ GLAPI void APIENTRY glMultTransposeMatrixd (const GLdouble *m);
 #define GL_TEXTURE_FILTER_CONTROL         0x8500
 #define GL_DEPTH_TEXTURE_MODE             0x884B
 #define GL_COMPARE_R_TO_TEXTURE           0x884E
+#define GL_FUNC_ADD                       0x8006
+#define GL_FUNC_SUBTRACT                  0x800A
+#define GL_FUNC_REVERSE_SUBTRACT          0x800B
+#define GL_MIN                            0x8007
+#define GL_MAX                            0x8008
+#define GL_CONSTANT_COLOR                 0x8001
+#define GL_ONE_MINUS_CONSTANT_COLOR       0x8002
+#define GL_CONSTANT_ALPHA                 0x8003
+#define GL_ONE_MINUS_CONSTANT_ALPHA       0x8004
 typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
 typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
-typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid *const*indices, GLsizei drawcount);
+typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSPROC) (GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount);
 typedef void (APIENTRYP PFNGLPOINTPARAMETERFPROC) (GLenum pname, GLfloat param);
 typedef void (APIENTRYP PFNGLPOINTPARAMETERFVPROC) (GLenum pname, const GLfloat *params);
 typedef void (APIENTRYP PFNGLPOINTPARAMETERIPROC) (GLenum pname, GLint param);
@@ -370,7 +375,7 @@ typedef void (APIENTRYP PFNGLFOGCOORDFPROC) (GLfloat coord);
 typedef void (APIENTRYP PFNGLFOGCOORDFVPROC) (const GLfloat *coord);
 typedef void (APIENTRYP PFNGLFOGCOORDDPROC) (GLdouble coord);
 typedef void (APIENTRYP PFNGLFOGCOORDDVPROC) (const GLdouble *coord);
-typedef void (APIENTRYP PFNGLFOGCOORDPOINTERPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLFOGCOORDPOINTERPROC) (GLenum type, GLsizei stride, const void *pointer);
 typedef void (APIENTRYP PFNGLSECONDARYCOLOR3BPROC) (GLbyte red, GLbyte green, GLbyte blue);
 typedef void (APIENTRYP PFNGLSECONDARYCOLOR3BVPROC) (const GLbyte *v);
 typedef void (APIENTRYP PFNGLSECONDARYCOLOR3DPROC) (GLdouble red, GLdouble green, GLdouble blue);
@@ -387,7 +392,7 @@ typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UIPROC) (GLuint red, GLuint green, G
 typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UIVPROC) (const GLuint *v);
 typedef void (APIENTRYP PFNGLSECONDARYCOLOR3USPROC) (GLushort red, GLushort green, GLushort blue);
 typedef void (APIENTRYP PFNGLSECONDARYCOLOR3USVPROC) (const GLushort *v);
-typedef void (APIENTRYP PFNGLSECONDARYCOLORPOINTERPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLSECONDARYCOLORPOINTERPROC) (GLint size, GLenum type, GLsizei stride, const void *pointer);
 typedef void (APIENTRYP PFNGLWINDOWPOS2DPROC) (GLdouble x, GLdouble y);
 typedef void (APIENTRYP PFNGLWINDOWPOS2DVPROC) (const GLdouble *v);
 typedef void (APIENTRYP PFNGLWINDOWPOS2FPROC) (GLfloat x, GLfloat y);
@@ -404,10 +409,12 @@ typedef void (APIENTRYP PFNGLWINDOWPOS3IPROC) (GLint x, GLint y, GLint z);
 typedef void (APIENTRYP PFNGLWINDOWPOS3IVPROC) (const GLint *v);
 typedef void (APIENTRYP PFNGLWINDOWPOS3SPROC) (GLshort x, GLshort y, GLshort z);
 typedef void (APIENTRYP PFNGLWINDOWPOS3SVPROC) (const GLshort *v);
+typedef void (APIENTRYP PFNGLBLENDCOLORPROC) (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
+typedef void (APIENTRYP PFNGLBLENDEQUATIONPROC) (GLenum mode);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glBlendFuncSeparate (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
 GLAPI void APIENTRY glMultiDrawArrays (GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
-GLAPI void APIENTRY glMultiDrawElements (GLenum mode, const GLsizei *count, GLenum type, const GLvoid *const*indices, GLsizei drawcount);
+GLAPI void APIENTRY glMultiDrawElements (GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount);
 GLAPI void APIENTRY glPointParameterf (GLenum pname, GLfloat param);
 GLAPI void APIENTRY glPointParameterfv (GLenum pname, const GLfloat *params);
 GLAPI void APIENTRY glPointParameteri (GLenum pname, GLint param);
@@ -416,7 +423,7 @@ GLAPI void APIENTRY glFogCoordf (GLfloat coord);
 GLAPI void APIENTRY glFogCoordfv (const GLfloat *coord);
 GLAPI void APIENTRY glFogCoordd (GLdouble coord);
 GLAPI void APIENTRY glFogCoorddv (const GLdouble *coord);
-GLAPI void APIENTRY glFogCoordPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
+GLAPI void APIENTRY glFogCoordPointer (GLenum type, GLsizei stride, const void *pointer);
 GLAPI void APIENTRY glSecondaryColor3b (GLbyte red, GLbyte green, GLbyte blue);
 GLAPI void APIENTRY glSecondaryColor3bv (const GLbyte *v);
 GLAPI void APIENTRY glSecondaryColor3d (GLdouble red, GLdouble green, GLdouble blue);
@@ -433,7 +440,7 @@ GLAPI void APIENTRY glSecondaryColor3ui (GLuint red, GLuint green, GLuint blue);
 GLAPI void APIENTRY glSecondaryColor3uiv (const GLuint *v);
 GLAPI void APIENTRY glSecondaryColor3us (GLushort red, GLushort green, GLushort blue);
 GLAPI void APIENTRY glSecondaryColor3usv (const GLushort *v);
-GLAPI void APIENTRY glSecondaryColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+GLAPI void APIENTRY glSecondaryColorPointer (GLint size, GLenum type, GLsizei stride, const void *pointer);
 GLAPI void APIENTRY glWindowPos2d (GLdouble x, GLdouble y);
 GLAPI void APIENTRY glWindowPos2dv (const GLdouble *v);
 GLAPI void APIENTRY glWindowPos2f (GLfloat x, GLfloat y);
@@ -450,6 +457,8 @@ GLAPI void APIENTRY glWindowPos3i (GLint x, GLint y, GLint z);
 GLAPI void APIENTRY glWindowPos3iv (const GLint *v);
 GLAPI void APIENTRY glWindowPos3s (GLshort x, GLshort y, GLshort z);
 GLAPI void APIENTRY glWindowPos3sv (const GLshort *v);
+GLAPI void APIENTRY glBlendColor (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
+GLAPI void APIENTRY glBlendEquation (GLenum mode);
 #endif
 #endif /* GL_VERSION_1_4 */
 
@@ -520,13 +529,13 @@ typedef void (APIENTRYP PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
 typedef void (APIENTRYP PFNGLDELETEBUFFERSPROC) (GLsizei n, const GLuint *buffers);
 typedef void (APIENTRYP PFNGLGENBUFFERSPROC) (GLsizei n, GLuint *buffers);
 typedef GLboolean (APIENTRYP PFNGLISBUFFERPROC) (GLuint buffer);
-typedef void (APIENTRYP PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
-typedef void (APIENTRYP PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
-typedef void (APIENTRYP PFNGLGETBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
+typedef void (APIENTRYP PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const void *data, GLenum usage);
+typedef void (APIENTRYP PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const void *data);
+typedef void (APIENTRYP PFNGLGETBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, void *data);
 typedef void *(APIENTRYP PFNGLMAPBUFFERPROC) (GLenum target, GLenum access);
 typedef GLboolean (APIENTRYP PFNGLUNMAPBUFFERPROC) (GLenum target);
 typedef void (APIENTRYP PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
-typedef void (APIENTRYP PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, GLvoid **params);
+typedef void (APIENTRYP PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, void **params);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glGenQueries (GLsizei n, GLuint *ids);
 GLAPI void APIENTRY glDeleteQueries (GLsizei n, const GLuint *ids);
@@ -540,13 +549,13 @@ GLAPI void APIENTRY glBindBuffer (GLenum target, GLuint buffer);
 GLAPI void APIENTRY glDeleteBuffers (GLsizei n, const GLuint *buffers);
 GLAPI void APIENTRY glGenBuffers (GLsizei n, GLuint *buffers);
 GLAPI GLboolean APIENTRY glIsBuffer (GLuint buffer);
-GLAPI void APIENTRY glBufferData (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
-GLAPI void APIENTRY glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
-GLAPI void APIENTRY glGetBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid *data);
+GLAPI void APIENTRY glBufferData (GLenum target, GLsizeiptr size, const void *data, GLenum usage);
+GLAPI void APIENTRY glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const void *data);
+GLAPI void APIENTRY glGetBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, void *data);
 GLAPI void *APIENTRY glMapBuffer (GLenum target, GLenum access);
 GLAPI GLboolean APIENTRY glUnmapBuffer (GLenum target);
 GLAPI void APIENTRY glGetBufferParameteriv (GLenum target, GLenum pname, GLint *params);
-GLAPI void APIENTRY glGetBufferPointerv (GLenum target, GLenum pname, GLvoid **params);
+GLAPI void APIENTRY glGetBufferPointerv (GLenum target, GLenum pname, void **params);
 #endif
 #endif /* GL_VERSION_1_5 */
 
@@ -667,7 +676,7 @@ typedef void (APIENTRYP PFNGLGETUNIFORMIVPROC) (GLuint program, GLint location,
 typedef void (APIENTRYP PFNGLGETVERTEXATTRIBDVPROC) (GLuint index, GLenum pname, GLdouble *params);
 typedef void (APIENTRYP PFNGLGETVERTEXATTRIBFVPROC) (GLuint index, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIVPROC) (GLuint index, GLenum pname, GLint *params);
-typedef void (APIENTRYP PFNGLGETVERTEXATTRIBPOINTERVPROC) (GLuint index, GLenum pname, GLvoid **pointer);
+typedef void (APIENTRYP PFNGLGETVERTEXATTRIBPOINTERVPROC) (GLuint index, GLenum pname, void **pointer);
 typedef GLboolean (APIENTRYP PFNGLISPROGRAMPROC) (GLuint program);
 typedef GLboolean (APIENTRYP PFNGLISSHADERPROC) (GLuint shader);
 typedef void (APIENTRYP PFNGLLINKPROGRAMPROC) (GLuint program);
@@ -729,7 +738,7 @@ typedef void (APIENTRYP PFNGLVERTEXATTRIB4SVPROC) (GLuint index, const GLshort *
 typedef void (APIENTRYP PFNGLVERTEXATTRIB4UBVPROC) (GLuint index, const GLubyte *v);
 typedef void (APIENTRYP PFNGLVERTEXATTRIB4UIVPROC) (GLuint index, const GLuint *v);
 typedef void (APIENTRYP PFNGLVERTEXATTRIB4USVPROC) (GLuint index, const GLushort *v);
-typedef void (APIENTRYP PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glBlendEquationSeparate (GLenum modeRGB, GLenum modeAlpha);
 GLAPI void APIENTRY glDrawBuffers (GLsizei n, const GLenum *bufs);
@@ -761,7 +770,7 @@ GLAPI void APIENTRY glGetUniformiv (GLuint program, GLint location, GLint *param
 GLAPI void APIENTRY glGetVertexAttribdv (GLuint index, GLenum pname, GLdouble *params);
 GLAPI void APIENTRY glGetVertexAttribfv (GLuint index, GLenum pname, GLfloat *params);
 GLAPI void APIENTRY glGetVertexAttribiv (GLuint index, GLenum pname, GLint *params);
-GLAPI void APIENTRY glGetVertexAttribPointerv (GLuint index, GLenum pname, GLvoid **pointer);
+GLAPI void APIENTRY glGetVertexAttribPointerv (GLuint index, GLenum pname, void **pointer);
 GLAPI GLboolean APIENTRY glIsProgram (GLuint program);
 GLAPI GLboolean APIENTRY glIsShader (GLuint shader);
 GLAPI void APIENTRY glLinkProgram (GLuint program);
@@ -823,7 +832,7 @@ GLAPI void APIENTRY glVertexAttrib4sv (GLuint index, const GLshort *v);
 GLAPI void APIENTRY glVertexAttrib4ubv (GLuint index, const GLubyte *v);
 GLAPI void APIENTRY glVertexAttrib4uiv (GLuint index, const GLuint *v);
 GLAPI void APIENTRY glVertexAttrib4usv (GLuint index, const GLushort *v);
-GLAPI void APIENTRY glVertexAttribPointer (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
+GLAPI void APIENTRY glVertexAttribPointer (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
 #endif
 #endif /* GL_VERSION_2_0 */
 
@@ -1107,7 +1116,7 @@ typedef void (APIENTRYP PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) (GLuint program, G
 typedef void (APIENTRYP PFNGLCLAMPCOLORPROC) (GLenum target, GLenum clamp);
 typedef void (APIENTRYP PFNGLBEGINCONDITIONALRENDERPROC) (GLuint id, GLenum mode);
 typedef void (APIENTRYP PFNGLENDCONDITIONALRENDERPROC) (void);
-typedef void (APIENTRYP PFNGLVERTEXATTRIBIPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBIPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
 typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIIVPROC) (GLuint index, GLenum pname, GLint *params);
 typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIUIVPROC) (GLuint index, GLenum pname, GLuint *params);
 typedef void (APIENTRYP PFNGLVERTEXATTRIBI1IPROC) (GLuint index, GLint x);
@@ -1192,7 +1201,7 @@ GLAPI void APIENTRY glGetTransformFeedbackVarying (GLuint program, GLuint index,
 GLAPI void APIENTRY glClampColor (GLenum target, GLenum clamp);
 GLAPI void APIENTRY glBeginConditionalRender (GLuint id, GLenum mode);
 GLAPI void APIENTRY glEndConditionalRender (void);
-GLAPI void APIENTRY glVertexAttribIPointer (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+GLAPI void APIENTRY glVertexAttribIPointer (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
 GLAPI void APIENTRY glGetVertexAttribIiv (GLuint index, GLenum pname, GLint *params);
 GLAPI void APIENTRY glGetVertexAttribIuiv (GLuint index, GLenum pname, GLuint *params);
 GLAPI void APIENTRY glVertexAttribI1i (GLuint index, GLint x);
@@ -1325,7 +1334,7 @@ GLAPI GLboolean APIENTRY glIsVertexArray (GLuint array);
 #define GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER 0x8A46
 #define GL_INVALID_INDEX                  0xFFFFFFFFu
 typedef void (APIENTRYP PFNGLDRAWARRAYSINSTANCEDPROC) (GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
-typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount);
+typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount);
 typedef void (APIENTRYP PFNGLTEXBUFFERPROC) (GLenum target, GLenum internalformat, GLuint buffer);
 typedef void (APIENTRYP PFNGLPRIMITIVERESTARTINDEXPROC) (GLuint index);
 typedef void (APIENTRYP PFNGLCOPYBUFFERSUBDATAPROC) (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
@@ -1338,7 +1347,7 @@ typedef void (APIENTRYP PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) (GLuint program, GLu
 typedef void (APIENTRYP PFNGLUNIFORMBLOCKBINDINGPROC) (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glDrawArraysInstanced (GLenum mode, GLint first, GLsizei count, GLsizei instancecount);
-GLAPI void APIENTRY glDrawElementsInstanced (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount);
+GLAPI void APIENTRY glDrawElementsInstanced (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount);
 GLAPI void APIENTRY glTexBuffer (GLenum target, GLenum internalformat, GLuint buffer);
 GLAPI void APIENTRY glPrimitiveRestartIndex (GLuint index);
 GLAPI void APIENTRY glCopyBufferSubData (GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
@@ -1458,10 +1467,10 @@ typedef int64_t GLint64;
 #define GL_MAX_COLOR_TEXTURE_SAMPLES      0x910E
 #define GL_MAX_DEPTH_TEXTURE_SAMPLES      0x910F
 #define GL_MAX_INTEGER_SAMPLES            0x9110
-typedef void (APIENTRYP PFNGLDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
-typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
-typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount, GLint basevertex);
-typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid *const*indices, GLsizei drawcount, const GLint *basevertex);
+typedef void (APIENTRYP PFNGLDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex);
+typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex);
+typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex);
+typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount, const GLint *basevertex);
 typedef void (APIENTRYP PFNGLPROVOKINGVERTEXPROC) (GLenum mode);
 typedef GLsync (APIENTRYP PFNGLFENCESYNCPROC) (GLenum condition, GLbitfield flags);
 typedef GLboolean (APIENTRYP PFNGLISSYNCPROC) (GLsync sync);
@@ -1473,15 +1482,15 @@ typedef void (APIENTRYP PFNGLGETSYNCIVPROC) (GLsync sync, GLenum pname, GLsizei
 typedef void (APIENTRYP PFNGLGETINTEGER64I_VPROC) (GLenum target, GLuint index, GLint64 *data);
 typedef void (APIENTRYP PFNGLGETBUFFERPARAMETERI64VPROC) (GLenum target, GLenum pname, GLint64 *params);
 typedef void (APIENTRYP PFNGLFRAMEBUFFERTEXTUREPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
-typedef void (APIENTRYP PFNGLTEXIMAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
-typedef void (APIENTRYP PFNGLTEXIMAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
+typedef void (APIENTRYP PFNGLTEXIMAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
+typedef void (APIENTRYP PFNGLTEXIMAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
 typedef void (APIENTRYP PFNGLGETMULTISAMPLEFVPROC) (GLenum pname, GLuint index, GLfloat *val);
 typedef void (APIENTRYP PFNGLSAMPLEMASKIPROC) (GLuint index, GLbitfield mask);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glDrawElementsBaseVertex (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
-GLAPI void APIENTRY glDrawRangeElementsBaseVertex (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices, GLint basevertex);
-GLAPI void APIENTRY glDrawElementsInstancedBaseVertex (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei instancecount, GLint basevertex);
-GLAPI void APIENTRY glMultiDrawElementsBaseVertex (GLenum mode, const GLsizei *count, GLenum type, const GLvoid *const*indices, GLsizei drawcount, const GLint *basevertex);
+GLAPI void APIENTRY glDrawElementsBaseVertex (GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex);
+GLAPI void APIENTRY glDrawRangeElementsBaseVertex (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex);
+GLAPI void APIENTRY glDrawElementsInstancedBaseVertex (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex);
+GLAPI void APIENTRY glMultiDrawElementsBaseVertex (GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei drawcount, const GLint *basevertex);
 GLAPI void APIENTRY glProvokingVertex (GLenum mode);
 GLAPI GLsync APIENTRY glFenceSync (GLenum condition, GLbitfield flags);
 GLAPI GLboolean APIENTRY glIsSync (GLsync sync);
@@ -1493,8 +1502,8 @@ GLAPI void APIENTRY glGetSynciv (GLsync sync, GLenum pname, GLsizei bufSize, GLs
 GLAPI void APIENTRY glGetInteger64i_v (GLenum target, GLuint index, GLint64 *data);
 GLAPI void APIENTRY glGetBufferParameteri64v (GLenum target, GLenum pname, GLint64 *params);
 GLAPI void APIENTRY glFramebufferTexture (GLenum target, GLenum attachment, GLuint texture, GLint level);
-GLAPI void APIENTRY glTexImage2DMultisample (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
-GLAPI void APIENTRY glTexImage3DMultisample (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
+GLAPI void APIENTRY glTexImage2DMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
+GLAPI void APIENTRY glTexImage3DMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
 GLAPI void APIENTRY glGetMultisamplefv (GLenum pname, GLuint index, GLfloat *val);
 GLAPI void APIENTRY glSampleMaski (GLuint index, GLbitfield mask);
 #endif
@@ -1722,8 +1731,8 @@ typedef void (APIENTRYP PFNGLBLENDEQUATIONIPROC) (GLuint buf, GLenum mode);
 typedef void (APIENTRYP PFNGLBLENDEQUATIONSEPARATEIPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
 typedef void (APIENTRYP PFNGLBLENDFUNCIPROC) (GLuint buf, GLenum src, GLenum dst);
 typedef void (APIENTRYP PFNGLBLENDFUNCSEPARATEIPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
-typedef void (APIENTRYP PFNGLDRAWARRAYSINDIRECTPROC) (GLenum mode, const GLvoid *indirect);
-typedef void (APIENTRYP PFNGLDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const GLvoid *indirect);
+typedef void (APIENTRYP PFNGLDRAWARRAYSINDIRECTPROC) (GLenum mode, const void *indirect);
+typedef void (APIENTRYP PFNGLDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const void *indirect);
 typedef void (APIENTRYP PFNGLUNIFORM1DPROC) (GLint location, GLdouble x);
 typedef void (APIENTRYP PFNGLUNIFORM2DPROC) (GLint location, GLdouble x, GLdouble y);
 typedef void (APIENTRYP PFNGLUNIFORM3DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z);
@@ -1769,8 +1778,8 @@ GLAPI void APIENTRY glBlendEquationi (GLuint buf, GLenum mode);
 GLAPI void APIENTRY glBlendEquationSeparatei (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
 GLAPI void APIENTRY glBlendFunci (GLuint buf, GLenum src, GLenum dst);
 GLAPI void APIENTRY glBlendFuncSeparatei (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
-GLAPI void APIENTRY glDrawArraysIndirect (GLenum mode, const GLvoid *indirect);
-GLAPI void APIENTRY glDrawElementsIndirect (GLenum mode, GLenum type, const GLvoid *indirect);
+GLAPI void APIENTRY glDrawArraysIndirect (GLenum mode, const void *indirect);
+GLAPI void APIENTRY glDrawElementsIndirect (GLenum mode, GLenum type, const void *indirect);
 GLAPI void APIENTRY glUniform1d (GLint location, GLdouble x);
 GLAPI void APIENTRY glUniform2d (GLint location, GLdouble x, GLdouble y);
 GLAPI void APIENTRY glUniform3d (GLint location, GLdouble x, GLdouble y, GLdouble z);
@@ -1851,12 +1860,12 @@ GLAPI void APIENTRY glGetQueryIndexediv (GLenum target, GLuint index, GLenum pna
 #define GL_VIEWPORT_INDEX_PROVOKING_VERTEX 0x825F
 #define GL_UNDEFINED_VERTEX               0x8260
 typedef void (APIENTRYP PFNGLRELEASESHADERCOMPILERPROC) (void);
-typedef void (APIENTRYP PFNGLSHADERBINARYPROC) (GLsizei count, const GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLsizei length);
+typedef void (APIENTRYP PFNGLSHADERBINARYPROC) (GLsizei count, const GLuint *shaders, GLenum binaryformat, const void *binary, GLsizei length);
 typedef void (APIENTRYP PFNGLGETSHADERPRECISIONFORMATPROC) (GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision);
 typedef void (APIENTRYP PFNGLDEPTHRANGEFPROC) (GLfloat n, GLfloat f);
 typedef void (APIENTRYP PFNGLCLEARDEPTHFPROC) (GLfloat d);
-typedef void (APIENTRYP PFNGLGETPROGRAMBINARYPROC) (GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary);
-typedef void (APIENTRYP PFNGLPROGRAMBINARYPROC) (GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length);
+typedef void (APIENTRYP PFNGLGETPROGRAMBINARYPROC) (GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary);
+typedef void (APIENTRYP PFNGLPROGRAMBINARYPROC) (GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
 typedef void (APIENTRYP PFNGLPROGRAMPARAMETERIPROC) (GLuint program, GLenum pname, GLint value);
 typedef void (APIENTRYP PFNGLUSEPROGRAMSTAGESPROC) (GLuint pipeline, GLbitfield stages, GLuint program);
 typedef void (APIENTRYP PFNGLACTIVESHADERPROGRAMPROC) (GLuint pipeline, GLuint program);
@@ -1926,7 +1935,7 @@ typedef void (APIENTRYP PFNGLVERTEXATTRIBL1DVPROC) (GLuint index, const GLdouble
 typedef void (APIENTRYP PFNGLVERTEXATTRIBL2DVPROC) (GLuint index, const GLdouble *v);
 typedef void (APIENTRYP PFNGLVERTEXATTRIBL3DVPROC) (GLuint index, const GLdouble *v);
 typedef void (APIENTRYP PFNGLVERTEXATTRIBL4DVPROC) (GLuint index, const GLdouble *v);
-typedef void (APIENTRYP PFNGLVERTEXATTRIBLPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBLPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
 typedef void (APIENTRYP PFNGLGETVERTEXATTRIBLDVPROC) (GLuint index, GLenum pname, GLdouble *params);
 typedef void (APIENTRYP PFNGLVIEWPORTARRAYVPROC) (GLuint first, GLsizei count, const GLfloat *v);
 typedef void (APIENTRYP PFNGLVIEWPORTINDEXEDFPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
@@ -1940,12 +1949,12 @@ typedef void (APIENTRYP PFNGLGETFLOATI_VPROC) (GLenum target, GLuint index, GLfl
 typedef void (APIENTRYP PFNGLGETDOUBLEI_VPROC) (GLenum target, GLuint index, GLdouble *data);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glReleaseShaderCompiler (void);
-GLAPI void APIENTRY glShaderBinary (GLsizei count, const GLuint *shaders, GLenum binaryformat, const GLvoid *binary, GLsizei length);
+GLAPI void APIENTRY glShaderBinary (GLsizei count, const GLuint *shaders, GLenum binaryformat, const void *binary, GLsizei length);
 GLAPI void APIENTRY glGetShaderPrecisionFormat (GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision);
 GLAPI void APIENTRY glDepthRangef (GLfloat n, GLfloat f);
 GLAPI void APIENTRY glClearDepthf (GLfloat d);
-GLAPI void APIENTRY glGetProgramBinary (GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary);
-GLAPI void APIENTRY glProgramBinary (GLuint program, GLenum binaryFormat, const GLvoid *binary, GLsizei length);
+GLAPI void APIENTRY glGetProgramBinary (GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary);
+GLAPI void APIENTRY glProgramBinary (GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
 GLAPI void APIENTRY glProgramParameteri (GLuint program, GLenum pname, GLint value);
 GLAPI void APIENTRY glUseProgramStages (GLuint pipeline, GLbitfield stages, GLuint program);
 GLAPI void APIENTRY glActiveShaderProgram (GLuint pipeline, GLuint program);
@@ -2015,7 +2024,7 @@ GLAPI void APIENTRY glVertexAttribL1dv (GLuint index, const GLdouble *v);
 GLAPI void APIENTRY glVertexAttribL2dv (GLuint index, const GLdouble *v);
 GLAPI void APIENTRY glVertexAttribL3dv (GLuint index, const GLdouble *v);
 GLAPI void APIENTRY glVertexAttribL4dv (GLuint index, const GLdouble *v);
-GLAPI void APIENTRY glVertexAttribLPointer (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+GLAPI void APIENTRY glVertexAttribLPointer (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
 GLAPI void APIENTRY glGetVertexAttribLdv (GLuint index, GLenum pname, GLdouble *params);
 GLAPI void APIENTRY glViewportArrayv (GLuint first, GLsizei count, const GLfloat *v);
 GLAPI void APIENTRY glViewportIndexedf (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
@@ -2139,7 +2148,7 @@ GLAPI void APIENTRY glGetDoublei_v (GLenum target, GLuint index, GLdouble *data)
 typedef void (APIENTRYP PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
 typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance);
 typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);
-typedef void (APIENTRYP PFNGLGETINTERNALFORMATI64VPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params);
+typedef void (APIENTRYP PFNGLGETINTERNALFORMATIVPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
 typedef void (APIENTRYP PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) (GLuint program, GLuint bufferIndex, GLenum pname, GLint *params);
 typedef void (APIENTRYP PFNGLBINDIMAGETEXTUREPROC) (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
 typedef void (APIENTRYP PFNGLMEMORYBARRIERPROC) (GLbitfield barriers);
@@ -2152,7 +2161,7 @@ typedef void (APIENTRYP PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) (GLenum m
 GLAPI void APIENTRY glDrawArraysInstancedBaseInstance (GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
 GLAPI void APIENTRY glDrawElementsInstancedBaseInstance (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance);
 GLAPI void APIENTRY glDrawElementsInstancedBaseVertexBaseInstance (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);
-GLAPI void APIENTRY glGetInternalformati64v (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params);
+GLAPI void APIENTRY glGetInternalformativ (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
 GLAPI void APIENTRY glGetActiveAtomicCounterBufferiv (GLuint program, GLuint bufferIndex, GLenum pname, GLint *params);
 GLAPI void APIENTRY glBindImageTexture (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
 GLAPI void APIENTRY glMemoryBarrier (GLbitfield barriers);
@@ -2191,10 +2200,10 @@ typedef void (APIENTRY  *GLDEBUGPROC)(GLenum source,GLenum type,GLuint id,GLenum
 #define GL_MAX_COMPUTE_ATOMIC_COUNTER_BUFFERS 0x8264
 #define GL_MAX_COMPUTE_ATOMIC_COUNTERS    0x8265
 #define GL_MAX_COMBINED_COMPUTE_UNIFORM_COMPONENTS 0x8266
-#define GL_MAX_COMPUTE_LOCAL_INVOCATIONS  0x90EB
+#define GL_MAX_COMPUTE_WORK_GROUP_INVOCATIONS 0x90EB
 #define GL_MAX_COMPUTE_WORK_GROUP_COUNT   0x91BE
 #define GL_MAX_COMPUTE_WORK_GROUP_SIZE    0x91BF
-#define GL_COMPUTE_LOCAL_WORK_SIZE        0x8267
+#define GL_COMPUTE_WORK_GROUP_SIZE        0x8267
 #define GL_UNIFORM_BLOCK_REFERENCED_BY_COMPUTE_SHADER 0x90EC
 #define GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_COMPUTE_SHADER 0x90ED
 #define GL_DISPATCH_INDIRECT_BUFFER       0x90EE
@@ -2431,6 +2440,7 @@ typedef void (APIENTRYP PFNGLDISPATCHCOMPUTEINDIRECTPROC) (GLintptr indirect);
 typedef void (APIENTRYP PFNGLCOPYIMAGESUBDATAPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
 typedef void (APIENTRYP PFNGLFRAMEBUFFERPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
 typedef void (APIENTRYP PFNGLGETFRAMEBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLGETINTERNALFORMATI64VPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params);
 typedef void (APIENTRYP PFNGLINVALIDATETEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
 typedef void (APIENTRYP PFNGLINVALIDATETEXIMAGEPROC) (GLuint texture, GLint level);
 typedef void (APIENTRYP PFNGLINVALIDATEBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
@@ -2449,8 +2459,6 @@ typedef void (APIENTRYP PFNGLSHADERSTORAGEBLOCKBINDINGPROC) (GLuint program, GLu
 typedef void (APIENTRYP PFNGLTEXBUFFERRANGEPROC) (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
 typedef void (APIENTRYP PFNGLTEXSTORAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
 typedef void (APIENTRYP PFNGLTEXSTORAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
-typedef void (APIENTRYP PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
-typedef void (APIENTRYP PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
 typedef void (APIENTRYP PFNGLTEXTUREVIEWPROC) (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
 typedef void (APIENTRYP PFNGLBINDVERTEXBUFFERPROC) (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
 typedef void (APIENTRYP PFNGLVERTEXATTRIBFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
@@ -2461,7 +2469,7 @@ typedef void (APIENTRYP PFNGLVERTEXBINDINGDIVISORPROC) (GLuint bindingindex, GLu
 typedef void (APIENTRYP PFNGLDEBUGMESSAGECONTROLPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
 typedef void (APIENTRYP PFNGLDEBUGMESSAGEINSERTPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
 typedef void (APIENTRYP PFNGLDEBUGMESSAGECALLBACKPROC) (GLDEBUGPROC callback, const void *userParam);
-typedef GLuint (APIENTRYP PFNGLGETDEBUGMESSAGELOGPROC) (GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
+typedef GLuint (APIENTRYP PFNGLGETDEBUGMESSAGELOGPROC) (GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
 typedef void (APIENTRYP PFNGLPUSHDEBUGGROUPPROC) (GLenum source, GLuint id, GLsizei length, const GLchar *message);
 typedef void (APIENTRYP PFNGLPOPDEBUGGROUPPROC) (void);
 typedef void (APIENTRYP PFNGLOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei length, const GLchar *label);
@@ -2476,6 +2484,7 @@ GLAPI void APIENTRY glDispatchComputeIndirect (GLintptr indirect);
 GLAPI void APIENTRY glCopyImageSubData (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
 GLAPI void APIENTRY glFramebufferParameteri (GLenum target, GLenum pname, GLint param);
 GLAPI void APIENTRY glGetFramebufferParameteriv (GLenum target, GLenum pname, GLint *params);
+GLAPI void APIENTRY glGetInternalformati64v (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params);
 GLAPI void APIENTRY glInvalidateTexSubImage (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
 GLAPI void APIENTRY glInvalidateTexImage (GLuint texture, GLint level);
 GLAPI void APIENTRY glInvalidateBufferSubData (GLuint buffer, GLintptr offset, GLsizeiptr length);
@@ -2494,8 +2503,6 @@ GLAPI void APIENTRY glShaderStorageBlockBinding (GLuint program, GLuint storageB
 GLAPI void APIENTRY glTexBufferRange (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
 GLAPI void APIENTRY glTexStorage2DMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
 GLAPI void APIENTRY glTexStorage3DMultisample (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
-GLAPI void APIENTRY glTextureStorage2DMultisampleEXT (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
-GLAPI void APIENTRY glTextureStorage3DMultisampleEXT (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
 GLAPI void APIENTRY glTextureView (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
 GLAPI void APIENTRY glBindVertexBuffer (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
 GLAPI void APIENTRY glVertexAttribFormat (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
@@ -2506,7 +2513,7 @@ GLAPI void APIENTRY glVertexBindingDivisor (GLuint bindingindex, GLuint divisor)
 GLAPI void APIENTRY glDebugMessageControl (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
 GLAPI void APIENTRY glDebugMessageInsert (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
 GLAPI void APIENTRY glDebugMessageCallback (GLDEBUGPROC callback, const void *userParam);
-GLAPI GLuint APIENTRY glGetDebugMessageLog (GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
+GLAPI GLuint APIENTRY glGetDebugMessageLog (GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
 GLAPI void APIENTRY glPushDebugGroup (GLenum source, GLuint id, GLsizei length, const GLchar *message);
 GLAPI void APIENTRY glPopDebugGroup (void);
 GLAPI void APIENTRY glObjectLabel (GLenum identifier, GLuint name, GLsizei length, const GLchar *label);
@@ -2516,6 +2523,49 @@ GLAPI void APIENTRY glGetObjectPtrLabel (const void *ptr, GLsizei bufSize, GLsiz
 #endif
 #endif /* GL_VERSION_4_3 */
 
+#ifndef GL_VERSION_4_4
+#define GL_VERSION_4_4 1
+#define GL_MAX_VERTEX_ATTRIB_STRIDE       0x82E5
+#define GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED 0x8221
+#define GL_TEXTURE_BUFFER_BINDING         0x8C2A
+#define GL_MAP_PERSISTENT_BIT             0x0040
+#define GL_MAP_COHERENT_BIT               0x0080
+#define GL_DYNAMIC_STORAGE_BIT            0x0100
+#define GL_CLIENT_STORAGE_BIT             0x0200
+#define GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT 0x00004000
+#define GL_BUFFER_IMMUTABLE_STORAGE       0x821F
+#define GL_BUFFER_STORAGE_FLAGS           0x8220
+#define GL_CLEAR_TEXTURE                  0x9365
+#define GL_LOCATION_COMPONENT             0x934A
+#define GL_TRANSFORM_FEEDBACK_BUFFER_INDEX 0x934B
+#define GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE 0x934C
+#define GL_QUERY_BUFFER                   0x9192
+#define GL_QUERY_BUFFER_BARRIER_BIT       0x00008000
+#define GL_QUERY_BUFFER_BINDING           0x9193
+#define GL_QUERY_RESULT_NO_WAIT           0x9194
+#define GL_MIRROR_CLAMP_TO_EDGE           0x8743
+typedef void (APIENTRYP PFNGLBUFFERSTORAGEPROC) (GLenum target, GLsizeiptr size, const void *data, GLbitfield flags);
+typedef void (APIENTRYP PFNGLCLEARTEXIMAGEPROC) (GLuint texture, GLint level, GLenum format, GLenum type, const void *data);
+typedef void (APIENTRYP PFNGLCLEARTEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
+typedef void (APIENTRYP PFNGLBINDBUFFERSBASEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint *buffers);
+typedef void (APIENTRYP PFNGLBINDBUFFERSRANGEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizeiptr *sizes);
+typedef void (APIENTRYP PFNGLBINDTEXTURESPROC) (GLuint first, GLsizei count, const GLuint *textures);
+typedef void (APIENTRYP PFNGLBINDSAMPLERSPROC) (GLuint first, GLsizei count, const GLuint *samplers);
+typedef void (APIENTRYP PFNGLBINDIMAGETEXTURESPROC) (GLuint first, GLsizei count, const GLuint *textures);
+typedef void (APIENTRYP PFNGLBINDVERTEXBUFFERSPROC) (GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides);
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glBufferStorage (GLenum target, GLsizeiptr size, const void *data, GLbitfield flags);
+GLAPI void APIENTRY glClearTexImage (GLuint texture, GLint level, GLenum format, GLenum type, const void *data);
+GLAPI void APIENTRY glClearTexSubImage (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
+GLAPI void APIENTRY glBindBuffersBase (GLenum target, GLuint first, GLsizei count, const GLuint *buffers);
+GLAPI void APIENTRY glBindBuffersRange (GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizeiptr *sizes);
+GLAPI void APIENTRY glBindTextures (GLuint first, GLsizei count, const GLuint *textures);
+GLAPI void APIENTRY glBindSamplers (GLuint first, GLsizei count, const GLuint *samplers);
+GLAPI void APIENTRY glBindImageTextures (GLuint first, GLsizei count, const GLuint *textures);
+GLAPI void APIENTRY glBindVertexBuffers (GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides);
+#endif
+#endif /* GL_VERSION_4_4 */
+
 #ifndef GL_ARB_ES2_compatibility
 #define GL_ARB_ES2_compatibility 1
 #endif /* GL_ARB_ES2_compatibility */
@@ -2532,10 +2582,54 @@ GLAPI void APIENTRY glGetObjectPtrLabel (const void *ptr, GLsizei bufSize, GLsiz
 #define GL_ARB_base_instance 1
 #endif /* GL_ARB_base_instance */
 
+#ifndef GL_ARB_bindless_texture
+#define GL_ARB_bindless_texture 1
+typedef uint64_t GLuint64EXT;
+#define GL_UNSIGNED_INT64_ARB             0x140F
+typedef GLuint64 (APIENTRYP PFNGLGETTEXTUREHANDLEARBPROC) (GLuint texture);
+typedef GLuint64 (APIENTRYP PFNGLGETTEXTURESAMPLERHANDLEARBPROC) (GLuint texture, GLuint sampler);
+typedef void (APIENTRYP PFNGLMAKETEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
+typedef void (APIENTRYP PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC) (GLuint64 handle);
+typedef GLuint64 (APIENTRYP PFNGLGETIMAGEHANDLEARBPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
+typedef void (APIENTRYP PFNGLMAKEIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle, GLenum access);
+typedef void (APIENTRYP PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC) (GLuint64 handle);
+typedef void (APIENTRYP PFNGLUNIFORMHANDLEUI64ARBPROC) (GLint location, GLuint64 value);
+typedef void (APIENTRYP PFNGLUNIFORMHANDLEUI64VARBPROC) (GLint location, GLsizei count, const GLuint64 *value);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC) (GLuint program, GLint location, GLuint64 value);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64 *values);
+typedef GLboolean (APIENTRYP PFNGLISTEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
+typedef GLboolean (APIENTRYP PFNGLISIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBL1UI64ARBPROC) (GLuint index, GLuint64EXT x);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBL1UI64VARBPROC) (GLuint index, const GLuint64EXT *v);
+typedef void (APIENTRYP PFNGLGETVERTEXATTRIBLUI64VARBPROC) (GLuint index, GLenum pname, GLuint64EXT *params);
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI GLuint64 APIENTRY glGetTextureHandleARB (GLuint texture);
+GLAPI GLuint64 APIENTRY glGetTextureSamplerHandleARB (GLuint texture, GLuint sampler);
+GLAPI void APIENTRY glMakeTextureHandleResidentARB (GLuint64 handle);
+GLAPI void APIENTRY glMakeTextureHandleNonResidentARB (GLuint64 handle);
+GLAPI GLuint64 APIENTRY glGetImageHandleARB (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
+GLAPI void APIENTRY glMakeImageHandleResidentARB (GLuint64 handle, GLenum access);
+GLAPI void APIENTRY glMakeImageHandleNonResidentARB (GLuint64 handle);
+GLAPI void APIENTRY glUniformHandleui64ARB (GLint location, GLuint64 value);
+GLAPI void APIENTRY glUniformHandleui64vARB (GLint location, GLsizei count, const GLuint64 *value);
+GLAPI void APIENTRY glProgramUniformHandleui64ARB (GLuint program, GLint location, GLuint64 value);
+GLAPI void APIENTRY glProgramUniformHandleui64vARB (GLuint program, GLint location, GLsizei count, const GLuint64 *values);
+GLAPI GLboolean APIENTRY glIsTextureHandleResidentARB (GLuint64 handle);
+GLAPI GLboolean APIENTRY glIsImageHandleResidentARB (GLuint64 handle);
+GLAPI void APIENTRY glVertexAttribL1ui64ARB (GLuint index, GLuint64EXT x);
+GLAPI void APIENTRY glVertexAttribL1ui64vARB (GLuint index, const GLuint64EXT *v);
+GLAPI void APIENTRY glGetVertexAttribLui64vARB (GLuint index, GLenum pname, GLuint64EXT *params);
+#endif
+#endif /* GL_ARB_bindless_texture */
+
 #ifndef GL_ARB_blend_func_extended
 #define GL_ARB_blend_func_extended 1
 #endif /* GL_ARB_blend_func_extended */
 
+#ifndef GL_ARB_buffer_storage
+#define GL_ARB_buffer_storage 1
+#endif /* GL_ARB_buffer_storage */
+
 #ifndef GL_ARB_cl_event
 #define GL_ARB_cl_event 1
 struct _cl_context;
@@ -2550,14 +2644,12 @@ GLAPI GLsync APIENTRY glCreateSyncFromCLeventARB (struct _cl_context *context, s
 
 #ifndef GL_ARB_clear_buffer_object
 #define GL_ARB_clear_buffer_object 1
-typedef void (APIENTRYP PFNGLCLEARNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
-typedef void (APIENTRYP PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, GLsizeiptr offset, GLsizeiptr size, const void *data);
-#ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glClearNamedBufferDataEXT (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
-GLAPI void APIENTRY glClearNamedBufferSubDataEXT (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, GLsizeiptr offset, GLsizeiptr size, const void *data);
-#endif
 #endif /* GL_ARB_clear_buffer_object */
 
+#ifndef GL_ARB_clear_texture
+#define GL_ARB_clear_texture 1
+#endif /* GL_ARB_clear_texture */
+
 #ifndef GL_ARB_color_buffer_float
 #define GL_ARB_color_buffer_float 1
 #define GL_RGBA_FLOAT_MODE_ARB            0x8820
@@ -2584,6 +2676,18 @@ GLAPI void APIENTRY glClampColorARB (GLenum target, GLenum clamp);
 #define GL_COMPUTE_SHADER_BIT             0x00000020
 #endif /* GL_ARB_compute_shader */
 
+#ifndef GL_ARB_compute_variable_group_size
+#define GL_ARB_compute_variable_group_size 1
+#define GL_MAX_COMPUTE_VARIABLE_GROUP_INVOCATIONS_ARB 0x9344
+#define GL_MAX_COMPUTE_FIXED_GROUP_INVOCATIONS_ARB 0x90EB
+#define GL_MAX_COMPUTE_VARIABLE_GROUP_SIZE_ARB 0x9345
+#define GL_MAX_COMPUTE_FIXED_GROUP_SIZE_ARB 0x91BF
+typedef void (APIENTRYP PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z);
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glDispatchComputeGroupSizeARB (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z);
+#endif
+#endif /* GL_ARB_compute_variable_group_size */
+
 #ifndef GL_ARB_conservative_depth
 #define GL_ARB_conservative_depth 1
 #endif /* GL_ARB_conservative_depth */
@@ -2626,12 +2730,12 @@ typedef void (APIENTRY  *GLDEBUGPROCARB)(GLenum source,GLenum type,GLuint id,GLe
 typedef void (APIENTRYP PFNGLDEBUGMESSAGECONTROLARBPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
 typedef void (APIENTRYP PFNGLDEBUGMESSAGEINSERTARBPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
 typedef void (APIENTRYP PFNGLDEBUGMESSAGECALLBACKARBPROC) (GLDEBUGPROCARB callback, const void *userParam);
-typedef GLuint (APIENTRYP PFNGLGETDEBUGMESSAGELOGARBPROC) (GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
+typedef GLuint (APIENTRYP PFNGLGETDEBUGMESSAGELOGARBPROC) (GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glDebugMessageControlARB (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
 GLAPI void APIENTRY glDebugMessageInsertARB (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf);
 GLAPI void APIENTRY glDebugMessageCallbackARB (GLDEBUGPROCARB callback, const void *userParam);
-GLAPI GLuint APIENTRY glGetDebugMessageLogARB (GLuint count, GLsizei bufsize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
+GLAPI GLuint APIENTRY glGetDebugMessageLogARB (GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
 #endif
 #endif /* GL_ARB_debug_output */
 
@@ -2702,13 +2806,17 @@ GLAPI void APIENTRY glBlendFuncSeparateiARB (GLuint buf, GLenum srcRGB, GLenum d
 #ifndef GL_ARB_draw_instanced
 #define GL_ARB_draw_instanced 1
 typedef void (APIENTRYP PFNGLDRAWARRAYSINSTANCEDARBPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
-typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDARBPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
+typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDARBPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glDrawArraysInstancedARB (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
-GLAPI void APIENTRY glDrawElementsInstancedARB (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
+GLAPI void APIENTRY glDrawElementsInstancedARB (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
 #endif
 #endif /* GL_ARB_draw_instanced */
 
+#ifndef GL_ARB_enhanced_layouts
+#define GL_ARB_enhanced_layouts 1
+#endif /* GL_ARB_enhanced_layouts */
+
 #ifndef GL_ARB_explicit_attrib_location
 #define GL_ARB_explicit_attrib_location 1
 #endif /* GL_ARB_explicit_attrib_location */
@@ -2805,7 +2913,7 @@ GLAPI void APIENTRY glDrawElementsInstancedARB (GLenum mode, GLsizei count, GLen
 #define GL_MATRIX29_ARB                   0x88DD
 #define GL_MATRIX30_ARB                   0x88DE
 #define GL_MATRIX31_ARB                   0x88DF
-typedef void (APIENTRYP PFNGLPROGRAMSTRINGARBPROC) (GLenum target, GLenum format, GLsizei len, const GLvoid *string);
+typedef void (APIENTRYP PFNGLPROGRAMSTRINGARBPROC) (GLenum target, GLenum format, GLsizei len, const void *string);
 typedef void (APIENTRYP PFNGLBINDPROGRAMARBPROC) (GLenum target, GLuint program);
 typedef void (APIENTRYP PFNGLDELETEPROGRAMSARBPROC) (GLsizei n, const GLuint *programs);
 typedef void (APIENTRYP PFNGLGENPROGRAMSARBPROC) (GLsizei n, GLuint *programs);
@@ -2822,10 +2930,10 @@ typedef void (APIENTRYP PFNGLGETPROGRAMENVPARAMETERFVARBPROC) (GLenum target, GL
 typedef void (APIENTRYP PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble *params);
 typedef void (APIENTRYP PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETPROGRAMIVARBPROC) (GLenum target, GLenum pname, GLint *params);
-typedef void (APIENTRYP PFNGLGETPROGRAMSTRINGARBPROC) (GLenum target, GLenum pname, GLvoid *string);
+typedef void (APIENTRYP PFNGLGETPROGRAMSTRINGARBPROC) (GLenum target, GLenum pname, void *string);
 typedef GLboolean (APIENTRYP PFNGLISPROGRAMARBPROC) (GLuint program);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glProgramStringARB (GLenum target, GLenum format, GLsizei len, const GLvoid *string);
+GLAPI void APIENTRY glProgramStringARB (GLenum target, GLenum format, GLsizei len, const void *string);
 GLAPI void APIENTRY glBindProgramARB (GLenum target, GLuint program);
 GLAPI void APIENTRY glDeleteProgramsARB (GLsizei n, const GLuint *programs);
 GLAPI void APIENTRY glGenProgramsARB (GLsizei n, GLuint *programs);
@@ -2842,7 +2950,7 @@ GLAPI void APIENTRY glGetProgramEnvParameterfvARB (GLenum target, GLuint index,
 GLAPI void APIENTRY glGetProgramLocalParameterdvARB (GLenum target, GLuint index, GLdouble *params);
 GLAPI void APIENTRY glGetProgramLocalParameterfvARB (GLenum target, GLuint index, GLfloat *params);
 GLAPI void APIENTRY glGetProgramivARB (GLenum target, GLenum pname, GLint *params);
-GLAPI void APIENTRY glGetProgramStringARB (GLenum target, GLenum pname, GLvoid *string);
+GLAPI void APIENTRY glGetProgramStringARB (GLenum target, GLenum pname, void *string);
 GLAPI GLboolean APIENTRY glIsProgramARB (GLuint program);
 #endif
 #endif /* GL_ARB_fragment_program */
@@ -2860,12 +2968,6 @@ GLAPI GLboolean APIENTRY glIsProgramARB (GLuint program);
 
 #ifndef GL_ARB_framebuffer_no_attachments
 #define GL_ARB_framebuffer_no_attachments 1
-typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC) (GLuint framebuffer, GLenum pname, GLint param);
-typedef void (APIENTRYP PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint *params);
-#ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glNamedFramebufferParameteriEXT (GLuint framebuffer, GLenum pname, GLint param);
-GLAPI void APIENTRY glGetNamedFramebufferParameterivEXT (GLuint framebuffer, GLenum pname, GLint *params);
-#endif
 #endif /* GL_ARB_framebuffer_no_attachments */
 
 #ifndef GL_ARB_framebuffer_object
@@ -2918,42 +3020,6 @@ GLAPI void APIENTRY glFramebufferTextureFaceARB (GLenum target, GLenum attachmen
 
 #ifndef GL_ARB_gpu_shader_fp64
 #define GL_ARB_gpu_shader_fp64 1
-typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1DEXTPROC) (GLuint program, GLint location, GLdouble x);
-typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2DEXTPROC) (GLuint program, GLint location, GLdouble x, GLdouble y);
-typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3DEXTPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
-typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4DEXTPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
-typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
-typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
-typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
-typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
-typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
-typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
-typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
-typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
-typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
-typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
-typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
-typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
-typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
-#ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glProgramUniform1dEXT (GLuint program, GLint location, GLdouble x);
-GLAPI void APIENTRY glProgramUniform2dEXT (GLuint program, GLint location, GLdouble x, GLdouble y);
-GLAPI void APIENTRY glProgramUniform3dEXT (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
-GLAPI void APIENTRY glProgramUniform4dEXT (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
-GLAPI void APIENTRY glProgramUniform1dvEXT (GLuint program, GLint location, GLsizei count, const GLdouble *value);
-GLAPI void APIENTRY glProgramUniform2dvEXT (GLuint program, GLint location, GLsizei count, const GLdouble *value);
-GLAPI void APIENTRY glProgramUniform3dvEXT (GLuint program, GLint location, GLsizei count, const GLdouble *value);
-GLAPI void APIENTRY glProgramUniform4dvEXT (GLuint program, GLint location, GLsizei count, const GLdouble *value);
-GLAPI void APIENTRY glProgramUniformMatrix2dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
-GLAPI void APIENTRY glProgramUniformMatrix3dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
-GLAPI void APIENTRY glProgramUniformMatrix4dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
-GLAPI void APIENTRY glProgramUniformMatrix2x3dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
-GLAPI void APIENTRY glProgramUniformMatrix2x4dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
-GLAPI void APIENTRY glProgramUniformMatrix3x2dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
-GLAPI void APIENTRY glProgramUniformMatrix3x4dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
-GLAPI void APIENTRY glProgramUniformMatrix4x2dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
-GLAPI void APIENTRY glProgramUniformMatrix4x3dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
-#endif
 #endif /* GL_ARB_gpu_shader_fp64 */
 
 #ifndef GL_ARB_half_float_pixel
@@ -2968,17 +3034,8 @@ typedef unsigned short GLhalfARB;
 
 #ifndef GL_ARB_imaging
 #define GL_ARB_imaging 1
-#define GL_CONSTANT_COLOR                 0x8001
-#define GL_ONE_MINUS_CONSTANT_COLOR       0x8002
-#define GL_CONSTANT_ALPHA                 0x8003
-#define GL_ONE_MINUS_CONSTANT_ALPHA       0x8004
 #define GL_BLEND_COLOR                    0x8005
-#define GL_FUNC_ADD                       0x8006
-#define GL_MIN                            0x8007
-#define GL_MAX                            0x8008
 #define GL_BLEND_EQUATION                 0x8009
-#define GL_FUNC_SUBTRACT                  0x800A
-#define GL_FUNC_REVERSE_SUBTRACT          0x800B
 #define GL_CONVOLUTION_1D                 0x8010
 #define GL_CONVOLUTION_2D                 0x8011
 #define GL_SEPARABLE_2D                   0x8012
@@ -3043,32 +3100,32 @@ typedef unsigned short GLhalfARB;
 #define GL_CONSTANT_BORDER                0x8151
 #define GL_REPLICATE_BORDER               0x8153
 #define GL_CONVOLUTION_BORDER_COLOR       0x8154
-typedef void (APIENTRYP PFNGLCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
+typedef void (APIENTRYP PFNGLCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
 typedef void (APIENTRYP PFNGLCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
 typedef void (APIENTRYP PFNGLCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
 typedef void (APIENTRYP PFNGLCOPYCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
-typedef void (APIENTRYP PFNGLGETCOLORTABLEPROC) (GLenum target, GLenum format, GLenum type, GLvoid *table);
+typedef void (APIENTRYP PFNGLGETCOLORTABLEPROC) (GLenum target, GLenum format, GLenum type, void *table);
 typedef void (APIENTRYP PFNGLGETCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
-typedef void (APIENTRYP PFNGLCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
+typedef void (APIENTRYP PFNGLCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
 typedef void (APIENTRYP PFNGLCOPYCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
-typedef void (APIENTRYP PFNGLCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
-typedef void (APIENTRYP PFNGLCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
+typedef void (APIENTRYP PFNGLCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
+typedef void (APIENTRYP PFNGLCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
 typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat params);
 typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
 typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERIPROC) (GLenum target, GLenum pname, GLint params);
 typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
 typedef void (APIENTRYP PFNGLCOPYCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
 typedef void (APIENTRYP PFNGLCOPYCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
-typedef void (APIENTRYP PFNGLGETCONVOLUTIONFILTERPROC) (GLenum target, GLenum format, GLenum type, GLvoid *image);
+typedef void (APIENTRYP PFNGLGETCONVOLUTIONFILTERPROC) (GLenum target, GLenum format, GLenum type, void *image);
 typedef void (APIENTRYP PFNGLGETCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
-typedef void (APIENTRYP PFNGLGETSEPARABLEFILTERPROC) (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
-typedef void (APIENTRYP PFNGLSEPARABLEFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
-typedef void (APIENTRYP PFNGLGETHISTOGRAMPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
+typedef void (APIENTRYP PFNGLGETSEPARABLEFILTERPROC) (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
+typedef void (APIENTRYP PFNGLSEPARABLEFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);
+typedef void (APIENTRYP PFNGLGETHISTOGRAMPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
 typedef void (APIENTRYP PFNGLGETHISTOGRAMPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETHISTOGRAMPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
-typedef void (APIENTRYP PFNGLGETMINMAXPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
+typedef void (APIENTRYP PFNGLGETMINMAXPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
 typedef void (APIENTRYP PFNGLGETMINMAXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETMINMAXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
 typedef void (APIENTRYP PFNGLHISTOGRAMPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
@@ -3076,32 +3133,32 @@ typedef void (APIENTRYP PFNGLMINMAXPROC) (GLenum target, GLenum internalformat,
 typedef void (APIENTRYP PFNGLRESETHISTOGRAMPROC) (GLenum target);
 typedef void (APIENTRYP PFNGLRESETMINMAXPROC) (GLenum target);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glColorTable (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
+GLAPI void APIENTRY glColorTable (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
 GLAPI void APIENTRY glColorTableParameterfv (GLenum target, GLenum pname, const GLfloat *params);
 GLAPI void APIENTRY glColorTableParameteriv (GLenum target, GLenum pname, const GLint *params);
 GLAPI void APIENTRY glCopyColorTable (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
-GLAPI void APIENTRY glGetColorTable (GLenum target, GLenum format, GLenum type, GLvoid *table);
+GLAPI void APIENTRY glGetColorTable (GLenum target, GLenum format, GLenum type, void *table);
 GLAPI void APIENTRY glGetColorTableParameterfv (GLenum target, GLenum pname, GLfloat *params);
 GLAPI void APIENTRY glGetColorTableParameteriv (GLenum target, GLenum pname, GLint *params);
-GLAPI void APIENTRY glColorSubTable (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
+GLAPI void APIENTRY glColorSubTable (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
 GLAPI void APIENTRY glCopyColorSubTable (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
-GLAPI void APIENTRY glConvolutionFilter1D (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
-GLAPI void APIENTRY glConvolutionFilter2D (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
+GLAPI void APIENTRY glConvolutionFilter1D (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
+GLAPI void APIENTRY glConvolutionFilter2D (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
 GLAPI void APIENTRY glConvolutionParameterf (GLenum target, GLenum pname, GLfloat params);
 GLAPI void APIENTRY glConvolutionParameterfv (GLenum target, GLenum pname, const GLfloat *params);
 GLAPI void APIENTRY glConvolutionParameteri (GLenum target, GLenum pname, GLint params);
 GLAPI void APIENTRY glConvolutionParameteriv (GLenum target, GLenum pname, const GLint *params);
 GLAPI void APIENTRY glCopyConvolutionFilter1D (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
 GLAPI void APIENTRY glCopyConvolutionFilter2D (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
-GLAPI void APIENTRY glGetConvolutionFilter (GLenum target, GLenum format, GLenum type, GLvoid *image);
+GLAPI void APIENTRY glGetConvolutionFilter (GLenum target, GLenum format, GLenum type, void *image);
 GLAPI void APIENTRY glGetConvolutionParameterfv (GLenum target, GLenum pname, GLfloat *params);
 GLAPI void APIENTRY glGetConvolutionParameteriv (GLenum target, GLenum pname, GLint *params);
-GLAPI void APIENTRY glGetSeparableFilter (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
-GLAPI void APIENTRY glSeparableFilter2D (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
-GLAPI void APIENTRY glGetHistogram (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
+GLAPI void APIENTRY glGetSeparableFilter (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
+GLAPI void APIENTRY glSeparableFilter2D (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);
+GLAPI void APIENTRY glGetHistogram (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
 GLAPI void APIENTRY glGetHistogramParameterfv (GLenum target, GLenum pname, GLfloat *params);
 GLAPI void APIENTRY glGetHistogramParameteriv (GLenum target, GLenum pname, GLint *params);
-GLAPI void APIENTRY glGetMinmax (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
+GLAPI void APIENTRY glGetMinmax (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
 GLAPI void APIENTRY glGetMinmaxParameterfv (GLenum target, GLenum pname, GLfloat *params);
 GLAPI void APIENTRY glGetMinmaxParameteriv (GLenum target, GLenum pname, GLint *params);
 GLAPI void APIENTRY glHistogram (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
@@ -3111,6 +3168,18 @@ GLAPI void APIENTRY glResetMinmax (GLenum target);
 #endif
 #endif /* GL_ARB_imaging */
 
+#ifndef GL_ARB_indirect_parameters
+#define GL_ARB_indirect_parameters 1
+#define GL_PARAMETER_BUFFER_ARB           0x80EE
+#define GL_PARAMETER_BUFFER_BINDING_ARB   0x80EF
+typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC) (GLenum mode, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
+typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC) (GLenum mode, GLenum type, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glMultiDrawArraysIndirectCountARB (GLenum mode, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
+GLAPI void APIENTRY glMultiDrawElementsIndirectCountARB (GLenum mode, GLenum type, GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
+#endif
+#endif /* GL_ARB_indirect_parameters */
+
 #ifndef GL_ARB_instanced_arrays
 #define GL_ARB_instanced_arrays 1
 #define GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB 0x88FE
@@ -3122,10 +3191,6 @@ GLAPI void APIENTRY glVertexAttribDivisorARB (GLuint index, GLuint divisor);
 
 #ifndef GL_ARB_internalformat_query
 #define GL_ARB_internalformat_query 1
-typedef void (APIENTRYP PFNGLGETINTERNALFORMATIVPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
-#ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glGetInternalformativ (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
-#endif
 #endif /* GL_ARB_internalformat_query */
 
 #ifndef GL_ARB_internalformat_query2
@@ -3161,16 +3226,20 @@ typedef void (APIENTRYP PFNGLCURRENTPALETTEMATRIXARBPROC) (GLint index);
 typedef void (APIENTRYP PFNGLMATRIXINDEXUBVARBPROC) (GLint size, const GLubyte *indices);
 typedef void (APIENTRYP PFNGLMATRIXINDEXUSVARBPROC) (GLint size, const GLushort *indices);
 typedef void (APIENTRYP PFNGLMATRIXINDEXUIVARBPROC) (GLint size, const GLuint *indices);
-typedef void (APIENTRYP PFNGLMATRIXINDEXPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLMATRIXINDEXPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, const void *pointer);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glCurrentPaletteMatrixARB (GLint index);
 GLAPI void APIENTRY glMatrixIndexubvARB (GLint size, const GLubyte *indices);
 GLAPI void APIENTRY glMatrixIndexusvARB (GLint size, const GLushort *indices);
 GLAPI void APIENTRY glMatrixIndexuivARB (GLint size, const GLuint *indices);
-GLAPI void APIENTRY glMatrixIndexPointerARB (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+GLAPI void APIENTRY glMatrixIndexPointerARB (GLint size, GLenum type, GLsizei stride, const void *pointer);
 #endif
 #endif /* GL_ARB_matrix_palette */
 
+#ifndef GL_ARB_multi_bind
+#define GL_ARB_multi_bind 1
+#endif /* GL_ARB_multi_bind */
+
 #ifndef GL_ARB_multi_draw_indirect
 #define GL_ARB_multi_draw_indirect 1
 #endif /* GL_ARB_multi_draw_indirect */
@@ -3368,6 +3437,10 @@ GLAPI void APIENTRY glPointParameterfvARB (GLenum pname, const GLfloat *params);
 #define GL_ARB_provoking_vertex 1
 #endif /* GL_ARB_provoking_vertex */
 
+#ifndef GL_ARB_query_buffer_object
+#define GL_ARB_query_buffer_object 1
+#endif /* GL_ARB_query_buffer_object */
+
 #ifndef GL_ARB_robust_buffer_access_behavior
 #define GL_ARB_robust_buffer_access_behavior 1
 #endif /* GL_ARB_robust_buffer_access_behavior */
@@ -3382,9 +3455,9 @@ GLAPI void APIENTRY glPointParameterfvARB (GLenum pname, const GLfloat *params);
 #define GL_RESET_NOTIFICATION_STRATEGY_ARB 0x8256
 #define GL_NO_RESET_NOTIFICATION_ARB      0x8261
 typedef GLenum (APIENTRYP PFNGLGETGRAPHICSRESETSTATUSARBPROC) (void);
-typedef void (APIENTRYP PFNGLGETNTEXIMAGEARBPROC) (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *img);
-typedef void (APIENTRYP PFNGLREADNPIXELSARBPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data);
-typedef void (APIENTRYP PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, GLsizei bufSize, GLvoid *img);
+typedef void (APIENTRYP PFNGLGETNTEXIMAGEARBPROC) (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *img);
+typedef void (APIENTRYP PFNGLREADNPIXELSARBPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);
+typedef void (APIENTRYP PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, GLsizei bufSize, void *img);
 typedef void (APIENTRYP PFNGLGETNUNIFORMFVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETNUNIFORMIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint *params);
 typedef void (APIENTRYP PFNGLGETNUNIFORMUIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint *params);
@@ -3396,16 +3469,16 @@ typedef void (APIENTRYP PFNGLGETNPIXELMAPFVARBPROC) (GLenum map, GLsizei bufSize
 typedef void (APIENTRYP PFNGLGETNPIXELMAPUIVARBPROC) (GLenum map, GLsizei bufSize, GLuint *values);
 typedef void (APIENTRYP PFNGLGETNPIXELMAPUSVARBPROC) (GLenum map, GLsizei bufSize, GLushort *values);
 typedef void (APIENTRYP PFNGLGETNPOLYGONSTIPPLEARBPROC) (GLsizei bufSize, GLubyte *pattern);
-typedef void (APIENTRYP PFNGLGETNCOLORTABLEARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *table);
-typedef void (APIENTRYP PFNGLGETNCONVOLUTIONFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *image);
-typedef void (APIENTRYP PFNGLGETNSEPARABLEFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid *row, GLsizei columnBufSize, GLvoid *column, GLvoid *span);
-typedef void (APIENTRYP PFNGLGETNHISTOGRAMARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values);
-typedef void (APIENTRYP PFNGLGETNMINMAXARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values);
+typedef void (APIENTRYP PFNGLGETNCOLORTABLEARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table);
+typedef void (APIENTRYP PFNGLGETNCONVOLUTIONFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image);
+typedef void (APIENTRYP PFNGLGETNSEPARABLEFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span);
+typedef void (APIENTRYP PFNGLGETNHISTOGRAMARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values);
+typedef void (APIENTRYP PFNGLGETNMINMAXARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI GLenum APIENTRY glGetGraphicsResetStatusARB (void);
-GLAPI void APIENTRY glGetnTexImageARB (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *img);
-GLAPI void APIENTRY glReadnPixelsARB (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid *data);
-GLAPI void APIENTRY glGetnCompressedTexImageARB (GLenum target, GLint lod, GLsizei bufSize, GLvoid *img);
+GLAPI void APIENTRY glGetnTexImageARB (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *img);
+GLAPI void APIENTRY glReadnPixelsARB (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);
+GLAPI void APIENTRY glGetnCompressedTexImageARB (GLenum target, GLint lod, GLsizei bufSize, void *img);
 GLAPI void APIENTRY glGetnUniformfvARB (GLuint program, GLint location, GLsizei bufSize, GLfloat *params);
 GLAPI void APIENTRY glGetnUniformivARB (GLuint program, GLint location, GLsizei bufSize, GLint *params);
 GLAPI void APIENTRY glGetnUniformuivARB (GLuint program, GLint location, GLsizei bufSize, GLuint *params);
@@ -3417,11 +3490,11 @@ GLAPI void APIENTRY glGetnPixelMapfvARB (GLenum map, GLsizei bufSize, GLfloat *v
 GLAPI void APIENTRY glGetnPixelMapuivARB (GLenum map, GLsizei bufSize, GLuint *values);
 GLAPI void APIENTRY glGetnPixelMapusvARB (GLenum map, GLsizei bufSize, GLushort *values);
 GLAPI void APIENTRY glGetnPolygonStippleARB (GLsizei bufSize, GLubyte *pattern);
-GLAPI void APIENTRY glGetnColorTableARB (GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *table);
-GLAPI void APIENTRY glGetnConvolutionFilterARB (GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid *image);
-GLAPI void APIENTRY glGetnSeparableFilterARB (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid *row, GLsizei columnBufSize, GLvoid *column, GLvoid *span);
-GLAPI void APIENTRY glGetnHistogramARB (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values);
-GLAPI void APIENTRY glGetnMinmaxARB (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid *values);
+GLAPI void APIENTRY glGetnColorTableARB (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table);
+GLAPI void APIENTRY glGetnConvolutionFilterARB (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image);
+GLAPI void APIENTRY glGetnSeparableFilterARB (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span);
+GLAPI void APIENTRY glGetnHistogramARB (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values);
+GLAPI void APIENTRY glGetnMinmaxARB (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values);
 #endif
 #endif /* GL_ARB_robustness */
 
@@ -3447,6 +3520,10 @@ GLAPI void APIENTRY glMinSampleShadingARB (GLfloat value);
 #define GL_ARB_seamless_cube_map 1
 #endif /* GL_ARB_seamless_cube_map */
 
+#ifndef GL_ARB_seamless_cubemap_per_texture
+#define GL_ARB_seamless_cubemap_per_texture 1
+#endif /* GL_ARB_seamless_cubemap_per_texture */
+
 #ifndef GL_ARB_separate_shader_objects
 #define GL_ARB_separate_shader_objects 1
 #endif /* GL_ARB_separate_shader_objects */
@@ -3459,6 +3536,14 @@ GLAPI void APIENTRY glMinSampleShadingARB (GLfloat value);
 #define GL_ARB_shader_bit_encoding 1
 #endif /* GL_ARB_shader_bit_encoding */
 
+#ifndef GL_ARB_shader_draw_parameters
+#define GL_ARB_shader_draw_parameters 1
+#endif /* GL_ARB_shader_draw_parameters */
+
+#ifndef GL_ARB_shader_group_vote
+#define GL_ARB_shader_group_vote 1
+#endif /* GL_ARB_shader_group_vote */
+
 #ifndef GL_ARB_shader_image_load_store
 #define GL_ARB_shader_image_load_store 1
 #endif /* GL_ARB_shader_image_load_store */
@@ -3657,6 +3742,25 @@ GLAPI void APIENTRY glGetNamedStringivARB (GLint namelen, const GLchar *name, GL
 #define GL_TEXTURE_COMPARE_FAIL_VALUE_ARB 0x80BF
 #endif /* GL_ARB_shadow_ambient */
 
+#ifndef GL_ARB_sparse_texture
+#define GL_ARB_sparse_texture 1
+#define GL_TEXTURE_SPARSE_ARB             0x91A6
+#define GL_VIRTUAL_PAGE_SIZE_INDEX_ARB    0x91A7
+#define GL_MIN_SPARSE_LEVEL_ARB           0x919B
+#define GL_NUM_VIRTUAL_PAGE_SIZES_ARB     0x91A8
+#define GL_VIRTUAL_PAGE_SIZE_X_ARB        0x9195
+#define GL_VIRTUAL_PAGE_SIZE_Y_ARB        0x9196
+#define GL_VIRTUAL_PAGE_SIZE_Z_ARB        0x9197
+#define GL_MAX_SPARSE_TEXTURE_SIZE_ARB    0x9198
+#define GL_MAX_SPARSE_3D_TEXTURE_SIZE_ARB 0x9199
+#define GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_ARB 0x919A
+#define GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_ARB 0x91A9
+typedef void (APIENTRYP PFNGLTEXPAGECOMMITMENTARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean resident);
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glTexPageCommitmentARB (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean resident);
+#endif
+#endif /* GL_ARB_sparse_texture */
+
 #ifndef GL_ARB_stencil_texturing
 #define GL_ARB_stencil_texturing 1
 #endif /* GL_ARB_stencil_texturing */
@@ -3693,10 +3797,6 @@ GLAPI void APIENTRY glTexBufferARB (GLenum target, GLenum internalformat, GLuint
 
 #ifndef GL_ARB_texture_buffer_range
 #define GL_ARB_texture_buffer_range 1
-typedef void (APIENTRYP PFNGLTEXTUREBUFFERRANGEEXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
-#ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glTextureBufferRangeEXT (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
-#endif
 #endif /* GL_ARB_texture_buffer_range */
 
 #ifndef GL_ARB_texture_compression
@@ -3712,21 +3812,21 @@ GLAPI void APIENTRY glTextureBufferRangeEXT (GLuint texture, GLenum target, GLen
 #define GL_TEXTURE_COMPRESSED_ARB         0x86A1
 #define GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB 0x86A2
 #define GL_COMPRESSED_TEXTURE_FORMATS_ARB 0x86A3
-typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE3DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
-typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
-typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE1DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
-typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
-typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
-typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
-typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint level, GLvoid *img);
-#ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glCompressedTexImage3DARB (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
-GLAPI void APIENTRY glCompressedTexImage2DARB (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
-GLAPI void APIENTRY glCompressedTexImage1DARB (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
-GLAPI void APIENTRY glCompressedTexSubImage3DARB (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
-GLAPI void APIENTRY glCompressedTexSubImage2DARB (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
-GLAPI void APIENTRY glCompressedTexSubImage1DARB (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
-GLAPI void APIENTRY glGetCompressedTexImageARB (GLenum target, GLint level, GLvoid *img);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE3DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXIMAGE1DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
+typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint level, void *img);
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glCompressedTexImage3DARB (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
+GLAPI void APIENTRY glCompressedTexImage2DARB (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
+GLAPI void APIENTRY glCompressedTexImage1DARB (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
+GLAPI void APIENTRY glCompressedTexSubImage3DARB (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
+GLAPI void APIENTRY glCompressedTexSubImage2DARB (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
+GLAPI void APIENTRY glCompressedTexSubImage1DARB (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
+GLAPI void APIENTRY glGetCompressedTexImageARB (GLenum target, GLint level, void *img);
 #endif
 #endif /* GL_ARB_texture_compression */
 
@@ -3840,6 +3940,10 @@ GLAPI void APIENTRY glGetCompressedTexImageARB (GLenum target, GLint level, GLvo
 #define GL_MAX_PROGRAM_TEXTURE_GATHER_COMPONENTS_ARB 0x8F9F
 #endif /* GL_ARB_texture_gather */
 
+#ifndef GL_ARB_texture_mirror_clamp_to_edge
+#define GL_ARB_texture_mirror_clamp_to_edge 1
+#endif /* GL_ARB_texture_mirror_clamp_to_edge */
+
 #ifndef GL_ARB_texture_mirrored_repeat
 #define GL_ARB_texture_mirrored_repeat 1
 #define GL_MIRRORED_REPEAT_ARB            0x8370
@@ -3877,16 +3981,12 @@ GLAPI void APIENTRY glGetCompressedTexImageARB (GLenum target, GLint level, GLvo
 #define GL_ARB_texture_rgb10_a2ui 1
 #endif /* GL_ARB_texture_rgb10_a2ui */
 
+#ifndef GL_ARB_texture_stencil8
+#define GL_ARB_texture_stencil8 1
+#endif /* GL_ARB_texture_stencil8 */
+
 #ifndef GL_ARB_texture_storage
 #define GL_ARB_texture_storage 1
-typedef void (APIENTRYP PFNGLTEXTURESTORAGE1DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
-typedef void (APIENTRYP PFNGLTEXTURESTORAGE2DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
-typedef void (APIENTRYP PFNGLTEXTURESTORAGE3DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
-#ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glTextureStorage1DEXT (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
-GLAPI void APIENTRY glTextureStorage2DEXT (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
-GLAPI void APIENTRY glTextureStorage3DEXT (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
-#endif
 #endif /* GL_ARB_texture_storage */
 
 #ifndef GL_ARB_texture_storage_multisample
@@ -3958,20 +4058,6 @@ GLAPI void APIENTRY glMultTransposeMatrixdARB (const GLdouble *m);
 
 #ifndef GL_ARB_vertex_attrib_binding
 #define GL_ARB_vertex_attrib_binding 1
-typedef void (APIENTRYP PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
-typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
-typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
-typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
-typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC) (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
-typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint divisor);
-#ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glVertexArrayBindVertexBufferEXT (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
-GLAPI void APIENTRY glVertexArrayVertexAttribFormatEXT (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
-GLAPI void APIENTRY glVertexArrayVertexAttribIFormatEXT (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
-GLAPI void APIENTRY glVertexArrayVertexAttribLFormatEXT (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
-GLAPI void APIENTRY glVertexArrayVertexAttribBindingEXT (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
-GLAPI void APIENTRY glVertexArrayVertexBindingDivisorEXT (GLuint vaobj, GLuint bindingindex, GLuint divisor);
-#endif
 #endif /* GL_ARB_vertex_attrib_binding */
 
 #ifndef GL_ARB_vertex_blend
@@ -4026,7 +4112,7 @@ typedef void (APIENTRYP PFNGLWEIGHTDVARBPROC) (GLint size, const GLdouble *weigh
 typedef void (APIENTRYP PFNGLWEIGHTUBVARBPROC) (GLint size, const GLubyte *weights);
 typedef void (APIENTRYP PFNGLWEIGHTUSVARBPROC) (GLint size, const GLushort *weights);
 typedef void (APIENTRYP PFNGLWEIGHTUIVARBPROC) (GLint size, const GLuint *weights);
-typedef void (APIENTRYP PFNGLWEIGHTPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLWEIGHTPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, const void *pointer);
 typedef void (APIENTRYP PFNGLVERTEXBLENDARBPROC) (GLint count);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glWeightbvARB (GLint size, const GLbyte *weights);
@@ -4037,7 +4123,7 @@ GLAPI void APIENTRY glWeightdvARB (GLint size, const GLdouble *weights);
 GLAPI void APIENTRY glWeightubvARB (GLint size, const GLubyte *weights);
 GLAPI void APIENTRY glWeightusvARB (GLint size, const GLushort *weights);
 GLAPI void APIENTRY glWeightuivARB (GLint size, const GLuint *weights);
-GLAPI void APIENTRY glWeightPointerARB (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+GLAPI void APIENTRY glWeightPointerARB (GLint size, GLenum type, GLsizei stride, const void *pointer);
 GLAPI void APIENTRY glVertexBlendARB (GLint count);
 #endif
 #endif /* GL_ARB_vertex_blend */
@@ -4081,25 +4167,25 @@ typedef void (APIENTRYP PFNGLBINDBUFFERARBPROC) (GLenum target, GLuint buffer);
 typedef void (APIENTRYP PFNGLDELETEBUFFERSARBPROC) (GLsizei n, const GLuint *buffers);
 typedef void (APIENTRYP PFNGLGENBUFFERSARBPROC) (GLsizei n, GLuint *buffers);
 typedef GLboolean (APIENTRYP PFNGLISBUFFERARBPROC) (GLuint buffer);
-typedef void (APIENTRYP PFNGLBUFFERDATAARBPROC) (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
-typedef void (APIENTRYP PFNGLBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
-typedef void (APIENTRYP PFNGLGETBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
+typedef void (APIENTRYP PFNGLBUFFERDATAARBPROC) (GLenum target, GLsizeiptrARB size, const void *data, GLenum usage);
+typedef void (APIENTRYP PFNGLBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void *data);
+typedef void (APIENTRYP PFNGLGETBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, void *data);
 typedef void *(APIENTRYP PFNGLMAPBUFFERARBPROC) (GLenum target, GLenum access);
 typedef GLboolean (APIENTRYP PFNGLUNMAPBUFFERARBPROC) (GLenum target);
 typedef void (APIENTRYP PFNGLGETBUFFERPARAMETERIVARBPROC) (GLenum target, GLenum pname, GLint *params);
-typedef void (APIENTRYP PFNGLGETBUFFERPOINTERVARBPROC) (GLenum target, GLenum pname, GLvoid **params);
+typedef void (APIENTRYP PFNGLGETBUFFERPOINTERVARBPROC) (GLenum target, GLenum pname, void **params);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glBindBufferARB (GLenum target, GLuint buffer);
 GLAPI void APIENTRY glDeleteBuffersARB (GLsizei n, const GLuint *buffers);
 GLAPI void APIENTRY glGenBuffersARB (GLsizei n, GLuint *buffers);
 GLAPI GLboolean APIENTRY glIsBufferARB (GLuint buffer);
-GLAPI void APIENTRY glBufferDataARB (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
-GLAPI void APIENTRY glBufferSubDataARB (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
-GLAPI void APIENTRY glGetBufferSubDataARB (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
+GLAPI void APIENTRY glBufferDataARB (GLenum target, GLsizeiptrARB size, const void *data, GLenum usage);
+GLAPI void APIENTRY glBufferSubDataARB (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void *data);
+GLAPI void APIENTRY glGetBufferSubDataARB (GLenum target, GLintptrARB offset, GLsizeiptrARB size, void *data);
 GLAPI void *APIENTRY glMapBufferARB (GLenum target, GLenum access);
 GLAPI GLboolean APIENTRY glUnmapBufferARB (GLenum target);
 GLAPI void APIENTRY glGetBufferParameterivARB (GLenum target, GLenum pname, GLint *params);
-GLAPI void APIENTRY glGetBufferPointervARB (GLenum target, GLenum pname, GLvoid **params);
+GLAPI void APIENTRY glGetBufferPointervARB (GLenum target, GLenum pname, void **params);
 #endif
 #endif /* GL_ARB_vertex_buffer_object */
 
@@ -4157,13 +4243,13 @@ typedef void (APIENTRYP PFNGLVERTEXATTRIB4SVARBPROC) (GLuint index, const GLshor
 typedef void (APIENTRYP PFNGLVERTEXATTRIB4UBVARBPROC) (GLuint index, const GLubyte *v);
 typedef void (APIENTRYP PFNGLVERTEXATTRIB4UIVARBPROC) (GLuint index, const GLuint *v);
 typedef void (APIENTRYP PFNGLVERTEXATTRIB4USVARBPROC) (GLuint index, const GLushort *v);
-typedef void (APIENTRYP PFNGLVERTEXATTRIBPOINTERARBPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBPOINTERARBPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
 typedef void (APIENTRYP PFNGLENABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
 typedef void (APIENTRYP PFNGLDISABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
 typedef void (APIENTRYP PFNGLGETVERTEXATTRIBDVARBPROC) (GLuint index, GLenum pname, GLdouble *params);
 typedef void (APIENTRYP PFNGLGETVERTEXATTRIBFVARBPROC) (GLuint index, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIVARBPROC) (GLuint index, GLenum pname, GLint *params);
-typedef void (APIENTRYP PFNGLGETVERTEXATTRIBPOINTERVARBPROC) (GLuint index, GLenum pname, GLvoid **pointer);
+typedef void (APIENTRYP PFNGLGETVERTEXATTRIBPOINTERVARBPROC) (GLuint index, GLenum pname, void **pointer);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glVertexAttrib1dARB (GLuint index, GLdouble x);
 GLAPI void APIENTRY glVertexAttrib1dvARB (GLuint index, const GLdouble *v);
@@ -4201,13 +4287,13 @@ GLAPI void APIENTRY glVertexAttrib4svARB (GLuint index, const GLshort *v);
 GLAPI void APIENTRY glVertexAttrib4ubvARB (GLuint index, const GLubyte *v);
 GLAPI void APIENTRY glVertexAttrib4uivARB (GLuint index, const GLuint *v);
 GLAPI void APIENTRY glVertexAttrib4usvARB (GLuint index, const GLushort *v);
-GLAPI void APIENTRY glVertexAttribPointerARB (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer);
+GLAPI void APIENTRY glVertexAttribPointerARB (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
 GLAPI void APIENTRY glEnableVertexAttribArrayARB (GLuint index);
 GLAPI void APIENTRY glDisableVertexAttribArrayARB (GLuint index);
 GLAPI void APIENTRY glGetVertexAttribdvARB (GLuint index, GLenum pname, GLdouble *params);
 GLAPI void APIENTRY glGetVertexAttribfvARB (GLuint index, GLenum pname, GLfloat *params);
 GLAPI void APIENTRY glGetVertexAttribivARB (GLuint index, GLenum pname, GLint *params);
-GLAPI void APIENTRY glGetVertexAttribPointervARB (GLuint index, GLenum pname, GLvoid **pointer);
+GLAPI void APIENTRY glGetVertexAttribPointervARB (GLuint index, GLenum pname, void **pointer);
 #endif
 #endif /* GL_ARB_vertex_program */
 
@@ -4230,6 +4316,10 @@ GLAPI GLint APIENTRY glGetAttribLocationARB (GLhandleARB programObj, const GLcha
 #endif
 #endif /* GL_ARB_vertex_shader */
 
+#ifndef GL_ARB_vertex_type_10f_11f_11f_rev
+#define GL_ARB_vertex_type_10f_11f_11f_rev 1
+#endif /* GL_ARB_vertex_type_10f_11f_11f_rev */
+
 #ifndef GL_ARB_vertex_type_2_10_10_10_rev
 #define GL_ARB_vertex_type_2_10_10_10_rev 1
 #endif /* GL_ARB_vertex_type_2_10_10_10_rev */
@@ -4280,8 +4370,8 @@ GLAPI void APIENTRY glWindowPos3svARB (const GLshort *v);
 #define GL_KHR_debug 1
 #endif /* GL_KHR_debug */
 
-#ifndef GL_KHR_texture_compression_astc_ldr
-#define GL_KHR_texture_compression_astc_ldr 1
+#ifndef GL_KHR_texture_compression_astc_hdr
+#define GL_KHR_texture_compression_astc_hdr 1
 #define GL_COMPRESSED_RGBA_ASTC_4x4_KHR   0x93B0
 #define GL_COMPRESSED_RGBA_ASTC_5x4_KHR   0x93B1
 #define GL_COMPRESSED_RGBA_ASTC_5x5_KHR   0x93B2
@@ -4310,6 +4400,10 @@ GLAPI void APIENTRY glWindowPos3svARB (const GLshort *v);
 #define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR 0x93DB
 #define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR 0x93DC
 #define GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR 0x93DD
+#endif /* GL_KHR_texture_compression_astc_hdr */
+
+#ifndef GL_KHR_texture_compression_astc_ldr
+#define GL_KHR_texture_compression_astc_ldr 1
 #endif /* GL_KHR_texture_compression_astc_ldr */
 
 #ifndef GL_OES_byte_coordinates
@@ -4717,11 +4811,11 @@ GLAPI void APIENTRY glVertexAttribParameteriAMD (GLuint index, GLenum pname, GLi
 
 #ifndef GL_AMD_multi_draw_indirect
 #define GL_AMD_multi_draw_indirect 1
-typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC) (GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride);
-typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC) (GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride);
+typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC) (GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride);
+typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glMultiDrawArraysIndirectAMD (GLenum mode, const GLvoid *indirect, GLsizei primcount, GLsizei stride);
-GLAPI void APIENTRY glMultiDrawElementsIndirectAMD (GLenum mode, GLenum type, const GLvoid *indirect, GLsizei primcount, GLsizei stride);
+GLAPI void APIENTRY glMultiDrawArraysIndirectAMD (GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride);
+GLAPI void APIENTRY glMultiDrawElementsIndirectAMD (GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride);
 #endif
 #endif /* GL_AMD_multi_draw_indirect */
 
@@ -4755,7 +4849,7 @@ typedef void (APIENTRYP PFNGLGETPERFMONITORGROUPSAMDPROC) (GLint *numGroups, GLs
 typedef void (APIENTRYP PFNGLGETPERFMONITORCOUNTERSAMDPROC) (GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei counterSize, GLuint *counters);
 typedef void (APIENTRYP PFNGLGETPERFMONITORGROUPSTRINGAMDPROC) (GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString);
 typedef void (APIENTRYP PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC) (GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString);
-typedef void (APIENTRYP PFNGLGETPERFMONITORCOUNTERINFOAMDPROC) (GLuint group, GLuint counter, GLenum pname, GLvoid *data);
+typedef void (APIENTRYP PFNGLGETPERFMONITORCOUNTERINFOAMDPROC) (GLuint group, GLuint counter, GLenum pname, void *data);
 typedef void (APIENTRYP PFNGLGENPERFMONITORSAMDPROC) (GLsizei n, GLuint *monitors);
 typedef void (APIENTRYP PFNGLDELETEPERFMONITORSAMDPROC) (GLsizei n, GLuint *monitors);
 typedef void (APIENTRYP PFNGLSELECTPERFMONITORCOUNTERSAMDPROC) (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList);
@@ -4767,7 +4861,7 @@ GLAPI void APIENTRY glGetPerfMonitorGroupsAMD (GLint *numGroups, GLsizei groupsS
 GLAPI void APIENTRY glGetPerfMonitorCountersAMD (GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei counterSize, GLuint *counters);
 GLAPI void APIENTRY glGetPerfMonitorGroupStringAMD (GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString);
 GLAPI void APIENTRY glGetPerfMonitorCounterStringAMD (GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString);
-GLAPI void APIENTRY glGetPerfMonitorCounterInfoAMD (GLuint group, GLuint counter, GLenum pname, GLvoid *data);
+GLAPI void APIENTRY glGetPerfMonitorCounterInfoAMD (GLuint group, GLuint counter, GLenum pname, void *data);
 GLAPI void APIENTRY glGenPerfMonitorsAMD (GLsizei n, GLuint *monitors);
 GLAPI void APIENTRY glDeletePerfMonitorsAMD (GLsizei n, GLuint *monitors);
 GLAPI void APIENTRY glSelectPerfMonitorCountersAMD (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *counterList);
@@ -4802,6 +4896,10 @@ GLAPI void APIENTRY glSetMultisamplefvAMD (GLenum pname, GLuint index, const GLf
 #define GL_AMD_seamless_cubemap_per_texture 1
 #endif /* GL_AMD_seamless_cubemap_per_texture */
 
+#ifndef GL_AMD_shader_atomic_counter_ops
+#define GL_AMD_shader_atomic_counter_ops 1
+#endif /* GL_AMD_shader_atomic_counter_ops */
+
 #ifndef GL_AMD_shader_stencil_export
 #define GL_AMD_shader_stencil_export 1
 #endif /* GL_AMD_shader_stencil_export */
@@ -4889,13 +4987,13 @@ GLAPI void APIENTRY glTessellationModeAMD (GLenum mode);
 #define GL_ELEMENT_ARRAY_APPLE            0x8A0C
 #define GL_ELEMENT_ARRAY_TYPE_APPLE       0x8A0D
 #define GL_ELEMENT_ARRAY_POINTER_APPLE    0x8A0E
-typedef void (APIENTRYP PFNGLELEMENTPOINTERAPPLEPROC) (GLenum type, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLELEMENTPOINTERAPPLEPROC) (GLenum type, const void *pointer);
 typedef void (APIENTRYP PFNGLDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, GLint first, GLsizei count);
 typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
 typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
 typedef void (APIENTRYP PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, const GLint *first, const GLsizei *count, GLsizei primcount);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glElementPointerAPPLE (GLenum type, const GLvoid *pointer);
+GLAPI void APIENTRY glElementPointerAPPLE (GLenum type, const void *pointer);
 GLAPI void APIENTRY glDrawElementArrayAPPLE (GLenum mode, GLint first, GLsizei count);
 GLAPI void APIENTRY glDrawRangeElementArrayAPPLE (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
 GLAPI void APIENTRY glMultiDrawElementArrayAPPLE (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
@@ -4980,6 +5078,7 @@ GLAPI void APIENTRY glGetObjectParameterivAPPLE (GLenum objectType, GLuint name,
 #define GL_RGB_422_APPLE                  0x8A1F
 #define GL_UNSIGNED_SHORT_8_8_APPLE       0x85BA
 #define GL_UNSIGNED_SHORT_8_8_REV_APPLE   0x85BB
+#define GL_RGB_RAW_422_APPLE              0x8A51
 #endif /* GL_APPLE_rgb_422 */
 
 #ifndef GL_APPLE_row_bytes
@@ -5001,11 +5100,11 @@ GLAPI void APIENTRY glGetObjectParameterivAPPLE (GLenum objectType, GLuint name,
 #define GL_STORAGE_PRIVATE_APPLE          0x85BD
 #define GL_STORAGE_CACHED_APPLE           0x85BE
 #define GL_STORAGE_SHARED_APPLE           0x85BF
-typedef void (APIENTRYP PFNGLTEXTURERANGEAPPLEPROC) (GLenum target, GLsizei length, const GLvoid *pointer);
-typedef void (APIENTRYP PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC) (GLenum target, GLenum pname, GLvoid **params);
+typedef void (APIENTRYP PFNGLTEXTURERANGEAPPLEPROC) (GLenum target, GLsizei length, const void *pointer);
+typedef void (APIENTRYP PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC) (GLenum target, GLenum pname, void **params);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glTextureRangeAPPLE (GLenum target, GLsizei length, const GLvoid *pointer);
-GLAPI void APIENTRY glGetTexParameterPointervAPPLE (GLenum target, GLenum pname, GLvoid **params);
+GLAPI void APIENTRY glTextureRangeAPPLE (GLenum target, GLsizei length, const void *pointer);
+GLAPI void APIENTRY glGetTexParameterPointervAPPLE (GLenum target, GLenum pname, void **params);
 #endif
 #endif /* GL_APPLE_texture_range */
 
@@ -5036,12 +5135,12 @@ GLAPI GLboolean APIENTRY glIsVertexArrayAPPLE (GLuint array);
 #define GL_VERTEX_ARRAY_STORAGE_HINT_APPLE 0x851F
 #define GL_VERTEX_ARRAY_RANGE_POINTER_APPLE 0x8521
 #define GL_STORAGE_CLIENT_APPLE           0x85B4
-typedef void (APIENTRYP PFNGLVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, GLvoid *pointer);
-typedef void (APIENTRYP PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, GLvoid *pointer);
+typedef void (APIENTRYP PFNGLVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, void *pointer);
+typedef void (APIENTRYP PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, void *pointer);
 typedef void (APIENTRYP PFNGLVERTEXARRAYPARAMETERIAPPLEPROC) (GLenum pname, GLint param);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glVertexArrayRangeAPPLE (GLsizei length, GLvoid *pointer);
-GLAPI void APIENTRY glFlushVertexArrayRangeAPPLE (GLsizei length, GLvoid *pointer);
+GLAPI void APIENTRY glVertexArrayRangeAPPLE (GLsizei length, void *pointer);
+GLAPI void APIENTRY glFlushVertexArrayRangeAPPLE (GLsizei length, void *pointer);
 GLAPI void APIENTRY glVertexArrayParameteriAPPLE (GLenum pname, GLint param);
 #endif
 #endif /* GL_APPLE_vertex_array_range */
@@ -5111,11 +5210,11 @@ GLAPI void APIENTRY glDrawBuffersATI (GLsizei n, const GLenum *bufs);
 #define GL_ELEMENT_ARRAY_ATI              0x8768
 #define GL_ELEMENT_ARRAY_TYPE_ATI         0x8769
 #define GL_ELEMENT_ARRAY_POINTER_ATI      0x876A
-typedef void (APIENTRYP PFNGLELEMENTPOINTERATIPROC) (GLenum type, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLELEMENTPOINTERATIPROC) (GLenum type, const void *pointer);
 typedef void (APIENTRYP PFNGLDRAWELEMENTARRAYATIPROC) (GLenum mode, GLsizei count);
 typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTARRAYATIPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glElementPointerATI (GLenum type, const GLvoid *pointer);
+GLAPI void APIENTRY glElementPointerATI (GLenum type, const void *pointer);
 GLAPI void APIENTRY glDrawElementArrayATI (GLenum mode, GLsizei count);
 GLAPI void APIENTRY glDrawRangeElementArrayATI (GLenum mode, GLuint start, GLuint end, GLsizei count);
 #endif
@@ -5381,9 +5480,9 @@ GLAPI void APIENTRY glStencilFuncSeparateATI (GLenum frontfunc, GLenum backfunc,
 #define GL_OBJECT_BUFFER_USAGE_ATI        0x8765
 #define GL_ARRAY_OBJECT_BUFFER_ATI        0x8766
 #define GL_ARRAY_OBJECT_OFFSET_ATI        0x8767
-typedef GLuint (APIENTRYP PFNGLNEWOBJECTBUFFERATIPROC) (GLsizei size, const GLvoid *pointer, GLenum usage);
+typedef GLuint (APIENTRYP PFNGLNEWOBJECTBUFFERATIPROC) (GLsizei size, const void *pointer, GLenum usage);
 typedef GLboolean (APIENTRYP PFNGLISOBJECTBUFFERATIPROC) (GLuint buffer);
-typedef void (APIENTRYP PFNGLUPDATEOBJECTBUFFERATIPROC) (GLuint buffer, GLuint offset, GLsizei size, const GLvoid *pointer, GLenum preserve);
+typedef void (APIENTRYP PFNGLUPDATEOBJECTBUFFERATIPROC) (GLuint buffer, GLuint offset, GLsizei size, const void *pointer, GLenum preserve);
 typedef void (APIENTRYP PFNGLGETOBJECTBUFFERFVATIPROC) (GLuint buffer, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETOBJECTBUFFERIVATIPROC) (GLuint buffer, GLenum pname, GLint *params);
 typedef void (APIENTRYP PFNGLFREEOBJECTBUFFERATIPROC) (GLuint buffer);
@@ -5394,9 +5493,9 @@ typedef void (APIENTRYP PFNGLVARIANTARRAYOBJECTATIPROC) (GLuint id, GLenum type,
 typedef void (APIENTRYP PFNGLGETVARIANTARRAYOBJECTFVATIPROC) (GLuint id, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETVARIANTARRAYOBJECTIVATIPROC) (GLuint id, GLenum pname, GLint *params);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI GLuint APIENTRY glNewObjectBufferATI (GLsizei size, const GLvoid *pointer, GLenum usage);
+GLAPI GLuint APIENTRY glNewObjectBufferATI (GLsizei size, const void *pointer, GLenum usage);
 GLAPI GLboolean APIENTRY glIsObjectBufferATI (GLuint buffer);
-GLAPI void APIENTRY glUpdateObjectBufferATI (GLuint buffer, GLuint offset, GLsizei size, const GLvoid *pointer, GLenum preserve);
+GLAPI void APIENTRY glUpdateObjectBufferATI (GLuint buffer, GLuint offset, GLsizei size, const void *pointer, GLenum preserve);
 GLAPI void APIENTRY glGetObjectBufferfvATI (GLuint buffer, GLenum pname, GLfloat *params);
 GLAPI void APIENTRY glGetObjectBufferivATI (GLuint buffer, GLenum pname, GLint *params);
 GLAPI void APIENTRY glFreeObjectBufferATI (GLuint buffer);
@@ -5636,10 +5735,10 @@ GLAPI void APIENTRY glBlendEquationEXT (GLenum mode);
 
 #ifndef GL_EXT_color_subtable
 #define GL_EXT_color_subtable 1
-typedef void (APIENTRYP PFNGLCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
+typedef void (APIENTRYP PFNGLCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
 typedef void (APIENTRYP PFNGLCOPYCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glColorSubTableEXT (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
+GLAPI void APIENTRY glColorSubTableEXT (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
 GLAPI void APIENTRY glCopyColorSubTableEXT (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
 #endif
 #endif /* GL_EXT_color_subtable */
@@ -5678,33 +5777,33 @@ GLAPI void APIENTRY glUnlockArraysEXT (void);
 #define GL_POST_CONVOLUTION_GREEN_BIAS_EXT 0x8021
 #define GL_POST_CONVOLUTION_BLUE_BIAS_EXT 0x8022
 #define GL_POST_CONVOLUTION_ALPHA_BIAS_EXT 0x8023
-typedef void (APIENTRYP PFNGLCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
-typedef void (APIENTRYP PFNGLCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
+typedef void (APIENTRYP PFNGLCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
+typedef void (APIENTRYP PFNGLCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
 typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat params);
 typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat *params);
 typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint params);
 typedef void (APIENTRYP PFNGLCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
 typedef void (APIENTRYP PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
 typedef void (APIENTRYP PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
-typedef void (APIENTRYP PFNGLGETCONVOLUTIONFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *image);
+typedef void (APIENTRYP PFNGLGETCONVOLUTIONFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, void *image);
 typedef void (APIENTRYP PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
-typedef void (APIENTRYP PFNGLGETSEPARABLEFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
-typedef void (APIENTRYP PFNGLSEPARABLEFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
+typedef void (APIENTRYP PFNGLGETSEPARABLEFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
+typedef void (APIENTRYP PFNGLSEPARABLEFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glConvolutionFilter1DEXT (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
-GLAPI void APIENTRY glConvolutionFilter2DEXT (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
+GLAPI void APIENTRY glConvolutionFilter1DEXT (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
+GLAPI void APIENTRY glConvolutionFilter2DEXT (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
 GLAPI void APIENTRY glConvolutionParameterfEXT (GLenum target, GLenum pname, GLfloat params);
 GLAPI void APIENTRY glConvolutionParameterfvEXT (GLenum target, GLenum pname, const GLfloat *params);
 GLAPI void APIENTRY glConvolutionParameteriEXT (GLenum target, GLenum pname, GLint params);
 GLAPI void APIENTRY glConvolutionParameterivEXT (GLenum target, GLenum pname, const GLint *params);
 GLAPI void APIENTRY glCopyConvolutionFilter1DEXT (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
 GLAPI void APIENTRY glCopyConvolutionFilter2DEXT (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
-GLAPI void APIENTRY glGetConvolutionFilterEXT (GLenum target, GLenum format, GLenum type, GLvoid *image);
+GLAPI void APIENTRY glGetConvolutionFilterEXT (GLenum target, GLenum format, GLenum type, void *image);
 GLAPI void APIENTRY glGetConvolutionParameterfvEXT (GLenum target, GLenum pname, GLfloat *params);
 GLAPI void APIENTRY glGetConvolutionParameterivEXT (GLenum target, GLenum pname, GLint *params);
-GLAPI void APIENTRY glGetSeparableFilterEXT (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
-GLAPI void APIENTRY glSeparableFilter2DEXT (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
+GLAPI void APIENTRY glGetSeparableFilterEXT (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
+GLAPI void APIENTRY glSeparableFilter2DEXT (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);
 #endif
 #endif /* GL_EXT_convolution */
 
@@ -5744,8 +5843,8 @@ typedef void (APIENTRYP PFNGLBINORMAL3IEXTPROC) (GLint bx, GLint by, GLint bz);
 typedef void (APIENTRYP PFNGLBINORMAL3IVEXTPROC) (const GLint *v);
 typedef void (APIENTRYP PFNGLBINORMAL3SEXTPROC) (GLshort bx, GLshort by, GLshort bz);
 typedef void (APIENTRYP PFNGLBINORMAL3SVEXTPROC) (const GLshort *v);
-typedef void (APIENTRYP PFNGLTANGENTPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
-typedef void (APIENTRYP PFNGLBINORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLTANGENTPOINTEREXTPROC) (GLenum type, GLsizei stride, const void *pointer);
+typedef void (APIENTRYP PFNGLBINORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, const void *pointer);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glTangent3bEXT (GLbyte tx, GLbyte ty, GLbyte tz);
 GLAPI void APIENTRY glTangent3bvEXT (const GLbyte *v);
@@ -5767,8 +5866,8 @@ GLAPI void APIENTRY glBinormal3iEXT (GLint bx, GLint by, GLint bz);
 GLAPI void APIENTRY glBinormal3ivEXT (const GLint *v);
 GLAPI void APIENTRY glBinormal3sEXT (GLshort bx, GLshort by, GLshort bz);
 GLAPI void APIENTRY glBinormal3svEXT (const GLshort *v);
-GLAPI void APIENTRY glTangentPointerEXT (GLenum type, GLsizei stride, const GLvoid *pointer);
-GLAPI void APIENTRY glBinormalPointerEXT (GLenum type, GLsizei stride, const GLvoid *pointer);
+GLAPI void APIENTRY glTangentPointerEXT (GLenum type, GLsizei stride, const void *pointer);
+GLAPI void APIENTRY glBinormalPointerEXT (GLenum type, GLsizei stride, const void *pointer);
 #endif
 #endif /* GL_EXT_coordinate_frame */
 
@@ -5837,24 +5936,24 @@ typedef void (APIENTRYP PFNGLTEXTUREPARAMETERFEXTPROC) (GLuint texture, GLenum t
 typedef void (APIENTRYP PFNGLTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLfloat *params);
 typedef void (APIENTRYP PFNGLTEXTUREPARAMETERIEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint param);
 typedef void (APIENTRYP PFNGLTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint *params);
-typedef void (APIENTRYP PFNGLTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-typedef void (APIENTRYP PFNGLTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-typedef void (APIENTRYP PFNGLTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
-typedef void (APIENTRYP PFNGLTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
+typedef void (APIENTRYP PFNGLTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
+typedef void (APIENTRYP PFNGLTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
+typedef void (APIENTRYP PFNGLTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
+typedef void (APIENTRYP PFNGLTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
 typedef void (APIENTRYP PFNGLCOPYTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
 typedef void (APIENTRYP PFNGLCOPYTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
 typedef void (APIENTRYP PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
 typedef void (APIENTRYP PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
-typedef void (APIENTRYP PFNGLGETTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
+typedef void (APIENTRYP PFNGLGETTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
 typedef void (APIENTRYP PFNGLGETTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint *params);
 typedef void (APIENTRYP PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params);
-typedef void (APIENTRYP PFNGLTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-typedef void (APIENTRYP PFNGLTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
+typedef void (APIENTRYP PFNGLTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
+typedef void (APIENTRYP PFNGLTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
 typedef void (APIENTRYP PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
 typedef void (APIENTRYP PFNGLBINDMULTITEXTUREEXTPROC) (GLenum texunit, GLenum target, GLuint texture);
-typedef void (APIENTRYP PFNGLMULTITEXCOORDPOINTEREXTPROC) (GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLMULTITEXCOORDPOINTEREXTPROC) (GLenum texunit, GLint size, GLenum type, GLsizei stride, const void *pointer);
 typedef void (APIENTRYP PFNGLMULTITEXENVFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
 typedef void (APIENTRYP PFNGLMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat *params);
 typedef void (APIENTRYP PFNGLMULTITEXENVIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
@@ -5874,57 +5973,57 @@ typedef void (APIENTRYP PFNGLMULTITEXPARAMETERIEXTPROC) (GLenum texunit, GLenum
 typedef void (APIENTRYP PFNGLMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint *params);
 typedef void (APIENTRYP PFNGLMULTITEXPARAMETERFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
 typedef void (APIENTRYP PFNGLMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat *params);
-typedef void (APIENTRYP PFNGLMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-typedef void (APIENTRYP PFNGLMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-typedef void (APIENTRYP PFNGLMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
-typedef void (APIENTRYP PFNGLMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
+typedef void (APIENTRYP PFNGLMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
+typedef void (APIENTRYP PFNGLMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
+typedef void (APIENTRYP PFNGLMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
+typedef void (APIENTRYP PFNGLMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
 typedef void (APIENTRYP PFNGLCOPYMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
 typedef void (APIENTRYP PFNGLCOPYMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
 typedef void (APIENTRYP PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
 typedef void (APIENTRYP PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
-typedef void (APIENTRYP PFNGLGETMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
+typedef void (APIENTRYP PFNGLGETMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
 typedef void (APIENTRYP PFNGLGETMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint *params);
 typedef void (APIENTRYP PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params);
-typedef void (APIENTRYP PFNGLMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-typedef void (APIENTRYP PFNGLMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
+typedef void (APIENTRYP PFNGLMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
+typedef void (APIENTRYP PFNGLMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
 typedef void (APIENTRYP PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
 typedef void (APIENTRYP PFNGLENABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
 typedef void (APIENTRYP PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
 typedef void (APIENTRYP PFNGLGETFLOATINDEXEDVEXTPROC) (GLenum target, GLuint index, GLfloat *data);
 typedef void (APIENTRYP PFNGLGETDOUBLEINDEXEDVEXTPROC) (GLenum target, GLuint index, GLdouble *data);
-typedef void (APIENTRYP PFNGLGETPOINTERINDEXEDVEXTPROC) (GLenum target, GLuint index, GLvoid **data);
+typedef void (APIENTRYP PFNGLGETPOINTERINDEXEDVEXTPROC) (GLenum target, GLuint index, void **data);
 typedef void (APIENTRYP PFNGLENABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
 typedef void (APIENTRYP PFNGLDISABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
 typedef GLboolean (APIENTRYP PFNGLISENABLEDINDEXEDEXTPROC) (GLenum target, GLuint index);
 typedef void (APIENTRYP PFNGLGETINTEGERINDEXEDVEXTPROC) (GLenum target, GLuint index, GLint *data);
 typedef void (APIENTRYP PFNGLGETBOOLEANINDEXEDVEXTPROC) (GLenum target, GLuint index, GLboolean *data);
-typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits);
-typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits);
-typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *bits);
-typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *bits);
-typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *bits);
-typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *bits);
-typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint lod, GLvoid *img);
-typedef void (APIENTRYP PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits);
-typedef void (APIENTRYP PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits);
-typedef void (APIENTRYP PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *bits);
-typedef void (APIENTRYP PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *bits);
-typedef void (APIENTRYP PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *bits);
-typedef void (APIENTRYP PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *bits);
-typedef void (APIENTRYP PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint lod, GLvoid *img);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *bits);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *bits);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *bits);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *bits);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *bits);
+typedef void (APIENTRYP PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *bits);
+typedef void (APIENTRYP PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint lod, void *img);
+typedef void (APIENTRYP PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *bits);
+typedef void (APIENTRYP PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *bits);
+typedef void (APIENTRYP PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *bits);
+typedef void (APIENTRYP PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *bits);
+typedef void (APIENTRYP PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *bits);
+typedef void (APIENTRYP PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *bits);
+typedef void (APIENTRYP PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint lod, void *img);
 typedef void (APIENTRYP PFNGLMATRIXLOADTRANSPOSEFEXTPROC) (GLenum mode, const GLfloat *m);
 typedef void (APIENTRYP PFNGLMATRIXLOADTRANSPOSEDEXTPROC) (GLenum mode, const GLdouble *m);
 typedef void (APIENTRYP PFNGLMATRIXMULTTRANSPOSEFEXTPROC) (GLenum mode, const GLfloat *m);
 typedef void (APIENTRYP PFNGLMATRIXMULTTRANSPOSEDEXTPROC) (GLenum mode, const GLdouble *m);
-typedef void (APIENTRYP PFNGLNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLsizeiptr size, const GLvoid *data, GLenum usage);
-typedef void (APIENTRYP PFNGLNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *data);
+typedef void (APIENTRYP PFNGLNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
+typedef void (APIENTRYP PFNGLNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
 typedef void *(APIENTRYP PFNGLMAPNAMEDBUFFEREXTPROC) (GLuint buffer, GLenum access);
 typedef GLboolean (APIENTRYP PFNGLUNMAPNAMEDBUFFEREXTPROC) (GLuint buffer);
 typedef void (APIENTRYP PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC) (GLuint buffer, GLenum pname, GLint *params);
-typedef void (APIENTRYP PFNGLGETNAMEDBUFFERPOINTERVEXTPROC) (GLuint buffer, GLenum pname, GLvoid **params);
-typedef void (APIENTRYP PFNGLGETNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *data);
+typedef void (APIENTRYP PFNGLGETNAMEDBUFFERPOINTERVEXTPROC) (GLuint buffer, GLenum pname, void **params);
+typedef void (APIENTRYP PFNGLGETNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
 typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1FEXTPROC) (GLuint program, GLint location, GLfloat v0);
 typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1);
 typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
@@ -5981,8 +6080,8 @@ typedef void (APIENTRYP PFNGLENABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint in
 typedef void (APIENTRYP PFNGLDISABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
 typedef void (APIENTRYP PFNGLGETFLOATI_VEXTPROC) (GLenum pname, GLuint index, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETDOUBLEI_VEXTPROC) (GLenum pname, GLuint index, GLdouble *params);
-typedef void (APIENTRYP PFNGLGETPOINTERI_VEXTPROC) (GLenum pname, GLuint index, GLvoid **params);
-typedef void (APIENTRYP PFNGLNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid *string);
+typedef void (APIENTRYP PFNGLGETPOINTERI_VEXTPROC) (GLenum pname, GLuint index, void **params);
+typedef void (APIENTRYP PFNGLNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum format, GLsizei len, const void *string);
 typedef void (APIENTRYP PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
 typedef void (APIENTRYP PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLdouble *params);
 typedef void (APIENTRYP PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
@@ -5990,7 +6089,7 @@ typedef void (APIENTRYP PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC) (GLuint progr
 typedef void (APIENTRYP PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble *params);
 typedef void (APIENTRYP PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETNAMEDPROGRAMIVEXTPROC) (GLuint program, GLenum target, GLenum pname, GLint *params);
-typedef void (APIENTRYP PFNGLGETNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum pname, GLvoid *string);
+typedef void (APIENTRYP PFNGLGETNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum pname, void *string);
 typedef void (APIENTRYP PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
 typedef void (APIENTRYP PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC) (GLuint renderbuffer, GLenum pname, GLint *params);
 typedef void (APIENTRYP PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
@@ -6029,11 +6128,48 @@ typedef void (APIENTRYP PFNGLDISABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum ar
 typedef void (APIENTRYP PFNGLENABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
 typedef void (APIENTRYP PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
 typedef void (APIENTRYP PFNGLGETVERTEXARRAYINTEGERVEXTPROC) (GLuint vaobj, GLenum pname, GLint *param);
-typedef void (APIENTRYP PFNGLGETVERTEXARRAYPOINTERVEXTPROC) (GLuint vaobj, GLenum pname, GLvoid **param);
+typedef void (APIENTRYP PFNGLGETVERTEXARRAYPOINTERVEXTPROC) (GLuint vaobj, GLenum pname, void **param);
 typedef void (APIENTRYP PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint *param);
-typedef void (APIENTRYP PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, GLvoid **param);
+typedef void (APIENTRYP PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, void **param);
 typedef void *(APIENTRYP PFNGLMAPNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
 typedef void (APIENTRYP PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
+typedef void (APIENTRYP PFNGLNAMEDBUFFERSTORAGEEXTPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);
+typedef void (APIENTRYP PFNGLCLEARNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
+typedef void (APIENTRYP PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, GLsizeiptr offset, GLsizeiptr size, const void *data);
+typedef void (APIENTRYP PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC) (GLuint framebuffer, GLenum pname, GLint param);
+typedef void (APIENTRYP PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint *params);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1DEXTPROC) (GLuint program, GLint location, GLdouble x);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2DEXTPROC) (GLuint program, GLint location, GLdouble x, GLdouble y);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3DEXTPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4DEXTPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORM1DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORM2DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORM3DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORM4DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
+typedef void (APIENTRYP PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
+typedef void (APIENTRYP PFNGLTEXTUREBUFFERRANGEEXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
+typedef void (APIENTRYP PFNGLTEXTURESTORAGE1DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
+typedef void (APIENTRYP PFNGLTEXTURESTORAGE2DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
+typedef void (APIENTRYP PFNGLTEXTURESTORAGE3DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
+typedef void (APIENTRYP PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
+typedef void (APIENTRYP PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
+typedef void (APIENTRYP PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
+typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
+typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
+typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
+typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC) (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
+typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint divisor);
+typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
+typedef void (APIENTRYP PFNGLTEXTUREPAGECOMMITMENTEXTPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean resident);
+typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC) (GLuint vaobj, GLuint index, GLuint divisor);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glMatrixLoadfEXT (GLenum mode, const GLfloat *m);
 GLAPI void APIENTRY glMatrixLoaddEXT (GLenum mode, const GLdouble *m);
@@ -6056,24 +6192,24 @@ GLAPI void APIENTRY glTextureParameterfEXT (GLuint texture, GLenum target, GLenu
 GLAPI void APIENTRY glTextureParameterfvEXT (GLuint texture, GLenum target, GLenum pname, const GLfloat *params);
 GLAPI void APIENTRY glTextureParameteriEXT (GLuint texture, GLenum target, GLenum pname, GLint param);
 GLAPI void APIENTRY glTextureParameterivEXT (GLuint texture, GLenum target, GLenum pname, const GLint *params);
-GLAPI void APIENTRY glTextureImage1DEXT (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-GLAPI void APIENTRY glTextureImage2DEXT (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-GLAPI void APIENTRY glTextureSubImage1DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
-GLAPI void APIENTRY glTextureSubImage2DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
+GLAPI void APIENTRY glTextureImage1DEXT (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
+GLAPI void APIENTRY glTextureImage2DEXT (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
+GLAPI void APIENTRY glTextureSubImage1DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
+GLAPI void APIENTRY glTextureSubImage2DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
 GLAPI void APIENTRY glCopyTextureImage1DEXT (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
 GLAPI void APIENTRY glCopyTextureImage2DEXT (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
 GLAPI void APIENTRY glCopyTextureSubImage1DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
 GLAPI void APIENTRY glCopyTextureSubImage2DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
-GLAPI void APIENTRY glGetTextureImageEXT (GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
+GLAPI void APIENTRY glGetTextureImageEXT (GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
 GLAPI void APIENTRY glGetTextureParameterfvEXT (GLuint texture, GLenum target, GLenum pname, GLfloat *params);
 GLAPI void APIENTRY glGetTextureParameterivEXT (GLuint texture, GLenum target, GLenum pname, GLint *params);
 GLAPI void APIENTRY glGetTextureLevelParameterfvEXT (GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat *params);
 GLAPI void APIENTRY glGetTextureLevelParameterivEXT (GLuint texture, GLenum target, GLint level, GLenum pname, GLint *params);
-GLAPI void APIENTRY glTextureImage3DEXT (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-GLAPI void APIENTRY glTextureSubImage3DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
+GLAPI void APIENTRY glTextureImage3DEXT (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
+GLAPI void APIENTRY glTextureSubImage3DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
 GLAPI void APIENTRY glCopyTextureSubImage3DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
 GLAPI void APIENTRY glBindMultiTextureEXT (GLenum texunit, GLenum target, GLuint texture);
-GLAPI void APIENTRY glMultiTexCoordPointerEXT (GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+GLAPI void APIENTRY glMultiTexCoordPointerEXT (GLenum texunit, GLint size, GLenum type, GLsizei stride, const void *pointer);
 GLAPI void APIENTRY glMultiTexEnvfEXT (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
 GLAPI void APIENTRY glMultiTexEnvfvEXT (GLenum texunit, GLenum target, GLenum pname, const GLfloat *params);
 GLAPI void APIENTRY glMultiTexEnviEXT (GLenum texunit, GLenum target, GLenum pname, GLint param);
@@ -6093,57 +6229,57 @@ GLAPI void APIENTRY glMultiTexParameteriEXT (GLenum texunit, GLenum target, GLen
 GLAPI void APIENTRY glMultiTexParameterivEXT (GLenum texunit, GLenum target, GLenum pname, const GLint *params);
 GLAPI void APIENTRY glMultiTexParameterfEXT (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
 GLAPI void APIENTRY glMultiTexParameterfvEXT (GLenum texunit, GLenum target, GLenum pname, const GLfloat *params);
-GLAPI void APIENTRY glMultiTexImage1DEXT (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-GLAPI void APIENTRY glMultiTexImage2DEXT (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-GLAPI void APIENTRY glMultiTexSubImage1DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
-GLAPI void APIENTRY glMultiTexSubImage2DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
+GLAPI void APIENTRY glMultiTexImage1DEXT (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
+GLAPI void APIENTRY glMultiTexImage2DEXT (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
+GLAPI void APIENTRY glMultiTexSubImage1DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
+GLAPI void APIENTRY glMultiTexSubImage2DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
 GLAPI void APIENTRY glCopyMultiTexImage1DEXT (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
 GLAPI void APIENTRY glCopyMultiTexImage2DEXT (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
 GLAPI void APIENTRY glCopyMultiTexSubImage1DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
 GLAPI void APIENTRY glCopyMultiTexSubImage2DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
-GLAPI void APIENTRY glGetMultiTexImageEXT (GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
+GLAPI void APIENTRY glGetMultiTexImageEXT (GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
 GLAPI void APIENTRY glGetMultiTexParameterfvEXT (GLenum texunit, GLenum target, GLenum pname, GLfloat *params);
 GLAPI void APIENTRY glGetMultiTexParameterivEXT (GLenum texunit, GLenum target, GLenum pname, GLint *params);
 GLAPI void APIENTRY glGetMultiTexLevelParameterfvEXT (GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat *params);
 GLAPI void APIENTRY glGetMultiTexLevelParameterivEXT (GLenum texunit, GLenum target, GLint level, GLenum pname, GLint *params);
-GLAPI void APIENTRY glMultiTexImage3DEXT (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-GLAPI void APIENTRY glMultiTexSubImage3DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
+GLAPI void APIENTRY glMultiTexImage3DEXT (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
+GLAPI void APIENTRY glMultiTexSubImage3DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
 GLAPI void APIENTRY glCopyMultiTexSubImage3DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
 GLAPI void APIENTRY glEnableClientStateIndexedEXT (GLenum array, GLuint index);
 GLAPI void APIENTRY glDisableClientStateIndexedEXT (GLenum array, GLuint index);
 GLAPI void APIENTRY glGetFloatIndexedvEXT (GLenum target, GLuint index, GLfloat *data);
 GLAPI void APIENTRY glGetDoubleIndexedvEXT (GLenum target, GLuint index, GLdouble *data);
-GLAPI void APIENTRY glGetPointerIndexedvEXT (GLenum target, GLuint index, GLvoid **data);
+GLAPI void APIENTRY glGetPointerIndexedvEXT (GLenum target, GLuint index, void **data);
 GLAPI void APIENTRY glEnableIndexedEXT (GLenum target, GLuint index);
 GLAPI void APIENTRY glDisableIndexedEXT (GLenum target, GLuint index);
 GLAPI GLboolean APIENTRY glIsEnabledIndexedEXT (GLenum target, GLuint index);
 GLAPI void APIENTRY glGetIntegerIndexedvEXT (GLenum target, GLuint index, GLint *data);
 GLAPI void APIENTRY glGetBooleanIndexedvEXT (GLenum target, GLuint index, GLboolean *data);
-GLAPI void APIENTRY glCompressedTextureImage3DEXT (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits);
-GLAPI void APIENTRY glCompressedTextureImage2DEXT (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits);
-GLAPI void APIENTRY glCompressedTextureImage1DEXT (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *bits);
-GLAPI void APIENTRY glCompressedTextureSubImage3DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *bits);
-GLAPI void APIENTRY glCompressedTextureSubImage2DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *bits);
-GLAPI void APIENTRY glCompressedTextureSubImage1DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *bits);
-GLAPI void APIENTRY glGetCompressedTextureImageEXT (GLuint texture, GLenum target, GLint lod, GLvoid *img);
-GLAPI void APIENTRY glCompressedMultiTexImage3DEXT (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *bits);
-GLAPI void APIENTRY glCompressedMultiTexImage2DEXT (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *bits);
-GLAPI void APIENTRY glCompressedMultiTexImage1DEXT (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *bits);
-GLAPI void APIENTRY glCompressedMultiTexSubImage3DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *bits);
-GLAPI void APIENTRY glCompressedMultiTexSubImage2DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *bits);
-GLAPI void APIENTRY glCompressedMultiTexSubImage1DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *bits);
-GLAPI void APIENTRY glGetCompressedMultiTexImageEXT (GLenum texunit, GLenum target, GLint lod, GLvoid *img);
+GLAPI void APIENTRY glCompressedTextureImage3DEXT (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *bits);
+GLAPI void APIENTRY glCompressedTextureImage2DEXT (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *bits);
+GLAPI void APIENTRY glCompressedTextureImage1DEXT (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *bits);
+GLAPI void APIENTRY glCompressedTextureSubImage3DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *bits);
+GLAPI void APIENTRY glCompressedTextureSubImage2DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *bits);
+GLAPI void APIENTRY glCompressedTextureSubImage1DEXT (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *bits);
+GLAPI void APIENTRY glGetCompressedTextureImageEXT (GLuint texture, GLenum target, GLint lod, void *img);
+GLAPI void APIENTRY glCompressedMultiTexImage3DEXT (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *bits);
+GLAPI void APIENTRY glCompressedMultiTexImage2DEXT (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *bits);
+GLAPI void APIENTRY glCompressedMultiTexImage1DEXT (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *bits);
+GLAPI void APIENTRY glCompressedMultiTexSubImage3DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *bits);
+GLAPI void APIENTRY glCompressedMultiTexSubImage2DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *bits);
+GLAPI void APIENTRY glCompressedMultiTexSubImage1DEXT (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *bits);
+GLAPI void APIENTRY glGetCompressedMultiTexImageEXT (GLenum texunit, GLenum target, GLint lod, void *img);
 GLAPI void APIENTRY glMatrixLoadTransposefEXT (GLenum mode, const GLfloat *m);
 GLAPI void APIENTRY glMatrixLoadTransposedEXT (GLenum mode, const GLdouble *m);
 GLAPI void APIENTRY glMatrixMultTransposefEXT (GLenum mode, const GLfloat *m);
 GLAPI void APIENTRY glMatrixMultTransposedEXT (GLenum mode, const GLdouble *m);
-GLAPI void APIENTRY glNamedBufferDataEXT (GLuint buffer, GLsizeiptr size, const GLvoid *data, GLenum usage);
-GLAPI void APIENTRY glNamedBufferSubDataEXT (GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid *data);
+GLAPI void APIENTRY glNamedBufferDataEXT (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
+GLAPI void APIENTRY glNamedBufferSubDataEXT (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
 GLAPI void *APIENTRY glMapNamedBufferEXT (GLuint buffer, GLenum access);
 GLAPI GLboolean APIENTRY glUnmapNamedBufferEXT (GLuint buffer);
 GLAPI void APIENTRY glGetNamedBufferParameterivEXT (GLuint buffer, GLenum pname, GLint *params);
-GLAPI void APIENTRY glGetNamedBufferPointervEXT (GLuint buffer, GLenum pname, GLvoid **params);
-GLAPI void APIENTRY glGetNamedBufferSubDataEXT (GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid *data);
+GLAPI void APIENTRY glGetNamedBufferPointervEXT (GLuint buffer, GLenum pname, void **params);
+GLAPI void APIENTRY glGetNamedBufferSubDataEXT (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
 GLAPI void APIENTRY glProgramUniform1fEXT (GLuint program, GLint location, GLfloat v0);
 GLAPI void APIENTRY glProgramUniform2fEXT (GLuint program, GLint location, GLfloat v0, GLfloat v1);
 GLAPI void APIENTRY glProgramUniform3fEXT (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
@@ -6200,8 +6336,8 @@ GLAPI void APIENTRY glEnableClientStateiEXT (GLenum array, GLuint index);
 GLAPI void APIENTRY glDisableClientStateiEXT (GLenum array, GLuint index);
 GLAPI void APIENTRY glGetFloati_vEXT (GLenum pname, GLuint index, GLfloat *params);
 GLAPI void APIENTRY glGetDoublei_vEXT (GLenum pname, GLuint index, GLdouble *params);
-GLAPI void APIENTRY glGetPointeri_vEXT (GLenum pname, GLuint index, GLvoid **params);
-GLAPI void APIENTRY glNamedProgramStringEXT (GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid *string);
+GLAPI void APIENTRY glGetPointeri_vEXT (GLenum pname, GLuint index, void **params);
+GLAPI void APIENTRY glNamedProgramStringEXT (GLuint program, GLenum target, GLenum format, GLsizei len, const void *string);
 GLAPI void APIENTRY glNamedProgramLocalParameter4dEXT (GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
 GLAPI void APIENTRY glNamedProgramLocalParameter4dvEXT (GLuint program, GLenum target, GLuint index, const GLdouble *params);
 GLAPI void APIENTRY glNamedProgramLocalParameter4fEXT (GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
@@ -6209,7 +6345,7 @@ GLAPI void APIENTRY glNamedProgramLocalParameter4fvEXT (GLuint program, GLenum t
 GLAPI void APIENTRY glGetNamedProgramLocalParameterdvEXT (GLuint program, GLenum target, GLuint index, GLdouble *params);
 GLAPI void APIENTRY glGetNamedProgramLocalParameterfvEXT (GLuint program, GLenum target, GLuint index, GLfloat *params);
 GLAPI void APIENTRY glGetNamedProgramivEXT (GLuint program, GLenum target, GLenum pname, GLint *params);
-GLAPI void APIENTRY glGetNamedProgramStringEXT (GLuint program, GLenum target, GLenum pname, GLvoid *string);
+GLAPI void APIENTRY glGetNamedProgramStringEXT (GLuint program, GLenum target, GLenum pname, void *string);
 GLAPI void APIENTRY glNamedRenderbufferStorageEXT (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
 GLAPI void APIENTRY glGetNamedRenderbufferParameterivEXT (GLuint renderbuffer, GLenum pname, GLint *params);
 GLAPI void APIENTRY glNamedRenderbufferStorageMultisampleEXT (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
@@ -6248,11 +6384,48 @@ GLAPI void APIENTRY glDisableVertexArrayEXT (GLuint vaobj, GLenum array);
 GLAPI void APIENTRY glEnableVertexArrayAttribEXT (GLuint vaobj, GLuint index);
 GLAPI void APIENTRY glDisableVertexArrayAttribEXT (GLuint vaobj, GLuint index);
 GLAPI void APIENTRY glGetVertexArrayIntegervEXT (GLuint vaobj, GLenum pname, GLint *param);
-GLAPI void APIENTRY glGetVertexArrayPointervEXT (GLuint vaobj, GLenum pname, GLvoid **param);
+GLAPI void APIENTRY glGetVertexArrayPointervEXT (GLuint vaobj, GLenum pname, void **param);
 GLAPI void APIENTRY glGetVertexArrayIntegeri_vEXT (GLuint vaobj, GLuint index, GLenum pname, GLint *param);
-GLAPI void APIENTRY glGetVertexArrayPointeri_vEXT (GLuint vaobj, GLuint index, GLenum pname, GLvoid **param);
+GLAPI void APIENTRY glGetVertexArrayPointeri_vEXT (GLuint vaobj, GLuint index, GLenum pname, void **param);
 GLAPI void *APIENTRY glMapNamedBufferRangeEXT (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
 GLAPI void APIENTRY glFlushMappedNamedBufferRangeEXT (GLuint buffer, GLintptr offset, GLsizeiptr length);
+GLAPI void APIENTRY glNamedBufferStorageEXT (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);
+GLAPI void APIENTRY glClearNamedBufferDataEXT (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
+GLAPI void APIENTRY glClearNamedBufferSubDataEXT (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, GLsizeiptr offset, GLsizeiptr size, const void *data);
+GLAPI void APIENTRY glNamedFramebufferParameteriEXT (GLuint framebuffer, GLenum pname, GLint param);
+GLAPI void APIENTRY glGetNamedFramebufferParameterivEXT (GLuint framebuffer, GLenum pname, GLint *params);
+GLAPI void APIENTRY glProgramUniform1dEXT (GLuint program, GLint location, GLdouble x);
+GLAPI void APIENTRY glProgramUniform2dEXT (GLuint program, GLint location, GLdouble x, GLdouble y);
+GLAPI void APIENTRY glProgramUniform3dEXT (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
+GLAPI void APIENTRY glProgramUniform4dEXT (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
+GLAPI void APIENTRY glProgramUniform1dvEXT (GLuint program, GLint location, GLsizei count, const GLdouble *value);
+GLAPI void APIENTRY glProgramUniform2dvEXT (GLuint program, GLint location, GLsizei count, const GLdouble *value);
+GLAPI void APIENTRY glProgramUniform3dvEXT (GLuint program, GLint location, GLsizei count, const GLdouble *value);
+GLAPI void APIENTRY glProgramUniform4dvEXT (GLuint program, GLint location, GLsizei count, const GLdouble *value);
+GLAPI void APIENTRY glProgramUniformMatrix2dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
+GLAPI void APIENTRY glProgramUniformMatrix3dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
+GLAPI void APIENTRY glProgramUniformMatrix4dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
+GLAPI void APIENTRY glProgramUniformMatrix2x3dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
+GLAPI void APIENTRY glProgramUniformMatrix2x4dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
+GLAPI void APIENTRY glProgramUniformMatrix3x2dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
+GLAPI void APIENTRY glProgramUniformMatrix3x4dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
+GLAPI void APIENTRY glProgramUniformMatrix4x2dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
+GLAPI void APIENTRY glProgramUniformMatrix4x3dvEXT (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
+GLAPI void APIENTRY glTextureBufferRangeEXT (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
+GLAPI void APIENTRY glTextureStorage1DEXT (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
+GLAPI void APIENTRY glTextureStorage2DEXT (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
+GLAPI void APIENTRY glTextureStorage3DEXT (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
+GLAPI void APIENTRY glTextureStorage2DMultisampleEXT (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
+GLAPI void APIENTRY glTextureStorage3DMultisampleEXT (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
+GLAPI void APIENTRY glVertexArrayBindVertexBufferEXT (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
+GLAPI void APIENTRY glVertexArrayVertexAttribFormatEXT (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
+GLAPI void APIENTRY glVertexArrayVertexAttribIFormatEXT (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
+GLAPI void APIENTRY glVertexArrayVertexAttribLFormatEXT (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
+GLAPI void APIENTRY glVertexArrayVertexAttribBindingEXT (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
+GLAPI void APIENTRY glVertexArrayVertexBindingDivisorEXT (GLuint vaobj, GLuint bindingindex, GLuint divisor);
+GLAPI void APIENTRY glVertexArrayVertexAttribLOffsetEXT (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
+GLAPI void APIENTRY glTexturePageCommitmentEXT (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean resident);
+GLAPI void APIENTRY glVertexArrayVertexAttribDivisorEXT (GLuint vaobj, GLuint index, GLuint divisor);
 #endif
 #endif /* GL_EXT_direct_state_access */
 
@@ -6267,10 +6440,10 @@ GLAPI void APIENTRY glColorMaskIndexedEXT (GLuint index, GLboolean r, GLboolean
 #ifndef GL_EXT_draw_instanced
 #define GL_EXT_draw_instanced 1
 typedef void (APIENTRYP PFNGLDRAWARRAYSINSTANCEDEXTPROC) (GLenum mode, GLint start, GLsizei count, GLsizei primcount);
-typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDEXTPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
+typedef void (APIENTRYP PFNGLDRAWELEMENTSINSTANCEDEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glDrawArraysInstancedEXT (GLenum mode, GLint start, GLsizei count, GLsizei primcount);
-GLAPI void APIENTRY glDrawElementsInstancedEXT (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
+GLAPI void APIENTRY glDrawElementsInstancedEXT (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
 #endif
 #endif /* GL_EXT_draw_instanced */
 
@@ -6278,9 +6451,9 @@ GLAPI void APIENTRY glDrawElementsInstancedEXT (GLenum mode, GLsizei count, GLen
 #define GL_EXT_draw_range_elements 1
 #define GL_MAX_ELEMENTS_VERTICES_EXT      0x80E8
 #define GL_MAX_ELEMENTS_INDICES_EXT       0x80E9
-typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTSEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
+typedef void (APIENTRYP PFNGLDRAWRANGEELEMENTSEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glDrawRangeElementsEXT (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
+GLAPI void APIENTRY glDrawRangeElementsEXT (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
 #endif
 #endif /* GL_EXT_draw_range_elements */
 
@@ -6298,13 +6471,13 @@ typedef void (APIENTRYP PFNGLFOGCOORDFEXTPROC) (GLfloat coord);
 typedef void (APIENTRYP PFNGLFOGCOORDFVEXTPROC) (const GLfloat *coord);
 typedef void (APIENTRYP PFNGLFOGCOORDDEXTPROC) (GLdouble coord);
 typedef void (APIENTRYP PFNGLFOGCOORDDVEXTPROC) (const GLdouble *coord);
-typedef void (APIENTRYP PFNGLFOGCOORDPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLFOGCOORDPOINTEREXTPROC) (GLenum type, GLsizei stride, const void *pointer);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glFogCoordfEXT (GLfloat coord);
 GLAPI void APIENTRY glFogCoordfvEXT (const GLfloat *coord);
 GLAPI void APIENTRY glFogCoorddEXT (GLdouble coord);
 GLAPI void APIENTRY glFogCoorddvEXT (const GLdouble *coord);
-GLAPI void APIENTRY glFogCoordPointerEXT (GLenum type, GLsizei stride, const GLvoid *pointer);
+GLAPI void APIENTRY glFogCoordPointerEXT (GLenum type, GLsizei stride, const void *pointer);
 #endif
 #endif /* GL_EXT_fog_coord */
 
@@ -6544,10 +6717,10 @@ GLAPI void APIENTRY glUniform4uivEXT (GLint location, GLsizei count, const GLuin
 #define GL_MINMAX_FORMAT_EXT              0x802F
 #define GL_MINMAX_SINK_EXT                0x8030
 #define GL_TABLE_TOO_LARGE_EXT            0x8031
-typedef void (APIENTRYP PFNGLGETHISTOGRAMEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
+typedef void (APIENTRYP PFNGLGETHISTOGRAMEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
 typedef void (APIENTRYP PFNGLGETHISTOGRAMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETHISTOGRAMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
-typedef void (APIENTRYP PFNGLGETMINMAXEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
+typedef void (APIENTRYP PFNGLGETMINMAXEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
 typedef void (APIENTRYP PFNGLGETMINMAXPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETMINMAXPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
 typedef void (APIENTRYP PFNGLHISTOGRAMEXTPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
@@ -6555,10 +6728,10 @@ typedef void (APIENTRYP PFNGLMINMAXEXTPROC) (GLenum target, GLenum internalforma
 typedef void (APIENTRYP PFNGLRESETHISTOGRAMEXTPROC) (GLenum target);
 typedef void (APIENTRYP PFNGLRESETMINMAXEXTPROC) (GLenum target);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glGetHistogramEXT (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
+GLAPI void APIENTRY glGetHistogramEXT (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
 GLAPI void APIENTRY glGetHistogramParameterfvEXT (GLenum target, GLenum pname, GLfloat *params);
 GLAPI void APIENTRY glGetHistogramParameterivEXT (GLenum target, GLenum pname, GLint *params);
-GLAPI void APIENTRY glGetMinmaxEXT (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
+GLAPI void APIENTRY glGetMinmaxEXT (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
 GLAPI void APIENTRY glGetMinmaxParameterfvEXT (GLenum target, GLenum pname, GLfloat *params);
 GLAPI void APIENTRY glGetMinmaxParameterivEXT (GLenum target, GLenum pname, GLint *params);
 GLAPI void APIENTRY glHistogramEXT (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
@@ -6634,10 +6807,10 @@ GLAPI void APIENTRY glTextureMaterialEXT (GLenum face, GLenum mode);
 #ifndef GL_EXT_multi_draw_arrays
 #define GL_EXT_multi_draw_arrays 1
 typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSEXTPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
-typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSEXTPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid *const*indices, GLsizei primcount);
+typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSEXTPROC) (GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glMultiDrawArraysEXT (GLenum mode, const GLint *first, const GLsizei *count, GLsizei primcount);
-GLAPI void APIENTRY glMultiDrawElementsEXT (GLenum mode, const GLsizei *count, GLenum type, const GLvoid *const*indices, GLsizei primcount);
+GLAPI void APIENTRY glMultiDrawElementsEXT (GLenum mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount);
 #endif
 #endif /* GL_EXT_multi_draw_arrays */
 
@@ -6701,13 +6874,13 @@ GLAPI void APIENTRY glSamplePatternEXT (GLenum pattern);
 #define GL_COLOR_INDEX12_EXT              0x80E6
 #define GL_COLOR_INDEX16_EXT              0x80E7
 #define GL_TEXTURE_INDEX_SIZE_EXT         0x80ED
-typedef void (APIENTRYP PFNGLCOLORTABLEEXTPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
-typedef void (APIENTRYP PFNGLGETCOLORTABLEEXTPROC) (GLenum target, GLenum format, GLenum type, GLvoid *data);
+typedef void (APIENTRYP PFNGLCOLORTABLEEXTPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void *table);
+typedef void (APIENTRYP PFNGLGETCOLORTABLEEXTPROC) (GLenum target, GLenum format, GLenum type, void *data);
 typedef void (APIENTRYP PFNGLGETCOLORTABLEPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
 typedef void (APIENTRYP PFNGLGETCOLORTABLEPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat *params);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glColorTableEXT (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
-GLAPI void APIENTRY glGetColorTableEXT (GLenum target, GLenum format, GLenum type, GLvoid *data);
+GLAPI void APIENTRY glColorTableEXT (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void *table);
+GLAPI void APIENTRY glGetColorTableEXT (GLenum target, GLenum format, GLenum type, void *data);
 GLAPI void APIENTRY glGetColorTableParameterivEXT (GLenum target, GLenum pname, GLint *params);
 GLAPI void APIENTRY glGetColorTableParameterfvEXT (GLenum target, GLenum pname, GLfloat *params);
 #endif
@@ -6819,7 +6992,7 @@ typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UIEXTPROC) (GLuint red, GLuint green
 typedef void (APIENTRYP PFNGLSECONDARYCOLOR3UIVEXTPROC) (const GLuint *v);
 typedef void (APIENTRYP PFNGLSECONDARYCOLOR3USEXTPROC) (GLushort red, GLushort green, GLushort blue);
 typedef void (APIENTRYP PFNGLSECONDARYCOLOR3USVEXTPROC) (const GLushort *v);
-typedef void (APIENTRYP PFNGLSECONDARYCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLSECONDARYCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, const void *pointer);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glSecondaryColor3bEXT (GLbyte red, GLbyte green, GLbyte blue);
 GLAPI void APIENTRY glSecondaryColor3bvEXT (const GLbyte *v);
@@ -6837,7 +7010,7 @@ GLAPI void APIENTRY glSecondaryColor3uiEXT (GLuint red, GLuint green, GLuint blu
 GLAPI void APIENTRY glSecondaryColor3uivEXT (const GLuint *v);
 GLAPI void APIENTRY glSecondaryColor3usEXT (GLushort red, GLushort green, GLushort blue);
 GLAPI void APIENTRY glSecondaryColor3usvEXT (const GLushort *v);
-GLAPI void APIENTRY glSecondaryColorPointerEXT (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+GLAPI void APIENTRY glSecondaryColorPointerEXT (GLint size, GLenum type, GLsizei stride, const void *pointer);
 #endif
 #endif /* GL_EXT_secondary_color */
 
@@ -6926,6 +7099,10 @@ GLAPI void APIENTRY glMemoryBarrierEXT (GLbitfield barriers);
 #endif
 #endif /* GL_EXT_shader_image_load_store */
 
+#ifndef GL_EXT_shader_integer_mix
+#define GL_EXT_shader_integer_mix 1
+#endif /* GL_EXT_shader_integer_mix */
+
 #ifndef GL_EXT_shadow_funcs
 #define GL_EXT_shadow_funcs 1
 #endif /* GL_EXT_shadow_funcs */
@@ -6963,11 +7140,11 @@ GLAPI void APIENTRY glActiveStencilFaceEXT (GLenum face);
 
 #ifndef GL_EXT_subtexture
 #define GL_EXT_subtexture 1
-typedef void (APIENTRYP PFNGLTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
-typedef void (APIENTRYP PFNGLTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
+typedef void (APIENTRYP PFNGLTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
+typedef void (APIENTRYP PFNGLTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glTexSubImage1DEXT (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
-GLAPI void APIENTRY glTexSubImage2DEXT (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
+GLAPI void APIENTRY glTexSubImage1DEXT (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
+GLAPI void APIENTRY glTexSubImage2DEXT (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
 #endif
 #endif /* GL_EXT_subtexture */
 
@@ -7029,11 +7206,11 @@ GLAPI void APIENTRY glTexSubImage2DEXT (GLenum target, GLint level, GLint xoffse
 #define GL_TEXTURE_DEPTH_EXT              0x8071
 #define GL_TEXTURE_WRAP_R_EXT             0x8072
 #define GL_MAX_3D_TEXTURE_SIZE_EXT        0x8073
-typedef void (APIENTRYP PFNGLTEXIMAGE3DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-typedef void (APIENTRYP PFNGLTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
+typedef void (APIENTRYP PFNGLTEXIMAGE3DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
+typedef void (APIENTRYP PFNGLTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glTexImage3DEXT (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-GLAPI void APIENTRY glTexSubImage3DEXT (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
+GLAPI void APIENTRY glTexImage3DEXT (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
+GLAPI void APIENTRY glTexSubImage3DEXT (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
 #endif
 #endif /* GL_EXT_texture3D */
 
@@ -7399,24 +7576,24 @@ GLAPI void APIENTRY glGetTransformFeedbackVaryingEXT (GLuint program, GLuint ind
 #define GL_TEXTURE_COORD_ARRAY_POINTER_EXT 0x8092
 #define GL_EDGE_FLAG_ARRAY_POINTER_EXT    0x8093
 typedef void (APIENTRYP PFNGLARRAYELEMENTEXTPROC) (GLint i);
-typedef void (APIENTRYP PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
 typedef void (APIENTRYP PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
 typedef void (APIENTRYP PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean *pointer);
-typedef void (APIENTRYP PFNGLGETPOINTERVEXTPROC) (GLenum pname, GLvoid **params);
-typedef void (APIENTRYP PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
-typedef void (APIENTRYP PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
-typedef void (APIENTRYP PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
-typedef void (APIENTRYP PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLGETPOINTERVEXTPROC) (GLenum pname, void **params);
+typedef void (APIENTRYP PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const void *pointer);
+typedef void (APIENTRYP PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const void *pointer);
+typedef void (APIENTRYP PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
+typedef void (APIENTRYP PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glArrayElementEXT (GLint i);
-GLAPI void APIENTRY glColorPointerEXT (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
+GLAPI void APIENTRY glColorPointerEXT (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
 GLAPI void APIENTRY glDrawArraysEXT (GLenum mode, GLint first, GLsizei count);
 GLAPI void APIENTRY glEdgeFlagPointerEXT (GLsizei stride, GLsizei count, const GLboolean *pointer);
-GLAPI void APIENTRY glGetPointervEXT (GLenum pname, GLvoid **params);
-GLAPI void APIENTRY glIndexPointerEXT (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
-GLAPI void APIENTRY glNormalPointerEXT (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
-GLAPI void APIENTRY glTexCoordPointerEXT (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
-GLAPI void APIENTRY glVertexPointerEXT (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
+GLAPI void APIENTRY glGetPointervEXT (GLenum pname, void **params);
+GLAPI void APIENTRY glIndexPointerEXT (GLenum type, GLsizei stride, GLsizei count, const void *pointer);
+GLAPI void APIENTRY glNormalPointerEXT (GLenum type, GLsizei stride, GLsizei count, const void *pointer);
+GLAPI void APIENTRY glTexCoordPointerEXT (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
+GLAPI void APIENTRY glVertexPointerEXT (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
 #endif
 #endif /* GL_EXT_vertex_array */
 
@@ -7446,9 +7623,8 @@ typedef void (APIENTRYP PFNGLVERTEXATTRIBL1DVEXTPROC) (GLuint index, const GLdou
 typedef void (APIENTRYP PFNGLVERTEXATTRIBL2DVEXTPROC) (GLuint index, const GLdouble *v);
 typedef void (APIENTRYP PFNGLVERTEXATTRIBL3DVEXTPROC) (GLuint index, const GLdouble *v);
 typedef void (APIENTRYP PFNGLVERTEXATTRIBL4DVEXTPROC) (GLuint index, const GLdouble *v);
-typedef void (APIENTRYP PFNGLVERTEXATTRIBLPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBLPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
 typedef void (APIENTRYP PFNGLGETVERTEXATTRIBLDVEXTPROC) (GLuint index, GLenum pname, GLdouble *params);
-typedef void (APIENTRYP PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glVertexAttribL1dEXT (GLuint index, GLdouble x);
 GLAPI void APIENTRY glVertexAttribL2dEXT (GLuint index, GLdouble x, GLdouble y);
@@ -7458,9 +7634,8 @@ GLAPI void APIENTRY glVertexAttribL1dvEXT (GLuint index, const GLdouble *v);
 GLAPI void APIENTRY glVertexAttribL2dvEXT (GLuint index, const GLdouble *v);
 GLAPI void APIENTRY glVertexAttribL3dvEXT (GLuint index, const GLdouble *v);
 GLAPI void APIENTRY glVertexAttribL4dvEXT (GLuint index, const GLdouble *v);
-GLAPI void APIENTRY glVertexAttribLPointerEXT (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+GLAPI void APIENTRY glVertexAttribLPointerEXT (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
 GLAPI void APIENTRY glGetVertexAttribLdvEXT (GLuint index, GLenum pname, GLdouble *params);
-GLAPI void APIENTRY glVertexArrayVertexAttribLOffsetEXT (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
 #endif
 #endif /* GL_EXT_vertex_attrib_64bit */
 
@@ -7589,8 +7764,8 @@ typedef void (APIENTRYP PFNGLWRITEMASKEXTPROC) (GLuint res, GLuint in, GLenum ou
 typedef void (APIENTRYP PFNGLINSERTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
 typedef void (APIENTRYP PFNGLEXTRACTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
 typedef GLuint (APIENTRYP PFNGLGENSYMBOLSEXTPROC) (GLenum datatype, GLenum storagetype, GLenum range, GLuint components);
-typedef void (APIENTRYP PFNGLSETINVARIANTEXTPROC) (GLuint id, GLenum type, const GLvoid *addr);
-typedef void (APIENTRYP PFNGLSETLOCALCONSTANTEXTPROC) (GLuint id, GLenum type, const GLvoid *addr);
+typedef void (APIENTRYP PFNGLSETINVARIANTEXTPROC) (GLuint id, GLenum type, const void *addr);
+typedef void (APIENTRYP PFNGLSETLOCALCONSTANTEXTPROC) (GLuint id, GLenum type, const void *addr);
 typedef void (APIENTRYP PFNGLVARIANTBVEXTPROC) (GLuint id, const GLbyte *addr);
 typedef void (APIENTRYP PFNGLVARIANTSVEXTPROC) (GLuint id, const GLshort *addr);
 typedef void (APIENTRYP PFNGLVARIANTIVEXTPROC) (GLuint id, const GLint *addr);
@@ -7599,7 +7774,7 @@ typedef void (APIENTRYP PFNGLVARIANTDVEXTPROC) (GLuint id, const GLdouble *addr)
 typedef void (APIENTRYP PFNGLVARIANTUBVEXTPROC) (GLuint id, const GLubyte *addr);
 typedef void (APIENTRYP PFNGLVARIANTUSVEXTPROC) (GLuint id, const GLushort *addr);
 typedef void (APIENTRYP PFNGLVARIANTUIVEXTPROC) (GLuint id, const GLuint *addr);
-typedef void (APIENTRYP PFNGLVARIANTPOINTEREXTPROC) (GLuint id, GLenum type, GLuint stride, const GLvoid *addr);
+typedef void (APIENTRYP PFNGLVARIANTPOINTEREXTPROC) (GLuint id, GLenum type, GLuint stride, const void *addr);
 typedef void (APIENTRYP PFNGLENABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
 typedef void (APIENTRYP PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
 typedef GLuint (APIENTRYP PFNGLBINDLIGHTPARAMETEREXTPROC) (GLenum light, GLenum value);
@@ -7611,7 +7786,7 @@ typedef GLboolean (APIENTRYP PFNGLISVARIANTENABLEDEXTPROC) (GLuint id, GLenum ca
 typedef void (APIENTRYP PFNGLGETVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
 typedef void (APIENTRYP PFNGLGETVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
 typedef void (APIENTRYP PFNGLGETVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
-typedef void (APIENTRYP PFNGLGETVARIANTPOINTERVEXTPROC) (GLuint id, GLenum value, GLvoid **data);
+typedef void (APIENTRYP PFNGLGETVARIANTPOINTERVEXTPROC) (GLuint id, GLenum value, void **data);
 typedef void (APIENTRYP PFNGLGETINVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
 typedef void (APIENTRYP PFNGLGETINVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
 typedef void (APIENTRYP PFNGLGETINVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
@@ -7632,8 +7807,8 @@ GLAPI void APIENTRY glWriteMaskEXT (GLuint res, GLuint in, GLenum outX, GLenum o
 GLAPI void APIENTRY glInsertComponentEXT (GLuint res, GLuint src, GLuint num);
 GLAPI void APIENTRY glExtractComponentEXT (GLuint res, GLuint src, GLuint num);
 GLAPI GLuint APIENTRY glGenSymbolsEXT (GLenum datatype, GLenum storagetype, GLenum range, GLuint components);
-GLAPI void APIENTRY glSetInvariantEXT (GLuint id, GLenum type, const GLvoid *addr);
-GLAPI void APIENTRY glSetLocalConstantEXT (GLuint id, GLenum type, const GLvoid *addr);
+GLAPI void APIENTRY glSetInvariantEXT (GLuint id, GLenum type, const void *addr);
+GLAPI void APIENTRY glSetLocalConstantEXT (GLuint id, GLenum type, const void *addr);
 GLAPI void APIENTRY glVariantbvEXT (GLuint id, const GLbyte *addr);
 GLAPI void APIENTRY glVariantsvEXT (GLuint id, const GLshort *addr);
 GLAPI void APIENTRY glVariantivEXT (GLuint id, const GLint *addr);
@@ -7642,7 +7817,7 @@ GLAPI void APIENTRY glVariantdvEXT (GLuint id, const GLdouble *addr);
 GLAPI void APIENTRY glVariantubvEXT (GLuint id, const GLubyte *addr);
 GLAPI void APIENTRY glVariantusvEXT (GLuint id, const GLushort *addr);
 GLAPI void APIENTRY glVariantuivEXT (GLuint id, const GLuint *addr);
-GLAPI void APIENTRY glVariantPointerEXT (GLuint id, GLenum type, GLuint stride, const GLvoid *addr);
+GLAPI void APIENTRY glVariantPointerEXT (GLuint id, GLenum type, GLuint stride, const void *addr);
 GLAPI void APIENTRY glEnableVariantClientStateEXT (GLuint id);
 GLAPI void APIENTRY glDisableVariantClientStateEXT (GLuint id);
 GLAPI GLuint APIENTRY glBindLightParameterEXT (GLenum light, GLenum value);
@@ -7654,7 +7829,7 @@ GLAPI GLboolean APIENTRY glIsVariantEnabledEXT (GLuint id, GLenum cap);
 GLAPI void APIENTRY glGetVariantBooleanvEXT (GLuint id, GLenum value, GLboolean *data);
 GLAPI void APIENTRY glGetVariantIntegervEXT (GLuint id, GLenum value, GLint *data);
 GLAPI void APIENTRY glGetVariantFloatvEXT (GLuint id, GLenum value, GLfloat *data);
-GLAPI void APIENTRY glGetVariantPointervEXT (GLuint id, GLenum value, GLvoid **data);
+GLAPI void APIENTRY glGetVariantPointervEXT (GLuint id, GLenum value, void **data);
 GLAPI void APIENTRY glGetInvariantBooleanvEXT (GLuint id, GLenum value, GLboolean *data);
 GLAPI void APIENTRY glGetInvariantIntegervEXT (GLuint id, GLenum value, GLint *data);
 GLAPI void APIENTRY glGetInvariantFloatvEXT (GLuint id, GLenum value, GLfloat *data);
@@ -7681,11 +7856,11 @@ GLAPI void APIENTRY glGetLocalConstantFloatvEXT (GLuint id, GLenum value, GLfloa
 #define GL_VERTEX_WEIGHT_ARRAY_POINTER_EXT 0x8510
 typedef void (APIENTRYP PFNGLVERTEXWEIGHTFEXTPROC) (GLfloat weight);
 typedef void (APIENTRYP PFNGLVERTEXWEIGHTFVEXTPROC) (const GLfloat *weight);
-typedef void (APIENTRYP PFNGLVERTEXWEIGHTPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLVERTEXWEIGHTPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, const void *pointer);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glVertexWeightfEXT (GLfloat weight);
 GLAPI void APIENTRY glVertexWeightfvEXT (const GLfloat *weight);
-GLAPI void APIENTRY glVertexWeightPointerEXT (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+GLAPI void APIENTRY glVertexWeightPointerEXT (GLint size, GLenum type, GLsizei stride, const void *pointer);
 #endif
 #endif /* GL_EXT_vertex_weighting */
 
@@ -7708,9 +7883,9 @@ GLAPI void APIENTRY glFrameTerminatorGREMEDY (void);
 
 #ifndef GL_GREMEDY_string_marker
 #define GL_GREMEDY_string_marker 1
-typedef void (APIENTRYP PFNGLSTRINGMARKERGREMEDYPROC) (GLsizei len, const GLvoid *string);
+typedef void (APIENTRYP PFNGLSTRINGMARKERGREMEDYPROC) (GLsizei len, const void *string);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glStringMarkerGREMEDY (GLsizei len, const GLvoid *string);
+GLAPI void APIENTRY glStringMarkerGREMEDY (GLsizei len, const void *string);
 #endif
 #endif /* GL_GREMEDY_string_marker */
 
@@ -7776,10 +7951,10 @@ GLAPI void APIENTRY glGetImageTransformParameterfvHP (GLenum target, GLenum pnam
 #ifndef GL_IBM_multimode_draw_arrays
 #define GL_IBM_multimode_draw_arrays 1
 typedef void (APIENTRYP PFNGLMULTIMODEDRAWARRAYSIBMPROC) (const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
-typedef void (APIENTRYP PFNGLMULTIMODEDRAWELEMENTSIBMPROC) (const GLenum *mode, const GLsizei *count, GLenum type, const GLvoid *const*indices, GLsizei primcount, GLint modestride);
+typedef void (APIENTRYP PFNGLMULTIMODEDRAWELEMENTSIBMPROC) (const GLenum *mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount, GLint modestride);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glMultiModeDrawArraysIBM (const GLenum *mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
-GLAPI void APIENTRY glMultiModeDrawElementsIBM (const GLenum *mode, const GLsizei *count, GLenum type, const GLvoid *const*indices, GLsizei primcount, GLint modestride);
+GLAPI void APIENTRY glMultiModeDrawElementsIBM (const GLenum *mode, const GLsizei *count, GLenum type, const void *const*indices, GLsizei primcount, GLint modestride);
 #endif
 #endif /* GL_IBM_multimode_draw_arrays */
 
@@ -7821,23 +7996,23 @@ GLAPI void APIENTRY glFlushStaticDataIBM (GLenum target);
 #define GL_EDGE_FLAG_ARRAY_LIST_STRIDE_IBM 103085
 #define GL_FOG_COORDINATE_ARRAY_LIST_STRIDE_IBM 103086
 #define GL_SECONDARY_COLOR_ARRAY_LIST_STRIDE_IBM 103087
-typedef void (APIENTRYP PFNGLCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
-typedef void (APIENTRYP PFNGLSECONDARYCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
+typedef void (APIENTRYP PFNGLCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride);
+typedef void (APIENTRYP PFNGLSECONDARYCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride);
 typedef void (APIENTRYP PFNGLEDGEFLAGPOINTERLISTIBMPROC) (GLint stride, const GLboolean **pointer, GLint ptrstride);
-typedef void (APIENTRYP PFNGLFOGCOORDPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
-typedef void (APIENTRYP PFNGLINDEXPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
-typedef void (APIENTRYP PFNGLNORMALPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
-typedef void (APIENTRYP PFNGLTEXCOORDPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
-typedef void (APIENTRYP PFNGLVERTEXPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
-#ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glColorPointerListIBM (GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
-GLAPI void APIENTRY glSecondaryColorPointerListIBM (GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
+typedef void (APIENTRYP PFNGLFOGCOORDPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void **pointer, GLint ptrstride);
+typedef void (APIENTRYP PFNGLINDEXPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void **pointer, GLint ptrstride);
+typedef void (APIENTRYP PFNGLNORMALPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void **pointer, GLint ptrstride);
+typedef void (APIENTRYP PFNGLTEXCOORDPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride);
+typedef void (APIENTRYP PFNGLVERTEXPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride);
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glColorPointerListIBM (GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride);
+GLAPI void APIENTRY glSecondaryColorPointerListIBM (GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride);
 GLAPI void APIENTRY glEdgeFlagPointerListIBM (GLint stride, const GLboolean **pointer, GLint ptrstride);
-GLAPI void APIENTRY glFogCoordPointerListIBM (GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
-GLAPI void APIENTRY glIndexPointerListIBM (GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
-GLAPI void APIENTRY glNormalPointerListIBM (GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
-GLAPI void APIENTRY glTexCoordPointerListIBM (GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
-GLAPI void APIENTRY glVertexPointerListIBM (GLint size, GLenum type, GLint stride, const GLvoid **pointer, GLint ptrstride);
+GLAPI void APIENTRY glFogCoordPointerListIBM (GLenum type, GLint stride, const void **pointer, GLint ptrstride);
+GLAPI void APIENTRY glIndexPointerListIBM (GLenum type, GLint stride, const void **pointer, GLint ptrstride);
+GLAPI void APIENTRY glNormalPointerListIBM (GLenum type, GLint stride, const void **pointer, GLint ptrstride);
+GLAPI void APIENTRY glTexCoordPointerListIBM (GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride);
+GLAPI void APIENTRY glVertexPointerListIBM (GLint size, GLenum type, GLint stride, const void **pointer, GLint ptrstride);
 #endif
 #endif /* GL_IBM_vertex_array_lists */
 
@@ -7874,11 +8049,11 @@ GLAPI void APIENTRY glBlendFuncSeparateINGR (GLenum sfactorRGB, GLenum dfactorRG
 #define GL_LAYOUT_LINEAR_CPU_CACHED_INTEL 2
 typedef void (APIENTRYP PFNGLSYNCTEXTUREINTELPROC) (GLuint texture);
 typedef void (APIENTRYP PFNGLUNMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level);
-typedef void *(APIENTRYP PFNGLMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level, GLbitfield access, const GLint *stride, const GLenum *layout);
+typedef void *(APIENTRYP PFNGLMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level, GLbitfield access, GLint *stride, GLenum *layout);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glSyncTextureINTEL (GLuint texture);
 GLAPI void APIENTRY glUnmapTexture2DINTEL (GLuint texture, GLint level);
-GLAPI void *APIENTRY glMapTexture2DINTEL (GLuint texture, GLint level, GLbitfield access, const GLint *stride, const GLenum *layout);
+GLAPI void *APIENTRY glMapTexture2DINTEL (GLuint texture, GLint level, GLbitfield access, GLint *stride, GLenum *layout);
 #endif
 #endif /* GL_INTEL_map_texture */
 
@@ -7889,15 +8064,15 @@ GLAPI void *APIENTRY glMapTexture2DINTEL (GLuint texture, GLint level, GLbitfiel
 #define GL_NORMAL_ARRAY_PARALLEL_POINTERS_INTEL 0x83F6
 #define GL_COLOR_ARRAY_PARALLEL_POINTERS_INTEL 0x83F7
 #define GL_TEXTURE_COORD_ARRAY_PARALLEL_POINTERS_INTEL 0x83F8
-typedef void (APIENTRYP PFNGLVERTEXPOINTERVINTELPROC) (GLint size, GLenum type, const GLvoid **pointer);
-typedef void (APIENTRYP PFNGLNORMALPOINTERVINTELPROC) (GLenum type, const GLvoid **pointer);
-typedef void (APIENTRYP PFNGLCOLORPOINTERVINTELPROC) (GLint size, GLenum type, const GLvoid **pointer);
-typedef void (APIENTRYP PFNGLTEXCOORDPOINTERVINTELPROC) (GLint size, GLenum type, const GLvoid **pointer);
+typedef void (APIENTRYP PFNGLVERTEXPOINTERVINTELPROC) (GLint size, GLenum type, const void **pointer);
+typedef void (APIENTRYP PFNGLNORMALPOINTERVINTELPROC) (GLenum type, const void **pointer);
+typedef void (APIENTRYP PFNGLCOLORPOINTERVINTELPROC) (GLint size, GLenum type, const void **pointer);
+typedef void (APIENTRYP PFNGLTEXCOORDPOINTERVINTELPROC) (GLint size, GLenum type, const void **pointer);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glVertexPointervINTEL (GLint size, GLenum type, const GLvoid **pointer);
-GLAPI void APIENTRY glNormalPointervINTEL (GLenum type, const GLvoid **pointer);
-GLAPI void APIENTRY glColorPointervINTEL (GLint size, GLenum type, const GLvoid **pointer);
-GLAPI void APIENTRY glTexCoordPointervINTEL (GLint size, GLenum type, const GLvoid **pointer);
+GLAPI void APIENTRY glVertexPointervINTEL (GLint size, GLenum type, const void **pointer);
+GLAPI void APIENTRY glNormalPointervINTEL (GLenum type, const void **pointer);
+GLAPI void APIENTRY glColorPointervINTEL (GLint size, GLenum type, const void **pointer);
+GLAPI void APIENTRY glTexCoordPointervINTEL (GLint size, GLenum type, const void **pointer);
 #endif
 #endif /* GL_INTEL_parallel_arrays */
 
@@ -7995,6 +8170,16 @@ GLAPI void APIENTRY glEndConditionalRenderNVX (void);
 #endif
 #endif /* GL_NVX_conditional_render */
 
+#ifndef GL_NV_bindless_multi_draw_indirect
+#define GL_NV_bindless_multi_draw_indirect 1
+typedef void (APIENTRYP PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC) (GLenum mode, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
+typedef void (APIENTRYP PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glMultiDrawArraysIndirectBindlessNV (GLenum mode, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
+GLAPI void APIENTRY glMultiDrawElementsIndirectBindlessNV (GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
+#endif
+#endif /* GL_NV_bindless_multi_draw_indirect */
+
 #ifndef GL_NV_bindless_texture
 #define GL_NV_bindless_texture 1
 typedef GLuint64 (APIENTRYP PFNGLGETTEXTUREHANDLENVPROC) (GLuint texture);
@@ -8027,6 +8212,66 @@ GLAPI GLboolean APIENTRY glIsImageHandleResidentNV (GLuint64 handle);
 #endif
 #endif /* GL_NV_bindless_texture */
 
+#ifndef GL_NV_blend_equation_advanced
+#define GL_NV_blend_equation_advanced 1
+#define GL_BLEND_ADVANCED_COHERENT_NV     0x9285
+#define GL_BLEND_OVERLAP_NV               0x9281
+#define GL_BLEND_PREMULTIPLIED_SRC_NV     0x9280
+#define GL_COLORBURN_NV                   0x929A
+#define GL_COLORDODGE_NV                  0x9299
+#define GL_CONJOINT_NV                    0x9284
+#define GL_CONTRAST_NV                    0x92A1
+#define GL_DARKEN_NV                      0x9297
+#define GL_DIFFERENCE_NV                  0x929E
+#define GL_DISJOINT_NV                    0x9283
+#define GL_DST_ATOP_NV                    0x928F
+#define GL_DST_IN_NV                      0x928B
+#define GL_DST_NV                         0x9287
+#define GL_DST_OUT_NV                     0x928D
+#define GL_DST_OVER_NV                    0x9289
+#define GL_EXCLUSION_NV                   0x92A0
+#define GL_HARDLIGHT_NV                   0x929B
+#define GL_HARDMIX_NV                     0x92A9
+#define GL_HSL_COLOR_NV                   0x92AF
+#define GL_HSL_HUE_NV                     0x92AD
+#define GL_HSL_LUMINOSITY_NV              0x92B0
+#define GL_HSL_SATURATION_NV              0x92AE
+#define GL_INVERT_OVG_NV                  0x92B4
+#define GL_INVERT_RGB_NV                  0x92A3
+#define GL_LIGHTEN_NV                     0x9298
+#define GL_LINEARBURN_NV                  0x92A5
+#define GL_LINEARDODGE_NV                 0x92A4
+#define GL_LINEARLIGHT_NV                 0x92A7
+#define GL_MINUS_CLAMPED_NV               0x92B3
+#define GL_MINUS_NV                       0x929F
+#define GL_MULTIPLY_NV                    0x9294
+#define GL_OVERLAY_NV                     0x9296
+#define GL_PINLIGHT_NV                    0x92A8
+#define GL_PLUS_CLAMPED_ALPHA_NV          0x92B2
+#define GL_PLUS_CLAMPED_NV                0x92B1
+#define GL_PLUS_DARKER_NV                 0x9292
+#define GL_PLUS_NV                        0x9291
+#define GL_SCREEN_NV                      0x9295
+#define GL_SOFTLIGHT_NV                   0x929C
+#define GL_SRC_ATOP_NV                    0x928E
+#define GL_SRC_IN_NV                      0x928A
+#define GL_SRC_NV                         0x9286
+#define GL_SRC_OUT_NV                     0x928C
+#define GL_SRC_OVER_NV                    0x9288
+#define GL_UNCORRELATED_NV                0x9282
+#define GL_VIVIDLIGHT_NV                  0x92A6
+typedef void (APIENTRYP PFNGLBLENDPARAMETERINVPROC) (GLenum pname, GLint value);
+typedef void (APIENTRYP PFNGLBLENDBARRIERNVPROC) (void);
+#ifdef GL_GLEXT_PROTOTYPES
+GLAPI void APIENTRY glBlendParameteriNV (GLenum pname, GLint value);
+GLAPI void APIENTRY glBlendBarrierNV (void);
+#endif
+#endif /* GL_NV_blend_equation_advanced */
+
+#ifndef GL_NV_blend_equation_advanced_coherent
+#define GL_NV_blend_equation_advanced_coherent 1
+#endif /* GL_NV_blend_equation_advanced_coherent */
+
 #ifndef GL_NV_blend_square
 #define GL_NV_blend_square 1
 #endif /* GL_NV_blend_square */
@@ -8126,20 +8371,20 @@ GLAPI void APIENTRY glDrawTextureNV (GLuint texture, GLuint sampler, GLfloat x0,
 #define GL_EVAL_VERTEX_ATTRIB15_NV        0x86D5
 #define GL_MAX_MAP_TESSELLATION_NV        0x86D6
 #define GL_MAX_RATIONAL_EVAL_ORDER_NV     0x86D7
-typedef void (APIENTRYP PFNGLMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points);
+typedef void (APIENTRYP PFNGLMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void *points);
 typedef void (APIENTRYP PFNGLMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, const GLint *params);
 typedef void (APIENTRYP PFNGLMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, const GLfloat *params);
-typedef void (APIENTRYP PFNGLGETMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *points);
+typedef void (APIENTRYP PFNGLGETMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void *points);
 typedef void (APIENTRYP PFNGLGETMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, GLint *params);
 typedef void (APIENTRYP PFNGLGETMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETMAPATTRIBPARAMETERIVNVPROC) (GLenum target, GLuint index, GLenum pname, GLint *params);
 typedef void (APIENTRYP PFNGLGETMAPATTRIBPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLEVALMAPSNVPROC) (GLenum target, GLenum mode);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glMapControlPointsNV (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid *points);
+GLAPI void APIENTRY glMapControlPointsNV (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void *points);
 GLAPI void APIENTRY glMapParameterivNV (GLenum target, GLenum pname, const GLint *params);
 GLAPI void APIENTRY glMapParameterfvNV (GLenum target, GLenum pname, const GLfloat *params);
-GLAPI void APIENTRY glGetMapControlPointsNV (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid *points);
+GLAPI void APIENTRY glGetMapControlPointsNV (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void *points);
 GLAPI void APIENTRY glGetMapParameterivNV (GLenum target, GLenum pname, GLint *params);
 GLAPI void APIENTRY glGetMapParameterfvNV (GLenum target, GLenum pname, GLfloat *params);
 GLAPI void APIENTRY glGetMapAttribParameterivNV (GLenum target, GLuint index, GLenum pname, GLint *params);
@@ -8357,10 +8602,13 @@ GLAPI void APIENTRY glGetProgramSubroutineParameteruivNV (GLenum target, GLuint
 #endif
 #endif /* GL_NV_gpu_program5 */
 
+#ifndef GL_NV_gpu_program5_mem_extended
+#define GL_NV_gpu_program5_mem_extended 1
+#endif /* GL_NV_gpu_program5_mem_extended */
+
 #ifndef GL_NV_gpu_shader5
 #define GL_NV_gpu_shader5 1
 typedef int64_t GLint64EXT;
-typedef uint64_t GLuint64EXT;
 #define GL_INT64_NV                       0x140E
 #define GL_UNSIGNED_INT64_NV              0x140F
 #define GL_INT8_NV                        0x8FE0
@@ -8760,13 +9008,13 @@ GLAPI void APIENTRY glProgramBufferParametersIuivNV (GLenum target, GLuint bindi
 typedef GLuint (APIENTRYP PFNGLGENPATHSNVPROC) (GLsizei range);
 typedef void (APIENTRYP PFNGLDELETEPATHSNVPROC) (GLuint path, GLsizei range);
 typedef GLboolean (APIENTRYP PFNGLISPATHNVPROC) (GLuint path);
-typedef void (APIENTRYP PFNGLPATHCOMMANDSNVPROC) (GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords);
-typedef void (APIENTRYP PFNGLPATHCOORDSNVPROC) (GLuint path, GLsizei numCoords, GLenum coordType, const GLvoid *coords);
-typedef void (APIENTRYP PFNGLPATHSUBCOMMANDSNVPROC) (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords);
-typedef void (APIENTRYP PFNGLPATHSUBCOORDSNVPROC) (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const GLvoid *coords);
-typedef void (APIENTRYP PFNGLPATHSTRINGNVPROC) (GLuint path, GLenum format, GLsizei length, const GLvoid *pathString);
-typedef void (APIENTRYP PFNGLPATHGLYPHSNVPROC) (GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
-typedef void (APIENTRYP PFNGLPATHGLYPHRANGENVPROC) (GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
+typedef void (APIENTRYP PFNGLPATHCOMMANDSNVPROC) (GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords);
+typedef void (APIENTRYP PFNGLPATHCOORDSNVPROC) (GLuint path, GLsizei numCoords, GLenum coordType, const void *coords);
+typedef void (APIENTRYP PFNGLPATHSUBCOMMANDSNVPROC) (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords);
+typedef void (APIENTRYP PFNGLPATHSUBCOORDSNVPROC) (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void *coords);
+typedef void (APIENTRYP PFNGLPATHSTRINGNVPROC) (GLuint path, GLenum format, GLsizei length, const void *pathString);
+typedef void (APIENTRYP PFNGLPATHGLYPHSNVPROC) (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
+typedef void (APIENTRYP PFNGLPATHGLYPHRANGENVPROC) (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
 typedef void (APIENTRYP PFNGLWEIGHTPATHSNVPROC) (GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights);
 typedef void (APIENTRYP PFNGLCOPYPATHNVPROC) (GLuint resultPath, GLuint srcPath);
 typedef void (APIENTRYP PFNGLINTERPOLATEPATHSNVPROC) (GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);
@@ -8780,24 +9028,24 @@ typedef void (APIENTRYP PFNGLPATHSTENCILFUNCNVPROC) (GLenum func, GLint ref, GLu
 typedef void (APIENTRYP PFNGLPATHSTENCILDEPTHOFFSETNVPROC) (GLfloat factor, GLfloat units);
 typedef void (APIENTRYP PFNGLSTENCILFILLPATHNVPROC) (GLuint path, GLenum fillMode, GLuint mask);
 typedef void (APIENTRYP PFNGLSTENCILSTROKEPATHNVPROC) (GLuint path, GLint reference, GLuint mask);
-typedef void (APIENTRYP PFNGLSTENCILFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues);
-typedef void (APIENTRYP PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues);
+typedef void (APIENTRYP PFNGLSTENCILFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues);
+typedef void (APIENTRYP PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues);
 typedef void (APIENTRYP PFNGLPATHCOVERDEPTHFUNCNVPROC) (GLenum func);
 typedef void (APIENTRYP PFNGLPATHCOLORGENNVPROC) (GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat *coeffs);
 typedef void (APIENTRYP PFNGLPATHTEXGENNVPROC) (GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat *coeffs);
 typedef void (APIENTRYP PFNGLPATHFOGGENNVPROC) (GLenum genMode);
 typedef void (APIENTRYP PFNGLCOVERFILLPATHNVPROC) (GLuint path, GLenum coverMode);
 typedef void (APIENTRYP PFNGLCOVERSTROKEPATHNVPROC) (GLuint path, GLenum coverMode);
-typedef void (APIENTRYP PFNGLCOVERFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
-typedef void (APIENTRYP PFNGLCOVERSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
+typedef void (APIENTRYP PFNGLCOVERFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
+typedef void (APIENTRYP PFNGLCOVERSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
 typedef void (APIENTRYP PFNGLGETPATHPARAMETERIVNVPROC) (GLuint path, GLenum pname, GLint *value);
 typedef void (APIENTRYP PFNGLGETPATHPARAMETERFVNVPROC) (GLuint path, GLenum pname, GLfloat *value);
 typedef void (APIENTRYP PFNGLGETPATHCOMMANDSNVPROC) (GLuint path, GLubyte *commands);
 typedef void (APIENTRYP PFNGLGETPATHCOORDSNVPROC) (GLuint path, GLfloat *coords);
 typedef void (APIENTRYP PFNGLGETPATHDASHARRAYNVPROC) (GLuint path, GLfloat *dashArray);
-typedef void (APIENTRYP PFNGLGETPATHMETRICSNVPROC) (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics);
+typedef void (APIENTRYP PFNGLGETPATHMETRICSNVPROC) (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics);
 typedef void (APIENTRYP PFNGLGETPATHMETRICRANGENVPROC) (GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics);
-typedef void (APIENTRYP PFNGLGETPATHSPACINGNVPROC) (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing);
+typedef void (APIENTRYP PFNGLGETPATHSPACINGNVPROC) (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing);
 typedef void (APIENTRYP PFNGLGETPATHCOLORGENIVNVPROC) (GLenum color, GLenum pname, GLint *value);
 typedef void (APIENTRYP PFNGLGETPATHCOLORGENFVNVPROC) (GLenum color, GLenum pname, GLfloat *value);
 typedef void (APIENTRYP PFNGLGETPATHTEXGENIVNVPROC) (GLenum texCoordSet, GLenum pname, GLint *value);
@@ -8810,13 +9058,13 @@ typedef GLboolean (APIENTRYP PFNGLPOINTALONGPATHNVPROC) (GLuint path, GLsizei st
 GLAPI GLuint APIENTRY glGenPathsNV (GLsizei range);
 GLAPI void APIENTRY glDeletePathsNV (GLuint path, GLsizei range);
 GLAPI GLboolean APIENTRY glIsPathNV (GLuint path);
-GLAPI void APIENTRY glPathCommandsNV (GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords);
-GLAPI void APIENTRY glPathCoordsNV (GLuint path, GLsizei numCoords, GLenum coordType, const GLvoid *coords);
-GLAPI void APIENTRY glPathSubCommandsNV (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const GLvoid *coords);
-GLAPI void APIENTRY glPathSubCoordsNV (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const GLvoid *coords);
-GLAPI void APIENTRY glPathStringNV (GLuint path, GLenum format, GLsizei length, const GLvoid *pathString);
-GLAPI void APIENTRY glPathGlyphsNV (GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
-GLAPI void APIENTRY glPathGlyphRangeNV (GLuint firstPathName, GLenum fontTarget, const GLvoid *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
+GLAPI void APIENTRY glPathCommandsNV (GLuint path, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords);
+GLAPI void APIENTRY glPathCoordsNV (GLuint path, GLsizei numCoords, GLenum coordType, const void *coords);
+GLAPI void APIENTRY glPathSubCommandsNV (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte *commands, GLsizei numCoords, GLenum coordType, const void *coords);
+GLAPI void APIENTRY glPathSubCoordsNV (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void *coords);
+GLAPI void APIENTRY glPathStringNV (GLuint path, GLenum format, GLsizei length, const void *pathString);
+GLAPI void APIENTRY glPathGlyphsNV (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void *charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
+GLAPI void APIENTRY glPathGlyphRangeNV (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
 GLAPI void APIENTRY glWeightPathsNV (GLuint resultPath, GLsizei numPaths, const GLuint *paths, const GLfloat *weights);
 GLAPI void APIENTRY glCopyPathNV (GLuint resultPath, GLuint srcPath);
 GLAPI void APIENTRY glInterpolatePathsNV (GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);
@@ -8830,24 +9078,24 @@ GLAPI void APIENTRY glPathStencilFuncNV (GLenum func, GLint ref, GLuint mask);
 GLAPI void APIENTRY glPathStencilDepthOffsetNV (GLfloat factor, GLfloat units);
 GLAPI void APIENTRY glStencilFillPathNV (GLuint path, GLenum fillMode, GLuint mask);
 GLAPI void APIENTRY glStencilStrokePathNV (GLuint path, GLint reference, GLuint mask);
-GLAPI void APIENTRY glStencilFillPathInstancedNV (GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues);
-GLAPI void APIENTRY glStencilStrokePathInstancedNV (GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues);
+GLAPI void APIENTRY glStencilFillPathInstancedNV (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues);
+GLAPI void APIENTRY glStencilStrokePathInstancedNV (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues);
 GLAPI void APIENTRY glPathCoverDepthFuncNV (GLenum func);
 GLAPI void APIENTRY glPathColorGenNV (GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat *coeffs);
 GLAPI void APIENTRY glPathTexGenNV (GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat *coeffs);
 GLAPI void APIENTRY glPathFogGenNV (GLenum genMode);
 GLAPI void APIENTRY glCoverFillPathNV (GLuint path, GLenum coverMode);
 GLAPI void APIENTRY glCoverStrokePathNV (GLuint path, GLenum coverMode);
-GLAPI void APIENTRY glCoverFillPathInstancedNV (GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
-GLAPI void APIENTRY glCoverStrokePathInstancedNV (GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
+GLAPI void APIENTRY glCoverFillPathInstancedNV (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
+GLAPI void APIENTRY glCoverStrokePathInstancedNV (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
 GLAPI void APIENTRY glGetPathParameterivNV (GLuint path, GLenum pname, GLint *value);
 GLAPI void APIENTRY glGetPathParameterfvNV (GLuint path, GLenum pname, GLfloat *value);
 GLAPI void APIENTRY glGetPathCommandsNV (GLuint path, GLubyte *commands);
 GLAPI void APIENTRY glGetPathCoordsNV (GLuint path, GLfloat *coords);
 GLAPI void APIENTRY glGetPathDashArrayNV (GLuint path, GLfloat *dashArray);
-GLAPI void APIENTRY glGetPathMetricsNV (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics);
+GLAPI void APIENTRY glGetPathMetricsNV (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics);
 GLAPI void APIENTRY glGetPathMetricRangeNV (GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat *metrics);
-GLAPI void APIENTRY glGetPathSpacingNV (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const GLvoid *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing);
+GLAPI void APIENTRY glGetPathSpacingNV (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing);
 GLAPI void APIENTRY glGetPathColorGenivNV (GLenum color, GLenum pname, GLint *value);
 GLAPI void APIENTRY glGetPathColorGenfvNV (GLenum color, GLenum pname, GLfloat *value);
 GLAPI void APIENTRY glGetPathTexGenivNV (GLenum texCoordSet, GLenum pname, GLint *value);
@@ -8867,10 +9115,10 @@ GLAPI GLboolean APIENTRY glPointAlongPathNV (GLuint path, GLsizei startSegment,
 #define GL_READ_PIXEL_DATA_RANGE_LENGTH_NV 0x887B
 #define GL_WRITE_PIXEL_DATA_RANGE_POINTER_NV 0x887C
 #define GL_READ_PIXEL_DATA_RANGE_POINTER_NV 0x887D
-typedef void (APIENTRYP PFNGLPIXELDATARANGENVPROC) (GLenum target, GLsizei length, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLPIXELDATARANGENVPROC) (GLenum target, GLsizei length, const void *pointer);
 typedef void (APIENTRYP PFNGLFLUSHPIXELDATARANGENVPROC) (GLenum target);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glPixelDataRangeNV (GLenum target, GLsizei length, const GLvoid *pointer);
+GLAPI void APIENTRY glPixelDataRangeNV (GLenum target, GLsizei length, const void *pointer);
 GLAPI void APIENTRY glFlushPixelDataRangeNV (GLenum target);
 #endif
 #endif /* GL_NV_pixel_data_range */
@@ -9341,10 +9589,10 @@ typedef GLintptr GLvdpauSurfaceNV;
 #define GL_SURFACE_REGISTERED_NV          0x86FD
 #define GL_SURFACE_MAPPED_NV              0x8700
 #define GL_WRITE_DISCARD_NV               0x88BE
-typedef void (APIENTRYP PFNGLVDPAUINITNVPROC) (const GLvoid *vdpDevice, const GLvoid *getProcAddress);
+typedef void (APIENTRYP PFNGLVDPAUINITNVPROC) (const void *vdpDevice, const void *getProcAddress);
 typedef void (APIENTRYP PFNGLVDPAUFININVPROC) (void);
-typedef GLvdpauSurfaceNV (APIENTRYP PFNGLVDPAUREGISTERVIDEOSURFACENVPROC) (const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
-typedef GLvdpauSurfaceNV (APIENTRYP PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC) (const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
+typedef GLvdpauSurfaceNV (APIENTRYP PFNGLVDPAUREGISTERVIDEOSURFACENVPROC) (const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
+typedef GLvdpauSurfaceNV (APIENTRYP PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC) (const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
 typedef void (APIENTRYP PFNGLVDPAUISSURFACENVPROC) (GLvdpauSurfaceNV surface);
 typedef void (APIENTRYP PFNGLVDPAUUNREGISTERSURFACENVPROC) (GLvdpauSurfaceNV surface);
 typedef void (APIENTRYP PFNGLVDPAUGETSURFACEIVNVPROC) (GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
@@ -9352,10 +9600,10 @@ typedef void (APIENTRYP PFNGLVDPAUSURFACEACCESSNVPROC) (GLvdpauSurfaceNV surface
 typedef void (APIENTRYP PFNGLVDPAUMAPSURFACESNVPROC) (GLsizei numSurfaces, const GLvdpauSurfaceNV *surfaces);
 typedef void (APIENTRYP PFNGLVDPAUUNMAPSURFACESNVPROC) (GLsizei numSurface, const GLvdpauSurfaceNV *surfaces);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glVDPAUInitNV (const GLvoid *vdpDevice, const GLvoid *getProcAddress);
+GLAPI void APIENTRY glVDPAUInitNV (const void *vdpDevice, const void *getProcAddress);
 GLAPI void APIENTRY glVDPAUFiniNV (void);
-GLAPI GLvdpauSurfaceNV APIENTRY glVDPAURegisterVideoSurfaceNV (const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
-GLAPI GLvdpauSurfaceNV APIENTRY glVDPAURegisterOutputSurfaceNV (const GLvoid *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
+GLAPI GLvdpauSurfaceNV APIENTRY glVDPAURegisterVideoSurfaceNV (const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
+GLAPI GLvdpauSurfaceNV APIENTRY glVDPAURegisterOutputSurfaceNV (const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
 GLAPI void APIENTRY glVDPAUIsSurfaceNV (GLvdpauSurfaceNV surface);
 GLAPI void APIENTRY glVDPAUUnregisterSurfaceNV (GLvdpauSurfaceNV surface);
 GLAPI void APIENTRY glVDPAUGetSurfaceivNV (GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
@@ -9373,10 +9621,10 @@ GLAPI void APIENTRY glVDPAUUnmapSurfacesNV (GLsizei numSurface, const GLvdpauSur
 #define GL_MAX_VERTEX_ARRAY_RANGE_ELEMENT_NV 0x8520
 #define GL_VERTEX_ARRAY_RANGE_POINTER_NV  0x8521
 typedef void (APIENTRYP PFNGLFLUSHVERTEXARRAYRANGENVPROC) (void);
-typedef void (APIENTRYP PFNGLVERTEXARRAYRANGENVPROC) (GLsizei length, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLVERTEXARRAYRANGENVPROC) (GLsizei length, const void *pointer);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glFlushVertexArrayRangeNV (void);
-GLAPI void APIENTRY glVertexArrayRangeNV (GLsizei length, const GLvoid *pointer);
+GLAPI void APIENTRY glVertexArrayRangeNV (GLsizei length, const void *pointer);
 #endif
 #endif /* GL_NV_vertex_array_range */
 
@@ -9582,7 +9830,7 @@ typedef void (APIENTRYP PFNGLGETTRACKMATRIXIVNVPROC) (GLenum target, GLuint addr
 typedef void (APIENTRYP PFNGLGETVERTEXATTRIBDVNVPROC) (GLuint index, GLenum pname, GLdouble *params);
 typedef void (APIENTRYP PFNGLGETVERTEXATTRIBFVNVPROC) (GLuint index, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIVNVPROC) (GLuint index, GLenum pname, GLint *params);
-typedef void (APIENTRYP PFNGLGETVERTEXATTRIBPOINTERVNVPROC) (GLuint index, GLenum pname, GLvoid **pointer);
+typedef void (APIENTRYP PFNGLGETVERTEXATTRIBPOINTERVNVPROC) (GLuint index, GLenum pname, void **pointer);
 typedef GLboolean (APIENTRYP PFNGLISPROGRAMNVPROC) (GLuint id);
 typedef void (APIENTRYP PFNGLLOADPROGRAMNVPROC) (GLenum target, GLuint id, GLsizei len, const GLubyte *program);
 typedef void (APIENTRYP PFNGLPROGRAMPARAMETER4DNVPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
@@ -9593,7 +9841,7 @@ typedef void (APIENTRYP PFNGLPROGRAMPARAMETERS4DVNVPROC) (GLenum target, GLuint
 typedef void (APIENTRYP PFNGLPROGRAMPARAMETERS4FVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat *v);
 typedef void (APIENTRYP PFNGLREQUESTRESIDENTPROGRAMSNVPROC) (GLsizei n, const GLuint *programs);
 typedef void (APIENTRYP PFNGLTRACKMATRIXNVPROC) (GLenum target, GLuint address, GLenum matrix, GLenum transform);
-typedef void (APIENTRYP PFNGLVERTEXATTRIBPOINTERNVPROC) (GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBPOINTERNVPROC) (GLuint index, GLint fsize, GLenum type, GLsizei stride, const void *pointer);
 typedef void (APIENTRYP PFNGLVERTEXATTRIB1DNVPROC) (GLuint index, GLdouble x);
 typedef void (APIENTRYP PFNGLVERTEXATTRIB1DVNVPROC) (GLuint index, const GLdouble *v);
 typedef void (APIENTRYP PFNGLVERTEXATTRIB1FNVPROC) (GLuint index, GLfloat x);
@@ -9647,7 +9895,7 @@ GLAPI void APIENTRY glGetTrackMatrixivNV (GLenum target, GLuint address, GLenum
 GLAPI void APIENTRY glGetVertexAttribdvNV (GLuint index, GLenum pname, GLdouble *params);
 GLAPI void APIENTRY glGetVertexAttribfvNV (GLuint index, GLenum pname, GLfloat *params);
 GLAPI void APIENTRY glGetVertexAttribivNV (GLuint index, GLenum pname, GLint *params);
-GLAPI void APIENTRY glGetVertexAttribPointervNV (GLuint index, GLenum pname, GLvoid **pointer);
+GLAPI void APIENTRY glGetVertexAttribPointervNV (GLuint index, GLenum pname, void **pointer);
 GLAPI GLboolean APIENTRY glIsProgramNV (GLuint id);
 GLAPI void APIENTRY glLoadProgramNV (GLenum target, GLuint id, GLsizei len, const GLubyte *program);
 GLAPI void APIENTRY glProgramParameter4dNV (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
@@ -9658,7 +9906,7 @@ GLAPI void APIENTRY glProgramParameters4dvNV (GLenum target, GLuint index, GLsiz
 GLAPI void APIENTRY glProgramParameters4fvNV (GLenum target, GLuint index, GLsizei count, const GLfloat *v);
 GLAPI void APIENTRY glRequestResidentProgramsNV (GLsizei n, const GLuint *programs);
 GLAPI void APIENTRY glTrackMatrixNV (GLenum target, GLuint address, GLenum matrix, GLenum transform);
-GLAPI void APIENTRY glVertexAttribPointerNV (GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid *pointer);
+GLAPI void APIENTRY glVertexAttribPointerNV (GLuint index, GLint fsize, GLenum type, GLsizei stride, const void *pointer);
 GLAPI void APIENTRY glVertexAttrib1dNV (GLuint index, GLdouble x);
 GLAPI void APIENTRY glVertexAttrib1dvNV (GLuint index, const GLdouble *v);
 GLAPI void APIENTRY glVertexAttrib1fNV (GLuint index, GLfloat x);
@@ -9740,7 +9988,7 @@ typedef void (APIENTRYP PFNGLVERTEXATTRIBI4BVEXTPROC) (GLuint index, const GLbyt
 typedef void (APIENTRYP PFNGLVERTEXATTRIBI4SVEXTPROC) (GLuint index, const GLshort *v);
 typedef void (APIENTRYP PFNGLVERTEXATTRIBI4UBVEXTPROC) (GLuint index, const GLubyte *v);
 typedef void (APIENTRYP PFNGLVERTEXATTRIBI4USVEXTPROC) (GLuint index, const GLushort *v);
-typedef void (APIENTRYP PFNGLVERTEXATTRIBIPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+typedef void (APIENTRYP PFNGLVERTEXATTRIBIPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
 typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIIVEXTPROC) (GLuint index, GLenum pname, GLint *params);
 typedef void (APIENTRYP PFNGLGETVERTEXATTRIBIUIVEXTPROC) (GLuint index, GLenum pname, GLuint *params);
 #ifdef GL_GLEXT_PROTOTYPES
@@ -9764,7 +10012,7 @@ GLAPI void APIENTRY glVertexAttribI4bvEXT (GLuint index, const GLbyte *v);
 GLAPI void APIENTRY glVertexAttribI4svEXT (GLuint index, const GLshort *v);
 GLAPI void APIENTRY glVertexAttribI4ubvEXT (GLuint index, const GLubyte *v);
 GLAPI void APIENTRY glVertexAttribI4usvEXT (GLuint index, const GLushort *v);
-GLAPI void APIENTRY glVertexAttribIPointerEXT (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
+GLAPI void APIENTRY glVertexAttribIPointerEXT (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
 GLAPI void APIENTRY glGetVertexAttribIivEXT (GLuint index, GLenum pname, GLint *params);
 GLAPI void APIENTRY glGetVertexAttribIuivEXT (GLuint index, GLenum pname, GLuint *params);
 #endif
@@ -10058,11 +10306,11 @@ GLAPI void APIENTRY glGetSharpenTexFuncSGIS (GLenum target, GLfloat *points);
 #define GL_TEXTURE_WRAP_Q_SGIS            0x8137
 #define GL_MAX_4D_TEXTURE_SIZE_SGIS       0x8138
 #define GL_TEXTURE_4D_BINDING_SGIS        0x814F
-typedef void (APIENTRYP PFNGLTEXIMAGE4DSGISPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-typedef void (APIENTRYP PFNGLTEXSUBIMAGE4DSGISPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels);
+typedef void (APIENTRYP PFNGLTEXIMAGE4DSGISPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const void *pixels);
+typedef void (APIENTRYP PFNGLTEXSUBIMAGE4DSGISPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const void *pixels);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glTexImage4DSGIS (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
-GLAPI void APIENTRY glTexSubImage4DSGIS (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid *pixels);
+GLAPI void APIENTRY glTexImage4DSGIS (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const void *pixels);
+GLAPI void APIENTRY glTexSubImage4DSGIS (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const void *pixels);
 #endif
 #endif /* GL_SGIS_texture4D */
 
@@ -10298,9 +10546,9 @@ GLAPI void APIENTRY glFrameZoomSGIX (GLint factor);
 
 #ifndef GL_SGIX_igloo_interface
 #define GL_SGIX_igloo_interface 1
-typedef void (APIENTRYP PFNGLIGLOOINTERFACESGIXPROC) (GLenum pname, const GLvoid *params);
+typedef void (APIENTRYP PFNGLIGLOOINTERFACESGIXPROC) (GLenum pname, const void *params);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glIglooInterfaceSGIX (GLenum pname, const GLvoid *params);
+GLAPI void APIENTRY glIglooInterfaceSGIX (GLenum pname, const void *params);
 #endif
 #endif /* GL_SGIX_igloo_interface */
 
@@ -10557,19 +10805,19 @@ GLAPI void APIENTRY glTagSampleBufferSGIX (void);
 #define GL_COLOR_TABLE_ALPHA_SIZE_SGI     0x80DD
 #define GL_COLOR_TABLE_LUMINANCE_SIZE_SGI 0x80DE
 #define GL_COLOR_TABLE_INTENSITY_SIZE_SGI 0x80DF
-typedef void (APIENTRYP PFNGLCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
+typedef void (APIENTRYP PFNGLCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
 typedef void (APIENTRYP PFNGLCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat *params);
 typedef void (APIENTRYP PFNGLCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint *params);
 typedef void (APIENTRYP PFNGLCOPYCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
-typedef void (APIENTRYP PFNGLGETCOLORTABLESGIPROC) (GLenum target, GLenum format, GLenum type, GLvoid *table);
+typedef void (APIENTRYP PFNGLGETCOLORTABLESGIPROC) (GLenum target, GLenum format, GLenum type, void *table);
 typedef void (APIENTRYP PFNGLGETCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat *params);
 typedef void (APIENTRYP PFNGLGETCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint *params);
 #ifdef GL_GLEXT_PROTOTYPES
-GLAPI void APIENTRY glColorTableSGI (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
+GLAPI void APIENTRY glColorTableSGI (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
 GLAPI void APIENTRY glColorTableParameterfvSGI (GLenum target, GLenum pname, const GLfloat *params);
 GLAPI void APIENTRY glColorTableParameterivSGI (GLenum target, GLenum pname, const GLint *params);
 GLAPI void APIENTRY glCopyColorTableSGI (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
-GLAPI void APIENTRY glGetColorTableSGI (GLenum target, GLenum format, GLenum type, GLvoid *table);
+GLAPI void APIENTRY glGetColorTableSGI (GLenum target, GLenum format, GLenum type, void *table);
 GLAPI void APIENTRY glGetColorTableParameterfvSGI (GLenum target, GLenum pname, GLfloat *params);
 GLAPI void APIENTRY glGetColorTableParameterivSGI (GLenum target, GLenum pname, GLint *params);
 #endif
@@ -10660,7 +10908,7 @@ typedef void (APIENTRYP PFNGLREPLACEMENTCODEUBSUNPROC) (GLubyte code);
 typedef void (APIENTRYP PFNGLREPLACEMENTCODEUIVSUNPROC) (const GLuint *code);
 typedef void (APIENTRYP PFNGLREPLACEMENTCODEUSVSUNPROC) (const GLushort *code);
 typedef void (APIENTRYP PFNGLREPLACEMENTCODEUBVSUNPROC) (const GLubyte *code);
-typedef void (APIENTRYP PFNGLREPLACEMENTCODEPOINTERSUNPROC) (GLenum type, GLsizei stride, const GLvoid **pointer);
+typedef void (APIENTRYP PFNGLREPLACEMENTCODEPOINTERSUNPROC) (GLenum type, GLsizei stride, const void **pointer);
 #ifdef GL_GLEXT_PROTOTYPES
 GLAPI void APIENTRY glReplacementCodeuiSUN (GLuint code);
 GLAPI void APIENTRY glReplacementCodeusSUN (GLushort code);
@@ -10668,7 +10916,7 @@ GLAPI void APIENTRY glReplacementCodeubSUN (GLubyte code);
 GLAPI void APIENTRY glReplacementCodeuivSUN (const GLuint *code);
 GLAPI void APIENTRY glReplacementCodeusvSUN (const GLushort *code);
 GLAPI void APIENTRY glReplacementCodeubvSUN (const GLubyte *code);
-GLAPI void APIENTRY glReplacementCodePointerSUN (GLenum type, GLsizei stride, const GLvoid **pointer);
+GLAPI void APIENTRY glReplacementCodePointerSUN (GLenum type, GLsizei stride, const void **pointer);
 #endif
 #endif /* GL_SUN_triangle_list */
 
diff --git a/include/GL/glx.h b/include/GL/glx.h
index 87c31fd..fa5a8ed 100644
--- a/include/GL/glx.h
+++ b/include/GL/glx.h
@@ -168,7 +168,6 @@ typedef XID GLXDrawable;
 /* GLX 1.3 and later */
 typedef struct __GLXFBConfigRec *GLXFBConfig;
 typedef XID GLXFBConfigID;
-typedef XID GLXContextID;
 typedef XID GLXWindow;
 typedef XID GLXPbuffer;
 
diff --git a/include/GL/glxext.h b/include/GL/glxext.h
index e640ff7..cfabe8c 100644
--- a/include/GL/glxext.h
+++ b/include/GL/glxext.h
@@ -1,13 +1,13 @@
 #ifndef __glxext_h_
-#define __glxext_h_
+#define __glxext_h_ 1
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 /*
-** Copyright (c) 2007-2012 The Khronos Group Inc.
-** 
+** Copyright (c) 2013 The Khronos Group Inc.
+**
 ** Permission is hereby granted, free of charge, to any person obtaining a
 ** copy of this software and/or associated documentation files (the
 ** "Materials"), to deal in the Materials without restriction, including
@@ -15,10 +15,10 @@ extern "C" {
 ** distribute, sublicense, and/or sell copies of the Materials, and to
 ** permit persons to whom the Materials are furnished to do so, subject to
 ** the following conditions:
-** 
+**
 ** The above copyright notice and this permission notice shall be included
 ** in all copies or substantial portions of the Materials.
-** 
+**
 ** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 ** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 ** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
@@ -27,464 +27,511 @@ extern "C" {
 ** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 ** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
 */
+/*
+** This header is generated from the Khronos OpenGL / OpenGL ES XML
+** API Registry. The current version of the Registry, generator scripts
+** used to make the header, and the header can be found at
+**   http://www.opengl.org/registry/
+**
+** Khronos $Revision: 23422 $ on $Date: 2013-10-08 15:40:45 -0700 (Tue, 08 Oct 2013) $
+*/
 
-/* Function declaration macros - to move into glplatform.h */
-
-#if defined(_WIN32) && !defined(APIENTRY) && !defined(__CYGWIN__) && !defined(__SCITECH_SNAP__)
-#define WIN32_LEAN_AND_MEAN 1
-#include <windows.h>
-#endif
-
-#ifndef APIENTRY
-#define APIENTRY
-#endif
-#ifndef APIENTRYP
-#define APIENTRYP APIENTRY *
-#endif
-#ifndef GLAPI
-#define GLAPI extern
-#endif
-
-/*************************************************************/
+#define GLX_GLXEXT_VERSION 20131008
 
-/* Header file version number, required by OpenGL ABI for Linux */
-/* glxext.h last updated 2012/02/29 */
-/* Current version at http://www.opengl.org/registry/ */
-#define GLX_GLXEXT_VERSION 33
+/* Generated C header for:
+ * API: glx
+ * Versions considered: .*
+ * Versions emitted: 1\.[3-9]
+ * Default extensions included: glx
+ * Additional extensions included: _nomatch_^
+ * Extensions removed: _nomatch_^
+ */
 
 #ifndef GLX_VERSION_1_3
-#define GLX_WINDOW_BIT                     0x00000001
-#define GLX_PIXMAP_BIT                     0x00000002
-#define GLX_PBUFFER_BIT                    0x00000004
-#define GLX_RGBA_BIT                       0x00000001
-#define GLX_COLOR_INDEX_BIT                0x00000002
-#define GLX_PBUFFER_CLOBBER_MASK           0x08000000
-#define GLX_FRONT_LEFT_BUFFER_BIT          0x00000001
-#define GLX_FRONT_RIGHT_BUFFER_BIT         0x00000002
-#define GLX_BACK_LEFT_BUFFER_BIT           0x00000004
-#define GLX_BACK_RIGHT_BUFFER_BIT          0x00000008
-#define GLX_AUX_BUFFERS_BIT                0x00000010
-#define GLX_DEPTH_BUFFER_BIT               0x00000020
-#define GLX_STENCIL_BUFFER_BIT             0x00000040
-#define GLX_ACCUM_BUFFER_BIT               0x00000080
-#define GLX_CONFIG_CAVEAT                  0x20
-#define GLX_X_VISUAL_TYPE                  0x22
-#define GLX_TRANSPARENT_TYPE               0x23
-#define GLX_TRANSPARENT_INDEX_VALUE        0x24
-#define GLX_TRANSPARENT_RED_VALUE          0x25
-#define GLX_TRANSPARENT_GREEN_VALUE        0x26
-#define GLX_TRANSPARENT_BLUE_VALUE         0x27
-#define GLX_TRANSPARENT_ALPHA_VALUE        0x28
-#define GLX_DONT_CARE                      0xFFFFFFFF
-#define GLX_NONE                           0x8000
-#define GLX_SLOW_CONFIG                    0x8001
-#define GLX_TRUE_COLOR                     0x8002
-#define GLX_DIRECT_COLOR                   0x8003
-#define GLX_PSEUDO_COLOR                   0x8004
-#define GLX_STATIC_COLOR                   0x8005
-#define GLX_GRAY_SCALE                     0x8006
-#define GLX_STATIC_GRAY                    0x8007
-#define GLX_TRANSPARENT_RGB                0x8008
-#define GLX_TRANSPARENT_INDEX              0x8009
-#define GLX_VISUAL_ID                      0x800B
-#define GLX_SCREEN                         0x800C
-#define GLX_NON_CONFORMANT_CONFIG          0x800D
-#define GLX_DRAWABLE_TYPE                  0x8010
-#define GLX_RENDER_TYPE                    0x8011
-#define GLX_X_RENDERABLE                   0x8012
-#define GLX_FBCONFIG_ID                    0x8013
-#define GLX_RGBA_TYPE                      0x8014
-#define GLX_COLOR_INDEX_TYPE               0x8015
-#define GLX_MAX_PBUFFER_WIDTH              0x8016
-#define GLX_MAX_PBUFFER_HEIGHT             0x8017
-#define GLX_MAX_PBUFFER_PIXELS             0x8018
-#define GLX_PRESERVED_CONTENTS             0x801B
-#define GLX_LARGEST_PBUFFER                0x801C
-#define GLX_WIDTH                          0x801D
-#define GLX_HEIGHT                         0x801E
-#define GLX_EVENT_MASK                     0x801F
-#define GLX_DAMAGED                        0x8020
-#define GLX_SAVED                          0x8021
-#define GLX_WINDOW                         0x8022
-#define GLX_PBUFFER                        0x8023
-#define GLX_PBUFFER_HEIGHT                 0x8040
-#define GLX_PBUFFER_WIDTH                  0x8041
-#endif
+#define GLX_VERSION_1_3 1
+typedef struct __GLXFBConfigRec *GLXFBConfig;
+typedef XID GLXWindow;
+typedef XID GLXPbuffer;
+#define GLX_WINDOW_BIT                    0x00000001
+#define GLX_PIXMAP_BIT                    0x00000002
+#define GLX_PBUFFER_BIT                   0x00000004
+#define GLX_RGBA_BIT                      0x00000001
+#define GLX_COLOR_INDEX_BIT               0x00000002
+#define GLX_PBUFFER_CLOBBER_MASK          0x08000000
+#define GLX_FRONT_LEFT_BUFFER_BIT         0x00000001
+#define GLX_FRONT_RIGHT_BUFFER_BIT        0x00000002
+#define GLX_BACK_LEFT_BUFFER_BIT          0x00000004
+#define GLX_BACK_RIGHT_BUFFER_BIT         0x00000008
+#define GLX_AUX_BUFFERS_BIT               0x00000010
+#define GLX_DEPTH_BUFFER_BIT              0x00000020
+#define GLX_STENCIL_BUFFER_BIT            0x00000040
+#define GLX_ACCUM_BUFFER_BIT              0x00000080
+#define GLX_CONFIG_CAVEAT                 0x20
+#define GLX_X_VISUAL_TYPE                 0x22
+#define GLX_TRANSPARENT_TYPE              0x23
+#define GLX_TRANSPARENT_INDEX_VALUE       0x24
+#define GLX_TRANSPARENT_RED_VALUE         0x25
+#define GLX_TRANSPARENT_GREEN_VALUE       0x26
+#define GLX_TRANSPARENT_BLUE_VALUE        0x27
+#define GLX_TRANSPARENT_ALPHA_VALUE       0x28
+#define GLX_DONT_CARE                     0xFFFFFFFF
+#define GLX_NONE                          0x8000
+#define GLX_SLOW_CONFIG                   0x8001
+#define GLX_TRUE_COLOR                    0x8002
+#define GLX_DIRECT_COLOR                  0x8003
+#define GLX_PSEUDO_COLOR                  0x8004
+#define GLX_STATIC_COLOR                  0x8005
+#define GLX_GRAY_SCALE                    0x8006
+#define GLX_STATIC_GRAY                   0x8007
+#define GLX_TRANSPARENT_RGB               0x8008
+#define GLX_TRANSPARENT_INDEX             0x8009
+#define GLX_VISUAL_ID                     0x800B
+#define GLX_SCREEN                        0x800C
+#define GLX_NON_CONFORMANT_CONFIG         0x800D
+#define GLX_DRAWABLE_TYPE                 0x8010
+#define GLX_RENDER_TYPE                   0x8011
+#define GLX_X_RENDERABLE                  0x8012
+#define GLX_FBCONFIG_ID                   0x8013
+#define GLX_RGBA_TYPE                     0x8014
+#define GLX_COLOR_INDEX_TYPE              0x8015
+#define GLX_MAX_PBUFFER_WIDTH             0x8016
+#define GLX_MAX_PBUFFER_HEIGHT            0x8017
+#define GLX_MAX_PBUFFER_PIXELS            0x8018
+#define GLX_PRESERVED_CONTENTS            0x801B
+#define GLX_LARGEST_PBUFFER               0x801C
+#define GLX_WIDTH                         0x801D
+#define GLX_HEIGHT                        0x801E
+#define GLX_EVENT_MASK                    0x801F
+#define GLX_DAMAGED                       0x8020
+#define GLX_SAVED                         0x8021
+#define GLX_WINDOW                        0x8022
+#define GLX_PBUFFER                       0x8023
+#define GLX_PBUFFER_HEIGHT                0x8040
+#define GLX_PBUFFER_WIDTH                 0x8041
+typedef GLXFBConfig *( *PFNGLXGETFBCONFIGSPROC) (Display *dpy, int screen, int *nelements);
+typedef GLXFBConfig *( *PFNGLXCHOOSEFBCONFIGPROC) (Display *dpy, int screen, const int *attrib_list, int *nelements);
+typedef int ( *PFNGLXGETFBCONFIGATTRIBPROC) (Display *dpy, GLXFBConfig config, int attribute, int *value);
+typedef XVisualInfo *( *PFNGLXGETVISUALFROMFBCONFIGPROC) (Display *dpy, GLXFBConfig config);
+typedef GLXWindow ( *PFNGLXCREATEWINDOWPROC) (Display *dpy, GLXFBConfig config, Window win, const int *attrib_list);
+typedef void ( *PFNGLXDESTROYWINDOWPROC) (Display *dpy, GLXWindow win);
+typedef GLXPixmap ( *PFNGLXCREATEPIXMAPPROC) (Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list);
+typedef void ( *PFNGLXDESTROYPIXMAPPROC) (Display *dpy, GLXPixmap pixmap);
+typedef GLXPbuffer ( *PFNGLXCREATEPBUFFERPROC) (Display *dpy, GLXFBConfig config, const int *attrib_list);
+typedef void ( *PFNGLXDESTROYPBUFFERPROC) (Display *dpy, GLXPbuffer pbuf);
+typedef void ( *PFNGLXQUERYDRAWABLEPROC) (Display *dpy, GLXDrawable draw, int attribute, unsigned int *value);
+typedef GLXContext ( *PFNGLXCREATENEWCONTEXTPROC) (Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct);
+typedef Bool ( *PFNGLXMAKECONTEXTCURRENTPROC) (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
+typedef GLXDrawable ( *PFNGLXGETCURRENTREADDRAWABLEPROC) (void);
+typedef int ( *PFNGLXQUERYCONTEXTPROC) (Display *dpy, GLXContext ctx, int attribute, int *value);
+typedef void ( *PFNGLXSELECTEVENTPROC) (Display *dpy, GLXDrawable draw, unsigned long event_mask);
+typedef void ( *PFNGLXGETSELECTEDEVENTPROC) (Display *dpy, GLXDrawable draw, unsigned long *event_mask);
+#ifdef GLX_GLXEXT_PROTOTYPES
+GLXFBConfig *glXGetFBConfigs (Display *dpy, int screen, int *nelements);
+GLXFBConfig *glXChooseFBConfig (Display *dpy, int screen, const int *attrib_list, int *nelements);
+int glXGetFBConfigAttrib (Display *dpy, GLXFBConfig config, int attribute, int *value);
+XVisualInfo *glXGetVisualFromFBConfig (Display *dpy, GLXFBConfig config);
+GLXWindow glXCreateWindow (Display *dpy, GLXFBConfig config, Window win, const int *attrib_list);
+void glXDestroyWindow (Display *dpy, GLXWindow win);
+GLXPixmap glXCreatePixmap (Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list);
+void glXDestroyPixmap (Display *dpy, GLXPixmap pixmap);
+GLXPbuffer glXCreatePbuffer (Display *dpy, GLXFBConfig config, const int *attrib_list);
+void glXDestroyPbuffer (Display *dpy, GLXPbuffer pbuf);
+void glXQueryDrawable (Display *dpy, GLXDrawable draw, int attribute, unsigned int *value);
+GLXContext glXCreateNewContext (Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct);
+Bool glXMakeContextCurrent (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
+GLXDrawable glXGetCurrentReadDrawable (void);
+int glXQueryContext (Display *dpy, GLXContext ctx, int attribute, int *value);
+void glXSelectEvent (Display *dpy, GLXDrawable draw, unsigned long event_mask);
+void glXGetSelectedEvent (Display *dpy, GLXDrawable draw, unsigned long *event_mask);
+#endif
+#endif /* GLX_VERSION_1_3 */
 
 #ifndef GLX_VERSION_1_4
-#define GLX_SAMPLE_BUFFERS                 100000
-#define GLX_SAMPLES                        100001
-#endif
-
-#ifndef GLX_ARB_get_proc_address
-#endif
-
-#ifndef GLX_ARB_multisample
-#define GLX_SAMPLE_BUFFERS_ARB             100000
-#define GLX_SAMPLES_ARB                    100001
-#endif
-
-#ifndef GLX_ARB_vertex_buffer_object
-#define GLX_CONTEXT_ALLOW_BUFFER_BYTE_ORDER_MISMATCH_ARB 0x2095
-#endif
-
-#ifndef GLX_ARB_fbconfig_float
-#define GLX_RGBA_FLOAT_TYPE_ARB            0x20B9
-#define GLX_RGBA_FLOAT_BIT_ARB             0x00000004
-#endif
-
-#ifndef GLX_ARB_framebuffer_sRGB
-#define GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB   0x20B2
+#define GLX_VERSION_1_4 1
+typedef void ( *__GLXextFuncPtr)(void);
+#define GLX_SAMPLE_BUFFERS                100000
+#define GLX_SAMPLES                       100001
+typedef __GLXextFuncPtr ( *PFNGLXGETPROCADDRESSPROC) (const GLubyte *procName);
+#ifdef GLX_GLXEXT_PROTOTYPES
+__GLXextFuncPtr glXGetProcAddress (const GLubyte *procName);
 #endif
+#endif /* GLX_VERSION_1_4 */
 
 #ifndef GLX_ARB_create_context
-#define GLX_CONTEXT_DEBUG_BIT_ARB          0x00000001
+#define GLX_ARB_create_context 1
+#define GLX_CONTEXT_DEBUG_BIT_ARB         0x00000001
 #define GLX_CONTEXT_FORWARD_COMPATIBLE_BIT_ARB 0x00000002
-#define GLX_CONTEXT_MAJOR_VERSION_ARB      0x2091
-#define GLX_CONTEXT_MINOR_VERSION_ARB      0x2092
-#define GLX_CONTEXT_FLAGS_ARB              0x2094
+#define GLX_CONTEXT_MAJOR_VERSION_ARB     0x2091
+#define GLX_CONTEXT_MINOR_VERSION_ARB     0x2092
+#define GLX_CONTEXT_FLAGS_ARB             0x2094
+typedef GLXContext ( *PFNGLXCREATECONTEXTATTRIBSARBPROC) (Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list);
+#ifdef GLX_GLXEXT_PROTOTYPES
+GLXContext glXCreateContextAttribsARB (Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list);
 #endif
+#endif /* GLX_ARB_create_context */
 
 #ifndef GLX_ARB_create_context_profile
-#define GLX_CONTEXT_CORE_PROFILE_BIT_ARB   0x00000001
+#define GLX_ARB_create_context_profile 1
+#define GLX_CONTEXT_CORE_PROFILE_BIT_ARB  0x00000001
 #define GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB 0x00000002
-#define GLX_CONTEXT_PROFILE_MASK_ARB       0x9126
-#endif
+#define GLX_CONTEXT_PROFILE_MASK_ARB      0x9126
+#endif /* GLX_ARB_create_context_profile */
 
 #ifndef GLX_ARB_create_context_robustness
-#define GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB  0x00000004
-#define GLX_LOSE_CONTEXT_ON_RESET_ARB      0x8252
+#define GLX_ARB_create_context_robustness 1
+#define GLX_CONTEXT_ROBUST_ACCESS_BIT_ARB 0x00000004
+#define GLX_LOSE_CONTEXT_ON_RESET_ARB     0x8252
 #define GLX_CONTEXT_RESET_NOTIFICATION_STRATEGY_ARB 0x8256
-#define GLX_NO_RESET_NOTIFICATION_ARB      0x8261
-#endif
+#define GLX_NO_RESET_NOTIFICATION_ARB     0x8261
+#endif /* GLX_ARB_create_context_robustness */
 
-#ifndef GLX_SGIS_multisample
-#define GLX_SAMPLE_BUFFERS_SGIS            100000
-#define GLX_SAMPLES_SGIS                   100001
-#endif
+#ifndef GLX_ARB_fbconfig_float
+#define GLX_ARB_fbconfig_float 1
+#define GLX_RGBA_FLOAT_TYPE_ARB           0x20B9
+#define GLX_RGBA_FLOAT_BIT_ARB            0x00000004
+#endif /* GLX_ARB_fbconfig_float */
 
-#ifndef GLX_EXT_visual_info
-#define GLX_X_VISUAL_TYPE_EXT              0x22
-#define GLX_TRANSPARENT_TYPE_EXT           0x23
-#define GLX_TRANSPARENT_INDEX_VALUE_EXT    0x24
-#define GLX_TRANSPARENT_RED_VALUE_EXT      0x25
-#define GLX_TRANSPARENT_GREEN_VALUE_EXT    0x26
-#define GLX_TRANSPARENT_BLUE_VALUE_EXT     0x27
-#define GLX_TRANSPARENT_ALPHA_VALUE_EXT    0x28
-#define GLX_NONE_EXT                       0x8000
-#define GLX_TRUE_COLOR_EXT                 0x8002
-#define GLX_DIRECT_COLOR_EXT               0x8003
-#define GLX_PSEUDO_COLOR_EXT               0x8004
-#define GLX_STATIC_COLOR_EXT               0x8005
-#define GLX_GRAY_SCALE_EXT                 0x8006
-#define GLX_STATIC_GRAY_EXT                0x8007
-#define GLX_TRANSPARENT_RGB_EXT            0x8008
-#define GLX_TRANSPARENT_INDEX_EXT          0x8009
-#endif
+#ifndef GLX_ARB_framebuffer_sRGB
+#define GLX_ARB_framebuffer_sRGB 1
+#define GLX_FRAMEBUFFER_SRGB_CAPABLE_ARB  0x20B2
+#endif /* GLX_ARB_framebuffer_sRGB */
 
-#ifndef GLX_SGI_swap_control
+#ifndef GLX_ARB_get_proc_address
+#define GLX_ARB_get_proc_address 1
+typedef __GLXextFuncPtr ( *PFNGLXGETPROCADDRESSARBPROC) (const GLubyte *procName);
+#ifdef GLX_GLXEXT_PROTOTYPES
+__GLXextFuncPtr glXGetProcAddressARB (const GLubyte *procName);
 #endif
+#endif /* GLX_ARB_get_proc_address */
 
-#ifndef GLX_SGI_video_sync
-#endif
+#ifndef GLX_ARB_multisample
+#define GLX_ARB_multisample 1
+#define GLX_SAMPLE_BUFFERS_ARB            100000
+#define GLX_SAMPLES_ARB                   100001
+#endif /* GLX_ARB_multisample */
 
-#ifndef GLX_SGI_make_current_read
-#endif
+#ifndef GLX_ARB_robustness_application_isolation
+#define GLX_ARB_robustness_application_isolation 1
+#define GLX_CONTEXT_RESET_ISOLATION_BIT_ARB 0x00000008
+#endif /* GLX_ARB_robustness_application_isolation */
 
-#ifndef GLX_SGIX_video_source
-#endif
+#ifndef GLX_ARB_robustness_share_group_isolation
+#define GLX_ARB_robustness_share_group_isolation 1
+#endif /* GLX_ARB_robustness_share_group_isolation */
 
-#ifndef GLX_EXT_visual_rating
-#define GLX_VISUAL_CAVEAT_EXT              0x20
-#define GLX_SLOW_VISUAL_EXT                0x8001
-#define GLX_NON_CONFORMANT_VISUAL_EXT      0x800D
-/* reuse GLX_NONE_EXT */
-#endif
+#ifndef GLX_ARB_vertex_buffer_object
+#define GLX_ARB_vertex_buffer_object 1
+#define GLX_CONTEXT_ALLOW_BUFFER_BYTE_ORDER_MISMATCH_ARB 0x2095
+#endif /* GLX_ARB_vertex_buffer_object */
 
-#ifndef GLX_EXT_import_context
-#define GLX_SHARE_CONTEXT_EXT              0x800A
-#define GLX_VISUAL_ID_EXT                  0x800B
-#define GLX_SCREEN_EXT                     0x800C
-#endif
+#ifndef GLX_3DFX_multisample
+#define GLX_3DFX_multisample 1
+#define GLX_SAMPLE_BUFFERS_3DFX           0x8050
+#define GLX_SAMPLES_3DFX                  0x8051
+#endif /* GLX_3DFX_multisample */
 
-#ifndef GLX_SGIX_fbconfig
-#define GLX_WINDOW_BIT_SGIX                0x00000001
-#define GLX_PIXMAP_BIT_SGIX                0x00000002
-#define GLX_RGBA_BIT_SGIX                  0x00000001
-#define GLX_COLOR_INDEX_BIT_SGIX           0x00000002
-#define GLX_DRAWABLE_TYPE_SGIX             0x8010
-#define GLX_RENDER_TYPE_SGIX               0x8011
-#define GLX_X_RENDERABLE_SGIX              0x8012
-#define GLX_FBCONFIG_ID_SGIX               0x8013
-#define GLX_RGBA_TYPE_SGIX                 0x8014
-#define GLX_COLOR_INDEX_TYPE_SGIX          0x8015
-/* reuse GLX_SCREEN_EXT */
-#endif
+#ifndef GLX_AMD_gpu_association
+#define GLX_AMD_gpu_association 1
+#define GLX_GPU_VENDOR_AMD                0x1F00
+#define GLX_GPU_RENDERER_STRING_AMD       0x1F01
+#define GLX_GPU_OPENGL_VERSION_STRING_AMD 0x1F02
+#define GLX_GPU_FASTEST_TARGET_GPUS_AMD   0x21A2
+#define GLX_GPU_RAM_AMD                   0x21A3
+#define GLX_GPU_CLOCK_AMD                 0x21A4
+#define GLX_GPU_NUM_PIPES_AMD             0x21A5
+#define GLX_GPU_NUM_SIMD_AMD              0x21A6
+#define GLX_GPU_NUM_RB_AMD                0x21A7
+#define GLX_GPU_NUM_SPI_AMD               0x21A8
+#endif /* GLX_AMD_gpu_association */
+
+#ifndef GLX_EXT_buffer_age
+#define GLX_EXT_buffer_age 1
+#define GLX_BACK_BUFFER_AGE_EXT           0x20F4
+#endif /* GLX_EXT_buffer_age */
 
-#ifndef GLX_SGIX_pbuffer
-#define GLX_PBUFFER_BIT_SGIX               0x00000004
-#define GLX_BUFFER_CLOBBER_MASK_SGIX       0x08000000
-#define GLX_FRONT_LEFT_BUFFER_BIT_SGIX     0x00000001
-#define GLX_FRONT_RIGHT_BUFFER_BIT_SGIX    0x00000002
-#define GLX_BACK_LEFT_BUFFER_BIT_SGIX      0x00000004
-#define GLX_BACK_RIGHT_BUFFER_BIT_SGIX     0x00000008
-#define GLX_AUX_BUFFERS_BIT_SGIX           0x00000010
-#define GLX_DEPTH_BUFFER_BIT_SGIX          0x00000020
-#define GLX_STENCIL_BUFFER_BIT_SGIX        0x00000040
-#define GLX_ACCUM_BUFFER_BIT_SGIX          0x00000080
-#define GLX_SAMPLE_BUFFERS_BIT_SGIX        0x00000100
-#define GLX_MAX_PBUFFER_WIDTH_SGIX         0x8016
-#define GLX_MAX_PBUFFER_HEIGHT_SGIX        0x8017
-#define GLX_MAX_PBUFFER_PIXELS_SGIX        0x8018
-#define GLX_OPTIMAL_PBUFFER_WIDTH_SGIX     0x8019
-#define GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX    0x801A
-#define GLX_PRESERVED_CONTENTS_SGIX        0x801B
-#define GLX_LARGEST_PBUFFER_SGIX           0x801C
-#define GLX_WIDTH_SGIX                     0x801D
-#define GLX_HEIGHT_SGIX                    0x801E
-#define GLX_EVENT_MASK_SGIX                0x801F
-#define GLX_DAMAGED_SGIX                   0x8020
-#define GLX_SAVED_SGIX                     0x8021
-#define GLX_WINDOW_SGIX                    0x8022
-#define GLX_PBUFFER_SGIX                   0x8023
-#endif
+#ifndef GLX_EXT_create_context_es2_profile
+#define GLX_EXT_create_context_es2_profile 1
+#define GLX_CONTEXT_ES2_PROFILE_BIT_EXT   0x00000004
+#endif /* GLX_EXT_create_context_es2_profile */
 
-#ifndef GLX_SGI_cushion
-#endif
+#ifndef GLX_EXT_create_context_es_profile
+#define GLX_EXT_create_context_es_profile 1
+#define GLX_CONTEXT_ES_PROFILE_BIT_EXT    0x00000004
+#endif /* GLX_EXT_create_context_es_profile */
 
-#ifndef GLX_SGIX_video_resize
-#define GLX_SYNC_FRAME_SGIX                0x00000000
-#define GLX_SYNC_SWAP_SGIX                 0x00000001
-#endif
+#ifndef GLX_EXT_fbconfig_packed_float
+#define GLX_EXT_fbconfig_packed_float 1
+#define GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT  0x20B1
+#define GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT   0x00000008
+#endif /* GLX_EXT_fbconfig_packed_float */
 
-#ifndef GLX_SGIX_dmbuffer
-#define GLX_DIGITAL_MEDIA_PBUFFER_SGIX     0x8024
-#endif
+#ifndef GLX_EXT_framebuffer_sRGB
+#define GLX_EXT_framebuffer_sRGB 1
+#define GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT  0x20B2
+#endif /* GLX_EXT_framebuffer_sRGB */
 
-#ifndef GLX_SGIX_swap_group
+#ifndef GLX_EXT_import_context
+#define GLX_EXT_import_context 1
+typedef XID GLXContextID;
+#define GLX_SHARE_CONTEXT_EXT             0x800A
+#define GLX_VISUAL_ID_EXT                 0x800B
+#define GLX_SCREEN_EXT                    0x800C
+typedef Display *( *PFNGLXGETCURRENTDISPLAYEXTPROC) (void);
+typedef int ( *PFNGLXQUERYCONTEXTINFOEXTPROC) (Display *dpy, GLXContext context, int attribute, int *value);
+typedef GLXContextID ( *PFNGLXGETCONTEXTIDEXTPROC) (const GLXContext context);
+typedef GLXContext ( *PFNGLXIMPORTCONTEXTEXTPROC) (Display *dpy, GLXContextID contextID);
+typedef void ( *PFNGLXFREECONTEXTEXTPROC) (Display *dpy, GLXContext context);
+#ifdef GLX_GLXEXT_PROTOTYPES
+Display *glXGetCurrentDisplayEXT (void);
+int glXQueryContextInfoEXT (Display *dpy, GLXContext context, int attribute, int *value);
+GLXContextID glXGetContextIDEXT (const GLXContext context);
+GLXContext glXImportContextEXT (Display *dpy, GLXContextID contextID);
+void glXFreeContextEXT (Display *dpy, GLXContext context);
 #endif
+#endif /* GLX_EXT_import_context */
 
-#ifndef GLX_SGIX_swap_barrier
+#ifndef GLX_EXT_swap_control
+#define GLX_EXT_swap_control 1
+#define GLX_SWAP_INTERVAL_EXT             0x20F1
+#define GLX_MAX_SWAP_INTERVAL_EXT         0x20F2
+typedef void ( *PFNGLXSWAPINTERVALEXTPROC) (Display *dpy, GLXDrawable drawable, int interval);
+#ifdef GLX_GLXEXT_PROTOTYPES
+void glXSwapIntervalEXT (Display *dpy, GLXDrawable drawable, int interval);
 #endif
+#endif /* GLX_EXT_swap_control */
 
-#ifndef GLX_SGIS_blended_overlay
-#define GLX_BLENDED_RGBA_SGIS              0x8025
-#endif
+#ifndef GLX_EXT_swap_control_tear
+#define GLX_EXT_swap_control_tear 1
+#define GLX_LATE_SWAPS_TEAR_EXT           0x20F3
+#endif /* GLX_EXT_swap_control_tear */
 
-#ifndef GLX_SGIS_shared_multisample
-#define GLX_MULTISAMPLE_SUB_RECT_WIDTH_SGIS 0x8026
-#define GLX_MULTISAMPLE_SUB_RECT_HEIGHT_SGIS 0x8027
+#ifndef GLX_EXT_texture_from_pixmap
+#define GLX_EXT_texture_from_pixmap 1
+#define GLX_TEXTURE_1D_BIT_EXT            0x00000001
+#define GLX_TEXTURE_2D_BIT_EXT            0x00000002
+#define GLX_TEXTURE_RECTANGLE_BIT_EXT     0x00000004
+#define GLX_BIND_TO_TEXTURE_RGB_EXT       0x20D0
+#define GLX_BIND_TO_TEXTURE_RGBA_EXT      0x20D1
+#define GLX_BIND_TO_MIPMAP_TEXTURE_EXT    0x20D2
+#define GLX_BIND_TO_TEXTURE_TARGETS_EXT   0x20D3
+#define GLX_Y_INVERTED_EXT                0x20D4
+#define GLX_TEXTURE_FORMAT_EXT            0x20D5
+#define GLX_TEXTURE_TARGET_EXT            0x20D6
+#define GLX_MIPMAP_TEXTURE_EXT            0x20D7
+#define GLX_TEXTURE_FORMAT_NONE_EXT       0x20D8
+#define GLX_TEXTURE_FORMAT_RGB_EXT        0x20D9
+#define GLX_TEXTURE_FORMAT_RGBA_EXT       0x20DA
+#define GLX_TEXTURE_1D_EXT                0x20DB
+#define GLX_TEXTURE_2D_EXT                0x20DC
+#define GLX_TEXTURE_RECTANGLE_EXT         0x20DD
+#define GLX_FRONT_LEFT_EXT                0x20DE
+#define GLX_FRONT_RIGHT_EXT               0x20DF
+#define GLX_BACK_LEFT_EXT                 0x20E0
+#define GLX_BACK_RIGHT_EXT                0x20E1
+#define GLX_FRONT_EXT                     0x20DE
+#define GLX_BACK_EXT                      0x20E0
+#define GLX_AUX0_EXT                      0x20E2
+#define GLX_AUX1_EXT                      0x20E3
+#define GLX_AUX2_EXT                      0x20E4
+#define GLX_AUX3_EXT                      0x20E5
+#define GLX_AUX4_EXT                      0x20E6
+#define GLX_AUX5_EXT                      0x20E7
+#define GLX_AUX6_EXT                      0x20E8
+#define GLX_AUX7_EXT                      0x20E9
+#define GLX_AUX8_EXT                      0x20EA
+#define GLX_AUX9_EXT                      0x20EB
+typedef void ( *PFNGLXBINDTEXIMAGEEXTPROC) (Display *dpy, GLXDrawable drawable, int buffer, const int *attrib_list);
+typedef void ( *PFNGLXRELEASETEXIMAGEEXTPROC) (Display *dpy, GLXDrawable drawable, int buffer);
+#ifdef GLX_GLXEXT_PROTOTYPES
+void glXBindTexImageEXT (Display *dpy, GLXDrawable drawable, int buffer, const int *attrib_list);
+void glXReleaseTexImageEXT (Display *dpy, GLXDrawable drawable, int buffer);
 #endif
+#endif /* GLX_EXT_texture_from_pixmap */
 
-#ifndef GLX_SUN_get_transparent_index
-#endif
+#ifndef GLX_EXT_visual_info
+#define GLX_EXT_visual_info 1
+#define GLX_X_VISUAL_TYPE_EXT             0x22
+#define GLX_TRANSPARENT_TYPE_EXT          0x23
+#define GLX_TRANSPARENT_INDEX_VALUE_EXT   0x24
+#define GLX_TRANSPARENT_RED_VALUE_EXT     0x25
+#define GLX_TRANSPARENT_GREEN_VALUE_EXT   0x26
+#define GLX_TRANSPARENT_BLUE_VALUE_EXT    0x27
+#define GLX_TRANSPARENT_ALPHA_VALUE_EXT   0x28
+#define GLX_NONE_EXT                      0x8000
+#define GLX_TRUE_COLOR_EXT                0x8002
+#define GLX_DIRECT_COLOR_EXT              0x8003
+#define GLX_PSEUDO_COLOR_EXT              0x8004
+#define GLX_STATIC_COLOR_EXT              0x8005
+#define GLX_GRAY_SCALE_EXT                0x8006
+#define GLX_STATIC_GRAY_EXT               0x8007
+#define GLX_TRANSPARENT_RGB_EXT           0x8008
+#define GLX_TRANSPARENT_INDEX_EXT         0x8009
+#endif /* GLX_EXT_visual_info */
 
-#ifndef GLX_3DFX_multisample
-#define GLX_SAMPLE_BUFFERS_3DFX            0x8050
-#define GLX_SAMPLES_3DFX                   0x8051
+#ifndef GLX_EXT_visual_rating
+#define GLX_EXT_visual_rating 1
+#define GLX_VISUAL_CAVEAT_EXT             0x20
+#define GLX_SLOW_VISUAL_EXT               0x8001
+#define GLX_NON_CONFORMANT_VISUAL_EXT     0x800D
+#endif /* GLX_EXT_visual_rating */
+
+#ifndef GLX_INTEL_swap_event
+#define GLX_INTEL_swap_event 1
+#define GLX_BUFFER_SWAP_COMPLETE_INTEL_MASK 0x04000000
+#define GLX_EXCHANGE_COMPLETE_INTEL       0x8180
+#define GLX_COPY_COMPLETE_INTEL           0x8181
+#define GLX_FLIP_COMPLETE_INTEL           0x8182
+#endif /* GLX_INTEL_swap_event */
+
+#ifndef GLX_MESA_agp_offset
+#define GLX_MESA_agp_offset 1
+typedef unsigned int ( *PFNGLXGETAGPOFFSETMESAPROC) (const void *pointer);
+#ifdef GLX_GLXEXT_PROTOTYPES
+unsigned int glXGetAGPOffsetMESA (const void *pointer);
 #endif
+#endif /* GLX_MESA_agp_offset */
 
 #ifndef GLX_MESA_copy_sub_buffer
+#define GLX_MESA_copy_sub_buffer 1
+typedef void ( *PFNGLXCOPYSUBBUFFERMESAPROC) (Display *dpy, GLXDrawable drawable, int x, int y, int width, int height);
+#ifdef GLX_GLXEXT_PROTOTYPES
+void glXCopySubBufferMESA (Display *dpy, GLXDrawable drawable, int x, int y, int width, int height);
 #endif
+#endif /* GLX_MESA_copy_sub_buffer */
 
 #ifndef GLX_MESA_pixmap_colormap
+#define GLX_MESA_pixmap_colormap 1
+typedef GLXPixmap ( *PFNGLXCREATEGLXPIXMAPMESAPROC) (Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap);
+#ifdef GLX_GLXEXT_PROTOTYPES
+GLXPixmap glXCreateGLXPixmapMESA (Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap);
 #endif
+#endif /* GLX_MESA_pixmap_colormap */
 
 #ifndef GLX_MESA_release_buffers
+#define GLX_MESA_release_buffers 1
+typedef Bool ( *PFNGLXRELEASEBUFFERSMESAPROC) (Display *dpy, GLXDrawable drawable);
+#ifdef GLX_GLXEXT_PROTOTYPES
+Bool glXReleaseBuffersMESA (Display *dpy, GLXDrawable drawable);
 #endif
+#endif /* GLX_MESA_release_buffers */
 
 #ifndef GLX_MESA_set_3dfx_mode
-#define GLX_3DFX_WINDOW_MODE_MESA          0x1
-#define GLX_3DFX_FULLSCREEN_MODE_MESA      0x2
-#endif
-
-#ifndef GLX_SGIX_visual_select_group
-#define GLX_VISUAL_SELECT_GROUP_SGIX       0x8028
-#endif
-
-#ifndef GLX_OML_swap_method
-#define GLX_SWAP_METHOD_OML                0x8060
-#define GLX_SWAP_EXCHANGE_OML              0x8061
-#define GLX_SWAP_COPY_OML                  0x8062
-#define GLX_SWAP_UNDEFINED_OML             0x8063
+#define GLX_MESA_set_3dfx_mode 1
+#define GLX_3DFX_WINDOW_MODE_MESA         0x1
+#define GLX_3DFX_FULLSCREEN_MODE_MESA     0x2
+typedef Bool ( *PFNGLXSET3DFXMODEMESAPROC) (int mode);
+#ifdef GLX_GLXEXT_PROTOTYPES
+Bool glXSet3DfxModeMESA (int mode);
 #endif
+#endif /* GLX_MESA_set_3dfx_mode */
 
-#ifndef GLX_OML_sync_control
+#ifndef GLX_NV_copy_image
+#define GLX_NV_copy_image 1
+typedef void ( *PFNGLXCOPYIMAGESUBDATANVPROC) (Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
+#ifdef GLX_GLXEXT_PROTOTYPES
+void glXCopyImageSubDataNV (Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
 #endif
+#endif /* GLX_NV_copy_image */
 
 #ifndef GLX_NV_float_buffer
-#define GLX_FLOAT_COMPONENTS_NV            0x20B0
-#endif
-
-#ifndef GLX_SGIX_hyperpipe
-#define GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX 80
-#define GLX_BAD_HYPERPIPE_CONFIG_SGIX      91
-#define GLX_BAD_HYPERPIPE_SGIX             92
-#define GLX_HYPERPIPE_DISPLAY_PIPE_SGIX    0x00000001
-#define GLX_HYPERPIPE_RENDER_PIPE_SGIX     0x00000002
-#define GLX_PIPE_RECT_SGIX                 0x00000001
-#define GLX_PIPE_RECT_LIMITS_SGIX          0x00000002
-#define GLX_HYPERPIPE_STEREO_SGIX          0x00000003
-#define GLX_HYPERPIPE_PIXEL_AVERAGE_SGIX   0x00000004
-#define GLX_HYPERPIPE_ID_SGIX              0x8030
-#endif
-
-#ifndef GLX_MESA_agp_offset
-#endif
-
-#ifndef GLX_EXT_fbconfig_packed_float
-#define GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT   0x20B1
-#define GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT    0x00000008
-#endif
-
-#ifndef GLX_EXT_framebuffer_sRGB
-#define GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT   0x20B2
-#endif
+#define GLX_NV_float_buffer 1
+#define GLX_FLOAT_COMPONENTS_NV           0x20B0
+#endif /* GLX_NV_float_buffer */
 
-#ifndef GLX_EXT_texture_from_pixmap
-#define GLX_TEXTURE_1D_BIT_EXT             0x00000001
-#define GLX_TEXTURE_2D_BIT_EXT             0x00000002
-#define GLX_TEXTURE_RECTANGLE_BIT_EXT      0x00000004
-#define GLX_BIND_TO_TEXTURE_RGB_EXT        0x20D0
-#define GLX_BIND_TO_TEXTURE_RGBA_EXT       0x20D1
-#define GLX_BIND_TO_MIPMAP_TEXTURE_EXT     0x20D2
-#define GLX_BIND_TO_TEXTURE_TARGETS_EXT    0x20D3
-#define GLX_Y_INVERTED_EXT                 0x20D4
-#define GLX_TEXTURE_FORMAT_EXT             0x20D5
-#define GLX_TEXTURE_TARGET_EXT             0x20D6
-#define GLX_MIPMAP_TEXTURE_EXT             0x20D7
-#define GLX_TEXTURE_FORMAT_NONE_EXT        0x20D8
-#define GLX_TEXTURE_FORMAT_RGB_EXT         0x20D9
-#define GLX_TEXTURE_FORMAT_RGBA_EXT        0x20DA
-#define GLX_TEXTURE_1D_EXT                 0x20DB
-#define GLX_TEXTURE_2D_EXT                 0x20DC
-#define GLX_TEXTURE_RECTANGLE_EXT          0x20DD
-#define GLX_FRONT_LEFT_EXT                 0x20DE
-#define GLX_FRONT_RIGHT_EXT                0x20DF
-#define GLX_BACK_LEFT_EXT                  0x20E0
-#define GLX_BACK_RIGHT_EXT                 0x20E1
-#define GLX_FRONT_EXT                      GLX_FRONT_LEFT_EXT
-#define GLX_BACK_EXT                       GLX_BACK_LEFT_EXT
-#define GLX_AUX0_EXT                       0x20E2
-#define GLX_AUX1_EXT                       0x20E3
-#define GLX_AUX2_EXT                       0x20E4
-#define GLX_AUX3_EXT                       0x20E5
-#define GLX_AUX4_EXT                       0x20E6
-#define GLX_AUX5_EXT                       0x20E7
-#define GLX_AUX6_EXT                       0x20E8
-#define GLX_AUX7_EXT                       0x20E9
-#define GLX_AUX8_EXT                       0x20EA
-#define GLX_AUX9_EXT                       0x20EB
-#endif
+#ifndef GLX_NV_multisample_coverage
+#define GLX_NV_multisample_coverage 1
+#define GLX_COVERAGE_SAMPLES_NV           100001
+#define GLX_COLOR_SAMPLES_NV              0x20B3
+#endif /* GLX_NV_multisample_coverage */
 
 #ifndef GLX_NV_present_video
-#define GLX_NUM_VIDEO_SLOTS_NV             0x20F0
-#endif
-
-#ifndef GLX_NV_video_out
-#define GLX_VIDEO_OUT_COLOR_NV             0x20C3
-#define GLX_VIDEO_OUT_ALPHA_NV             0x20C4
-#define GLX_VIDEO_OUT_DEPTH_NV             0x20C5
-#define GLX_VIDEO_OUT_COLOR_AND_ALPHA_NV   0x20C6
-#define GLX_VIDEO_OUT_COLOR_AND_DEPTH_NV   0x20C7
-#define GLX_VIDEO_OUT_FRAME_NV             0x20C8
-#define GLX_VIDEO_OUT_FIELD_1_NV           0x20C9
-#define GLX_VIDEO_OUT_FIELD_2_NV           0x20CA
-#define GLX_VIDEO_OUT_STACKED_FIELDS_1_2_NV 0x20CB
-#define GLX_VIDEO_OUT_STACKED_FIELDS_2_1_NV 0x20CC
+#define GLX_NV_present_video 1
+#define GLX_NUM_VIDEO_SLOTS_NV            0x20F0
+typedef unsigned int *( *PFNGLXENUMERATEVIDEODEVICESNVPROC) (Display *dpy, int screen, int *nelements);
+typedef int ( *PFNGLXBINDVIDEODEVICENVPROC) (Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list);
+#ifdef GLX_GLXEXT_PROTOTYPES
+unsigned int *glXEnumerateVideoDevicesNV (Display *dpy, int screen, int *nelements);
+int glXBindVideoDeviceNV (Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list);
 #endif
+#endif /* GLX_NV_present_video */
 
 #ifndef GLX_NV_swap_group
+#define GLX_NV_swap_group 1
+typedef Bool ( *PFNGLXJOINSWAPGROUPNVPROC) (Display *dpy, GLXDrawable drawable, GLuint group);
+typedef Bool ( *PFNGLXBINDSWAPBARRIERNVPROC) (Display *dpy, GLuint group, GLuint barrier);
+typedef Bool ( *PFNGLXQUERYSWAPGROUPNVPROC) (Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier);
+typedef Bool ( *PFNGLXQUERYMAXSWAPGROUPSNVPROC) (Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers);
+typedef Bool ( *PFNGLXQUERYFRAMECOUNTNVPROC) (Display *dpy, int screen, GLuint *count);
+typedef Bool ( *PFNGLXRESETFRAMECOUNTNVPROC) (Display *dpy, int screen);
+#ifdef GLX_GLXEXT_PROTOTYPES
+Bool glXJoinSwapGroupNV (Display *dpy, GLXDrawable drawable, GLuint group);
+Bool glXBindSwapBarrierNV (Display *dpy, GLuint group, GLuint barrier);
+Bool glXQuerySwapGroupNV (Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier);
+Bool glXQueryMaxSwapGroupsNV (Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers);
+Bool glXQueryFrameCountNV (Display *dpy, int screen, GLuint *count);
+Bool glXResetFrameCountNV (Display *dpy, int screen);
 #endif
+#endif /* GLX_NV_swap_group */
 
 #ifndef GLX_NV_video_capture
-#define GLX_DEVICE_ID_NV                   0x20CD
-#define GLX_UNIQUE_ID_NV                   0x20CE
-#define GLX_NUM_VIDEO_CAPTURE_SLOTS_NV     0x20CF
-#endif
-
-#ifndef GLX_EXT_swap_control
-#define GLX_SWAP_INTERVAL_EXT              0x20F1
-#define GLX_MAX_SWAP_INTERVAL_EXT          0x20F2
-#endif
-
-#ifndef GLX_NV_copy_image
-#endif
-
-#ifndef GLX_INTEL_swap_event
-#define GLX_BUFFER_SWAP_COMPLETE_INTEL_MASK 0x04000000
-#define GLX_EXCHANGE_COMPLETE_INTEL        0x8180
-#define GLX_COPY_COMPLETE_INTEL            0x8181
-#define GLX_FLIP_COMPLETE_INTEL            0x8182
-#endif
-
-#ifndef GLX_NV_multisample_coverage
-#define GLX_COVERAGE_SAMPLES_NV            100001
-#define GLX_COLOR_SAMPLES_NV               0x20B3
-#endif
-
-#ifndef GLX_AMD_gpu_association
-#define GLX_GPU_VENDOR_AMD                 0x1F00
-#define GLX_GPU_RENDERER_STRING_AMD        0x1F01
-#define GLX_GPU_OPENGL_VERSION_STRING_AMD  0x1F02
-#define GLX_GPU_FASTEST_TARGET_GPUS_AMD    0x21A2
-#define GLX_GPU_RAM_AMD                    0x21A3
-#define GLX_GPU_CLOCK_AMD                  0x21A4
-#define GLX_GPU_NUM_PIPES_AMD              0x21A5
-#define GLX_GPU_NUM_SIMD_AMD               0x21A6
-#define GLX_GPU_NUM_RB_AMD                 0x21A7
-#define GLX_GPU_NUM_SPI_AMD                0x21A8
-#endif
-
-#ifndef GLX_EXT_create_context_es2_profile
-#define GLX_CONTEXT_ES2_PROFILE_BIT_EXT    0x00000004
-#endif
-
-#ifndef GLX_EXT_swap_control_tear
-#define GLX_LATE_SWAPS_TEAR_EXT            0x20F3
-#endif
-
-
-/*************************************************************/
-
-#ifndef GLX_ARB_get_proc_address
-typedef void (*__GLXextFuncPtr)(void);
-#endif
-
-#ifndef GLX_SGIX_video_source
-typedef XID GLXVideoSourceSGIX;
-#endif
-
-#ifndef GLX_SGIX_fbconfig
-typedef XID GLXFBConfigIDSGIX;
-typedef struct __GLXFBConfigRec *GLXFBConfigSGIX;
-#endif
-
-#ifndef GLX_SGIX_pbuffer
-typedef XID GLXPbufferSGIX;
-typedef struct {
-    int type;
-    unsigned long serial;	  /* # of last request processed by server */
-    Bool send_event;		  /* true if this came for SendEvent request */
-    Display *display;		  /* display the event was read from */
-    GLXDrawable drawable;	  /* i.d. of Drawable */
-    int event_type;		  /* GLX_DAMAGED_SGIX or GLX_SAVED_SGIX */
-    int draw_type;		  /* GLX_WINDOW_SGIX or GLX_PBUFFER_SGIX */
-    unsigned int mask;	  /* mask indicating which buffers are affected*/
-    int x, y;
-    int width, height;
-    int count;		  /* if nonzero, at least this many more */
-} GLXBufferClobberEventSGIX;
+#define GLX_NV_video_capture 1
+typedef XID GLXVideoCaptureDeviceNV;
+#define GLX_DEVICE_ID_NV                  0x20CD
+#define GLX_UNIQUE_ID_NV                  0x20CE
+#define GLX_NUM_VIDEO_CAPTURE_SLOTS_NV    0x20CF
+typedef int ( *PFNGLXBINDVIDEOCAPTUREDEVICENVPROC) (Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device);
+typedef GLXVideoCaptureDeviceNV *( *PFNGLXENUMERATEVIDEOCAPTUREDEVICESNVPROC) (Display *dpy, int screen, int *nelements);
+typedef void ( *PFNGLXLOCKVIDEOCAPTUREDEVICENVPROC) (Display *dpy, GLXVideoCaptureDeviceNV device);
+typedef int ( *PFNGLXQUERYVIDEOCAPTUREDEVICENVPROC) (Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value);
+typedef void ( *PFNGLXRELEASEVIDEOCAPTUREDEVICENVPROC) (Display *dpy, GLXVideoCaptureDeviceNV device);
+#ifdef GLX_GLXEXT_PROTOTYPES
+int glXBindVideoCaptureDeviceNV (Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device);
+GLXVideoCaptureDeviceNV *glXEnumerateVideoCaptureDevicesNV (Display *dpy, int screen, int *nelements);
+void glXLockVideoCaptureDeviceNV (Display *dpy, GLXVideoCaptureDeviceNV device);
+int glXQueryVideoCaptureDeviceNV (Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value);
+void glXReleaseVideoCaptureDeviceNV (Display *dpy, GLXVideoCaptureDeviceNV device);
 #endif
+#endif /* GLX_NV_video_capture */
 
 #ifndef GLX_NV_video_output
+#define GLX_NV_video_output 1
 typedef unsigned int GLXVideoDeviceNV;
+#define GLX_VIDEO_OUT_COLOR_NV            0x20C3
+#define GLX_VIDEO_OUT_ALPHA_NV            0x20C4
+#define GLX_VIDEO_OUT_DEPTH_NV            0x20C5
+#define GLX_VIDEO_OUT_COLOR_AND_ALPHA_NV  0x20C6
+#define GLX_VIDEO_OUT_COLOR_AND_DEPTH_NV  0x20C7
+#define GLX_VIDEO_OUT_FRAME_NV            0x20C8
+#define GLX_VIDEO_OUT_FIELD_1_NV          0x20C9
+#define GLX_VIDEO_OUT_FIELD_2_NV          0x20CA
+#define GLX_VIDEO_OUT_STACKED_FIELDS_1_2_NV 0x20CB
+#define GLX_VIDEO_OUT_STACKED_FIELDS_2_1_NV 0x20CC
+typedef int ( *PFNGLXGETVIDEODEVICENVPROC) (Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice);
+typedef int ( *PFNGLXRELEASEVIDEODEVICENVPROC) (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice);
+typedef int ( *PFNGLXBINDVIDEOIMAGENVPROC) (Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer);
+typedef int ( *PFNGLXRELEASEVIDEOIMAGENVPROC) (Display *dpy, GLXPbuffer pbuf);
+typedef int ( *PFNGLXSENDPBUFFERTOVIDEONVPROC) (Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock);
+typedef int ( *PFNGLXGETVIDEOINFONVPROC) (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo);
+#ifdef GLX_GLXEXT_PROTOTYPES
+int glXGetVideoDeviceNV (Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice);
+int glXReleaseVideoDeviceNV (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice);
+int glXBindVideoImageNV (Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer);
+int glXReleaseVideoImageNV (Display *dpy, GLXPbuffer pbuf);
+int glXSendPbufferToVideoNV (Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock);
+int glXGetVideoInfoNV (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo);
 #endif
+#endif /* GLX_NV_video_output */
 
-#ifndef GLX_NV_video_capture
-typedef XID GLXVideoCaptureDeviceNV;
-#endif
+#ifndef GLX_OML_swap_method
+#define GLX_OML_swap_method 1
+#define GLX_SWAP_METHOD_OML               0x8060
+#define GLX_SWAP_EXCHANGE_OML             0x8061
+#define GLX_SWAP_COPY_OML                 0x8062
+#define GLX_SWAP_UNDEFINED_OML            0x8063
+#endif /* GLX_OML_swap_method */
 
+#ifndef GLX_OML_sync_control
+#define GLX_OML_sync_control 1
 #ifndef GLEXT_64_TYPES_DEFINED
 /* This code block is duplicated in glext.h, so must be protected */
 #define GLEXT_64_TYPES_DEFINED
@@ -518,481 +565,271 @@ typedef __int32 int32_t;
 typedef __int64 int64_t;
 typedef unsigned __int64 uint64_t;
 #else
-#include <inttypes.h>     /* Fallback option */
-#endif
-#endif
-
-#ifndef GLX_VERSION_1_3
-#define GLX_VERSION_1_3 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern GLXFBConfig * glXGetFBConfigs (Display *dpy, int screen, int *nelements);
-extern GLXFBConfig * glXChooseFBConfig (Display *dpy, int screen, const int *attrib_list, int *nelements);
-extern int glXGetFBConfigAttrib (Display *dpy, GLXFBConfig config, int attribute, int *value);
-extern XVisualInfo * glXGetVisualFromFBConfig (Display *dpy, GLXFBConfig config);
-extern GLXWindow glXCreateWindow (Display *dpy, GLXFBConfig config, Window win, const int *attrib_list);
-extern void glXDestroyWindow (Display *dpy, GLXWindow win);
-extern GLXPixmap glXCreatePixmap (Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list);
-extern void glXDestroyPixmap (Display *dpy, GLXPixmap pixmap);
-extern GLXPbuffer glXCreatePbuffer (Display *dpy, GLXFBConfig config, const int *attrib_list);
-extern void glXDestroyPbuffer (Display *dpy, GLXPbuffer pbuf);
-extern void glXQueryDrawable (Display *dpy, GLXDrawable draw, int attribute, unsigned int *value);
-extern GLXContext glXCreateNewContext (Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct);
-extern Bool glXMakeContextCurrent (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
-extern GLXDrawable glXGetCurrentReadDrawable (void);
-extern Display * glXGetCurrentDisplay (void);
-extern int glXQueryContext (Display *dpy, GLXContext ctx, int attribute, int *value);
-extern void glXSelectEvent (Display *dpy, GLXDrawable draw, unsigned long event_mask);
-extern void glXGetSelectedEvent (Display *dpy, GLXDrawable draw, unsigned long *event_mask);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef GLXFBConfig * ( * PFNGLXGETFBCONFIGSPROC) (Display *dpy, int screen, int *nelements);
-typedef GLXFBConfig * ( * PFNGLXCHOOSEFBCONFIGPROC) (Display *dpy, int screen, const int *attrib_list, int *nelements);
-typedef int ( * PFNGLXGETFBCONFIGATTRIBPROC) (Display *dpy, GLXFBConfig config, int attribute, int *value);
-typedef XVisualInfo * ( * PFNGLXGETVISUALFROMFBCONFIGPROC) (Display *dpy, GLXFBConfig config);
-typedef GLXWindow ( * PFNGLXCREATEWINDOWPROC) (Display *dpy, GLXFBConfig config, Window win, const int *attrib_list);
-typedef void ( * PFNGLXDESTROYWINDOWPROC) (Display *dpy, GLXWindow win);
-typedef GLXPixmap ( * PFNGLXCREATEPIXMAPPROC) (Display *dpy, GLXFBConfig config, Pixmap pixmap, const int *attrib_list);
-typedef void ( * PFNGLXDESTROYPIXMAPPROC) (Display *dpy, GLXPixmap pixmap);
-typedef GLXPbuffer ( * PFNGLXCREATEPBUFFERPROC) (Display *dpy, GLXFBConfig config, const int *attrib_list);
-typedef void ( * PFNGLXDESTROYPBUFFERPROC) (Display *dpy, GLXPbuffer pbuf);
-typedef void ( * PFNGLXQUERYDRAWABLEPROC) (Display *dpy, GLXDrawable draw, int attribute, unsigned int *value);
-typedef GLXContext ( * PFNGLXCREATENEWCONTEXTPROC) (Display *dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct);
-typedef Bool ( * PFNGLXMAKECONTEXTCURRENTPROC) (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
-typedef GLXDrawable ( * PFNGLXGETCURRENTREADDRAWABLEPROC) (void);
-typedef Display * ( * PFNGLXGETCURRENTDISPLAYPROC) (void);
-typedef int ( * PFNGLXQUERYCONTEXTPROC) (Display *dpy, GLXContext ctx, int attribute, int *value);
-typedef void ( * PFNGLXSELECTEVENTPROC) (Display *dpy, GLXDrawable draw, unsigned long event_mask);
-typedef void ( * PFNGLXGETSELECTEDEVENTPROC) (Display *dpy, GLXDrawable draw, unsigned long *event_mask);
-#endif
-
-#ifndef GLX_VERSION_1_4
-#define GLX_VERSION_1_4 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern __GLXextFuncPtr glXGetProcAddress (const GLubyte *procName);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef __GLXextFuncPtr ( * PFNGLXGETPROCADDRESSPROC) (const GLubyte *procName);
-#endif
-
-#ifndef GLX_ARB_get_proc_address
-#define GLX_ARB_get_proc_address 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern __GLXextFuncPtr glXGetProcAddressARB (const GLubyte *procName);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef __GLXextFuncPtr ( * PFNGLXGETPROCADDRESSARBPROC) (const GLubyte *procName);
-#endif
-
-#ifndef GLX_ARB_multisample
-#define GLX_ARB_multisample 1
+/* Fallback if nothing above works */
+#include <inttypes.h>
 #endif
-
-#ifndef GLX_ARB_fbconfig_float
-#define GLX_ARB_fbconfig_float 1
 #endif
-
-#ifndef GLX_ARB_framebuffer_sRGB
-#define GLX_ARB_framebuffer_sRGB 1
-#endif
-
-#ifndef GLX_ARB_create_context
-#define GLX_ARB_create_context 1
+typedef Bool ( *PFNGLXGETSYNCVALUESOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc);
+typedef Bool ( *PFNGLXGETMSCRATEOMLPROC) (Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator);
+typedef int64_t ( *PFNGLXSWAPBUFFERSMSCOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder);
+typedef Bool ( *PFNGLXWAITFORMSCOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc);
+typedef Bool ( *PFNGLXWAITFORSBCOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc);
 #ifdef GLX_GLXEXT_PROTOTYPES
-extern GLXContext glXCreateContextAttribsARB (Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef GLXContext ( * PFNGLXCREATECONTEXTATTRIBSARBPROC) (Display *dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int *attrib_list);
-#endif
-
-#ifndef GLX_ARB_create_context_profile
-#define GLX_ARB_create_context_profile 1
+Bool glXGetSyncValuesOML (Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc);
+Bool glXGetMscRateOML (Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator);
+int64_t glXSwapBuffersMscOML (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder);
+Bool glXWaitForMscOML (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc);
+Bool glXWaitForSbcOML (Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc);
 #endif
+#endif /* GLX_OML_sync_control */
 
-#ifndef GLX_ARB_create_context_robustness
-#define GLX_ARB_create_context_robustness 1
-#endif
+#ifndef GLX_SGIS_blended_overlay
+#define GLX_SGIS_blended_overlay 1
+#define GLX_BLENDED_RGBA_SGIS             0x8025
+#endif /* GLX_SGIS_blended_overlay */
 
 #ifndef GLX_SGIS_multisample
 #define GLX_SGIS_multisample 1
-#endif
-
-#ifndef GLX_EXT_visual_info
-#define GLX_EXT_visual_info 1
-#endif
-
-#ifndef GLX_SGI_swap_control
-#define GLX_SGI_swap_control 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern int glXSwapIntervalSGI (int interval);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef int ( * PFNGLXSWAPINTERVALSGIPROC) (int interval);
-#endif
-
-#ifndef GLX_SGI_video_sync
-#define GLX_SGI_video_sync 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern int glXGetVideoSyncSGI (unsigned int *count);
-extern int glXWaitVideoSyncSGI (int divisor, int remainder, unsigned int *count);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef int ( * PFNGLXGETVIDEOSYNCSGIPROC) (unsigned int *count);
-typedef int ( * PFNGLXWAITVIDEOSYNCSGIPROC) (int divisor, int remainder, unsigned int *count);
-#endif
-
-#ifndef GLX_SGI_make_current_read
-#define GLX_SGI_make_current_read 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern Bool glXMakeCurrentReadSGI (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
-extern GLXDrawable glXGetCurrentReadDrawableSGI (void);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef Bool ( * PFNGLXMAKECURRENTREADSGIPROC) (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
-typedef GLXDrawable ( * PFNGLXGETCURRENTREADDRAWABLESGIPROC) (void);
-#endif
+#define GLX_SAMPLE_BUFFERS_SGIS           100000
+#define GLX_SAMPLES_SGIS                  100001
+#endif /* GLX_SGIS_multisample */
 
-#ifndef GLX_SGIX_video_source
-#define GLX_SGIX_video_source 1
-#ifdef _VL_H
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern GLXVideoSourceSGIX glXCreateGLXVideoSourceSGIX (Display *display, int screen, VLServer server, VLPath path, int nodeClass, VLNode drainNode);
-extern void glXDestroyGLXVideoSourceSGIX (Display *dpy, GLXVideoSourceSGIX glxvideosource);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef GLXVideoSourceSGIX ( * PFNGLXCREATEGLXVIDEOSOURCESGIXPROC) (Display *display, int screen, VLServer server, VLPath path, int nodeClass, VLNode drainNode);
-typedef void ( * PFNGLXDESTROYGLXVIDEOSOURCESGIXPROC) (Display *dpy, GLXVideoSourceSGIX glxvideosource);
-#endif /* _VL_H */
-#endif
-
-#ifndef GLX_EXT_visual_rating
-#define GLX_EXT_visual_rating 1
-#endif
-
-#ifndef GLX_EXT_import_context
-#define GLX_EXT_import_context 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern Display * glXGetCurrentDisplayEXT (void);
-extern int glXQueryContextInfoEXT (Display *dpy, GLXContext context, int attribute, int *value);
-extern GLXContextID glXGetContextIDEXT (const GLXContext context);
-extern GLXContext glXImportContextEXT (Display *dpy, GLXContextID contextID);
-extern void glXFreeContextEXT (Display *dpy, GLXContext context);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef Display * ( * PFNGLXGETCURRENTDISPLAYEXTPROC) (void);
-typedef int ( * PFNGLXQUERYCONTEXTINFOEXTPROC) (Display *dpy, GLXContext context, int attribute, int *value);
-typedef GLXContextID ( * PFNGLXGETCONTEXTIDEXTPROC) (const GLXContext context);
-typedef GLXContext ( * PFNGLXIMPORTCONTEXTEXTPROC) (Display *dpy, GLXContextID contextID);
-typedef void ( * PFNGLXFREECONTEXTEXTPROC) (Display *dpy, GLXContext context);
-#endif
-
-#ifndef GLX_SGIX_fbconfig
-#define GLX_SGIX_fbconfig 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern int glXGetFBConfigAttribSGIX (Display *dpy, GLXFBConfigSGIX config, int attribute, int *value);
-extern GLXFBConfigSGIX * glXChooseFBConfigSGIX (Display *dpy, int screen, int *attrib_list, int *nelements);
-extern GLXPixmap glXCreateGLXPixmapWithConfigSGIX (Display *dpy, GLXFBConfigSGIX config, Pixmap pixmap);
-extern GLXContext glXCreateContextWithConfigSGIX (Display *dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct);
-extern XVisualInfo * glXGetVisualFromFBConfigSGIX (Display *dpy, GLXFBConfigSGIX config);
-extern GLXFBConfigSGIX glXGetFBConfigFromVisualSGIX (Display *dpy, XVisualInfo *vis);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef int ( * PFNGLXGETFBCONFIGATTRIBSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, int attribute, int *value);
-typedef GLXFBConfigSGIX * ( * PFNGLXCHOOSEFBCONFIGSGIXPROC) (Display *dpy, int screen, int *attrib_list, int *nelements);
-typedef GLXPixmap ( * PFNGLXCREATEGLXPIXMAPWITHCONFIGSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, Pixmap pixmap);
-typedef GLXContext ( * PFNGLXCREATECONTEXTWITHCONFIGSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct);
-typedef XVisualInfo * ( * PFNGLXGETVISUALFROMFBCONFIGSGIXPROC) (Display *dpy, GLXFBConfigSGIX config);
-typedef GLXFBConfigSGIX ( * PFNGLXGETFBCONFIGFROMVISUALSGIXPROC) (Display *dpy, XVisualInfo *vis);
-#endif
-
-#ifndef GLX_SGIX_pbuffer
-#define GLX_SGIX_pbuffer 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern GLXPbufferSGIX glXCreateGLXPbufferSGIX (Display *dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int *attrib_list);
-extern void glXDestroyGLXPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuf);
-extern int glXQueryGLXPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);
-extern void glXSelectEventSGIX (Display *dpy, GLXDrawable drawable, unsigned long mask);
-extern void glXGetSelectedEventSGIX (Display *dpy, GLXDrawable drawable, unsigned long *mask);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef GLXPbufferSGIX ( * PFNGLXCREATEGLXPBUFFERSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int *attrib_list);
-typedef void ( * PFNGLXDESTROYGLXPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuf);
-typedef int ( * PFNGLXQUERYGLXPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);
-typedef void ( * PFNGLXSELECTEVENTSGIXPROC) (Display *dpy, GLXDrawable drawable, unsigned long mask);
-typedef void ( * PFNGLXGETSELECTEDEVENTSGIXPROC) (Display *dpy, GLXDrawable drawable, unsigned long *mask);
-#endif
-
-#ifndef GLX_SGI_cushion
-#define GLX_SGI_cushion 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern void glXCushionSGI (Display *dpy, Window window, float cushion);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef void ( * PFNGLXCUSHIONSGIPROC) (Display *dpy, Window window, float cushion);
-#endif
-
-#ifndef GLX_SGIX_video_resize
-#define GLX_SGIX_video_resize 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern int glXBindChannelToWindowSGIX (Display *display, int screen, int channel, Window window);
-extern int glXChannelRectSGIX (Display *display, int screen, int channel, int x, int y, int w, int h);
-extern int glXQueryChannelRectSGIX (Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh);
-extern int glXQueryChannelDeltasSGIX (Display *display, int screen, int channel, int *x, int *y, int *w, int *h);
-extern int glXChannelRectSyncSGIX (Display *display, int screen, int channel, GLenum synctype);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef int ( * PFNGLXBINDCHANNELTOWINDOWSGIXPROC) (Display *display, int screen, int channel, Window window);
-typedef int ( * PFNGLXCHANNELRECTSGIXPROC) (Display *display, int screen, int channel, int x, int y, int w, int h);
-typedef int ( * PFNGLXQUERYCHANNELRECTSGIXPROC) (Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh);
-typedef int ( * PFNGLXQUERYCHANNELDELTASSGIXPROC) (Display *display, int screen, int channel, int *x, int *y, int *w, int *h);
-typedef int ( * PFNGLXCHANNELRECTSYNCSGIXPROC) (Display *display, int screen, int channel, GLenum synctype);
-#endif
+#ifndef GLX_SGIS_shared_multisample
+#define GLX_SGIS_shared_multisample 1
+#define GLX_MULTISAMPLE_SUB_RECT_WIDTH_SGIS 0x8026
+#define GLX_MULTISAMPLE_SUB_RECT_HEIGHT_SGIS 0x8027
+#endif /* GLX_SGIS_shared_multisample */
 
 #ifndef GLX_SGIX_dmbuffer
 #define GLX_SGIX_dmbuffer 1
+typedef XID GLXPbufferSGIX;
 #ifdef _DM_BUFFER_H_
+#define GLX_DIGITAL_MEDIA_PBUFFER_SGIX    0x8024
+typedef Bool ( *PFNGLXASSOCIATEDMPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuffer, DMparams *params, DMbuffer dmbuffer);
 #ifdef GLX_GLXEXT_PROTOTYPES
-extern Bool glXAssociateDMPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuffer, DMparams *params, DMbuffer dmbuffer);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef Bool ( * PFNGLXASSOCIATEDMPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuffer, DMparams *params, DMbuffer dmbuffer);
-#endif /* _DM_BUFFER_H_ */
-#endif
-
-#ifndef GLX_SGIX_swap_group
-#define GLX_SGIX_swap_group 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern void glXJoinSwapGroupSGIX (Display *dpy, GLXDrawable drawable, GLXDrawable member);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef void ( * PFNGLXJOINSWAPGROUPSGIXPROC) (Display *dpy, GLXDrawable drawable, GLXDrawable member);
-#endif
-
-#ifndef GLX_SGIX_swap_barrier
-#define GLX_SGIX_swap_barrier 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern void glXBindSwapBarrierSGIX (Display *dpy, GLXDrawable drawable, int barrier);
-extern Bool glXQueryMaxSwapBarriersSGIX (Display *dpy, int screen, int *max);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef void ( * PFNGLXBINDSWAPBARRIERSGIXPROC) (Display *dpy, GLXDrawable drawable, int barrier);
-typedef Bool ( * PFNGLXQUERYMAXSWAPBARRIERSSGIXPROC) (Display *dpy, int screen, int *max);
-#endif
-
-#ifndef GLX_SUN_get_transparent_index
-#define GLX_SUN_get_transparent_index 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern Status glXGetTransparentIndexSUN (Display *dpy, Window overlay, Window underlay, long *pTransparentIndex);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef Status ( * PFNGLXGETTRANSPARENTINDEXSUNPROC) (Display *dpy, Window overlay, Window underlay, long *pTransparentIndex);
-#endif
-
-#ifndef GLX_MESA_copy_sub_buffer
-#define GLX_MESA_copy_sub_buffer 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern void glXCopySubBufferMESA (Display *dpy, GLXDrawable drawable, int x, int y, int width, int height);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef void ( * PFNGLXCOPYSUBBUFFERMESAPROC) (Display *dpy, GLXDrawable drawable, int x, int y, int width, int height);
-#endif
-
-#ifndef GLX_MESA_pixmap_colormap
-#define GLX_MESA_pixmap_colormap 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern GLXPixmap glXCreateGLXPixmapMESA (Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef GLXPixmap ( * PFNGLXCREATEGLXPIXMAPMESAPROC) (Display *dpy, XVisualInfo *visual, Pixmap pixmap, Colormap cmap);
-#endif
-
-#ifndef GLX_MESA_release_buffers
-#define GLX_MESA_release_buffers 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern Bool glXReleaseBuffersMESA (Display *dpy, GLXDrawable drawable);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef Bool ( * PFNGLXRELEASEBUFFERSMESAPROC) (Display *dpy, GLXDrawable drawable);
-#endif
-
-#ifndef GLX_MESA_set_3dfx_mode
-#define GLX_MESA_set_3dfx_mode 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern Bool glXSet3DfxModeMESA (int mode);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef Bool ( * PFNGLXSET3DFXMODEMESAPROC) (int mode);
-#endif
-
-#ifndef GLX_SGIX_visual_select_group
-#define GLX_SGIX_visual_select_group 1
-#endif
-
-#ifndef GLX_OML_swap_method
-#define GLX_OML_swap_method 1
+Bool glXAssociateDMPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuffer, DMparams *params, DMbuffer dmbuffer);
 #endif
+#endif /* _DM_BUFFER_H_ */
+#endif /* GLX_SGIX_dmbuffer */
 
-#ifndef GLX_OML_sync_control
-#define GLX_OML_sync_control 1
+#ifndef GLX_SGIX_fbconfig
+#define GLX_SGIX_fbconfig 1
+typedef struct __GLXFBConfigRec *GLXFBConfigSGIX;
+#define GLX_WINDOW_BIT_SGIX               0x00000001
+#define GLX_PIXMAP_BIT_SGIX               0x00000002
+#define GLX_RGBA_BIT_SGIX                 0x00000001
+#define GLX_COLOR_INDEX_BIT_SGIX          0x00000002
+#define GLX_DRAWABLE_TYPE_SGIX            0x8010
+#define GLX_RENDER_TYPE_SGIX              0x8011
+#define GLX_X_RENDERABLE_SGIX             0x8012
+#define GLX_FBCONFIG_ID_SGIX              0x8013
+#define GLX_RGBA_TYPE_SGIX                0x8014
+#define GLX_COLOR_INDEX_TYPE_SGIX         0x8015
+typedef int ( *PFNGLXGETFBCONFIGATTRIBSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, int attribute, int *value);
+typedef GLXFBConfigSGIX *( *PFNGLXCHOOSEFBCONFIGSGIXPROC) (Display *dpy, int screen, int *attrib_list, int *nelements);
+typedef GLXPixmap ( *PFNGLXCREATEGLXPIXMAPWITHCONFIGSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, Pixmap pixmap);
+typedef GLXContext ( *PFNGLXCREATECONTEXTWITHCONFIGSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct);
+typedef XVisualInfo *( *PFNGLXGETVISUALFROMFBCONFIGSGIXPROC) (Display *dpy, GLXFBConfigSGIX config);
+typedef GLXFBConfigSGIX ( *PFNGLXGETFBCONFIGFROMVISUALSGIXPROC) (Display *dpy, XVisualInfo *vis);
 #ifdef GLX_GLXEXT_PROTOTYPES
-extern Bool glXGetSyncValuesOML (Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc);
-extern Bool glXGetMscRateOML (Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator);
-extern int64_t glXSwapBuffersMscOML (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder);
-extern Bool glXWaitForMscOML (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc);
-extern Bool glXWaitForSbcOML (Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef Bool ( * PFNGLXGETSYNCVALUESOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t *ust, int64_t *msc, int64_t *sbc);
-typedef Bool ( * PFNGLXGETMSCRATEOMLPROC) (Display *dpy, GLXDrawable drawable, int32_t *numerator, int32_t *denominator);
-typedef int64_t ( * PFNGLXSWAPBUFFERSMSCOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder);
-typedef Bool ( * PFNGLXWAITFORMSCOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t *ust, int64_t *msc, int64_t *sbc);
-typedef Bool ( * PFNGLXWAITFORSBCOMLPROC) (Display *dpy, GLXDrawable drawable, int64_t target_sbc, int64_t *ust, int64_t *msc, int64_t *sbc);
-#endif
-
-#ifndef GLX_NV_float_buffer
-#define GLX_NV_float_buffer 1
+int glXGetFBConfigAttribSGIX (Display *dpy, GLXFBConfigSGIX config, int attribute, int *value);
+GLXFBConfigSGIX *glXChooseFBConfigSGIX (Display *dpy, int screen, int *attrib_list, int *nelements);
+GLXPixmap glXCreateGLXPixmapWithConfigSGIX (Display *dpy, GLXFBConfigSGIX config, Pixmap pixmap);
+GLXContext glXCreateContextWithConfigSGIX (Display *dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct);
+XVisualInfo *glXGetVisualFromFBConfigSGIX (Display *dpy, GLXFBConfigSGIX config);
+GLXFBConfigSGIX glXGetFBConfigFromVisualSGIX (Display *dpy, XVisualInfo *vis);
 #endif
+#endif /* GLX_SGIX_fbconfig */
 
 #ifndef GLX_SGIX_hyperpipe
 #define GLX_SGIX_hyperpipe 1
-
 typedef struct {
-    char    pipeName[GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX];
+    char    pipeName[80]; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
     int     networkId;
 } GLXHyperpipeNetworkSGIX;
-
 typedef struct {
-    char    pipeName[GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX];
+    char    pipeName[80]; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
     int     channel;
-    unsigned int
-      participationType;
+    unsigned int participationType;
     int     timeSlice;
 } GLXHyperpipeConfigSGIX;
-
 typedef struct {
-    char pipeName[GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX];
+    char pipeName[80]; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
     int srcXOrigin, srcYOrigin, srcWidth, srcHeight;
     int destXOrigin, destYOrigin, destWidth, destHeight;
 } GLXPipeRect;
-
 typedef struct {
-    char pipeName[GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX];
+    char pipeName[80]; /* Should be [GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX] */
     int XOrigin, YOrigin, maxHeight, maxWidth;
 } GLXPipeRectLimits;
-
+#define GLX_HYPERPIPE_PIPE_NAME_LENGTH_SGIX 80
+#define GLX_BAD_HYPERPIPE_CONFIG_SGIX     91
+#define GLX_BAD_HYPERPIPE_SGIX            92
+#define GLX_HYPERPIPE_DISPLAY_PIPE_SGIX   0x00000001
+#define GLX_HYPERPIPE_RENDER_PIPE_SGIX    0x00000002
+#define GLX_PIPE_RECT_SGIX                0x00000001
+#define GLX_PIPE_RECT_LIMITS_SGIX         0x00000002
+#define GLX_HYPERPIPE_STEREO_SGIX         0x00000003
+#define GLX_HYPERPIPE_PIXEL_AVERAGE_SGIX  0x00000004
+#define GLX_HYPERPIPE_ID_SGIX             0x8030
+typedef GLXHyperpipeNetworkSGIX *( *PFNGLXQUERYHYPERPIPENETWORKSGIXPROC) (Display *dpy, int *npipes);
+typedef int ( *PFNGLXHYPERPIPECONFIGSGIXPROC) (Display *dpy, int networkId, int npipes, GLXHyperpipeConfigSGIX *cfg, int *hpId);
+typedef GLXHyperpipeConfigSGIX *( *PFNGLXQUERYHYPERPIPECONFIGSGIXPROC) (Display *dpy, int hpId, int *npipes);
+typedef int ( *PFNGLXDESTROYHYPERPIPECONFIGSGIXPROC) (Display *dpy, int hpId);
+typedef int ( *PFNGLXBINDHYPERPIPESGIXPROC) (Display *dpy, int hpId);
+typedef int ( *PFNGLXQUERYHYPERPIPEBESTATTRIBSGIXPROC) (Display *dpy, int timeSlice, int attrib, int size, void *attribList, void *returnAttribList);
+typedef int ( *PFNGLXHYPERPIPEATTRIBSGIXPROC) (Display *dpy, int timeSlice, int attrib, int size, void *attribList);
+typedef int ( *PFNGLXQUERYHYPERPIPEATTRIBSGIXPROC) (Display *dpy, int timeSlice, int attrib, int size, void *returnAttribList);
 #ifdef GLX_GLXEXT_PROTOTYPES
-extern GLXHyperpipeNetworkSGIX * glXQueryHyperpipeNetworkSGIX (Display *dpy, int *npipes);
-extern int glXHyperpipeConfigSGIX (Display *dpy, int networkId, int npipes, GLXHyperpipeConfigSGIX *cfg, int *hpId);
-extern GLXHyperpipeConfigSGIX * glXQueryHyperpipeConfigSGIX (Display *dpy, int hpId, int *npipes);
-extern int glXDestroyHyperpipeConfigSGIX (Display *dpy, int hpId);
-extern int glXBindHyperpipeSGIX (Display *dpy, int hpId);
-extern int glXQueryHyperpipeBestAttribSGIX (Display *dpy, int timeSlice, int attrib, int size, void *attribList, void *returnAttribList);
-extern int glXHyperpipeAttribSGIX (Display *dpy, int timeSlice, int attrib, int size, void *attribList);
-extern int glXQueryHyperpipeAttribSGIX (Display *dpy, int timeSlice, int attrib, int size, void *returnAttribList);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef GLXHyperpipeNetworkSGIX * ( * PFNGLXQUERYHYPERPIPENETWORKSGIXPROC) (Display *dpy, int *npipes);
-typedef int ( * PFNGLXHYPERPIPECONFIGSGIXPROC) (Display *dpy, int networkId, int npipes, GLXHyperpipeConfigSGIX *cfg, int *hpId);
-typedef GLXHyperpipeConfigSGIX * ( * PFNGLXQUERYHYPERPIPECONFIGSGIXPROC) (Display *dpy, int hpId, int *npipes);
-typedef int ( * PFNGLXDESTROYHYPERPIPECONFIGSGIXPROC) (Display *dpy, int hpId);
-typedef int ( * PFNGLXBINDHYPERPIPESGIXPROC) (Display *dpy, int hpId);
-typedef int ( * PFNGLXQUERYHYPERPIPEBESTATTRIBSGIXPROC) (Display *dpy, int timeSlice, int attrib, int size, void *attribList, void *returnAttribList);
-typedef int ( * PFNGLXHYPERPIPEATTRIBSGIXPROC) (Display *dpy, int timeSlice, int attrib, int size, void *attribList);
-typedef int ( * PFNGLXQUERYHYPERPIPEATTRIBSGIXPROC) (Display *dpy, int timeSlice, int attrib, int size, void *returnAttribList);
+GLXHyperpipeNetworkSGIX *glXQueryHyperpipeNetworkSGIX (Display *dpy, int *npipes);
+int glXHyperpipeConfigSGIX (Display *dpy, int networkId, int npipes, GLXHyperpipeConfigSGIX *cfg, int *hpId);
+GLXHyperpipeConfigSGIX *glXQueryHyperpipeConfigSGIX (Display *dpy, int hpId, int *npipes);
+int glXDestroyHyperpipeConfigSGIX (Display *dpy, int hpId);
+int glXBindHyperpipeSGIX (Display *dpy, int hpId);
+int glXQueryHyperpipeBestAttribSGIX (Display *dpy, int timeSlice, int attrib, int size, void *attribList, void *returnAttribList);
+int glXHyperpipeAttribSGIX (Display *dpy, int timeSlice, int attrib, int size, void *attribList);
+int glXQueryHyperpipeAttribSGIX (Display *dpy, int timeSlice, int attrib, int size, void *returnAttribList);
 #endif
+#endif /* GLX_SGIX_hyperpipe */
 
-#ifndef GLX_MESA_agp_offset
-#define GLX_MESA_agp_offset 1
+#ifndef GLX_SGIX_pbuffer
+#define GLX_SGIX_pbuffer 1
+#define GLX_PBUFFER_BIT_SGIX              0x00000004
+#define GLX_BUFFER_CLOBBER_MASK_SGIX      0x08000000
+#define GLX_FRONT_LEFT_BUFFER_BIT_SGIX    0x00000001
+#define GLX_FRONT_RIGHT_BUFFER_BIT_SGIX   0x00000002
+#define GLX_BACK_LEFT_BUFFER_BIT_SGIX     0x00000004
+#define GLX_BACK_RIGHT_BUFFER_BIT_SGIX    0x00000008
+#define GLX_AUX_BUFFERS_BIT_SGIX          0x00000010
+#define GLX_DEPTH_BUFFER_BIT_SGIX         0x00000020
+#define GLX_STENCIL_BUFFER_BIT_SGIX       0x00000040
+#define GLX_ACCUM_BUFFER_BIT_SGIX         0x00000080
+#define GLX_SAMPLE_BUFFERS_BIT_SGIX       0x00000100
+#define GLX_MAX_PBUFFER_WIDTH_SGIX        0x8016
+#define GLX_MAX_PBUFFER_HEIGHT_SGIX       0x8017
+#define GLX_MAX_PBUFFER_PIXELS_SGIX       0x8018
+#define GLX_OPTIMAL_PBUFFER_WIDTH_SGIX    0x8019
+#define GLX_OPTIMAL_PBUFFER_HEIGHT_SGIX   0x801A
+#define GLX_PRESERVED_CONTENTS_SGIX       0x801B
+#define GLX_LARGEST_PBUFFER_SGIX          0x801C
+#define GLX_WIDTH_SGIX                    0x801D
+#define GLX_HEIGHT_SGIX                   0x801E
+#define GLX_EVENT_MASK_SGIX               0x801F
+#define GLX_DAMAGED_SGIX                  0x8020
+#define GLX_SAVED_SGIX                    0x8021
+#define GLX_WINDOW_SGIX                   0x8022
+#define GLX_PBUFFER_SGIX                  0x8023
+typedef GLXPbufferSGIX ( *PFNGLXCREATEGLXPBUFFERSGIXPROC) (Display *dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int *attrib_list);
+typedef void ( *PFNGLXDESTROYGLXPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuf);
+typedef int ( *PFNGLXQUERYGLXPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);
+typedef void ( *PFNGLXSELECTEVENTSGIXPROC) (Display *dpy, GLXDrawable drawable, unsigned long mask);
+typedef void ( *PFNGLXGETSELECTEDEVENTSGIXPROC) (Display *dpy, GLXDrawable drawable, unsigned long *mask);
 #ifdef GLX_GLXEXT_PROTOTYPES
-extern unsigned int glXGetAGPOffsetMESA (const void *pointer);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef unsigned int ( * PFNGLXGETAGPOFFSETMESAPROC) (const void *pointer);
-#endif
-
-#ifndef GLX_EXT_fbconfig_packed_float
-#define GLX_EXT_fbconfig_packed_float 1
+GLXPbufferSGIX glXCreateGLXPbufferSGIX (Display *dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int *attrib_list);
+void glXDestroyGLXPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuf);
+int glXQueryGLXPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);
+void glXSelectEventSGIX (Display *dpy, GLXDrawable drawable, unsigned long mask);
+void glXGetSelectedEventSGIX (Display *dpy, GLXDrawable drawable, unsigned long *mask);
 #endif
+#endif /* GLX_SGIX_pbuffer */
 
-#ifndef GLX_EXT_framebuffer_sRGB
-#define GLX_EXT_framebuffer_sRGB 1
-#endif
-
-#ifndef GLX_EXT_texture_from_pixmap
-#define GLX_EXT_texture_from_pixmap 1
+#ifndef GLX_SGIX_swap_barrier
+#define GLX_SGIX_swap_barrier 1
+typedef void ( *PFNGLXBINDSWAPBARRIERSGIXPROC) (Display *dpy, GLXDrawable drawable, int barrier);
+typedef Bool ( *PFNGLXQUERYMAXSWAPBARRIERSSGIXPROC) (Display *dpy, int screen, int *max);
 #ifdef GLX_GLXEXT_PROTOTYPES
-extern void glXBindTexImageEXT (Display *dpy, GLXDrawable drawable, int buffer, const int *attrib_list);
-extern void glXReleaseTexImageEXT (Display *dpy, GLXDrawable drawable, int buffer);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef void ( * PFNGLXBINDTEXIMAGEEXTPROC) (Display *dpy, GLXDrawable drawable, int buffer, const int *attrib_list);
-typedef void ( * PFNGLXRELEASETEXIMAGEEXTPROC) (Display *dpy, GLXDrawable drawable, int buffer);
+void glXBindSwapBarrierSGIX (Display *dpy, GLXDrawable drawable, int barrier);
+Bool glXQueryMaxSwapBarriersSGIX (Display *dpy, int screen, int *max);
 #endif
+#endif /* GLX_SGIX_swap_barrier */
 
-#ifndef GLX_NV_present_video
-#define GLX_NV_present_video 1
+#ifndef GLX_SGIX_swap_group
+#define GLX_SGIX_swap_group 1
+typedef void ( *PFNGLXJOINSWAPGROUPSGIXPROC) (Display *dpy, GLXDrawable drawable, GLXDrawable member);
 #ifdef GLX_GLXEXT_PROTOTYPES
-extern unsigned int * glXEnumerateVideoDevicesNV (Display *dpy, int screen, int *nelements);
-extern int glXBindVideoDeviceNV (Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef unsigned int * ( * PFNGLXENUMERATEVIDEODEVICESNVPROC) (Display *dpy, int screen, int *nelements);
-typedef int ( * PFNGLXBINDVIDEODEVICENVPROC) (Display *dpy, unsigned int video_slot, unsigned int video_device, const int *attrib_list);
+void glXJoinSwapGroupSGIX (Display *dpy, GLXDrawable drawable, GLXDrawable member);
 #endif
+#endif /* GLX_SGIX_swap_group */
 
-#ifndef GLX_NV_video_output
-#define GLX_NV_video_output 1
+#ifndef GLX_SGIX_video_resize
+#define GLX_SGIX_video_resize 1
+#define GLX_SYNC_FRAME_SGIX               0x00000000
+#define GLX_SYNC_SWAP_SGIX                0x00000001
+typedef int ( *PFNGLXBINDCHANNELTOWINDOWSGIXPROC) (Display *display, int screen, int channel, Window window);
+typedef int ( *PFNGLXCHANNELRECTSGIXPROC) (Display *display, int screen, int channel, int x, int y, int w, int h);
+typedef int ( *PFNGLXQUERYCHANNELRECTSGIXPROC) (Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh);
+typedef int ( *PFNGLXQUERYCHANNELDELTASSGIXPROC) (Display *display, int screen, int channel, int *x, int *y, int *w, int *h);
+typedef int ( *PFNGLXCHANNELRECTSYNCSGIXPROC) (Display *display, int screen, int channel, GLenum synctype);
 #ifdef GLX_GLXEXT_PROTOTYPES
-extern int glXGetVideoDeviceNV (Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice);
-extern int glXReleaseVideoDeviceNV (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice);
-extern int glXBindVideoImageNV (Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer);
-extern int glXReleaseVideoImageNV (Display *dpy, GLXPbuffer pbuf);
-extern int glXSendPbufferToVideoNV (Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock);
-extern int glXGetVideoInfoNV (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef int ( * PFNGLXGETVIDEODEVICENVPROC) (Display *dpy, int screen, int numVideoDevices, GLXVideoDeviceNV *pVideoDevice);
-typedef int ( * PFNGLXRELEASEVIDEODEVICENVPROC) (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice);
-typedef int ( * PFNGLXBINDVIDEOIMAGENVPROC) (Display *dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer);
-typedef int ( * PFNGLXRELEASEVIDEOIMAGENVPROC) (Display *dpy, GLXPbuffer pbuf);
-typedef int ( * PFNGLXSENDPBUFFERTOVIDEONVPROC) (Display *dpy, GLXPbuffer pbuf, int iBufferType, unsigned long *pulCounterPbuffer, GLboolean bBlock);
-typedef int ( * PFNGLXGETVIDEOINFONVPROC) (Display *dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long *pulCounterOutputPbuffer, unsigned long *pulCounterOutputVideo);
+int glXBindChannelToWindowSGIX (Display *display, int screen, int channel, Window window);
+int glXChannelRectSGIX (Display *display, int screen, int channel, int x, int y, int w, int h);
+int glXQueryChannelRectSGIX (Display *display, int screen, int channel, int *dx, int *dy, int *dw, int *dh);
+int glXQueryChannelDeltasSGIX (Display *display, int screen, int channel, int *x, int *y, int *w, int *h);
+int glXChannelRectSyncSGIX (Display *display, int screen, int channel, GLenum synctype);
 #endif
+#endif /* GLX_SGIX_video_resize */
 
-#ifndef GLX_NV_swap_group
-#define GLX_NV_swap_group 1
+#ifndef GLX_SGIX_video_source
+#define GLX_SGIX_video_source 1
+typedef XID GLXVideoSourceSGIX;
+#ifdef _VL_H
+typedef GLXVideoSourceSGIX ( *PFNGLXCREATEGLXVIDEOSOURCESGIXPROC) (Display *display, int screen, VLServer server, VLPath path, int nodeClass, VLNode drainNode);
+typedef void ( *PFNGLXDESTROYGLXVIDEOSOURCESGIXPROC) (Display *dpy, GLXVideoSourceSGIX glxvideosource);
 #ifdef GLX_GLXEXT_PROTOTYPES
-extern Bool glXJoinSwapGroupNV (Display *dpy, GLXDrawable drawable, GLuint group);
-extern Bool glXBindSwapBarrierNV (Display *dpy, GLuint group, GLuint barrier);
-extern Bool glXQuerySwapGroupNV (Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier);
-extern Bool glXQueryMaxSwapGroupsNV (Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers);
-extern Bool glXQueryFrameCountNV (Display *dpy, int screen, GLuint *count);
-extern Bool glXResetFrameCountNV (Display *dpy, int screen);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef Bool ( * PFNGLXJOINSWAPGROUPNVPROC) (Display *dpy, GLXDrawable drawable, GLuint group);
-typedef Bool ( * PFNGLXBINDSWAPBARRIERNVPROC) (Display *dpy, GLuint group, GLuint barrier);
-typedef Bool ( * PFNGLXQUERYSWAPGROUPNVPROC) (Display *dpy, GLXDrawable drawable, GLuint *group, GLuint *barrier);
-typedef Bool ( * PFNGLXQUERYMAXSWAPGROUPSNVPROC) (Display *dpy, int screen, GLuint *maxGroups, GLuint *maxBarriers);
-typedef Bool ( * PFNGLXQUERYFRAMECOUNTNVPROC) (Display *dpy, int screen, GLuint *count);
-typedef Bool ( * PFNGLXRESETFRAMECOUNTNVPROC) (Display *dpy, int screen);
+GLXVideoSourceSGIX glXCreateGLXVideoSourceSGIX (Display *display, int screen, VLServer server, VLPath path, int nodeClass, VLNode drainNode);
+void glXDestroyGLXVideoSourceSGIX (Display *dpy, GLXVideoSourceSGIX glxvideosource);
 #endif
+#endif /* _VL_H */
+#endif /* GLX_SGIX_video_source */
 
-#ifndef GLX_NV_video_capture
-#define GLX_NV_video_capture 1
-#ifdef GLX_GLXEXT_PROTOTYPES
-extern int glXBindVideoCaptureDeviceNV (Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device);
-extern GLXVideoCaptureDeviceNV * glXEnumerateVideoCaptureDevicesNV (Display *dpy, int screen, int *nelements);
-extern void glXLockVideoCaptureDeviceNV (Display *dpy, GLXVideoCaptureDeviceNV device);
-extern int glXQueryVideoCaptureDeviceNV (Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value);
-extern void glXReleaseVideoCaptureDeviceNV (Display *dpy, GLXVideoCaptureDeviceNV device);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef int ( * PFNGLXBINDVIDEOCAPTUREDEVICENVPROC) (Display *dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device);
-typedef GLXVideoCaptureDeviceNV * ( * PFNGLXENUMERATEVIDEOCAPTUREDEVICESNVPROC) (Display *dpy, int screen, int *nelements);
-typedef void ( * PFNGLXLOCKVIDEOCAPTUREDEVICENVPROC) (Display *dpy, GLXVideoCaptureDeviceNV device);
-typedef int ( * PFNGLXQUERYVIDEOCAPTUREDEVICENVPROC) (Display *dpy, GLXVideoCaptureDeviceNV device, int attribute, int *value);
-typedef void ( * PFNGLXRELEASEVIDEOCAPTUREDEVICENVPROC) (Display *dpy, GLXVideoCaptureDeviceNV device);
-#endif
+#ifndef GLX_SGIX_visual_select_group
+#define GLX_SGIX_visual_select_group 1
+#define GLX_VISUAL_SELECT_GROUP_SGIX      0x8028
+#endif /* GLX_SGIX_visual_select_group */
 
-#ifndef GLX_EXT_swap_control
-#define GLX_EXT_swap_control 1
+#ifndef GLX_SGI_cushion
+#define GLX_SGI_cushion 1
+typedef void ( *PFNGLXCUSHIONSGIPROC) (Display *dpy, Window window, float cushion);
 #ifdef GLX_GLXEXT_PROTOTYPES
-extern void glXSwapIntervalEXT (Display *dpy, GLXDrawable drawable, int interval);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef void ( * PFNGLXSWAPINTERVALEXTPROC) (Display *dpy, GLXDrawable drawable, int interval);
+void glXCushionSGI (Display *dpy, Window window, float cushion);
 #endif
+#endif /* GLX_SGI_cushion */
 
-#ifndef GLX_NV_copy_image
-#define GLX_NV_copy_image 1
+#ifndef GLX_SGI_make_current_read
+#define GLX_SGI_make_current_read 1
+typedef Bool ( *PFNGLXMAKECURRENTREADSGIPROC) (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
+typedef GLXDrawable ( *PFNGLXGETCURRENTREADDRAWABLESGIPROC) (void);
 #ifdef GLX_GLXEXT_PROTOTYPES
-extern void glXCopyImageSubDataNV (Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
-#endif /* GLX_GLXEXT_PROTOTYPES */
-typedef void ( * PFNGLXCOPYIMAGESUBDATANVPROC) (Display *dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
+Bool glXMakeCurrentReadSGI (Display *dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx);
+GLXDrawable glXGetCurrentReadDrawableSGI (void);
 #endif
+#endif /* GLX_SGI_make_current_read */
 
-#ifndef GLX_INTEL_swap_event
-#define GLX_INTEL_swap_event 1
+#ifndef GLX_SGI_swap_control
+#define GLX_SGI_swap_control 1
+typedef int ( *PFNGLXSWAPINTERVALSGIPROC) (int interval);
+#ifdef GLX_GLXEXT_PROTOTYPES
+int glXSwapIntervalSGI (int interval);
 #endif
+#endif /* GLX_SGI_swap_control */
 
-#ifndef GLX_NV_multisample_coverage
-#define GLX_NV_multisample_coverage 1
+#ifndef GLX_SGI_video_sync
+#define GLX_SGI_video_sync 1
+typedef int ( *PFNGLXGETVIDEOSYNCSGIPROC) (unsigned int *count);
+typedef int ( *PFNGLXWAITVIDEOSYNCSGIPROC) (int divisor, int remainder, unsigned int *count);
+#ifdef GLX_GLXEXT_PROTOTYPES
+int glXGetVideoSyncSGI (unsigned int *count);
+int glXWaitVideoSyncSGI (int divisor, int remainder, unsigned int *count);
 #endif
+#endif /* GLX_SGI_video_sync */
 
-#ifndef GLX_EXT_swap_control_tear
-#define GLX_EXT_swap_control_tear 1
+#ifndef GLX_SUN_get_transparent_index
+#define GLX_SUN_get_transparent_index 1
+typedef Status ( *PFNGLXGETTRANSPARENTINDEXSUNPROC) (Display *dpy, Window overlay, Window underlay, long *pTransparentIndex);
+#ifdef GLX_GLXEXT_PROTOTYPES
+Status glXGetTransparentIndexSUN (Display *dpy, Window overlay, Window underlay, long *pTransparentIndex);
 #endif
-
+#endif /* GLX_SUN_get_transparent_index */
 
 #ifdef __cplusplus
 }
diff --git a/include/GL/internal/dri_interface.h b/include/GL/internal/dri_interface.h
index 709fece..33b41ea 100644
--- a/include/GL/internal/dri_interface.h
+++ b/include/GL/internal/dri_interface.h
@@ -964,6 +964,8 @@ struct __DRIdri2ExtensionRec {
 #define __DRI_IMAGE_FORMAT_R8           0x1006 /* Since version 5 */
 #define __DRI_IMAGE_FORMAT_GR88         0x1007
 #define __DRI_IMAGE_FORMAT_NONE         0x1008
+#define __DRI_IMAGE_FORMAT_XRGB2101010  0x1009
+#define __DRI_IMAGE_FORMAT_ARGB2101010  0x100a
 
 #define __DRI_IMAGE_USE_SHARE		0x0001
 #define __DRI_IMAGE_USE_SCANOUT		0x0002
diff --git a/include/pci_ids/i965_pci_ids.h b/include/pci_ids/i965_pci_ids.h
index 9e30fe2..9d38a4a 100644
--- a/include/pci_ids/i965_pci_ids.h
+++ b/include/pci_ids/i965_pci_ids.h
@@ -1,93 +1,93 @@
-CHIPSET(0x29A2, I965_G,                 "Intel(R) 965G")
-CHIPSET(0x2992, I965_Q,                 "Intel(R) 965Q")
-CHIPSET(0x2982, I965_G_1,               "Intel(R) 965G")
-CHIPSET(0x2972, I946_GZ,                "Intel(R) 946GZ")
-CHIPSET(0x2A02, I965_GM,                "Intel(R) 965GM")
-CHIPSET(0x2A12, I965_GME,               "Intel(R) 965GME/GLE")
-CHIPSET(0x2A42, GM45_GM,                "Mobile Intel® GM45 Express Chipset")
-CHIPSET(0x2E02, IGD_E_G,                "Intel(R) Integrated Graphics Device")
-CHIPSET(0x2E12, Q45_G,                  "Intel(R) Q45/Q43")
-CHIPSET(0x2E22, G45_G,                  "Intel(R) G45/G43")
-CHIPSET(0x2E32, G41_G,                  "Intel(R) G41")
-CHIPSET(0x2E42, B43_G,                  "Intel(R) B43")
-CHIPSET(0x2E92, B43_G1,                 "Intel(R) B43")
-CHIPSET(0x0042, ILD_G,                  "Intel(R) Ironlake Desktop")
-CHIPSET(0x0046, ILM_G,                  "Intel(R) Ironlake Mobile")
-CHIPSET(0x0102, SANDYBRIDGE_GT1,        "Intel(R) Sandybridge Desktop")
-CHIPSET(0x0112, SANDYBRIDGE_GT2,        "Intel(R) Sandybridge Desktop")
-CHIPSET(0x0122, SANDYBRIDGE_GT2_PLUS,   "Intel(R) Sandybridge Desktop")
-CHIPSET(0x0106, SANDYBRIDGE_M_GT1,      "Intel(R) Sandybridge Mobile")
-CHIPSET(0x0116, SANDYBRIDGE_M_GT2,      "Intel(R) Sandybridge Mobile")
-CHIPSET(0x0126, SANDYBRIDGE_M_GT2_PLUS, "Intel(R) Sandybridge Mobile")
-CHIPSET(0x010A, SANDYBRIDGE_S,          "Intel(R) Sandybridge Server")
-CHIPSET(0x0152, IVYBRIDGE_GT1,          "Intel(R) Ivybridge Desktop")
-CHIPSET(0x0162, IVYBRIDGE_GT2,          "Intel(R) Ivybridge Desktop")
-CHIPSET(0x0156, IVYBRIDGE_M_GT1,        "Intel(R) Ivybridge Mobile")
-CHIPSET(0x0166, IVYBRIDGE_M_GT2,        "Intel(R) Ivybridge Mobile")
-CHIPSET(0x015a, IVYBRIDGE_S_GT1,        "Intel(R) Ivybridge Server")
-CHIPSET(0x016a, IVYBRIDGE_S_GT2,        "Intel(R) Ivybridge Server")
-CHIPSET(0x0402, HASWELL_GT1,            "Intel(R) Haswell Desktop")
-CHIPSET(0x0412, HASWELL_GT2,            "Intel(R) Haswell Desktop")
-CHIPSET(0x0422, HASWELL_GT3,            "Intel(R) Haswell Desktop")
-CHIPSET(0x0406, HASWELL_M_GT1,          "Intel(R) Haswell Mobile")
-CHIPSET(0x0416, HASWELL_M_GT2,          "Intel(R) Haswell Mobile")
-CHIPSET(0x0426, HASWELL_M_GT3,          "Intel(R) Haswell Mobile")
-CHIPSET(0x040A, HASWELL_S_GT1,          "Intel(R) Haswell Server")
-CHIPSET(0x041A, HASWELL_S_GT2,          "Intel(R) Haswell Server")
-CHIPSET(0x042A, HASWELL_S_GT3,          "Intel(R) Haswell Server")
-CHIPSET(0x040B, HASWELL_B_GT1,          "Intel(R) Haswell")
-CHIPSET(0x041B, HASWELL_B_GT2,          "Intel(R) Haswell")
-CHIPSET(0x042B, HASWELL_B_GT3,          "Intel(R) Haswell")
-CHIPSET(0x040E, HASWELL_E_GT1,          "Intel(R) Haswell")
-CHIPSET(0x041E, HASWELL_E_GT2,          "Intel(R) Haswell")
-CHIPSET(0x042E, HASWELL_E_GT3,          "Intel(R) Haswell")
-CHIPSET(0x0C02, HASWELL_SDV_GT1,        "Intel(R) Haswell Desktop")
-CHIPSET(0x0C12, HASWELL_SDV_GT2,        "Intel(R) Haswell Desktop")
-CHIPSET(0x0C22, HASWELL_SDV_GT3,        "Intel(R) Haswell Desktop")
-CHIPSET(0x0C06, HASWELL_SDV_M_GT1,      "Intel(R) Haswell Mobile")
-CHIPSET(0x0C16, HASWELL_SDV_M_GT2,      "Intel(R) Haswell Mobile")
-CHIPSET(0x0C26, HASWELL_SDV_M_GT3,      "Intel(R) Haswell Mobile")
-CHIPSET(0x0C0A, HASWELL_SDV_S_GT1,      "Intel(R) Haswell Server")
-CHIPSET(0x0C1A, HASWELL_SDV_S_GT2,      "Intel(R) Haswell Server")
-CHIPSET(0x0C2A, HASWELL_SDV_S_GT3,      "Intel(R) Haswell Server")
-CHIPSET(0x0C0B, HASWELL_SDV_B_GT1,      "Intel(R) Haswell")
-CHIPSET(0x0C1B, HASWELL_SDV_B_GT2,      "Intel(R) Haswell")
-CHIPSET(0x0C2B, HASWELL_SDV_B_GT3,      "Intel(R) Haswell")
-CHIPSET(0x0C0E, HASWELL_SDV_E_GT1,      "Intel(R) Haswell")
-CHIPSET(0x0C1E, HASWELL_SDV_E_GT2,      "Intel(R) Haswell")
-CHIPSET(0x0C2E, HASWELL_SDV_E_GT3,      "Intel(R) Haswell")
-CHIPSET(0x0A02, HASWELL_ULT_GT1,        "Intel(R) Haswell Desktop")
-CHIPSET(0x0A12, HASWELL_ULT_GT2,        "Intel(R) Haswell Desktop")
-CHIPSET(0x0A22, HASWELL_ULT_GT3,        "Intel(R) Haswell Desktop")
-CHIPSET(0x0A06, HASWELL_ULT_M_GT1,      "Intel(R) Haswell Mobile")
-CHIPSET(0x0A16, HASWELL_ULT_M_GT2,      "Intel(R) Haswell Mobile")
-CHIPSET(0x0A26, HASWELL_ULT_M_GT3,      "Intel(R) Haswell Mobile")
-CHIPSET(0x0A0A, HASWELL_ULT_S_GT1,      "Intel(R) Haswell Server")
-CHIPSET(0x0A1A, HASWELL_ULT_S_GT2,      "Intel(R) Haswell Server")
-CHIPSET(0x0A2A, HASWELL_ULT_S_GT3,      "Intel(R) Haswell Server")
-CHIPSET(0x0A0B, HASWELL_ULT_B_GT1,      "Intel(R) Haswell")
-CHIPSET(0x0A1B, HASWELL_ULT_B_GT2,      "Intel(R) Haswell")
-CHIPSET(0x0A2B, HASWELL_ULT_B_GT3,      "Intel(R) Haswell")
-CHIPSET(0x0A0E, HASWELL_ULT_E_GT1,      "Intel(R) Haswell")
-CHIPSET(0x0A1E, HASWELL_ULT_E_GT2,      "Intel(R) Haswell")
-CHIPSET(0x0A2E, HASWELL_ULT_E_GT3,      "Intel(R) Haswell")
-CHIPSET(0x0D02, HASWELL_CRW_GT1,        "Intel(R) Haswell Desktop")
-CHIPSET(0x0D12, HASWELL_CRW_GT2,        "Intel(R) Haswell Desktop")
-CHIPSET(0x0D22, HASWELL_CRW_GT3,        "Intel(R) Haswell Desktop")
-CHIPSET(0x0D06, HASWELL_CRW_M_GT1,      "Intel(R) Haswell Mobile")
-CHIPSET(0x0D16, HASWELL_CRW_M_GT2,      "Intel(R) Haswell Mobile")
-CHIPSET(0x0D26, HASWELL_CRW_M_GT3,      "Intel(R) Haswell Mobile")
-CHIPSET(0x0D0A, HASWELL_CRW_S_GT1,      "Intel(R) Haswell Server")
-CHIPSET(0x0D1A, HASWELL_CRW_S_GT2,      "Intel(R) Haswell Server")
-CHIPSET(0x0D2A, HASWELL_CRW_S_GT3,      "Intel(R) Haswell")
-CHIPSET(0x0D0B, HASWELL_CRW_B_GT1,      "Intel(R) Haswell")
-CHIPSET(0x0D1B, HASWELL_CRW_B_GT2,      "Intel(R) Haswell")
-CHIPSET(0x0D2B, HASWELL_CRW_B_GT3,      "Intel(R) Haswell")
-CHIPSET(0x0D0E, HASWELL_CRW_E_GT1,      "Intel(R) Haswell")
-CHIPSET(0x0D1E, HASWELL_CRW_E_GT2,      "Intel(R) Haswell")
-CHIPSET(0x0D2E, HASWELL_CRW_E_GT3,      "Intel(R) Haswell")
-CHIPSET(0x0F31, BAYTRAIL_M_1,           "Intel(R) Bay Trail")
-CHIPSET(0x0F32, BAYTRAIL_M_2,           "Intel(R) Bay Trail")
-CHIPSET(0x0F33, BAYTRAIL_M_3,           "Intel(R) Bay Trail")
-CHIPSET(0x0157, BAYTRAIL_M_4,           "Intel(R) Bay Trail")
-CHIPSET(0x0155, BAYTRAIL_D,             "Intel(R) Bay Trail")
+CHIPSET(0x29A2, i965,    "Intel(R) 965G")
+CHIPSET(0x2992, i965,    "Intel(R) 965Q")
+CHIPSET(0x2982, i965,    "Intel(R) 965G")
+CHIPSET(0x2972, i965,    "Intel(R) 946GZ")
+CHIPSET(0x2A02, i965,    "Intel(R) 965GM")
+CHIPSET(0x2A12, i965,    "Intel(R) 965GME/GLE")
+CHIPSET(0x2A42, g4x,     "Mobile Intel® GM45 Express Chipset")
+CHIPSET(0x2E02, g4x,     "Intel(R) Integrated Graphics Device")
+CHIPSET(0x2E12, g4x,     "Intel(R) Q45/Q43")
+CHIPSET(0x2E22, g4x,     "Intel(R) G45/G43")
+CHIPSET(0x2E32, g4x,     "Intel(R) G41")
+CHIPSET(0x2E42, g4x,     "Intel(R) B43")
+CHIPSET(0x2E92, g4x,     "Intel(R) B43")
+CHIPSET(0x0042, ilk,     "Intel(R) Ironlake Desktop")
+CHIPSET(0x0046, ilk,     "Intel(R) Ironlake Mobile")
+CHIPSET(0x0102, snb_gt1, "Intel(R) Sandybridge Desktop")
+CHIPSET(0x0112, snb_gt2, "Intel(R) Sandybridge Desktop")
+CHIPSET(0x0122, snb_gt2, "Intel(R) Sandybridge Desktop")
+CHIPSET(0x0106, snb_gt1, "Intel(R) Sandybridge Mobile")
+CHIPSET(0x0116, snb_gt2, "Intel(R) Sandybridge Mobile")
+CHIPSET(0x0126, snb_gt2, "Intel(R) Sandybridge Mobile")
+CHIPSET(0x010A, snb_gt1, "Intel(R) Sandybridge Server")
+CHIPSET(0x0152, ivb_gt1, "Intel(R) Ivybridge Desktop")
+CHIPSET(0x0162, ivb_gt2, "Intel(R) Ivybridge Desktop")
+CHIPSET(0x0156, ivb_gt1, "Intel(R) Ivybridge Mobile")
+CHIPSET(0x0166, ivb_gt2, "Intel(R) Ivybridge Mobile")
+CHIPSET(0x015a, ivb_gt1, "Intel(R) Ivybridge Server")
+CHIPSET(0x016a, ivb_gt2, "Intel(R) Ivybridge Server")
+CHIPSET(0x0402, hsw_gt1, "Intel(R) Haswell Desktop")
+CHIPSET(0x0412, hsw_gt2, "Intel(R) Haswell Desktop")
+CHIPSET(0x0422, hsw_gt3, "Intel(R) Haswell Desktop")
+CHIPSET(0x0406, hsw_gt1, "Intel(R) Haswell Mobile")
+CHIPSET(0x0416, hsw_gt2, "Intel(R) Haswell Mobile")
+CHIPSET(0x0426, hsw_gt3, "Intel(R) Haswell Mobile")
+CHIPSET(0x040A, hsw_gt1, "Intel(R) Haswell Server")
+CHIPSET(0x041A, hsw_gt2, "Intel(R) Haswell Server")
+CHIPSET(0x042A, hsw_gt3, "Intel(R) Haswell Server")
+CHIPSET(0x040B, hsw_gt1, "Intel(R) Haswell")
+CHIPSET(0x041B, hsw_gt2, "Intel(R) Haswell")
+CHIPSET(0x042B, hsw_gt3, "Intel(R) Haswell")
+CHIPSET(0x040E, hsw_gt1, "Intel(R) Haswell")
+CHIPSET(0x041E, hsw_gt2, "Intel(R) Haswell")
+CHIPSET(0x042E, hsw_gt3, "Intel(R) Haswell")
+CHIPSET(0x0C02, hsw_gt1, "Intel(R) Haswell Desktop")
+CHIPSET(0x0C12, hsw_gt2, "Intel(R) Haswell Desktop")
+CHIPSET(0x0C22, hsw_gt3, "Intel(R) Haswell Desktop")
+CHIPSET(0x0C06, hsw_gt1, "Intel(R) Haswell Mobile")
+CHIPSET(0x0C16, hsw_gt2, "Intel(R) Haswell Mobile")
+CHIPSET(0x0C26, hsw_gt3, "Intel(R) Haswell Mobile")
+CHIPSET(0x0C0A, hsw_gt1, "Intel(R) Haswell Server")
+CHIPSET(0x0C1A, hsw_gt2, "Intel(R) Haswell Server")
+CHIPSET(0x0C2A, hsw_gt3, "Intel(R) Haswell Server")
+CHIPSET(0x0C0B, hsw_gt1, "Intel(R) Haswell")
+CHIPSET(0x0C1B, hsw_gt2, "Intel(R) Haswell")
+CHIPSET(0x0C2B, hsw_gt3, "Intel(R) Haswell")
+CHIPSET(0x0C0E, hsw_gt1, "Intel(R) Haswell")
+CHIPSET(0x0C1E, hsw_gt2, "Intel(R) Haswell")
+CHIPSET(0x0C2E, hsw_gt3, "Intel(R) Haswell")
+CHIPSET(0x0A02, hsw_gt1, "Intel(R) Haswell Desktop")
+CHIPSET(0x0A12, hsw_gt2, "Intel(R) Haswell Desktop")
+CHIPSET(0x0A22, hsw_gt3, "Intel(R) Haswell Desktop")
+CHIPSET(0x0A06, hsw_gt1, "Intel(R) Haswell Mobile")
+CHIPSET(0x0A16, hsw_gt2, "Intel(R) Haswell Mobile")
+CHIPSET(0x0A26, hsw_gt3, "Intel(R) Haswell Mobile")
+CHIPSET(0x0A0A, hsw_gt1, "Intel(R) Haswell Server")
+CHIPSET(0x0A1A, hsw_gt2, "Intel(R) Haswell Server")
+CHIPSET(0x0A2A, hsw_gt3, "Intel(R) Haswell Server")
+CHIPSET(0x0A0B, hsw_gt1, "Intel(R) Haswell")
+CHIPSET(0x0A1B, hsw_gt2, "Intel(R) Haswell")
+CHIPSET(0x0A2B, hsw_gt3, "Intel(R) Haswell")
+CHIPSET(0x0A0E, hsw_gt1, "Intel(R) Haswell")
+CHIPSET(0x0A1E, hsw_gt2, "Intel(R) Haswell")
+CHIPSET(0x0A2E, hsw_gt3, "Intel(R) Haswell")
+CHIPSET(0x0D02, hsw_gt1, "Intel(R) Haswell Desktop")
+CHIPSET(0x0D12, hsw_gt2, "Intel(R) Haswell Desktop")
+CHIPSET(0x0D22, hsw_gt3, "Intel(R) Haswell Desktop")
+CHIPSET(0x0D06, hsw_gt1, "Intel(R) Haswell Mobile")
+CHIPSET(0x0D16, hsw_gt2, "Intel(R) Haswell Mobile")
+CHIPSET(0x0D26, hsw_gt3, "Intel(R) Haswell Mobile")
+CHIPSET(0x0D0A, hsw_gt1, "Intel(R) Haswell Server")
+CHIPSET(0x0D1A, hsw_gt2, "Intel(R) Haswell Server")
+CHIPSET(0x0D2A, hsw_gt3, "Intel(R) Haswell")
+CHIPSET(0x0D0B, hsw_gt1, "Intel(R) Haswell")
+CHIPSET(0x0D1B, hsw_gt2, "Intel(R) Haswell")
+CHIPSET(0x0D2B, hsw_gt3, "Intel(R) Haswell")
+CHIPSET(0x0D0E, hsw_gt1, "Intel(R) Haswell")
+CHIPSET(0x0D1E, hsw_gt2, "Intel(R) Haswell")
+CHIPSET(0x0D2E, hsw_gt3, "Intel(R) Haswell")
+CHIPSET(0x0F31, byt,     "Intel(R) Bay Trail")
+CHIPSET(0x0F32, byt,     "Intel(R) Bay Trail")
+CHIPSET(0x0F33, byt,     "Intel(R) Bay Trail")
+CHIPSET(0x0157, byt,     "Intel(R) Bay Trail")
+CHIPSET(0x0155, byt,     "Intel(R) Bay Trail")
diff --git a/include/pci_ids/pci_id_driver_map.h b/include/pci_ids/pci_id_driver_map.h
index 1d1f3c3..8a97c6f 100644
--- a/include/pci_ids/pci_id_driver_map.h
+++ b/include/pci_ids/pci_id_driver_map.h
@@ -14,7 +14,7 @@ static const int i915_chip_ids[] = {
 };
 
 static const int i965_chip_ids[] = {
-#define CHIPSET(chip, desc, name) chip,
+#define CHIPSET(chip, family, name) chip,
 #include "pci_ids/i965_pci_ids.h"
 #undef CHIPSET
 };
diff --git a/scons/gallium.py b/scons/gallium.py
index 2e341e9..5b20f3f 100755
--- a/scons/gallium.py
+++ b/scons/gallium.py
@@ -506,6 +506,8 @@ def generate(env):
         libs += ['m', 'pthread', 'dl']
     if env['platform'] in ('linux',):
         libs += ['rt']
+    if env['platform'] in ('haiku'):
+        libs += ['root', 'be', 'network']
     env.Append(LIBS = libs)
 
     # OpenMP
diff --git a/scons/llvm.py b/scons/llvm.py
index 7cd609c..8388d8e 100644
--- a/scons/llvm.py
+++ b/scons/llvm.py
@@ -190,14 +190,16 @@ def generate(env):
                 pass
             env.MergeFlags(cppflags)
 
+            # Match llvm --fno-rtti flag
+            cxxflags = env.backtick('llvm-config --cxxflags').split()
+            if '-fno-rtti' in cxxflags:
+                env.Append(CXXFLAGS = ['-fno-rtti'])
+
             components = ['engine', 'bitwriter', 'x86asmprinter']
 
             if llvm_version >= distutils.version.LooseVersion('3.1'):
                 components.append('mcjit')
 
-            if llvm_version >= distutils.version.LooseVersion('3.2'):
-                env.Append(CXXFLAGS = ('-fno-rtti',))
-
             env.ParseConfig('llvm-config --libs ' + ' '.join(components))
             env.ParseConfig('llvm-config --ldflags')
         except OSError:
diff --git a/src/egl/drivers/dri2/egl_dri2.c b/src/egl/drivers/dri2/egl_dri2.c
index 04ab564..b29eb1c 100644
--- a/src/egl/drivers/dri2/egl_dri2.c
+++ b/src/egl/drivers/dri2/egl_dri2.c
@@ -116,7 +116,7 @@ dri2_match_config(const _EGLConfig *conf, const _EGLConfig *criteria)
 
 struct dri2_egl_config *
 dri2_add_config(_EGLDisplay *disp, const __DRIconfig *dri_config, int id,
-		int depth, EGLint surface_type, const EGLint *attr_list,
+		EGLint surface_type, const EGLint *attr_list,
 		const unsigned int *rgba_masks)
 {
    struct dri2_egl_config *conf;
@@ -200,16 +200,6 @@ dri2_add_config(_EGLDisplay *disp, const __DRIconfig *dri_config, int id,
       for (i = 0; attr_list[i] != EGL_NONE; i += 2)
          _eglSetConfigKey(&base, attr_list[i], attr_list[i+1]);
 
-   /* Allow a 24-bit RGB visual to match a 32-bit RGBA EGLConfig.  Otherwise
-    * it will only match a 32-bit RGBA visual.  On a composited window manager
-    * on X11, this will make all of the EGLConfigs with destination alpha get
-    * blended by the compositor.  This is probably not what the application
-    * wants... especially on drivers that only have 32-bit RGBA EGLConfigs!
-    */
-   if (depth > 0 && depth != base.BufferSize
-       && !(depth == 24 && base.BufferSize == 32))
-      return NULL;
-
    if (rgba_masks && memcmp(rgba_masks, dri_masks, sizeof(dri_masks)))
       return NULL;
 
@@ -1212,7 +1202,8 @@ dri2_create_image_wayland_wl_buffer(_EGLDisplay *disp, _EGLContext *ctx,
    EGLint err;
    int32_t plane;
 
-   buffer = wayland_drm_buffer_get((struct wl_resource *) _buffer);
+   buffer = wayland_drm_buffer_get(dri2_dpy->wl_server_drm,
+                                   (struct wl_resource *) _buffer);
    if (!buffer)
        return NULL;
 
@@ -1852,6 +1843,11 @@ dri2_bind_wayland_display_wl(_EGLDriver *drv, _EGLDisplay *disp,
    if (!dri2_dpy->wl_server_drm)
 	   return EGL_FALSE;
 
+   /* We have to share the wl_drm instance with gbm, so gbm can convert
+    * wl_buffers to gbm bos. */
+   if (dri2_dpy->gbm_dri)
+      dri2_dpy->gbm_dri->wl_drm = dri2_dpy->wl_server_drm;
+
    return EGL_TRUE;
 }
 
@@ -1877,10 +1873,11 @@ dri2_query_wayland_buffer_wl(_EGLDriver *drv, _EGLDisplay *disp,
                              struct wl_resource *buffer_resource,
                              EGLint attribute, EGLint *value)
 {
+   struct dri2_egl_display *dri2_dpy = dri2_egl_display(disp);
    struct wl_drm_buffer *buffer;
    const struct wl_drm_components_descriptor *format;
 
-   buffer = wayland_drm_buffer_get(buffer_resource);
+   buffer = wayland_drm_buffer_get(dri2_dpy->wl_server_drm, buffer_resource);
    if (!buffer)
       return EGL_FALSE;
 
diff --git a/src/egl/drivers/dri2/egl_dri2.h b/src/egl/drivers/dri2/egl_dri2.h
index fba5f81..4a39efb 100644
--- a/src/egl/drivers/dri2/egl_dri2.h
+++ b/src/egl/drivers/dri2/egl_dri2.h
@@ -246,7 +246,7 @@ dri2_lookup_egl_image(__DRIscreen *screen, void *image, void *data);
 
 struct dri2_egl_config *
 dri2_add_config(_EGLDisplay *disp, const __DRIconfig *dri_config, int id,
-		int depth, EGLint surface_type, const EGLint *attr_list,
+		EGLint surface_type, const EGLint *attr_list,
 		const unsigned int *rgba_masks);
 
 _EGLImage *
diff --git a/src/egl/drivers/dri2/platform_android.c b/src/egl/drivers/dri2/platform_android.c
index ff41e83..2c20de7 100644
--- a/src/egl/drivers/dri2/platform_android.c
+++ b/src/egl/drivers/dri2/platform_android.c
@@ -547,14 +547,13 @@ droid_add_configs_for_visuals(_EGLDriver *drv, _EGLDisplay *dpy)
    struct dri2_egl_display *dri2_dpy = dri2_egl_display(dpy);
    const struct {
       int format;
-      int size;
       unsigned int rgba_masks[4];
    } visuals[] = {
-      { HAL_PIXEL_FORMAT_RGBA_8888, 32, { 0xff, 0xff00, 0xff0000, 0xff000000 } },
-      { HAL_PIXEL_FORMAT_RGBX_8888, 32, { 0xff, 0xff00, 0xff0000, 0x0 } },
-      { HAL_PIXEL_FORMAT_RGB_888,   24, { 0xff, 0xff00, 0xff0000, 0x0 } },
-      { HAL_PIXEL_FORMAT_RGB_565,   16, { 0xf800, 0x7e0, 0x1f, 0x0 } },
-      { HAL_PIXEL_FORMAT_BGRA_8888, 32, { 0xff0000, 0xff00, 0xff, 0xff000000 } },
+      { HAL_PIXEL_FORMAT_RGBA_8888, { 0xff, 0xff00, 0xff0000, 0xff000000 } },
+      { HAL_PIXEL_FORMAT_RGBX_8888, { 0xff, 0xff00, 0xff0000, 0x0 } },
+      { HAL_PIXEL_FORMAT_RGB_888,   { 0xff, 0xff00, 0xff0000, 0x0 } },
+      { HAL_PIXEL_FORMAT_RGB_565,   { 0xf800, 0x7e0, 0x1f, 0x0 } },
+      { HAL_PIXEL_FORMAT_BGRA_8888, { 0xff0000, 0xff00, 0xff, 0xff000000 } },
       { 0, 0, { 0, 0, 0, 0 } }
    };
    int count, i, j;
@@ -576,8 +575,7 @@ droid_add_configs_for_visuals(_EGLDriver *drv, _EGLDisplay *dpy)
             continue;
 
          dri2_conf = dri2_add_config(dpy, dri2_dpy->driver_configs[j],
-               count + 1, visuals[i].size, surface_type, NULL,
-               visuals[i].rgba_masks);
+               count + 1, surface_type, NULL, visuals[i].rgba_masks);
          if (dri2_conf) {
             dri2_conf->base.NativeVisualID = visuals[i].format;
             dri2_conf->base.NativeVisualType = visuals[i].format;
diff --git a/src/egl/drivers/dri2/platform_drm.c b/src/egl/drivers/dri2/platform_drm.c
index 615648b..7b1e3a1 100644
--- a/src/egl/drivers/dri2/platform_drm.c
+++ b/src/egl/drivers/dri2/platform_drm.c
@@ -476,9 +476,28 @@ dri2_initialize_drm(_EGLDriver *drv, _EGLDisplay *disp)
 
    dri2_setup_screen(disp);
 
-   for (i = 0; dri2_dpy->driver_configs[i]; i++)
+   for (i = 0; dri2_dpy->driver_configs[i]; i++) {
+      EGLint format, attr_list[3];
+      unsigned int mask;
+
+      dri2_dpy->core->getConfigAttrib(dri2_dpy->driver_configs[i],
+                                       __DRI_ATTRIB_RED_MASK, &mask);
+      if (mask == 0x3ff00000)
+         format = GBM_FORMAT_XRGB2101010;
+      else if (mask == 0x00ff0000)
+         format = GBM_FORMAT_XRGB8888;
+      else if (mask == 0xf800)
+         format = GBM_FORMAT_RGB565;
+      else
+         continue;
+
+      attr_list[0] = EGL_NATIVE_VISUAL_ID;
+      attr_list[1] = format;
+      attr_list[2] = EGL_NONE;
+
       dri2_add_config(disp, dri2_dpy->driver_configs[i],
-                      i + 1, 0, EGL_WINDOW_BIT, NULL, NULL);
+                      i + 1, EGL_WINDOW_BIT, attr_list, NULL);
+   }
 
    drv->API.CreateWindowSurface = dri2_create_window_surface;
    drv->API.DestroySurface = dri2_destroy_surface;
diff --git a/src/egl/drivers/dri2/platform_wayland.c b/src/egl/drivers/dri2/platform_wayland.c
index 1d417bb..c0de16b 100644
--- a/src/egl/drivers/dri2/platform_wayland.c
+++ b/src/egl/drivers/dri2/platform_wayland.c
@@ -42,7 +42,8 @@
 
 enum wl_drm_format_flags {
    HAS_ARGB8888 = 1,
-   HAS_XRGB8888 = 2
+   HAS_XRGB8888 = 2,
+   HAS_RGB565 = 4,
 };
 
 static void
@@ -132,7 +133,9 @@ dri2_create_surface(_EGLDriver *drv, _EGLDisplay *disp, EGLint type,
    if (!_eglInitSurface(&dri2_surf->base, disp, type, conf, attrib_list))
       goto cleanup_surf;
 
-   if (conf->AlphaSize == 0)
+   if (conf->RedSize == 5)
+      dri2_surf->format = WL_DRM_FORMAT_RGB565;
+   else if (conf->AlphaSize == 0)
       dri2_surf->format = WL_DRM_FORMAT_XRGB8888;
    else
       dri2_surf->format = WL_DRM_FORMAT_ARGB8888;
@@ -674,6 +677,9 @@ drm_handle_format(void *data, struct wl_drm *drm, uint32_t format)
    case WL_DRM_FORMAT_XRGB8888:
       dri2_dpy->formats |= HAS_XRGB8888;
       break;
+   case WL_DRM_FORMAT_RGB565:
+      dri2_dpy->formats |= HAS_RGB565;
+      break;
    }
 }
 
@@ -736,6 +742,7 @@ dri2_initialize_wayland(_EGLDriver *drv, _EGLDisplay *disp)
    static const unsigned int argb_masks[4] =
       { 0xff0000, 0xff00, 0xff, 0xff000000 };
    static const unsigned int rgb_masks[4] = { 0xff0000, 0xff00, 0xff, 0 };
+   static const unsigned int rgb565_masks[4] = { 0xf800, 0x07e0, 0x001f, 0 };
 
    drv->API.CreateWindowSurface = dri2_create_window_surface;
    drv->API.DestroySurface = dri2_destroy_surface;
@@ -814,9 +821,11 @@ dri2_initialize_wayland(_EGLDriver *drv, _EGLDisplay *disp)
    for (i = 0; dri2_dpy->driver_configs[i]; i++) {
       config = dri2_dpy->driver_configs[i];
       if (dri2_dpy->formats & HAS_XRGB8888)
-	 dri2_add_config(disp, config, i + 1, 0, types, NULL, rgb_masks);
+	 dri2_add_config(disp, config, i + 1, types, NULL, rgb_masks);
       if (dri2_dpy->formats & HAS_ARGB8888)
-	 dri2_add_config(disp, config, i + 1, 0, types, NULL, argb_masks);
+	 dri2_add_config(disp, config, i + 1, types, NULL, argb_masks);
+      if (dri2_dpy->formats & HAS_RGB565)
+        dri2_add_config(disp, config, i + 1, types, NULL, rgb565_masks);
    }
 
    disp->Extensions.WL_bind_wayland_display = EGL_TRUE;
diff --git a/src/egl/drivers/dri2/platform_x11.c b/src/egl/drivers/dri2/platform_x11.c
index ec76aec..a518db1 100644
--- a/src/egl/drivers/dri2/platform_x11.c
+++ b/src/egl/drivers/dri2/platform_x11.c
@@ -630,6 +630,7 @@ dri2_add_configs_for_visuals(struct dri2_egl_display *dri2_dpy,
    xcb_depth_iterator_t d;
    xcb_visualtype_t *visuals;
    int i, j, id;
+   unsigned int rgba_masks[4];
    EGLint surface_type;
    EGLint config_attrs[] = {
 	   EGL_NATIVE_VISUAL_ID,   0,
@@ -660,8 +661,26 @@ dri2_add_configs_for_visuals(struct dri2_egl_display *dri2_dpy,
             config_attrs[1] = visuals[i].visual_id;
             config_attrs[3] = visuals[i]._class;
 
+            rgba_masks[0] = visuals[i].red_mask;
+            rgba_masks[1] = visuals[i].green_mask;
+            rgba_masks[2] = visuals[i].blue_mask;
+            rgba_masks[3] = 0;
 	    dri2_add_config(disp, dri2_dpy->driver_configs[j], id++,
-			    d.data->depth, surface_type, config_attrs, NULL);
+			    surface_type, config_attrs, rgba_masks);
+
+            /* Allow a 24-bit RGB visual to match a 32-bit RGBA EGLConfig.
+             * Otherwise it will only match a 32-bit RGBA visual.  On a
+             * composited window manager on X11, this will make all of the
+             * EGLConfigs with destination alpha get blended by the
+             * compositor.  This is probably not what the application
+             * wants... especially on drivers that only have 32-bit RGBA
+             * EGLConfigs! */
+            if (d.data->depth == 24) {
+               rgba_masks[3] =
+                  ~(rgba_masks[0] | rgba_masks[1] | rgba_masks[2]);
+               dri2_add_config(disp, dri2_dpy->driver_configs[j], id++,
+                               surface_type, config_attrs, rgba_masks);
+            }
 	 }
       }
 
diff --git a/src/egl/main/Makefile.am b/src/egl/main/Makefile.am
index 786406a..60cb600 100644
--- a/src/egl/main/Makefile.am
+++ b/src/egl/main/Makefile.am
@@ -105,7 +105,7 @@ endif
 if HAVE_EGL_DRIVER_GLX
 AM_CFLAGS += -D_EGL_BUILT_IN_DRIVER_GLX
 libEGL_la_LIBADD += ../drivers/glx/libegl_glx.la
-libEGL_la_LIBADD += $(X11_LIBS) $(DLOPEN_LIBS)
+libEGL_la_LIBADD += $(DLOPEN_LIBS)
 endif
 
 if HAVE_EGL_DRIVER_DRI2
diff --git a/src/egl/wayland/wayland-drm/wayland-drm.c b/src/egl/wayland/wayland-drm/wayland-drm.c
index d317c5e..06bd18c 100644
--- a/src/egl/wayland/wayland-drm/wayland-drm.c
+++ b/src/egl/wayland/wayland-drm/wayland-drm.c
@@ -47,6 +47,8 @@ struct wl_drm {
         uint32_t flags;
 
 	struct wayland_drm_callbacks *callbacks;
+
+        struct wl_buffer_interface buffer_interface;
 };
 
 static void
@@ -65,10 +67,6 @@ buffer_destroy(struct wl_client *client, struct wl_resource *resource)
 	wl_resource_destroy(resource);
 }
 
-const static struct wl_buffer_interface drm_buffer_interface = {
-	buffer_destroy
-};
-
 static void
 create_buffer(struct wl_client *client, struct wl_resource *resource,
               uint32_t id, uint32_t name, int fd,
@@ -115,7 +113,7 @@ create_buffer(struct wl_client *client, struct wl_resource *resource,
 	}
 
 	wl_resource_set_implementation(buffer->resource,
-				       (void (**)(void)) &drm_buffer_interface,
+				       (void (**)(void)) &drm->buffer_interface,
 				       buffer, destroy_buffer);
 }
 
@@ -128,6 +126,7 @@ drm_create_buffer(struct wl_client *client, struct wl_resource *resource,
         case WL_DRM_FORMAT_ARGB8888:
         case WL_DRM_FORMAT_XRGB8888:
         case WL_DRM_FORMAT_YUYV:
+        case WL_DRM_FORMAT_RGB565:
                 break;
         default:
                 wl_resource_post_error(resource,
@@ -225,6 +224,8 @@ bind_drm(struct wl_client *client, void *data, uint32_t version, uint32_t id)
 			       WL_DRM_FORMAT_ARGB8888);
 	wl_resource_post_event(resource, WL_DRM_FORMAT,
 			       WL_DRM_FORMAT_XRGB8888);
+        wl_resource_post_event(resource, WL_DRM_FORMAT,
+                               WL_DRM_FORMAT_RGB565);
         wl_resource_post_event(resource, WL_DRM_FORMAT, WL_DRM_FORMAT_YUV410);
         wl_resource_post_event(resource, WL_DRM_FORMAT, WL_DRM_FORMAT_YUV411);
         wl_resource_post_event(resource, WL_DRM_FORMAT, WL_DRM_FORMAT_YUV420);
@@ -243,15 +244,17 @@ bind_drm(struct wl_client *client, void *data, uint32_t version, uint32_t id)
 }
 
 struct wl_drm_buffer *
-wayland_drm_buffer_get(struct wl_resource *resource)
+wayland_drm_buffer_get(struct wl_drm *drm, struct wl_resource *resource)
 {
+	struct wl_drm_buffer *buffer;
+
 	if (resource == NULL)
 		return NULL;
 
-	if (wl_resource_instance_of(resource, &wl_buffer_interface,
-				    &drm_buffer_interface))
+        if (wl_resource_instance_of(resource, &wl_buffer_interface,
+                                    &drm->buffer_interface))
 		return wl_resource_get_user_data(resource);
-	else
+        else
 		return NULL;
 }
 
@@ -270,6 +273,8 @@ wayland_drm_init(struct wl_display *display, char *device_name,
 	drm->user_data = user_data;
         drm->flags = flags;
 
+        drm->buffer_interface.destroy = buffer_destroy;
+
 	wl_global_create(display, &wl_drm_interface, 2, drm, bind_drm);
 
 	return drm;
diff --git a/src/egl/wayland/wayland-drm/wayland-drm.h b/src/egl/wayland/wayland-drm/wayland-drm.h
index ca04882..7892d56 100644
--- a/src/egl/wayland/wayland-drm/wayland-drm.h
+++ b/src/egl/wayland/wayland-drm/wayland-drm.h
@@ -92,7 +92,7 @@ struct wayland_drm_callbacks {
 enum { WAYLAND_DRM_PRIME = 0x01 };
 
 struct wl_drm_buffer *
-wayland_drm_buffer_get(struct wl_resource *resource);
+wayland_drm_buffer_get(struct wl_drm *drm, struct wl_resource *resource);
 
 struct wl_drm *
 wayland_drm_init(struct wl_display *display, char *device_name,
diff --git a/src/gallium/SConscript b/src/gallium/SConscript
index ca75f37..9a25cca 100644
--- a/src/gallium/SConscript
+++ b/src/gallium/SConscript
@@ -122,6 +122,7 @@ if not env['embedded']:
     if env['platform'] == 'haiku':
         SConscript([
             'targets/haiku-softpipe/SConscript',
+            'targets/libgl-haiku/SConscript',
         ])
 
     if env['dri']:
diff --git a/src/gallium/auxiliary/Makefile.am b/src/gallium/auxiliary/Makefile.am
index 670e124..2d2d8d4 100644
--- a/src/gallium/auxiliary/Makefile.am
+++ b/src/gallium/auxiliary/Makefile.am
@@ -25,12 +25,6 @@ AM_CXXFLAGS += \
 	$(GALLIUM_CFLAGS) \
 	$(LLVM_CXXFLAGS)
 
-if LLVM_NEEDS_FNORTTI
-
-AM_CXXFLAGS += -fno-rtti
-
-endif
-
 libgallium_la_SOURCES += \
 	$(GALLIVM_SOURCES) \
 	$(GALLIVM_CPP_SOURCES)
diff --git a/src/gallium/auxiliary/cso_cache/cso_context.c b/src/gallium/auxiliary/cso_cache/cso_context.c
index 6805427..4d7c387 100644
--- a/src/gallium/auxiliary/cso_cache/cso_context.c
+++ b/src/gallium/auxiliary/cso_cache/cso_context.c
@@ -304,9 +304,21 @@ void cso_release_all( struct cso_context *ctx )
    if (ctx->pipe) {
       ctx->pipe->bind_blend_state( ctx->pipe, NULL );
       ctx->pipe->bind_rasterizer_state( ctx->pipe, NULL );
-      ctx->pipe->bind_fragment_sampler_states( ctx->pipe, 0, NULL );
-      if (ctx->pipe->bind_vertex_sampler_states)
-         ctx->pipe->bind_vertex_sampler_states(ctx->pipe, 0, NULL);
+
+      {
+         static void *zeros[PIPE_MAX_SAMPLERS] = { NULL };
+         struct pipe_screen *scr = ctx->pipe->screen;
+         unsigned sh;
+         for (sh = 0; sh < PIPE_SHADER_TYPES; sh++) {
+            int max = scr->get_shader_param(scr, sh,
+                                      PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS);
+            assert(max <= PIPE_MAX_SAMPLERS);
+            if (max > 0) {
+               ctx->pipe->bind_sampler_states(ctx->pipe, sh, 0, max, zeros);
+            }
+         }
+      }
+
       ctx->pipe->bind_depth_stencil_alpha_state( ctx->pipe, NULL );
       ctx->pipe->bind_fs_state( ctx->pipe, NULL );
       ctx->pipe->bind_vs_state( ctx->pipe, NULL );
@@ -1077,27 +1089,17 @@ single_sampler_done(struct cso_context *ctx, unsigned shader_stage)
       memcpy(info->hw.samplers,
              info->samplers,
              info->nr_samplers * sizeof(void *));
-      info->hw.nr_samplers = info->nr_samplers;
 
-      switch (shader_stage) {
-      case PIPE_SHADER_FRAGMENT:
-         ctx->pipe->bind_fragment_sampler_states(ctx->pipe,
-                                                 info->nr_samplers,
-                                                 info->samplers);
-         break;
-      case PIPE_SHADER_VERTEX:
-         ctx->pipe->bind_vertex_sampler_states(ctx->pipe,
-                                               info->nr_samplers,
-                                               info->samplers);
-         break;
-      case PIPE_SHADER_GEOMETRY:
-         ctx->pipe->bind_geometry_sampler_states(ctx->pipe,
-                                               info->nr_samplers,
-                                               info->samplers);
-         break;
-      default:
-         assert(!"bad shader type in single_sampler_done()");
-      }
+      /* set remaining slots/pointers to null */
+      for (i = info->nr_samplers; i < info->hw.nr_samplers; i++)
+         info->samplers[i] = NULL;
+
+      ctx->pipe->bind_sampler_states(ctx->pipe, shader_stage, 0,
+                                     MAX2(info->nr_samplers,
+                                          info->hw.nr_samplers),
+                                     info->samplers);
+
+      info->hw.nr_samplers = info->nr_samplers;
    }
 }
 
@@ -1219,6 +1221,7 @@ cso_restore_sampler_views(struct cso_context *ctx, unsigned shader_stage)
 {
    struct sampler_info *info = &ctx->samplers[shader_stage];
    unsigned i, nr_saved = info->nr_views_saved;
+   unsigned num;
 
    for (i = 0; i < nr_saved; i++) {
       pipe_sampler_view_reference(&info->views[i], NULL);
@@ -1230,16 +1233,18 @@ cso_restore_sampler_views(struct cso_context *ctx, unsigned shader_stage)
       pipe_sampler_view_reference(&info->views[i], NULL);
    }
 
+   num = MAX2(info->nr_views, nr_saved);
+
    /* bind the old/saved sampler views */
    switch (shader_stage) {
    case PIPE_SHADER_FRAGMENT:
-      ctx->pipe->set_fragment_sampler_views(ctx->pipe, nr_saved, info->views);
+      ctx->pipe->set_fragment_sampler_views(ctx->pipe, num, info->views);
       break;
    case PIPE_SHADER_VERTEX:
-      ctx->pipe->set_vertex_sampler_views(ctx->pipe, nr_saved, info->views);
+      ctx->pipe->set_vertex_sampler_views(ctx->pipe, num, info->views);
       break;
    case PIPE_SHADER_GEOMETRY:
-      ctx->pipe->set_geometry_sampler_views(ctx->pipe, nr_saved, info->views);
+      ctx->pipe->set_geometry_sampler_views(ctx->pipe, num, info->views);
       break;
    default:
       assert(!"bad shader type in cso_restore_sampler_views()");
diff --git a/src/gallium/auxiliary/draw/draw_gs.c b/src/gallium/auxiliary/draw/draw_gs.c
index 13d3d3b..f4fbb4c 100644
--- a/src/gallium/auxiliary/draw/draw_gs.c
+++ b/src/gallium/auxiliary/draw/draw_gs.c
@@ -126,7 +126,8 @@ static void tgsi_fetch_gs_input(struct draw_geometry_shader *shader,
                                 unsigned prim_idx)
 {
    struct tgsi_exec_machine *machine = shader->machine;
-   unsigned slot, vs_slot, i;
+   unsigned slot, i;
+   int vs_slot;
    unsigned input_vertex_stride = shader->input_vertex_stride;
    const float (*input_ptr)[4];
 
@@ -225,7 +226,8 @@ llvm_fetch_gs_input(struct draw_geometry_shader *shader,
                     unsigned num_vertices,
                     unsigned prim_idx)
 {
-   unsigned slot, vs_slot, i;
+   unsigned slot, i;
+   int vs_slot;
    unsigned input_vertex_stride = shader->input_vertex_stride;
    const float (*input_ptr)[4];
    float (*input_data)[6][PIPE_MAX_SHADER_INPUTS][TGSI_NUM_CHANNELS][TGSI_NUM_CHANNELS] = &shader->gs_input->data;
diff --git a/src/gallium/auxiliary/draw/draw_pipe_aaline.c b/src/gallium/auxiliary/draw/draw_pipe_aaline.c
index 8483bd7..3c93bf7 100644
--- a/src/gallium/auxiliary/draw/draw_pipe_aaline.c
+++ b/src/gallium/auxiliary/draw/draw_pipe_aaline.c
@@ -118,8 +118,8 @@ struct aaline_stage
    void (*driver_bind_fs_state)(struct pipe_context *, void *);
    void (*driver_delete_fs_state)(struct pipe_context *, void *);
 
-   void (*driver_bind_sampler_states)(struct pipe_context *, unsigned,
-                                      void **);
+   void (*driver_bind_sampler_states)(struct pipe_context *, unsigned, unsigned,
+                                      unsigned, void **);
 
    void (*driver_set_sampler_views)(struct pipe_context *,
                                     unsigned,
@@ -704,7 +704,10 @@ aaline_first_line(struct draw_stage *stage, struct prim_header *header)
                                aaline->sampler_view);
 
    draw->suspend_flushing = TRUE;
-   aaline->driver_bind_sampler_states(pipe, num_samplers, aaline->state.sampler);
+
+   aaline->driver_bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0,
+                                      num_samplers, aaline->state.sampler);
+
    aaline->driver_set_sampler_views(pipe, num_samplers, aaline->state.sampler_views);
 
    /* Disable triangle culling, stippling, unfilled mode etc. */
@@ -732,8 +735,11 @@ aaline_flush(struct draw_stage *stage, unsigned flags)
    /* restore original frag shader, texture, sampler state */
    draw->suspend_flushing = TRUE;
    aaline->driver_bind_fs_state(pipe, aaline->fs ? aaline->fs->driver_fs : NULL);
-   aaline->driver_bind_sampler_states(pipe, aaline->num_samplers,
+
+   aaline->driver_bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0,
+                                      aaline->num_samplers,
                                       aaline->state.sampler);
+
    aaline->driver_set_sampler_views(pipe,
                                     aaline->num_sampler_views,
                                     aaline->state.sampler_views);
@@ -784,7 +790,7 @@ aaline_destroy(struct draw_stage *stage)
    pipe->bind_fs_state = aaline->driver_bind_fs_state;
    pipe->delete_fs_state = aaline->driver_delete_fs_state;
 
-   pipe->bind_fragment_sampler_states = aaline->driver_bind_sampler_states;
+   pipe->bind_sampler_states = aaline->driver_bind_sampler_states;
    pipe->set_fragment_sampler_views = aaline->driver_set_sampler_views;
 
    FREE( stage );
@@ -903,21 +909,25 @@ aaline_delete_fs_state(struct pipe_context *pipe, void *fs)
 
 
 static void
-aaline_bind_sampler_states(struct pipe_context *pipe,
-                           unsigned num, void **sampler)
+aaline_bind_sampler_states(struct pipe_context *pipe, unsigned shader,
+                           unsigned start, unsigned num, void **sampler)
 {
    struct aaline_stage *aaline = aaline_stage_from_pipe(pipe);
 
+   assert(start == 0);
+
    if (aaline == NULL) {
       return;
    }
 
-   /* save current */
-   memcpy(aaline->state.sampler, sampler, num * sizeof(void *));
-   aaline->num_samplers = num;
+   if (shader == PIPE_SHADER_FRAGMENT) {
+      /* save current */
+      memcpy(aaline->state.sampler, sampler, num * sizeof(void *));
+      aaline->num_samplers = num;
+   }
 
    /* pass-through */
-   aaline->driver_bind_sampler_states(pipe, num, sampler);
+   aaline->driver_bind_sampler_states(pipe, shader, start, num, sampler);
 }
 
 
@@ -997,7 +1007,7 @@ draw_install_aaline_stage(struct draw_context *draw, struct pipe_context *pipe)
    aaline->driver_bind_fs_state = pipe->bind_fs_state;
    aaline->driver_delete_fs_state = pipe->delete_fs_state;
 
-   aaline->driver_bind_sampler_states = pipe->bind_fragment_sampler_states;
+   aaline->driver_bind_sampler_states = pipe->bind_sampler_states;
    aaline->driver_set_sampler_views = pipe->set_fragment_sampler_views;
 
    /* override the driver's functions */
@@ -1005,7 +1015,7 @@ draw_install_aaline_stage(struct draw_context *draw, struct pipe_context *pipe)
    pipe->bind_fs_state = aaline_bind_fs_state;
    pipe->delete_fs_state = aaline_delete_fs_state;
 
-   pipe->bind_fragment_sampler_states = aaline_bind_sampler_states;
+   pipe->bind_sampler_states = aaline_bind_sampler_states;
    pipe->set_fragment_sampler_views = aaline_set_sampler_views;
    
    /* Install once everything is known to be OK:
diff --git a/src/gallium/auxiliary/draw/draw_pipe_pstipple.c b/src/gallium/auxiliary/draw/draw_pipe_pstipple.c
index f38addd..e39276a 100644
--- a/src/gallium/auxiliary/draw/draw_pipe_pstipple.c
+++ b/src/gallium/auxiliary/draw/draw_pipe_pstipple.c
@@ -99,7 +99,8 @@ struct pstip_stage
    void (*driver_bind_fs_state)(struct pipe_context *, void *);
    void (*driver_delete_fs_state)(struct pipe_context *, void *);
 
-   void (*driver_bind_sampler_states)(struct pipe_context *, unsigned, void **);
+   void (*driver_bind_sampler_states)(struct pipe_context *, unsigned,
+                                      unsigned, unsigned, void **);
 
    void (*driver_set_sampler_views)(struct pipe_context *,
                                     unsigned,
@@ -547,7 +548,10 @@ pstip_first_tri(struct draw_stage *stage, struct prim_header *header)
    assert(num_samplers <= PIPE_MAX_SAMPLERS);
 
    draw->suspend_flushing = TRUE;
-   pstip->driver_bind_sampler_states(pipe, num_samplers, pstip->state.samplers);
+
+   pstip->driver_bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0,
+                                     num_samplers, pstip->state.samplers);
+
    pstip->driver_set_sampler_views(pipe, num_samplers, pstip->state.sampler_views);
    draw->suspend_flushing = FALSE;
 
@@ -570,8 +574,11 @@ pstip_flush(struct draw_stage *stage, unsigned flags)
    /* restore original frag shader, texture, sampler state */
    draw->suspend_flushing = TRUE;
    pstip->driver_bind_fs_state(pipe, pstip->fs ? pstip->fs->driver_fs : NULL);
-   pstip->driver_bind_sampler_states(pipe, pstip->num_samplers,
+
+   pstip->driver_bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0,
+                                     pstip->num_samplers,
                                      pstip->state.samplers);
+
    pstip->driver_set_sampler_views(pipe,
                                    pstip->num_sampler_views,
                                    pstip->state.sampler_views);
@@ -701,21 +708,25 @@ pstip_delete_fs_state(struct pipe_context *pipe, void *fs)
 
 
 static void
-pstip_bind_sampler_states(struct pipe_context *pipe,
-                          unsigned num, void **sampler)
+pstip_bind_sampler_states(struct pipe_context *pipe, unsigned shader,
+                          unsigned start, unsigned num, void **sampler)
 {
    struct pstip_stage *pstip = pstip_stage_from_pipe(pipe);
    uint i;
 
-   /* save current */
-   memcpy(pstip->state.samplers, sampler, num * sizeof(void *));
-   for (i = num; i < PIPE_MAX_SAMPLERS; i++) {
-      pstip->state.samplers[i] = NULL;
+   assert(start == 0);
+
+   if (shader == PIPE_SHADER_FRAGMENT) {
+      /* save current */
+      memcpy(pstip->state.samplers, sampler, num * sizeof(void *));
+      for (i = num; i < PIPE_MAX_SAMPLERS; i++) {
+         pstip->state.samplers[i] = NULL;
+      }
+      pstip->num_samplers = num;
    }
 
-   pstip->num_samplers = num;
    /* pass-through */
-   pstip->driver_bind_sampler_states(pstip->pipe, num, sampler);
+   pstip->driver_bind_sampler_states(pstip->pipe, shader, start, num, sampler);
 }
 
 
@@ -792,7 +803,7 @@ draw_install_pstipple_stage(struct draw_context *draw,
    pstip->driver_bind_fs_state = pipe->bind_fs_state;
    pstip->driver_delete_fs_state = pipe->delete_fs_state;
 
-   pstip->driver_bind_sampler_states = pipe->bind_fragment_sampler_states;
+   pstip->driver_bind_sampler_states = pipe->bind_sampler_states;
    pstip->driver_set_sampler_views = pipe->set_fragment_sampler_views;
    pstip->driver_set_polygon_stipple = pipe->set_polygon_stipple;
 
@@ -801,7 +812,7 @@ draw_install_pstipple_stage(struct draw_context *draw,
    pipe->bind_fs_state = pstip_bind_fs_state;
    pipe->delete_fs_state = pstip_delete_fs_state;
 
-   pipe->bind_fragment_sampler_states = pstip_bind_sampler_states;
+   pipe->bind_sampler_states = pstip_bind_sampler_states;
    pipe->set_fragment_sampler_views = pstip_set_sampler_views;
    pipe->set_polygon_stipple = pstip_set_polygon_stipple;
 
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_printf.c b/src/gallium/auxiliary/gallivm/lp_bld_printf.c
index 1324da2..69d829e 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_printf.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_printf.c
@@ -26,6 +26,7 @@
  **************************************************************************/
 
 #include <stdio.h>
+#include <inttypes.h>
 
 #include "util/u_debug.h"
 #include "util/u_memory.h"
@@ -106,7 +107,11 @@ lp_build_print_value(struct gallivm_state *gallivm,
       type_fmt[4] = 'g';
       type_fmt[5] = '\0';
    } else if (type_kind == LLVMIntegerTypeKind) {
-      if (LLVMGetIntTypeWidth(type_ref) == 8) {
+      if (LLVMGetIntTypeWidth(type_ref) == 64) {
+         unsigned flen = strlen(PRId64);
+         assert(flen <= 3);
+         strncpy(type_fmt + 2, PRId64, flen);
+      } else if (LLVMGetIntTypeWidth(type_ref) == 8) {
          type_fmt[2] = 'u';
       } else {
          type_fmt[2] = 'i';
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_sample.c b/src/gallium/auxiliary/gallivm/lp_bld_sample.c
index c775382..1c35200 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_sample.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_sample.c
@@ -269,13 +269,11 @@ lp_build_rho(struct lp_build_sample_context *bld,
       /* Could optimize this for single quad just skip the broadcast */
       cubesize = lp_build_extract_broadcast(gallivm, bld->float_size_in_type,
                                             rho_bld->type, float_size, index0);
-      if (no_rho_opt) {
-         /* skipping sqrt hence returning rho squared */
-         cubesize = lp_build_mul(rho_bld, cubesize, cubesize);
-      }
+      /* skipping sqrt hence returning rho squared */
+      cubesize = lp_build_mul(rho_bld, cubesize, cubesize);
       rho = lp_build_mul(rho_bld, cubesize, rho);
    }
-   else if (derivs && !(bld->static_texture_state->target == PIPE_TEXTURE_CUBE)) {
+   else if (derivs) {
       LLVMValueRef ddmax[3], ddx[3], ddy[3];
       for (i = 0; i < dims; i++) {
          LLVMValueRef floatdim;
@@ -757,8 +755,8 @@ lp_build_lod_selector(struct lp_build_sample_context *bld,
       }
       else {
          LLVMValueRef rho;
-         boolean rho_squared = (gallivm_debug & GALLIVM_DEBUG_NO_RHO_APPROX) &&
-                               (bld->dims > 1);
+         boolean rho_squared = ((gallivm_debug & GALLIVM_DEBUG_NO_RHO_APPROX) &&
+                                (bld->dims > 1)) || cube_rho;
 
          rho = lp_build_rho(bld, texture_unit, s, t, r, cube_rho, derivs);
 
@@ -1416,82 +1414,33 @@ lp_build_cube_imapos(struct lp_build_context *coord_bld, LLVMValueRef coord)
    return ima;
 }
 
-/** Helper used by lp_build_cube_lookup() */
-static LLVMValueRef
-lp_build_cube_imaneg(struct lp_build_context *coord_bld, LLVMValueRef coord)
-{
-   /* ima = -0.5 / abs(coord); */
-   LLVMValueRef negHalf = lp_build_const_vec(coord_bld->gallivm, coord_bld->type, -0.5);
-   LLVMValueRef absCoord = lp_build_abs(coord_bld, coord);
-   LLVMValueRef ima = lp_build_div(coord_bld, negHalf, absCoord);
-   return ima;
-}
-
-/**
- * Helper used by lp_build_cube_lookup()
- * FIXME: the sign here can also be 0.
- * Arithmetically this could definitely make a difference. Either
- * fix the comment or use other (simpler) sign function, not sure
- * which one it should be.
- * \param sign  scalar +1 or -1
- * \param coord  float vector
- * \param ima  float vector
- */
-static LLVMValueRef
-lp_build_cube_coord(struct lp_build_context *coord_bld,
-                    LLVMValueRef sign, int negate_coord,
-                    LLVMValueRef coord, LLVMValueRef ima)
-{
-   /* return negate(coord) * ima * sign + 0.5; */
-   LLVMValueRef half = lp_build_const_vec(coord_bld->gallivm, coord_bld->type, 0.5);
-   LLVMValueRef res;
-
-   assert(negate_coord == +1 || negate_coord == -1);
-
-   if (negate_coord == -1) {
-      coord = lp_build_negate(coord_bld, coord);
-   }
-
-   res = lp_build_mul(coord_bld, coord, ima);
-   if (sign) {
-      sign = lp_build_broadcast_scalar(coord_bld, sign);
-      res = lp_build_mul(coord_bld, res, sign);
-   }
-   res = lp_build_add(coord_bld, res, half);
-
-   return res;
-}
-
 
-/** Helper used by lp_build_cube_lookup()
- * Return (major_coord >= 0) ? pos_face : neg_face;
+/** Helper for doing 3-wise selection.
+ * Returns sel1 ? val2 : (sel0 ? val0 : val1).
  */
 static LLVMValueRef
-lp_build_cube_face(struct lp_build_sample_context *bld,
-                   LLVMValueRef major_coord,
-                   unsigned pos_face, unsigned neg_face)
+lp_build_select3(struct lp_build_context *sel_bld,
+                 LLVMValueRef sel0,
+                 LLVMValueRef sel1,
+                 LLVMValueRef val0,
+                 LLVMValueRef val1,
+                 LLVMValueRef val2)
 {
-   struct gallivm_state *gallivm = bld->gallivm;
-   LLVMBuilderRef builder = gallivm->builder;
-   LLVMValueRef cmp = LLVMBuildFCmp(builder, LLVMRealUGE,
-                                    major_coord,
-                                    bld->float_bld.zero, "");
-   LLVMValueRef pos = lp_build_const_int32(gallivm, pos_face);
-   LLVMValueRef neg = lp_build_const_int32(gallivm, neg_face);
-   LLVMValueRef res = LLVMBuildSelect(builder, cmp, pos, neg, "");
-   return res;
+   LLVMValueRef tmp;
+   tmp = lp_build_select(sel_bld, sel0, val0, val1);
+   return lp_build_select(sel_bld, sel1, val2, tmp);
 }
 
 
-
 /**
  * Generate code to do cube face selection and compute per-face texcoords.
  */
 void
 lp_build_cube_lookup(struct lp_build_sample_context *bld,
                      LLVMValueRef *coords,
-                     const struct lp_derivatives *derivs, /* optional */
+                     const struct lp_derivatives *derivs_in, /* optional */
                      LLVMValueRef *rho,
+                     struct lp_derivatives *derivs_out, /* optional */
                      boolean need_derivs)
 {
    struct lp_build_context *coord_bld = &bld->coord_bld;
@@ -1499,337 +1448,344 @@ lp_build_cube_lookup(struct lp_build_sample_context *bld,
    struct gallivm_state *gallivm = bld->gallivm;
    LLVMValueRef si, ti, ri;
 
-   if (1 || coord_bld->type.length > 4) {
-      /*
-       * Do per-pixel face selection. We cannot however (as we used to do)
-       * simply calculate the derivs afterwards (which is very bogus for
-       * explicit derivs btw) because the values would be "random" when
-       * not all pixels lie on the same face. So what we do here is just
-       * calculate the derivatives after scaling the coords by the absolute
-       * value of the inverse major axis, and essentially do rho calculation
-       * steps as if it were a 3d texture. This is perfect if all pixels hit
-       * the same face, but not so great at edges, I believe the max error
-       * should be sqrt(2) with no_rho_approx or 2 otherwise (essentially measuring
-       * the 3d distance between 2 points on the cube instead of measuring up/down
-       * the edge). Still this is possibly a win over just selecting the same face
-       * for all pixels. Unfortunately, something like that doesn't work for
-       * explicit derivatives.
-       * TODO: handle explicit derivatives by transforming them alongside coords
-       * somehow.
-       */
-      struct lp_build_context *cint_bld = &bld->int_coord_bld;
-      struct lp_type intctype = cint_bld->type;
-      LLVMValueRef signs, signt, signr, signma;
-      LLVMValueRef as, at, ar, face, face_s, face_t;
-      LLVMValueRef as_ge_at, maxasat, ar_ge_as_at;
-      LLVMValueRef snewx, tnewx, snewy, tnewy, snewz, tnewz;
-      LLVMValueRef tnegi, rnegi;
-      LLVMValueRef ma, mai, ima;
-      LLVMValueRef posHalf = lp_build_const_vec(gallivm, coord_bld->type, 0.5);
-      LLVMValueRef signmask = lp_build_const_int_vec(gallivm, intctype,
-                                                     1 << (intctype.width - 1));
-      LLVMValueRef signshift = lp_build_const_int_vec(gallivm, intctype,
-                                                      intctype.width -1);
-      LLVMValueRef facex = lp_build_const_int_vec(gallivm, intctype, PIPE_TEX_FACE_POS_X);
-      LLVMValueRef facey = lp_build_const_int_vec(gallivm, intctype, PIPE_TEX_FACE_POS_Y);
-      LLVMValueRef facez = lp_build_const_int_vec(gallivm, intctype, PIPE_TEX_FACE_POS_Z);
-      LLVMValueRef s = coords[0];
-      LLVMValueRef t = coords[1];
-      LLVMValueRef r = coords[2];
-
-      assert(PIPE_TEX_FACE_NEG_X == PIPE_TEX_FACE_POS_X + 1);
-      assert(PIPE_TEX_FACE_NEG_Y == PIPE_TEX_FACE_POS_Y + 1);
-      assert(PIPE_TEX_FACE_NEG_Z == PIPE_TEX_FACE_POS_Z + 1);
+   /*
+    * Do per-pixel face selection. We cannot however (as we used to do)
+    * simply calculate the derivs afterwards (which is very bogus for
+    * explicit derivs btw) because the values would be "random" when
+    * not all pixels lie on the same face. So what we do here is just
+    * calculate the derivatives after scaling the coords by the absolute
+    * value of the inverse major axis, and essentially do rho calculation
+    * steps as if it were a 3d texture. This is perfect if all pixels hit
+    * the same face, but not so great at edges, I believe the max error
+    * should be sqrt(2) with no_rho_approx or 2 otherwise (essentially measuring
+    * the 3d distance between 2 points on the cube instead of measuring up/down
+    * the edge). Still this is possibly a win over just selecting the same face
+    * for all pixels. Unfortunately, something like that doesn't work for
+    * explicit derivatives.
+    */
+   struct lp_build_context *cint_bld = &bld->int_coord_bld;
+   struct lp_type intctype = cint_bld->type;
+   LLVMTypeRef coord_vec_type = coord_bld->vec_type;
+   LLVMTypeRef cint_vec_type = cint_bld->vec_type;
+   LLVMValueRef as, at, ar, face, face_s, face_t;
+   LLVMValueRef as_ge_at, maxasat, ar_ge_as_at;
+   LLVMValueRef snewx, tnewx, snewy, tnewy, snewz, tnewz;
+   LLVMValueRef tnegi, rnegi;
+   LLVMValueRef ma, mai, signma, signmabit, imahalfpos;
+   LLVMValueRef posHalf = lp_build_const_vec(gallivm, coord_bld->type, 0.5);
+   LLVMValueRef signmask = lp_build_const_int_vec(gallivm, intctype,
+                                                  1 << (intctype.width - 1));
+   LLVMValueRef signshift = lp_build_const_int_vec(gallivm, intctype,
+                                                   intctype.width -1);
+   LLVMValueRef facex = lp_build_const_int_vec(gallivm, intctype, PIPE_TEX_FACE_POS_X);
+   LLVMValueRef facey = lp_build_const_int_vec(gallivm, intctype, PIPE_TEX_FACE_POS_Y);
+   LLVMValueRef facez = lp_build_const_int_vec(gallivm, intctype, PIPE_TEX_FACE_POS_Z);
+   LLVMValueRef s = coords[0];
+   LLVMValueRef t = coords[1];
+   LLVMValueRef r = coords[2];
+
+   assert(PIPE_TEX_FACE_NEG_X == PIPE_TEX_FACE_POS_X + 1);
+   assert(PIPE_TEX_FACE_NEG_Y == PIPE_TEX_FACE_POS_Y + 1);
+   assert(PIPE_TEX_FACE_NEG_Z == PIPE_TEX_FACE_POS_Z + 1);
+
+   /*
+    * get absolute value (for x/y/z face selection) and sign bit
+    * (for mirroring minor coords and pos/neg face selection)
+    * of the original coords.
+    */
+   as = lp_build_abs(&bld->coord_bld, s);
+   at = lp_build_abs(&bld->coord_bld, t);
+   ar = lp_build_abs(&bld->coord_bld, r);
+
+   /*
+    * major face determination: select x if x > y else select y
+    * select z if z >= max(x,y) else select previous result
+    * if some axis are the same we chose z over y, y over x - the
+    * dx10 spec seems to ask for it while OpenGL doesn't care (if we
+    * wouldn't care could save a select or two if using different
+    * compares and doing at_g_as_ar last since tnewx and tnewz are the
+    * same).
+    */
+   as_ge_at = lp_build_cmp(coord_bld, PIPE_FUNC_GREATER, as, at);
+   maxasat = lp_build_max(coord_bld, as, at);
+   ar_ge_as_at = lp_build_cmp(coord_bld, PIPE_FUNC_GEQUAL, ar, maxasat);
 
+   if (need_derivs && (derivs_in ||
+       ((gallivm_debug & GALLIVM_DEBUG_NO_QUAD_LOD) &&
+        (gallivm_debug & GALLIVM_DEBUG_NO_RHO_APPROX)))) {
       /*
-       * get absolute value (for x/y/z face selection) and sign bit
-       * (for mirroring minor coords and pos/neg face selection)
-       * of the original coords.
+       * XXX: This is really really complex.
+       * It is a bit overkill to use this for implicit derivatives as well,
+       * no way this is worth the cost in practice, but seems to be the
+       * only way for getting accurate and per-pixel lod values.
        */
-      as = lp_build_abs(&bld->coord_bld, s);
-      at = lp_build_abs(&bld->coord_bld, t);
-      ar = lp_build_abs(&bld->coord_bld, r);
-
+      LLVMValueRef ima, imahalf, tmp, ddx[3], ddy[3];
+      LLVMValueRef madx, mady, madxdivma, madydivma;
+      LLVMValueRef sdxi, tdxi, rdxi, sdyi, tdyi, rdyi;
+      LLVMValueRef tdxnegi, rdxnegi, tdynegi, rdynegi;
+      LLVMValueRef sdxnewx, sdxnewy, sdxnewz, tdxnewx, tdxnewy, tdxnewz;
+      LLVMValueRef sdynewx, sdynewy, sdynewz, tdynewx, tdynewy, tdynewz;
+      LLVMValueRef face_sdx, face_tdx, face_sdy, face_tdy;
       /*
-       * major face determination: select x if x > y else select y
-       * select z if z >= max(x,y) else select previous result
-       * if some axis are the same we chose z over y, y over x - the
-       * dx10 spec seems to ask for it while OpenGL doesn't care (if we
-       * wouldn't care could save a select or two if using different
-       * compares and doing at_g_as_ar last since tnewx and tnewz are the
-       * same).
+       * s = 1/2 * ( sc / ma + 1)
+       * t = 1/2 * ( tc / ma + 1)
+       *
+       * s' = 1/2 * (sc' * ma - sc * ma') / ma^2
+       * t' = 1/2 * (tc' * ma - tc * ma') / ma^2
+       *
+       * dx.s = 0.5 * (dx.sc - sc * dx.ma / ma) / ma
+       * dx.t = 0.5 * (dx.tc - tc * dx.ma / ma) / ma
+       * dy.s = 0.5 * (dy.sc - sc * dy.ma / ma) / ma
+       * dy.t = 0.5 * (dy.tc - tc * dy.ma / ma) / ma
        */
-      as_ge_at = lp_build_cmp(coord_bld, PIPE_FUNC_GREATER, as, at);
-      maxasat = lp_build_max(coord_bld, as, at);
-      ar_ge_as_at = lp_build_cmp(coord_bld, PIPE_FUNC_GEQUAL, ar, maxasat);
-
-      if (need_derivs) {
-         LLVMValueRef ddx_ddy[2], tmp[3], rho_vec;
-         static const unsigned char swizzle0[] = { /* no-op swizzle */
-            0, LP_BLD_SWIZZLE_DONTCARE,
-            LP_BLD_SWIZZLE_DONTCARE, LP_BLD_SWIZZLE_DONTCARE
-         };
-         static const unsigned char swizzle1[] = {
-            1, LP_BLD_SWIZZLE_DONTCARE,
-            LP_BLD_SWIZZLE_DONTCARE, LP_BLD_SWIZZLE_DONTCARE
-         };
-         static const unsigned char swizzle01[] = { /* no-op swizzle */
-            0, 1,
-            LP_BLD_SWIZZLE_DONTCARE, LP_BLD_SWIZZLE_DONTCARE
-         };
-         static const unsigned char swizzle23[] = {
-            2, 3,
-            LP_BLD_SWIZZLE_DONTCARE, LP_BLD_SWIZZLE_DONTCARE
-         };
-         static const unsigned char swizzle02[] = {
-            0, 2,
-            LP_BLD_SWIZZLE_DONTCARE, LP_BLD_SWIZZLE_DONTCARE
-         };
 
-         /*
-          * scale the s/t/r coords pre-select/mirror so we can calculate
-          * "reasonable" derivs.
-          */
-         ma = lp_build_select(coord_bld, as_ge_at, s, t);
-         ma = lp_build_select(coord_bld, ar_ge_as_at, r, ma);
-         ima = lp_build_cube_imapos(coord_bld, ma);
-         s = lp_build_mul(coord_bld, s, ima);
-         t = lp_build_mul(coord_bld, t, ima);
-         r = lp_build_mul(coord_bld, r, ima);
-
-         /*
-          * This isn't quite the same as the "ordinary" (3d deriv) path since we
-          * know the texture is square which simplifies things (we can omit the
-          * size mul which happens very early completely here and do it at the
-          * very end).
-          */
-         ddx_ddy[0] = lp_build_packed_ddx_ddy_twocoord(coord_bld, s, t);
-         ddx_ddy[1] = lp_build_packed_ddx_ddy_onecoord(coord_bld, r);
-
-         if (gallivm_debug & GALLIVM_DEBUG_NO_RHO_APPROX) {
-            ddx_ddy[0] = lp_build_mul(coord_bld, ddx_ddy[0], ddx_ddy[0]);
-            ddx_ddy[1] = lp_build_mul(coord_bld, ddx_ddy[1], ddx_ddy[1]);
-         }
-         else {
-            ddx_ddy[0] = lp_build_abs(coord_bld, ddx_ddy[0]);
-            ddx_ddy[1] = lp_build_abs(coord_bld, ddx_ddy[1]);
-         }
+      /* select ma, calculate ima */
+      ma = lp_build_select3(coord_bld, as_ge_at, ar_ge_as_at, s, t, r);
+      mai = LLVMBuildBitCast(builder, ma, cint_vec_type, "");
+      signmabit = LLVMBuildAnd(builder, mai, signmask, "");
+      ima = lp_build_div(coord_bld, coord_bld->one, ma);
+      imahalf = lp_build_mul(coord_bld, posHalf, ima);
+      imahalfpos = lp_build_abs(coord_bld, imahalf);
+
+      if (!derivs_in) {
+         ddx[0] = lp_build_ddx(coord_bld, s);
+         ddx[1] = lp_build_ddx(coord_bld, t);
+         ddx[2] = lp_build_ddx(coord_bld, r);
+         ddy[0] = lp_build_ddy(coord_bld, s);
+         ddy[1] = lp_build_ddy(coord_bld, t);
+         ddy[2] = lp_build_ddy(coord_bld, r);
+      }
+      else {
+         ddx[0] = derivs_in->ddx[0];
+         ddx[1] = derivs_in->ddx[1];
+         ddx[2] = derivs_in->ddx[2];
+         ddy[0] = derivs_in->ddy[0];
+         ddy[1] = derivs_in->ddy[1];
+         ddy[2] = derivs_in->ddy[2];
+      }
 
-         tmp[0] = lp_build_swizzle_aos(coord_bld, ddx_ddy[0], swizzle01);
-         tmp[1] = lp_build_swizzle_aos(coord_bld, ddx_ddy[0], swizzle23);
-         tmp[2] = lp_build_swizzle_aos(coord_bld, ddx_ddy[1], swizzle02);
+      /* select major derivatives */
+      madx = lp_build_select3(coord_bld, as_ge_at, ar_ge_as_at, ddx[0], ddx[1], ddx[2]);
+      mady = lp_build_select3(coord_bld, as_ge_at, ar_ge_as_at, ddy[0], ddy[1], ddy[2]);
 
-         if (gallivm_debug & GALLIVM_DEBUG_NO_RHO_APPROX) {
-            rho_vec = lp_build_add(coord_bld, tmp[0], tmp[1]);
-            rho_vec = lp_build_add(coord_bld, rho_vec, tmp[2]);
-         }
-         else {
-            rho_vec = lp_build_max(coord_bld, tmp[0], tmp[1]);
-            rho_vec = lp_build_max(coord_bld, rho_vec, tmp[2]);
-         }
+      si = LLVMBuildBitCast(builder, s, cint_vec_type, "");
+      ti = LLVMBuildBitCast(builder, t, cint_vec_type, "");
+      ri = LLVMBuildBitCast(builder, r, cint_vec_type, "");
 
-         tmp[0] = lp_build_swizzle_aos(coord_bld, rho_vec, swizzle0);
-         tmp[1] = lp_build_swizzle_aos(coord_bld, rho_vec, swizzle1);
-         *rho = lp_build_max(coord_bld, tmp[0], tmp[1]);
-      }
+      sdxi = LLVMBuildBitCast(builder, ddx[0], cint_vec_type, "");
+      tdxi = LLVMBuildBitCast(builder, ddx[1], cint_vec_type, "");
+      rdxi = LLVMBuildBitCast(builder, ddx[2], cint_vec_type, "");
 
-      si = LLVMBuildBitCast(builder, s, lp_build_vec_type(gallivm, intctype), "");
-      ti = LLVMBuildBitCast(builder, t, lp_build_vec_type(gallivm, intctype), "");
-      ri = LLVMBuildBitCast(builder, r, lp_build_vec_type(gallivm, intctype), "");
-      signs = LLVMBuildAnd(builder, si, signmask, "");
-      signt = LLVMBuildAnd(builder, ti, signmask, "");
-      signr = LLVMBuildAnd(builder, ri, signmask, "");
+      sdyi = LLVMBuildBitCast(builder, ddy[0], cint_vec_type, "");
+      tdyi = LLVMBuildBitCast(builder, ddy[1], cint_vec_type, "");
+      rdyi = LLVMBuildBitCast(builder, ddy[2], cint_vec_type, "");
 
       /*
-       * compute all possible new s/t coords
-       * snewx = signs * -r;
+       * compute all possible new s/t coords, which does the mirroring,
+       * and do the same for derivs minor axes.
+       * snewx = signma * -r;
        * tnewx = -t;
        * snewy = s;
-       * tnewy = signt * r;
-       * snewz = signr * s;
+       * tnewy = signma * r;
+       * snewz = signma * s;
        * tnewz = -t;
        */
       tnegi = LLVMBuildXor(builder, ti, signmask, "");
       rnegi = LLVMBuildXor(builder, ri, signmask, "");
+      tdxnegi = LLVMBuildXor(builder, tdxi, signmask, "");
+      rdxnegi = LLVMBuildXor(builder, rdxi, signmask, "");
+      tdynegi = LLVMBuildXor(builder, tdyi, signmask, "");
+      rdynegi = LLVMBuildXor(builder, rdyi, signmask, "");
 
-      snewx = LLVMBuildXor(builder, signs, rnegi, "");
+      snewx = LLVMBuildXor(builder, signmabit, rnegi, "");
       tnewx = tnegi;
+      sdxnewx = LLVMBuildXor(builder, signmabit, rdxnegi, "");
+      tdxnewx = tdxnegi;
+      sdynewx = LLVMBuildXor(builder, signmabit, rdynegi, "");
+      tdynewx = tdynegi;
 
       snewy = si;
-      tnewy = LLVMBuildXor(builder, signt, ri, "");
+      tnewy = LLVMBuildXor(builder, signmabit, ri, "");
+      sdxnewy = sdxi;
+      tdxnewy = LLVMBuildXor(builder, signmabit, rdxi, "");
+      sdynewy = sdyi;
+      tdynewy = LLVMBuildXor(builder, signmabit, rdyi, "");
 
-      snewz = LLVMBuildXor(builder, signr, si, "");
+      snewz = LLVMBuildXor(builder, signmabit, si, "");
       tnewz = tnegi;
+      sdxnewz = LLVMBuildXor(builder, signmabit, sdxi, "");
+      tdxnewz = tdxnegi;
+      sdynewz = LLVMBuildXor(builder, signmabit, sdyi, "");
+      tdynewz = tdynegi;
+
+      /* select the mirrored values */
+      face = lp_build_select3(cint_bld, as_ge_at, ar_ge_as_at, facex, facey, facez);
+      face_s = lp_build_select3(cint_bld, as_ge_at, ar_ge_as_at, snewx, snewy, snewz);
+      face_t = lp_build_select3(cint_bld, as_ge_at, ar_ge_as_at, tnewx, tnewy, tnewz);
+      face_sdx = lp_build_select3(cint_bld, as_ge_at, ar_ge_as_at, sdxnewx, sdxnewy, sdxnewz);
+      face_tdx = lp_build_select3(cint_bld, as_ge_at, ar_ge_as_at, tdxnewx, tdxnewy, tdxnewz);
+      face_sdy = lp_build_select3(cint_bld, as_ge_at, ar_ge_as_at, sdynewx, sdynewy, sdynewz);
+      face_tdy = lp_build_select3(cint_bld, as_ge_at, ar_ge_as_at, tdynewx, tdynewy, tdynewz);
+
+      face_s = LLVMBuildBitCast(builder, face_s, coord_vec_type, "");
+      face_t = LLVMBuildBitCast(builder, face_t, coord_vec_type, "");
+      face_sdx = LLVMBuildBitCast(builder, face_sdx, coord_vec_type, "");
+      face_tdx = LLVMBuildBitCast(builder, face_tdx, coord_vec_type, "");
+      face_sdy = LLVMBuildBitCast(builder, face_sdy, coord_vec_type, "");
+      face_tdy = LLVMBuildBitCast(builder, face_tdy, coord_vec_type, "");
+
+      /* deriv math, dx.s = 0.5 * (dx.sc - sc * dx.ma / ma) / ma */
+      madxdivma = lp_build_mul(coord_bld, madx, ima);
+      tmp = lp_build_mul(coord_bld, madxdivma, face_s);
+      tmp = lp_build_sub(coord_bld, face_sdx, tmp);
+      derivs_out->ddx[0] = lp_build_mul(coord_bld, tmp, imahalf);
+
+      /* dx.t = 0.5 * (dx.tc - tc * dx.ma / ma) / ma */
+      tmp = lp_build_mul(coord_bld, madxdivma, face_t);
+      tmp = lp_build_sub(coord_bld, face_tdx, tmp);
+      derivs_out->ddx[1] = lp_build_mul(coord_bld, tmp, imahalf);
+
+      /* dy.s = 0.5 * (dy.sc - sc * dy.ma / ma) / ma */
+      madydivma = lp_build_mul(coord_bld, mady, ima);
+      tmp = lp_build_mul(coord_bld, madydivma, face_s);
+      tmp = lp_build_sub(coord_bld, face_sdy, tmp);
+      derivs_out->ddy[0] = lp_build_mul(coord_bld, tmp, imahalf);
+
+      /* dy.t = 0.5 * (dy.tc - tc * dy.ma / ma) / ma */
+      tmp = lp_build_mul(coord_bld, madydivma, face_t);
+      tmp = lp_build_sub(coord_bld, face_tdy, tmp);
+      derivs_out->ddy[1] = lp_build_mul(coord_bld, tmp, imahalf);
 
-      /* XXX on x86 unclear if we should cast the values back to float
-       * or not - on some cpus (nehalem) pblendvb has twice the throughput
-       * of blendvps though on others there just might be domain
-       * transition penalties when using it (this depends on what llvm
-       * will chose for the bit ops above so there appears no "right way",
-       * but given the boatload of selects let's just use the int type).
-       */
-
-      /* select/mirror */
-      if (!need_derivs) {
-         ma = lp_build_select(coord_bld, as_ge_at, s, t);
-      }
-      face_s = lp_build_select(cint_bld, as_ge_at, snewx, snewy);
-      face_t = lp_build_select(cint_bld, as_ge_at, tnewx, tnewy);
-      face = lp_build_select(cint_bld, as_ge_at, facex, facey);
-
-      if (!need_derivs) {
-         ma = lp_build_select(coord_bld, ar_ge_as_at, r, ma);
-      }
-      face_s = lp_build_select(cint_bld, ar_ge_as_at, snewz, face_s);
-      face_t = lp_build_select(cint_bld, ar_ge_as_at, tnewz, face_t);
-      face = lp_build_select(cint_bld, ar_ge_as_at, facez, face);
-
-      face_s = LLVMBuildBitCast(builder, face_s,
-                               lp_build_vec_type(gallivm, coord_bld->type), "");
-      face_t = LLVMBuildBitCast(builder, face_t,
-                               lp_build_vec_type(gallivm, coord_bld->type), "");
-
-      /* add +1 for neg face */
-      /* XXX with AVX probably want to use another select here -
-       * as long as we ensure vblendvps gets used we can actually
-       * skip the comparison and just use sign as a "mask" directly.
-       */
-      mai = LLVMBuildBitCast(builder, ma, lp_build_vec_type(gallivm, intctype), "");
       signma = LLVMBuildLShr(builder, mai, signshift, "");
       coords[2] = LLVMBuildOr(builder, face, signma, "face");
 
       /* project coords */
-      if (!need_derivs) {
-         ima = lp_build_cube_imapos(coord_bld, ma);
-         face_s = lp_build_mul(coord_bld, face_s, ima);
-         face_t = lp_build_mul(coord_bld, face_t, ima);
-      }
+      face_s = lp_build_mul(coord_bld, face_s, imahalfpos);
+      face_t = lp_build_mul(coord_bld, face_t, imahalfpos);
 
       coords[0] = lp_build_add(coord_bld, face_s, posHalf);
       coords[1] = lp_build_add(coord_bld, face_t, posHalf);
+
+      return;
    }
 
-   else {
-      struct lp_build_if_state if_ctx;
-      LLVMValueRef face_s_var;
-      LLVMValueRef face_t_var;
-      LLVMValueRef face_var;
-      LLVMValueRef arx_ge_ary_arz, ary_ge_arx_arz;
-      LLVMValueRef shuffles[4];
-      LLVMValueRef arxy_ge_aryx, arxy_ge_arzz, arxy_ge_arxy_arzz;
-      LLVMValueRef arxyxy, aryxzz, arxyxy_ge_aryxzz;
-      LLVMValueRef tmp[4], rxyz, arxyz;
-      struct lp_build_context *float_bld = &bld->float_bld;
-      LLVMValueRef s, t, r, face, face_s, face_t;
-
-      assert(bld->coord_bld.type.length == 4);
-
-      tmp[0] = s = coords[0];
-      tmp[1] = t = coords[1];
-      tmp[2] = r = coords[2];
-      rxyz = lp_build_hadd_partial4(&bld->coord_bld, tmp, 3);
-      arxyz = lp_build_abs(&bld->coord_bld, rxyz);
-
-      shuffles[0] = lp_build_const_int32(gallivm, 0);
-      shuffles[1] = lp_build_const_int32(gallivm, 1);
-      shuffles[2] = lp_build_const_int32(gallivm, 0);
-      shuffles[3] = lp_build_const_int32(gallivm, 1);
-      arxyxy = LLVMBuildShuffleVector(builder, arxyz, arxyz, LLVMConstVector(shuffles, 4), "");
-      shuffles[0] = lp_build_const_int32(gallivm, 1);
-      shuffles[1] = lp_build_const_int32(gallivm, 0);
-      shuffles[2] = lp_build_const_int32(gallivm, 2);
-      shuffles[3] = lp_build_const_int32(gallivm, 2);
-      aryxzz = LLVMBuildShuffleVector(builder, arxyz, arxyz, LLVMConstVector(shuffles, 4), "");
-      arxyxy_ge_aryxzz = lp_build_cmp(&bld->coord_bld, PIPE_FUNC_GEQUAL, arxyxy, aryxzz);
-
-      shuffles[0] = lp_build_const_int32(gallivm, 0);
-      shuffles[1] = lp_build_const_int32(gallivm, 1);
-      arxy_ge_aryx = LLVMBuildShuffleVector(builder, arxyxy_ge_aryxzz, arxyxy_ge_aryxzz,
-                                            LLVMConstVector(shuffles, 2), "");
-      shuffles[0] = lp_build_const_int32(gallivm, 2);
-      shuffles[1] = lp_build_const_int32(gallivm, 3);
-      arxy_ge_arzz = LLVMBuildShuffleVector(builder, arxyxy_ge_aryxzz, arxyxy_ge_aryxzz,
-                                            LLVMConstVector(shuffles, 2), "");
-      arxy_ge_arxy_arzz = LLVMBuildAnd(builder, arxy_ge_aryx, arxy_ge_arzz, "");
-
-      arx_ge_ary_arz = LLVMBuildExtractElement(builder, arxy_ge_arxy_arzz,
-                                               lp_build_const_int32(gallivm, 0), "");
-      arx_ge_ary_arz = LLVMBuildICmp(builder, LLVMIntNE, arx_ge_ary_arz,
-                                               lp_build_const_int32(gallivm, 0), "");
-      ary_ge_arx_arz = LLVMBuildExtractElement(builder, arxy_ge_arxy_arzz,
-                                               lp_build_const_int32(gallivm, 1), "");
-      ary_ge_arx_arz = LLVMBuildICmp(builder, LLVMIntNE, ary_ge_arx_arz,
-                                               lp_build_const_int32(gallivm, 0), "");
-      face_s_var = lp_build_alloca(gallivm, bld->coord_bld.vec_type, "face_s_var");
-      face_t_var = lp_build_alloca(gallivm, bld->coord_bld.vec_type, "face_t_var");
-      face_var = lp_build_alloca(gallivm, bld->int_bld.vec_type, "face_var");
-
-      lp_build_if(&if_ctx, gallivm, arx_ge_ary_arz);
-      {
-         /* +/- X face */
-         LLVMValueRef sign, ima;
-         si = LLVMBuildExtractElement(builder, rxyz,
-                                      lp_build_const_int32(gallivm, 0), "");
-         /* +/- X face */
-         sign = lp_build_sgn(float_bld, si);
-         ima = lp_build_cube_imaneg(coord_bld, s);
-         face_s = lp_build_cube_coord(coord_bld, sign, +1, r, ima);
-         face_t = lp_build_cube_coord(coord_bld, NULL, +1, t, ima);
-         face = lp_build_cube_face(bld, si,
-                                    PIPE_TEX_FACE_POS_X,
-                                    PIPE_TEX_FACE_NEG_X);
-         LLVMBuildStore(builder, face_s, face_s_var);
-         LLVMBuildStore(builder, face_t, face_t_var);
-         LLVMBuildStore(builder, face, face_var);
-      }
-      lp_build_else(&if_ctx);
-      {
-         struct lp_build_if_state if_ctx2;
-
-         lp_build_if(&if_ctx2, gallivm, ary_ge_arx_arz);
-         {
-            LLVMValueRef sign, ima;
-            /* +/- Y face */
-            ti = LLVMBuildExtractElement(builder, rxyz,
-                                         lp_build_const_int32(gallivm, 1), "");
-            sign = lp_build_sgn(float_bld, ti);
-            ima = lp_build_cube_imaneg(coord_bld, t);
-            face_s = lp_build_cube_coord(coord_bld, NULL, -1, s, ima);
-            face_t = lp_build_cube_coord(coord_bld, sign, -1, r, ima);
-            face = lp_build_cube_face(bld, ti,
-                                       PIPE_TEX_FACE_POS_Y,
-                                       PIPE_TEX_FACE_NEG_Y);
-            LLVMBuildStore(builder, face_s, face_s_var);
-            LLVMBuildStore(builder, face_t, face_t_var);
-            LLVMBuildStore(builder, face, face_var);
-         }
-         lp_build_else(&if_ctx2);
-         {
-            /* +/- Z face */
-            LLVMValueRef sign, ima;
-            ri = LLVMBuildExtractElement(builder, rxyz,
-                                         lp_build_const_int32(gallivm, 2), "");
-            sign = lp_build_sgn(float_bld, ri);
-            ima = lp_build_cube_imaneg(coord_bld, r);
-            face_s = lp_build_cube_coord(coord_bld, sign, -1, s, ima);
-            face_t = lp_build_cube_coord(coord_bld, NULL, +1, t, ima);
-            face = lp_build_cube_face(bld, ri,
-                                       PIPE_TEX_FACE_POS_Z,
-                                       PIPE_TEX_FACE_NEG_Z);
-            LLVMBuildStore(builder, face_s, face_s_var);
-            LLVMBuildStore(builder, face_t, face_t_var);
-            LLVMBuildStore(builder, face, face_var);
-         }
-         lp_build_endif(&if_ctx2);
-      }
+   else if (need_derivs) {
+      LLVMValueRef ddx_ddy[2], tmp[3], rho_vec;
+      static const unsigned char swizzle0[] = { /* no-op swizzle */
+         0, LP_BLD_SWIZZLE_DONTCARE,
+         LP_BLD_SWIZZLE_DONTCARE, LP_BLD_SWIZZLE_DONTCARE
+      };
+      static const unsigned char swizzle1[] = {
+         1, LP_BLD_SWIZZLE_DONTCARE,
+         LP_BLD_SWIZZLE_DONTCARE, LP_BLD_SWIZZLE_DONTCARE
+      };
+      static const unsigned char swizzle01[] = { /* no-op swizzle */
+         0, 1,
+         LP_BLD_SWIZZLE_DONTCARE, LP_BLD_SWIZZLE_DONTCARE
+      };
+      static const unsigned char swizzle23[] = {
+         2, 3,
+         LP_BLD_SWIZZLE_DONTCARE, LP_BLD_SWIZZLE_DONTCARE
+      };
+      static const unsigned char swizzle02[] = {
+         0, 2,
+         LP_BLD_SWIZZLE_DONTCARE, LP_BLD_SWIZZLE_DONTCARE
+      };
 
-      lp_build_endif(&if_ctx);
+      /*
+       * scale the s/t/r coords pre-select/mirror so we can calculate
+       * "reasonable" derivs.
+       */
+      ma = lp_build_select3(coord_bld, as_ge_at, ar_ge_as_at, s, t, r);
+      imahalfpos = lp_build_cube_imapos(coord_bld, ma);
+      s = lp_build_mul(coord_bld, s, imahalfpos);
+      t = lp_build_mul(coord_bld, t, imahalfpos);
+      r = lp_build_mul(coord_bld, r, imahalfpos);
 
-      coords[0] = LLVMBuildLoad(builder, face_s_var, "face_s");
-      coords[1] = LLVMBuildLoad(builder, face_t_var, "face_t");
-      face   = LLVMBuildLoad(builder, face_var, "face");
-      coords[2]   = lp_build_broadcast_scalar(&bld->int_coord_bld, face);
+      /*
+       * This isn't quite the same as the "ordinary" (3d deriv) path since we
+       * know the texture is square which simplifies things (we can omit the
+       * size mul which happens very early completely here and do it at the
+       * very end).
+       * Also always do calculations according to GALLIVM_DEBUG_NO_RHO_APPROX
+       * since the error can get quite big otherwise at edges.
+       * (With no_rho_approx max error is sqrt(2) at edges, same as it is
+       * without no_rho_approx for 2d textures, otherwise it would be factor 2.)
+       */
+      ddx_ddy[0] = lp_build_packed_ddx_ddy_twocoord(coord_bld, s, t);
+      ddx_ddy[1] = lp_build_packed_ddx_ddy_onecoord(coord_bld, r);
+
+      ddx_ddy[0] = lp_build_mul(coord_bld, ddx_ddy[0], ddx_ddy[0]);
+      ddx_ddy[1] = lp_build_mul(coord_bld, ddx_ddy[1], ddx_ddy[1]);
+
+      tmp[0] = lp_build_swizzle_aos(coord_bld, ddx_ddy[0], swizzle01);
+      tmp[1] = lp_build_swizzle_aos(coord_bld, ddx_ddy[0], swizzle23);
+      tmp[2] = lp_build_swizzle_aos(coord_bld, ddx_ddy[1], swizzle02);
+
+      rho_vec = lp_build_add(coord_bld, tmp[0], tmp[1]);
+      rho_vec = lp_build_add(coord_bld, rho_vec, tmp[2]);
+
+      tmp[0] = lp_build_swizzle_aos(coord_bld, rho_vec, swizzle0);
+      tmp[1] = lp_build_swizzle_aos(coord_bld, rho_vec, swizzle1);
+      *rho = lp_build_max(coord_bld, tmp[0], tmp[1]);
    }
+
+   if (!need_derivs) {
+      ma = lp_build_select3(coord_bld, as_ge_at, ar_ge_as_at, s, t, r);
+   }
+   mai = LLVMBuildBitCast(builder, ma, cint_vec_type, "");
+   signmabit = LLVMBuildAnd(builder, mai, signmask, "");
+
+   si = LLVMBuildBitCast(builder, s, cint_vec_type, "");
+   ti = LLVMBuildBitCast(builder, t, cint_vec_type, "");
+   ri = LLVMBuildBitCast(builder, r, cint_vec_type, "");
+
+   /*
+    * compute all possible new s/t coords, which does the mirroring
+    * snewx = signma * -r;
+    * tnewx = -t;
+    * snewy = s;
+    * tnewy = signma * r;
+    * snewz = signma * s;
+    * tnewz = -t;
+    */
+   tnegi = LLVMBuildXor(builder, ti, signmask, "");
+   rnegi = LLVMBuildXor(builder, ri, signmask, "");
+
+   snewx = LLVMBuildXor(builder, signmabit, rnegi, "");
+   tnewx = tnegi;
+
+   snewy = si;
+   tnewy = LLVMBuildXor(builder, signmabit, ri, "");
+
+   snewz = LLVMBuildXor(builder, signmabit, si, "");
+   tnewz = tnegi;
+
+   /* select the mirrored values */
+   face_s = lp_build_select3(cint_bld, as_ge_at, ar_ge_as_at, snewx, snewy, snewz);
+   face_t = lp_build_select3(cint_bld, as_ge_at, ar_ge_as_at, tnewx, tnewy, tnewz);
+   face = lp_build_select3(cint_bld, as_ge_at, ar_ge_as_at, facex, facey, facez);
+
+   face_s = LLVMBuildBitCast(builder, face_s, coord_vec_type, "");
+   face_t = LLVMBuildBitCast(builder, face_t, coord_vec_type, "");
+
+   /* add +1 for neg face */
+   /* XXX with AVX probably want to use another select here -
+    * as long as we ensure vblendvps gets used we can actually
+    * skip the comparison and just use sign as a "mask" directly.
+    */
+   signma = LLVMBuildLShr(builder, mai, signshift, "");
+   coords[2] = LLVMBuildOr(builder, face, signma, "face");
+
+   /* project coords */
+   if (!need_derivs) {
+      imahalfpos = lp_build_cube_imapos(coord_bld, ma);
+      face_s = lp_build_mul(coord_bld, face_s, imahalfpos);
+      face_t = lp_build_mul(coord_bld, face_t, imahalfpos);
+   }
+
+   coords[0] = lp_build_add(coord_bld, face_s, posHalf);
+   coords[1] = lp_build_add(coord_bld, face_t, posHalf);
 }
 
 
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_sample.h b/src/gallium/auxiliary/gallivm/lp_bld_sample.h
index 803a99e..70f0350 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_sample.h
+++ b/src/gallium/auxiliary/gallivm/lp_bld_sample.h
@@ -457,8 +457,9 @@ lp_build_unnormalized_coords(struct lp_build_sample_context *bld,
 void
 lp_build_cube_lookup(struct lp_build_sample_context *bld,
                      LLVMValueRef *coords,
-                     const struct lp_derivatives *derivs, /* optional */
+                     const struct lp_derivatives *derivs_in, /* optional */
                      LLVMValueRef *rho,
+                     struct lp_derivatives *derivs_out, /* optional */
                      boolean need_derivs);
 
 
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_sample_soa.c b/src/gallium/auxiliary/gallivm/lp_bld_sample_soa.c
index 33378bc..54dee25 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_sample_soa.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_sample_soa.c
@@ -1387,6 +1387,7 @@ lp_build_sample_common(struct lp_build_sample_context *bld,
    const unsigned target = bld->static_texture_state->target;
    LLVMValueRef first_level, cube_rho = NULL;
    LLVMValueRef lod_ipart = NULL;
+   struct lp_derivatives cube_derivs;
 
    /*
    printf("%s mip %d  min %d  mag %d\n", __FUNCTION__,
@@ -1403,7 +1404,8 @@ lp_build_sample_common(struct lp_build_sample_context *bld,
                       mip_filter != PIPE_TEX_MIPFILTER_NONE) &&
                       !bld->static_sampler_state->min_max_lod_equal &&
                       !explicit_lod);
-      lp_build_cube_lookup(bld, coords, derivs, &cube_rho, need_derivs);
+      lp_build_cube_lookup(bld, coords, derivs, &cube_rho, &cube_derivs, need_derivs);
+      derivs = &cube_derivs;
    }
    else if (target == PIPE_TEXTURE_1D_ARRAY ||
             target == PIPE_TEXTURE_2D_ARRAY) {
@@ -2163,9 +2165,24 @@ lp_build_sample_soa(struct gallivm_state *gallivm,
     * avoided like min and max lod being equal.
     */
    bld.num_mips = bld.num_lods = 1;
-   if (lod_property == LP_SAMPLER_LOD_PER_ELEMENT &&
-       (explicit_lod || lod_bias ||
-        (derivs && static_texture_state->target != PIPE_TEXTURE_CUBE))) {
+
+   if ((gallivm_debug & GALLIVM_DEBUG_NO_QUAD_LOD) &&
+       (gallivm_debug & GALLIVM_DEBUG_NO_RHO_APPROX) &&
+       (static_texture_state->target == PIPE_TEXTURE_CUBE) &&
+       (!is_fetch && mip_filter != PIPE_TEX_MIPFILTER_NONE)) {
+      /*
+       * special case for using per-pixel lod even for implicit lod,
+       * which is generally never required (ok by APIs) except to please
+       * some (somewhat broken imho) tests (because per-pixel face selection
+       * can cause derivatives to be different for pixels outside the primitive
+       * due to the major axis division even if pre-project derivatives are
+       * looking normal).
+       */
+      bld.num_mips = type.length;
+      bld.num_lods = type.length;
+   }
+   else if (lod_property == LP_SAMPLER_LOD_PER_ELEMENT ||
+       (explicit_lod || lod_bias || derivs)) {
       if ((is_fetch && target != PIPE_BUFFER) ||
           (!is_fetch && mip_filter != PIPE_TEX_MIPFILTER_NONE)) {
          bld.num_mips = type.length;
@@ -2371,9 +2388,15 @@ lp_build_sample_soa(struct gallivm_state *gallivm,
          bld4.texel_type.length = 4;
 
          bld4.num_mips = bld4.num_lods = 1;
+         if ((gallivm_debug & GALLIVM_DEBUG_NO_QUAD_LOD) &&
+             (gallivm_debug & GALLIVM_DEBUG_NO_RHO_APPROX) &&
+             (static_texture_state->target == PIPE_TEXTURE_CUBE) &&
+             (!is_fetch && mip_filter != PIPE_TEX_MIPFILTER_NONE)) {
+            bld4.num_mips = type4.length;
+            bld4.num_lods = type4.length;
+         }
          if (lod_property == LP_SAMPLER_LOD_PER_ELEMENT &&
-             (explicit_lod || lod_bias ||
-              (derivs && static_texture_state->target != PIPE_TEXTURE_CUBE))) {
+             (explicit_lod || lod_bias || derivs)) {
             if ((is_fetch && target != PIPE_BUFFER) ||
                 (!is_fetch && mip_filter != PIPE_TEX_MIPFILTER_NONE)) {
                bld4.num_mips = type4.length;
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_tgsi_action.c b/src/gallium/auxiliary/gallivm/lp_bld_tgsi_action.c
index 1cfaf78..8caaf83 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_tgsi_action.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_tgsi_action.c
@@ -763,6 +763,64 @@ umul_emit(
                                    emit_data->args[0], emit_data->args[1]);
 }
 
+/* TGSI_OPCODE_IMUL_HI */
+static void
+imul_hi_emit(
+   const struct lp_build_tgsi_action * action,
+   struct lp_build_tgsi_context * bld_base,
+   struct lp_build_emit_data * emit_data)
+{
+   LLVMBuilderRef builder = bld_base->base.gallivm->builder;
+   struct lp_build_context *int_bld = &bld_base->int_bld;
+   struct lp_type type = int_bld->type;
+   LLVMValueRef src0, src1;
+   LLVMValueRef dst64;
+   LLVMTypeRef typeRef;
+
+   assert(type.width == 32);
+   type.width = 64;
+   typeRef = lp_build_vec_type(bld_base->base.gallivm, type);
+   src0 = LLVMBuildSExt(builder, emit_data->args[0], typeRef, "");
+   src1 = LLVMBuildSExt(builder, emit_data->args[1], typeRef, "");
+   dst64 = LLVMBuildMul(builder, src0, src1, "");
+   dst64 = LLVMBuildAShr(
+            builder, dst64,
+            lp_build_const_vec(bld_base->base.gallivm, type, 32), "");
+   type.width = 32;
+   typeRef = lp_build_vec_type(bld_base->base.gallivm, type);
+   emit_data->output[emit_data->chan] =
+         LLVMBuildTrunc(builder, dst64, typeRef, "");
+}
+
+/* TGSI_OPCODE_UMUL_HI */
+static void
+umul_hi_emit(
+   const struct lp_build_tgsi_action * action,
+   struct lp_build_tgsi_context * bld_base,
+   struct lp_build_emit_data * emit_data)
+{
+   LLVMBuilderRef builder = bld_base->base.gallivm->builder;
+   struct lp_build_context *uint_bld = &bld_base->uint_bld;
+   struct lp_type type = uint_bld->type;
+   LLVMValueRef src0, src1;
+   LLVMValueRef dst64;
+   LLVMTypeRef typeRef;
+
+   assert(type.width == 32);
+   type.width = 64;
+   typeRef = lp_build_vec_type(bld_base->base.gallivm, type);
+   src0 = LLVMBuildZExt(builder, emit_data->args[0], typeRef, "");
+   src1 = LLVMBuildZExt(builder, emit_data->args[1], typeRef, "");
+   dst64 = LLVMBuildMul(builder, src0, src1, "");
+   dst64 = LLVMBuildLShr(
+            builder, dst64,
+            lp_build_const_vec(bld_base->base.gallivm, type, 32), "");
+   type.width = 32;
+   typeRef = lp_build_vec_type(bld_base->base.gallivm, type);
+   emit_data->output[emit_data->chan] =
+         LLVMBuildTrunc(builder, dst64, typeRef, "");
+}
+
 /* TGSI_OPCODE_MAX */
 static void fmax_emit(
    const struct lp_build_tgsi_action * action,
@@ -894,6 +952,8 @@ lp_set_default_actions(struct lp_build_tgsi_context * bld_base)
    bld_base->op_actions[TGSI_OPCODE_U2F].emit = u2f_emit;
    bld_base->op_actions[TGSI_OPCODE_UMAD].emit = umad_emit;
    bld_base->op_actions[TGSI_OPCODE_UMUL].emit = umul_emit;
+   bld_base->op_actions[TGSI_OPCODE_IMUL_HI].emit = imul_hi_emit;
+   bld_base->op_actions[TGSI_OPCODE_UMUL_HI].emit = umul_hi_emit;
 
    bld_base->op_actions[TGSI_OPCODE_MAX].emit = fmax_emit;
    bld_base->op_actions[TGSI_OPCODE_MIN].emit = fmin_emit;
diff --git a/src/gallium/auxiliary/rtasm/rtasm_execmem.c b/src/gallium/auxiliary/rtasm/rtasm_execmem.c
index 8f7cc20..3c4b048 100644
--- a/src/gallium/auxiliary/rtasm/rtasm_execmem.c
+++ b/src/gallium/auxiliary/rtasm/rtasm_execmem.c
@@ -49,7 +49,7 @@
 #include <windows.h>
 #endif
 
-#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_HAIKU)
+#if defined(PIPE_OS_LINUX) || defined(PIPE_OS_BSD) || defined(PIPE_OS_SOLARIS) || defined(PIPE_OS_HAIKU) || defined(PIPE_OS_CYGWIN)
 
 
 /*
diff --git a/src/gallium/auxiliary/rtasm/rtasm_x86sse.h b/src/gallium/auxiliary/rtasm/rtasm_x86sse.h
index 67c9bdd..498ca82 100644
--- a/src/gallium/auxiliary/rtasm/rtasm_x86sse.h
+++ b/src/gallium/auxiliary/rtasm/rtasm_x86sse.h
@@ -140,7 +140,7 @@ static INLINE enum x86_target x86_target( struct x86_function* p )
 {
 #ifdef PIPE_ARCH_X86
    return X86_32;
-#elif defined(_WIN64)
+#elif (defined(PIPE_OS_CYGWIN) || defined(PIPE_OS_WINDOWS)) && defined(PIPE_ARCH_X86_64)
    return X86_64_WIN64_ABI;
 #elif defined(PIPE_ARCH_X86_64)
    return X86_64_STD_ABI;
diff --git a/src/gallium/auxiliary/tgsi/tgsi_exec.c b/src/gallium/auxiliary/tgsi/tgsi_exec.c
index 0750a50..6db1238 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_exec.c
+++ b/src/gallium/auxiliary/tgsi/tgsi_exec.c
@@ -3478,6 +3478,32 @@ micro_umul(union tgsi_exec_channel *dst,
 }
 
 static void
+micro_imul_hi(union tgsi_exec_channel *dst,
+              const union tgsi_exec_channel *src0,
+              const union tgsi_exec_channel *src1)
+{
+#define I64M(x, y) ((((int64_t)x) * ((int64_t)y)) >> 32)
+   dst->i[0] = I64M(src0->i[0], src1->i[0]);
+   dst->i[1] = I64M(src0->i[1], src1->i[1]);
+   dst->i[2] = I64M(src0->i[2], src1->i[2]);
+   dst->i[3] = I64M(src0->i[3], src1->i[3]);
+#undef I64M
+}
+
+static void
+micro_umul_hi(union tgsi_exec_channel *dst,
+              const union tgsi_exec_channel *src0,
+              const union tgsi_exec_channel *src1)
+{
+#define U64M(x, y) ((((uint64_t)x) * ((uint64_t)y)) >> 32)
+   dst->u[0] = U64M(src0->u[0], src1->u[0]);
+   dst->u[1] = U64M(src0->u[1], src1->u[1]);
+   dst->u[2] = U64M(src0->u[2], src1->u[2]);
+   dst->u[3] = U64M(src0->u[3], src1->u[3]);
+#undef U64M
+}
+
+static void
 micro_useq(union tgsi_exec_channel *dst,
            const union tgsi_exec_channel *src0,
            const union tgsi_exec_channel *src1)
@@ -4277,6 +4303,14 @@ exec_instruction(
       exec_vector_binary(mach, inst, micro_umul, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
       break;
 
+   case TGSI_OPCODE_IMUL_HI:
+      exec_vector_binary(mach, inst, micro_imul_hi, TGSI_EXEC_DATA_INT, TGSI_EXEC_DATA_INT);
+      break;
+
+   case TGSI_OPCODE_UMUL_HI:
+      exec_vector_binary(mach, inst, micro_umul_hi, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
+      break;
+
    case TGSI_OPCODE_USEQ:
       exec_vector_binary(mach, inst, micro_useq, TGSI_EXEC_DATA_UINT, TGSI_EXEC_DATA_UINT);
       break;
diff --git a/src/gallium/auxiliary/tgsi/tgsi_info.c b/src/gallium/auxiliary/tgsi/tgsi_info.c
index 7a5d18f..0beef44 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_info.c
+++ b/src/gallium/auxiliary/tgsi/tgsi_info.c
@@ -219,6 +219,8 @@ static const struct tgsi_opcode_info opcode_info[TGSI_OPCODE_LAST] =
    { 1, 3, 1, 0, 0, 0, OTHR, "TEX2", TGSI_OPCODE_TEX2 },
    { 1, 3, 1, 0, 0, 0, OTHR, "TXB2", TGSI_OPCODE_TXB2 },
    { 1, 3, 1, 0, 0, 0, OTHR, "TXL2", TGSI_OPCODE_TXL2 },
+   { 1, 2, 0, 0, 0, 0, COMP, "IMUL_HI", TGSI_OPCODE_IMUL_HI },
+   { 1, 2, 0, 0, 0, 0, COMP, "UMUL_HI", TGSI_OPCODE_UMUL_HI },
 };
 
 const struct tgsi_opcode_info *
@@ -297,6 +299,7 @@ tgsi_opcode_infer_type( uint opcode )
    case TGSI_OPCODE_USLT:
    case TGSI_OPCODE_USNE:
    case TGSI_OPCODE_SVIEWINFO:
+   case TGSI_OPCODE_UMUL_HI:
       return TGSI_TYPE_UNSIGNED;
    case TGSI_OPCODE_ARL:
    case TGSI_OPCODE_ARR:
@@ -317,6 +320,7 @@ tgsi_opcode_infer_type( uint opcode )
    case TGSI_OPCODE_UARL:
    case TGSI_OPCODE_IABS:
    case TGSI_OPCODE_ISSG:
+   case TGSI_OPCODE_IMUL_HI:
       return TGSI_TYPE_SIGNED;
    default:
       return TGSI_TYPE_FLOAT;
@@ -339,7 +343,9 @@ tgsi_opcode_infer_src_type( uint opcode )
    case TGSI_OPCODE_CASE:
    case TGSI_OPCODE_SAMPLE_I:
    case TGSI_OPCODE_SAMPLE_I_MS:
+   case TGSI_OPCODE_UMUL_HI:
       return TGSI_TYPE_UNSIGNED;
+   case TGSI_OPCODE_IMUL_HI:
    case TGSI_OPCODE_I2F:
       return TGSI_TYPE_SIGNED;
    case TGSI_OPCODE_ARL:
diff --git a/src/gallium/auxiliary/tgsi/tgsi_opcode_tmp.h b/src/gallium/auxiliary/tgsi/tgsi_opcode_tmp.h
index b8144a8..1ef78dd 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_opcode_tmp.h
+++ b/src/gallium/auxiliary/tgsi/tgsi_opcode_tmp.h
@@ -204,6 +204,9 @@ OP12(SAMPLE_INFO)
 
 OP13(UCMP)
 
+OP12(IMUL_HI)
+OP12(UMUL_HI)
+
 #undef OP00
 #undef OP01
 #undef OP10
diff --git a/src/gallium/auxiliary/tgsi/tgsi_util.c b/src/gallium/auxiliary/tgsi/tgsi_util.c
index b3bc8f2..73a0667 100644
--- a/src/gallium/auxiliary/tgsi/tgsi_util.c
+++ b/src/gallium/auxiliary/tgsi/tgsi_util.c
@@ -243,6 +243,8 @@ tgsi_util_get_inst_usage_mask(const struct tgsi_full_instruction *inst,
    case TGSI_OPCODE_USHR:
    case TGSI_OPCODE_USLT:
    case TGSI_OPCODE_USNE:
+   case TGSI_OPCODE_IMUL_HI:
+   case TGSI_OPCODE_UMUL_HI:
       /* Channel-wise operations */
       read_mask = write_mask;
       break;
diff --git a/src/gallium/auxiliary/translate/translate_sse.c b/src/gallium/auxiliary/translate/translate_sse.c
index 726a9b1..3e12f1e 100644
--- a/src/gallium/auxiliary/translate/translate_sse.c
+++ b/src/gallium/auxiliary/translate/translate_sse.c
@@ -1308,14 +1308,22 @@ static boolean build_vertex_emit( struct translate_sse *p,
    x86_push(p->func, p->outbuf_EBX);
    x86_push(p->func, p->count_EBP);
 
-/* on non-Win64 x86-64, these are already in the right registers */
+   /* on non-Win64 x86-64, these are already in the right registers */
    if(x86_target(p->func) != X86_64_STD_ABI)
    {
       x86_push(p->func, p->machine_EDI);
       x86_push(p->func, p->idx_ESI);
 
-      x86_mov(p->func, p->machine_EDI, x86_fn_arg(p->func, 1));
-      x86_mov(p->func, p->idx_ESI, x86_fn_arg(p->func, 2));
+      if(x86_target(p->func) != X86_32)
+      {
+        x64_mov64(p->func, p->machine_EDI, x86_fn_arg(p->func, 1));
+        x64_mov64(p->func, p->idx_ESI, x86_fn_arg(p->func, 2));
+      }
+      else
+      {
+        x86_mov(p->func, p->machine_EDI, x86_fn_arg(p->func, 1));
+        x86_mov(p->func, p->idx_ESI, x86_fn_arg(p->func, 2));
+      }
    }
 
    x86_mov(p->func, p->count_EBP, x86_fn_arg(p->func, 3));
diff --git a/src/gallium/auxiliary/util/u_blitter.c b/src/gallium/auxiliary/util/u_blitter.c
index be839d4..a51b9ef 100644
--- a/src/gallium/auxiliary/util/u_blitter.c
+++ b/src/gallium/auxiliary/util/u_blitter.c
@@ -528,9 +528,10 @@ static void blitter_restore_textures(struct blitter_context_priv *ctx)
    unsigned i;
 
    /* Fragment sampler states. */
-   pipe->bind_fragment_sampler_states(pipe,
-                                      ctx->base.saved_num_sampler_states,
-                                      ctx->base.saved_sampler_states);
+   pipe->bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0,
+                             ctx->base.saved_num_sampler_states,
+                             ctx->base.saved_sampler_states);
+
    ctx->base.saved_num_sampler_states = ~0;
 
    /* Fragment sampler views. */
@@ -1309,7 +1310,7 @@ void util_blitter_blit_generic(struct blitter_context *blitter,
       views[1] = pipe->create_sampler_view(pipe, src->texture, &templ);
 
       pipe->set_fragment_sampler_views(pipe, 2, views);
-      pipe->bind_fragment_sampler_states(pipe, 2, samplers);
+      pipe->bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0, 2, samplers);
 
       pipe_sampler_view_reference(&views[1], NULL);
    } else if (blit_stencil) {
@@ -1324,12 +1325,14 @@ void util_blitter_blit_generic(struct blitter_context *blitter,
       view = pipe->create_sampler_view(pipe, src->texture, &templ);
 
       pipe->set_fragment_sampler_views(pipe, 1, &view);
-      pipe->bind_fragment_sampler_states(pipe, 1, &sampler_state);
+      pipe->bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT,
+                                0, 1, &sampler_state);
 
       pipe_sampler_view_reference(&view, NULL);
    } else {
       pipe->set_fragment_sampler_views(pipe, 1, &src);
-      pipe->bind_fragment_sampler_states(pipe, 1, &sampler_state);
+      pipe->bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT,
+                                0, 1, &sampler_state);
    }
 
    pipe->bind_vertex_elements_state(pipe, ctx->velem_state);
diff --git a/src/gallium/auxiliary/util/u_math.h b/src/gallium/auxiliary/util/u_math.h
index 702d4e9..f5c14ef 100644
--- a/src/gallium/auxiliary/util/u_math.h
+++ b/src/gallium/auxiliary/util/u_math.h
@@ -162,7 +162,59 @@ float log2f(float f)
 #endif
 
 
+#if __STDC_VERSION__ < 199901L && (!defined(__cplusplus) || defined(_MSC_VER))
+static INLINE long int
+lrint(double d)
+{
+   long int rounded = (long int)(d + 0.5);
+
+   if (d - floor(d) == 0.5) {
+      if (rounded % 2 != 0)
+         rounded += (d > 0) ? -1 : 1;
+   }
+
+   return rounded;
+}
+
+static INLINE long int
+lrintf(float f)
+{
+   long int rounded = (long int)(f + 0.5f);
+
+   if (f - floorf(f) == 0.5f) {
+      if (rounded % 2 != 0)
+         rounded += (f > 0) ? -1 : 1;
+   }
+
+   return rounded;
+}
 
+static INLINE long long int
+llrint(double d)
+{
+   long long int rounded = (long long int)(d + 0.5);
+
+   if (d - floor(d) == 0.5) {
+      if (rounded % 2 != 0)
+         rounded += (d > 0) ? -1 : 1;
+   }
+
+   return rounded;
+}
+
+static INLINE long long int
+llrintf(float f)
+{
+   long long int rounded = (long long int)(f + 0.5f);
+
+   if (f - floorf(f) == 0.5f) {
+      if (rounded % 2 != 0)
+         rounded += (f > 0) ? -1 : 1;
+   }
+
+   return rounded;
+}
+#endif /* C99 */
 
 #define POW2_TABLE_SIZE_LOG2 9
 #define POW2_TABLE_SIZE (1 << POW2_TABLE_SIZE_LOG2)
diff --git a/src/gallium/auxiliary/util/u_pack_color.h b/src/gallium/auxiliary/util/u_pack_color.h
index 102ad60..3625273 100644
--- a/src/gallium/auxiliary/util/u_pack_color.h
+++ b/src/gallium/auxiliary/util/u_pack_color.h
@@ -528,12 +528,12 @@ util_pack_z(enum pipe_format format, double z)
    case PIPE_FORMAT_Z16_UNORM:
       if (z == 1.0)
          return 0xffff;
-      return (uint32_t) (z * 0xffff);
+      return (uint32_t) lrint(z * 0xffff);
    case PIPE_FORMAT_Z32_UNORM:
       /* special-case to avoid overflow */
       if (z == 1.0)
          return 0xffffffff;
-      return (uint32_t) (z * 0xffffffff);
+      return (uint32_t) llrint(z * 0xffffffff);
    case PIPE_FORMAT_Z32_FLOAT:
       fui.f = (float)z;
       return fui.ui;
@@ -541,12 +541,12 @@ util_pack_z(enum pipe_format format, double z)
    case PIPE_FORMAT_Z24X8_UNORM:
       if (z == 1.0)
          return 0xffffff;
-      return (uint32_t) (z * 0xffffff);
+      return (uint32_t) lrint(z * 0xffffff);
    case PIPE_FORMAT_S8_UINT_Z24_UNORM:
    case PIPE_FORMAT_X8Z24_UNORM:
       if (z == 1.0)
          return 0xffffff00;
-      return ((uint32_t) (z * 0xffffff)) << 8;
+      return ((uint32_t) lrint(z * 0xffffff)) << 8;
    case PIPE_FORMAT_S8_UINT:
       /* this case can get it via util_pack_z_stencil() */
       return 0;
diff --git a/src/gallium/auxiliary/vl/vl_compositor.c b/src/gallium/auxiliary/vl/vl_compositor.c
index 4b83087..db4c697 100644
--- a/src/gallium/auxiliary/vl/vl_compositor.c
+++ b/src/gallium/auxiliary/vl/vl_compositor.c
@@ -725,7 +725,8 @@ draw_layers(struct vl_compositor *c, struct vl_compositor_state *s, struct u_rec
          c->pipe->bind_blend_state(c->pipe, blend);
          c->pipe->set_viewport_states(c->pipe, 0, 1, &layer->viewport);
          c->pipe->bind_fs_state(c->pipe, layer->fs);
-         c->pipe->bind_fragment_sampler_states(c->pipe, num_sampler_views, layer->samplers);
+         c->pipe->bind_sampler_states(c->pipe, PIPE_SHADER_FRAGMENT, 0,
+                                      num_sampler_views, layer->samplers);
          c->pipe->set_fragment_sampler_views(c->pipe, num_sampler_views, samplers);
          util_draw_arrays(c->pipe, PIPE_PRIM_QUADS, vb_index * 4, 4);
          vb_index++;
diff --git a/src/gallium/auxiliary/vl/vl_idct.c b/src/gallium/auxiliary/vl/vl_idct.c
index 5346cbc..dc14bb7 100644
--- a/src/gallium/auxiliary/vl/vl_idct.c
+++ b/src/gallium/auxiliary/vl/vl_idct.c
@@ -825,7 +825,10 @@ vl_idct_flush(struct vl_idct *idct, struct vl_idct_buffer *buffer, unsigned num_
 
    idct->pipe->bind_rasterizer_state(idct->pipe, idct->rs_state);
    idct->pipe->bind_blend_state(idct->pipe, idct->blend);
-   idct->pipe->bind_fragment_sampler_states(idct->pipe, 2, idct->samplers);
+
+   idct->pipe->bind_sampler_states(idct->pipe, PIPE_SHADER_FRAGMENT,
+                                   0, 2, idct->samplers);
+
    idct->pipe->set_fragment_sampler_views(idct->pipe, 2, buffer->sampler_views.stage[0]);
 
    /* mismatch control */
@@ -850,7 +853,8 @@ vl_idct_prepare_stage2(struct vl_idct *idct, struct vl_idct_buffer *buffer)
 
    /* second stage */
    idct->pipe->bind_rasterizer_state(idct->pipe, idct->rs_state);
-   idct->pipe->bind_fragment_sampler_states(idct->pipe, 2, idct->samplers);
+   idct->pipe->bind_sampler_states(idct->pipe, PIPE_SHADER_FRAGMENT,
+                                   0, 2, idct->samplers);
    idct->pipe->set_fragment_sampler_views(idct->pipe, 2, buffer->sampler_views.stage[1]);
 }
 
diff --git a/src/gallium/auxiliary/vl/vl_matrix_filter.c b/src/gallium/auxiliary/vl/vl_matrix_filter.c
index 9bd7ed1..b7c88e7 100644
--- a/src/gallium/auxiliary/vl/vl_matrix_filter.c
+++ b/src/gallium/auxiliary/vl/vl_matrix_filter.c
@@ -306,7 +306,8 @@ vl_matrix_filter_render(struct vl_matrix_filter *filter,
 
    filter->pipe->bind_rasterizer_state(filter->pipe, filter->rs_state);
    filter->pipe->bind_blend_state(filter->pipe, filter->blend);
-   filter->pipe->bind_fragment_sampler_states(filter->pipe, 1, &filter->sampler);
+   filter->pipe->bind_sampler_states(filter->pipe, PIPE_SHADER_FRAGMENT,
+                                     0, 1, &filter->sampler);
    filter->pipe->set_fragment_sampler_views(filter->pipe, 1, &src);
    filter->pipe->bind_vs_state(filter->pipe, filter->vs);
    filter->pipe->bind_fs_state(filter->pipe, filter->fs);
diff --git a/src/gallium/auxiliary/vl/vl_mc.c b/src/gallium/auxiliary/vl/vl_mc.c
index 4877f5e..bd75df1 100644
--- a/src/gallium/auxiliary/vl/vl_mc.c
+++ b/src/gallium/auxiliary/vl/vl_mc.c
@@ -614,7 +614,8 @@ vl_mc_render_ref(struct vl_mc *renderer, struct vl_mc_buffer *buffer, struct pip
    renderer->pipe->bind_fs_state(renderer->pipe, renderer->fs_ref);
 
    renderer->pipe->set_fragment_sampler_views(renderer->pipe, 1, &ref);
-   renderer->pipe->bind_fragment_sampler_states(renderer->pipe, 1, &renderer->sampler_ref);
+   renderer->pipe->bind_sampler_states(renderer->pipe, PIPE_SHADER_FRAGMENT,
+                                       0, 1, &renderer->sampler_ref);
 
    util_draw_arrays_instanced(renderer->pipe, PIPE_PRIM_QUADS, 0, 4, 0,
                               renderer->buffer_width / VL_MACROBLOCK_WIDTH *
diff --git a/src/gallium/auxiliary/vl/vl_median_filter.c b/src/gallium/auxiliary/vl/vl_median_filter.c
index 158751a..f5ef117 100644
--- a/src/gallium/auxiliary/vl/vl_median_filter.c
+++ b/src/gallium/auxiliary/vl/vl_median_filter.c
@@ -385,7 +385,8 @@ vl_median_filter_render(struct vl_median_filter *filter,
 
    filter->pipe->bind_rasterizer_state(filter->pipe, filter->rs_state);
    filter->pipe->bind_blend_state(filter->pipe, filter->blend);
-   filter->pipe->bind_fragment_sampler_states(filter->pipe, 1, &filter->sampler);
+   filter->pipe->bind_sampler_states(filter->pipe, PIPE_SHADER_FRAGMENT,
+                                     0, 1, &filter->sampler);
    filter->pipe->set_fragment_sampler_views(filter->pipe, 1, &src);
    filter->pipe->bind_vs_state(filter->pipe, filter->vs);
    filter->pipe->bind_fs_state(filter->pipe, filter->fs);
diff --git a/src/gallium/auxiliary/vl/vl_mpeg12_decoder.c b/src/gallium/auxiliary/vl/vl_mpeg12_decoder.c
index f91f90b..bc207ac 100644
--- a/src/gallium/auxiliary/vl/vl_mpeg12_decoder.c
+++ b/src/gallium/auxiliary/vl/vl_mpeg12_decoder.c
@@ -747,7 +747,9 @@ vl_mpeg12_end_frame(struct pipe_video_codec *decoder,
             vl_idct_prepare_stage2(i ? &dec->idct_c : &dec->idct_y, &buf->idct[plane]);
          else {
             dec->base.context->set_fragment_sampler_views(dec->base.context, 1, &mc_source_sv[plane]);
-            dec->base.context->bind_fragment_sampler_states(dec->base.context, 1, &dec->sampler_ycbcr);
+            dec->base.context->bind_sampler_states(dec->base.context,
+                                                   PIPE_SHADER_FRAGMENT,
+                                                   0, 1, &dec->sampler_ycbcr);
          }
          vl_mc_render_ycbcr(i ? &dec->mc_c : &dec->mc_y, &buf->mc[i], j, buf->num_ycbcr_blocks[plane]);
       }
diff --git a/src/gallium/auxiliary/vl/vl_zscan.c b/src/gallium/auxiliary/vl/vl_zscan.c
index 33baa3d..2d616d57 100644
--- a/src/gallium/auxiliary/vl/vl_zscan.c
+++ b/src/gallium/auxiliary/vl/vl_zscan.c
@@ -574,7 +574,8 @@ vl_zscan_render(struct vl_zscan *zscan, struct vl_zscan_buffer *buffer, unsigned
 
    zscan->pipe->bind_rasterizer_state(zscan->pipe, zscan->rs_state);
    zscan->pipe->bind_blend_state(zscan->pipe, zscan->blend);
-   zscan->pipe->bind_fragment_sampler_states(zscan->pipe, 3, zscan->samplers);
+   zscan->pipe->bind_sampler_states(zscan->pipe, PIPE_SHADER_FRAGMENT,
+                                    0, 3, zscan->samplers);
    zscan->pipe->set_framebuffer_state(zscan->pipe, &buffer->fb_state);
    zscan->pipe->set_viewport_states(zscan->pipe, 0, 1, &buffer->viewport);
    zscan->pipe->set_fragment_sampler_views(zscan->pipe, 3, &buffer->src);
diff --git a/src/gallium/docs/source/context.rst b/src/gallium/docs/source/context.rst
index d5b4d77..e471eeb 100644
--- a/src/gallium/docs/source/context.rst
+++ b/src/gallium/docs/source/context.rst
@@ -25,10 +25,11 @@ CSO objects handled by the context object:
 
 * :ref:`Blend`: ``*_blend_state``
 * :ref:`Sampler`: Texture sampler states are bound separately for fragment,
-  vertex and geometry samplers.  Note that sampler states are set en masse.
-  If M is the max number of sampler units supported by the driver and N
-  samplers are bound with ``bind_fragment_sampler_states`` then sampler
-  units N..M-1 are considered disabled/NULL.
+  vertex, geometry and compute shaders with the ``bind_sampler_states``
+  function.  The ``start`` and ``num_samplers`` parameters indicate a range
+  of samplers to change.  NOTE: at this time, start is always zero and
+  the CSO module will always replace all samplers at once (no sub-ranges).
+  This may change in the future.
 * :ref:`Rasterizer`: ``*_rasterizer_state``
 * :ref:`Depth, Stencil, & Alpha`: ``*_depth_stencil_alpha_state``
 * :ref:`Shader`: These are create, bind and destroy methods for vertex,
@@ -599,6 +600,6 @@ may be specified by the user with the ``set_compute_resources``
 method.
 
 In addition, normal texture sampling is allowed from the compute
-program: ``bind_compute_sampler_states`` may be used to set up texture
+program: ``bind_sampler_states`` may be used to set up texture
 samplers for the compute stage and ``set_compute_sampler_views`` may
 be used to bind a number of sampler views to it.
diff --git a/src/gallium/docs/source/tgsi.rst b/src/gallium/docs/source/tgsi.rst
index 41f2798..f80c08d 100644
--- a/src/gallium/docs/source/tgsi.rst
+++ b/src/gallium/docs/source/tgsi.rst
@@ -1103,6 +1103,36 @@ Support for these opcodes indicated by PIPE_SHADER_CAP_INTEGERS (all of them?)
   dst.w = src0.w \times src1.w
 
 
+.. opcode:: IMUL_HI - Signed Integer Multiply High Bits
+
+   The high 32bits of the multiplication of 2 signed integers are returned.
+
+.. math::
+
+  dst.x = (src0.x \times src1.x) >> 32
+
+  dst.y = (src0.y \times src1.y) >> 32
+
+  dst.z = (src0.z \times src1.z) >> 32
+
+  dst.w = (src0.w \times src1.w) >> 32
+
+
+.. opcode:: UMUL_HI - Unsigned Integer Multiply High Bits
+
+   The high 32bits of the multiplication of 2 unsigned integers are returned.
+
+.. math::
+
+  dst.x = (src0.x \times src1.x) >> 32
+
+  dst.y = (src0.y \times src1.y) >> 32
+
+  dst.z = (src0.z \times src1.z) >> 32
+
+  dst.w = (src0.w \times src1.w) >> 32
+
+
 .. opcode:: IDIV - Signed Integer Division
 
    TBD: behavior for division by zero.
diff --git a/src/gallium/drivers/freedreno/freedreno_texture.c b/src/gallium/drivers/freedreno/freedreno_texture.c
index ff8a445..fc0c8aa 100644
--- a/src/gallium/drivers/freedreno/freedreno_texture.c
+++ b/src/gallium/drivers/freedreno/freedreno_texture.c
@@ -92,20 +92,29 @@ static void set_sampler_views(struct fd_texture_stateobj *prog,
 }
 
 static void
-fd_fragtex_sampler_states_bind(struct pipe_context *pctx,
+fd_sampler_states_bind(struct pipe_context *pctx,
+		unsigned shader, unsigned start,
 		unsigned nr, void **hwcso)
 {
 	struct fd_context *ctx = fd_context(pctx);
 
-	/* on a2xx, since there is a flat address space for textures/samplers,
-	 * a change in # of fragment textures/samplers will trigger patching and
-	 * re-emitting the vertex shader:
-	 */
-	if (nr != ctx->fragtex.num_samplers)
-		ctx->dirty |= FD_DIRTY_TEXSTATE;
+	assert(start == 0);
 
-	bind_sampler_states(&ctx->fragtex, nr, hwcso);
-	ctx->dirty |= FD_DIRTY_FRAGTEX;
+	if (shader == PIPE_SHADER_FRAGMENT) {
+		/* on a2xx, since there is a flat address space for textures/samplers,
+		 * a change in # of fragment textures/samplers will trigger patching and
+		 * re-emitting the vertex shader:
+		 */
+		if (nr != ctx->fragtex.num_samplers)
+			ctx->dirty |= FD_DIRTY_TEXSTATE;
+
+		bind_sampler_states(&ctx->fragtex, nr, hwcso);
+		ctx->dirty |= FD_DIRTY_FRAGTEX;
+	}
+	else if (shader == PIPE_SHADER_VERTEX) {
+		bind_sampler_states(&ctx->verttex, nr, hwcso);
+		ctx->dirty |= FD_DIRTY_VERTTEX;
+	}
 }
 
 
@@ -127,16 +136,6 @@ fd_fragtex_set_sampler_views(struct pipe_context *pctx, unsigned nr,
 }
 
 static void
-fd_verttex_sampler_states_bind(struct pipe_context *pctx,
-		unsigned nr, void **hwcso)
-{
-	struct fd_context *ctx = fd_context(pctx);
-	bind_sampler_states(&ctx->verttex, nr, hwcso);
-	ctx->dirty |= FD_DIRTY_VERTTEX;
-}
-
-
-static void
 fd_verttex_set_sampler_views(struct pipe_context *pctx, unsigned nr,
 		struct pipe_sampler_view **views)
 {
@@ -152,9 +151,8 @@ fd_texture_init(struct pipe_context *pctx)
 
 	pctx->sampler_view_destroy = fd_sampler_view_destroy;
 
-	pctx->bind_fragment_sampler_states = fd_fragtex_sampler_states_bind;
+	pctx->bind_sampler_states = fd_sampler_states_bind;
 	pctx->set_fragment_sampler_views = fd_fragtex_set_sampler_views;
 
-	pctx->bind_vertex_sampler_states = fd_verttex_sampler_states_bind;
 	pctx->set_vertex_sampler_views = fd_verttex_set_sampler_views;
 }
diff --git a/src/gallium/drivers/galahad/glhd_context.c b/src/gallium/drivers/galahad/glhd_context.c
index 3df22ce..dc3d5f0 100644
--- a/src/gallium/drivers/galahad/glhd_context.c
+++ b/src/gallium/drivers/galahad/glhd_context.c
@@ -197,50 +197,10 @@ galahad_context_bind_sampler_states(struct pipe_context *_pipe,
          num_samplers, PIPE_MAX_SAMPLERS);
    }
 
-   switch (shader) {
-   case PIPE_SHADER_VERTEX:
-      pipe->bind_vertex_sampler_states(pipe, num_samplers, samplers);
-      break;
-   case PIPE_SHADER_FRAGMENT:
-      pipe->bind_fragment_sampler_states(pipe, num_samplers, samplers);
-      break;
-   case PIPE_SHADER_GEOMETRY:
-      pipe->bind_geometry_sampler_states(pipe, num_samplers, samplers);
-      break;
-   default:
-      assert(0);
-   }
+   pipe->bind_sampler_states(pipe, shader, start, num_samplers, samplers);
 }
 
 static void
-galahad_context_bind_vertex_sampler_states(struct pipe_context *_pipe,
-                                           unsigned num_samplers,
-                                           void **samplers)
-{
-   galahad_context_bind_sampler_states(_pipe, PIPE_SHADER_VERTEX,
-                                       0, num_samplers, samplers);
-}
-
-static void
-galahad_context_bind_fragment_sampler_states(struct pipe_context *_pipe,
-                                             unsigned num_samplers,
-                                             void **samplers)
-{
-   galahad_context_bind_sampler_states(_pipe, PIPE_SHADER_FRAGMENT,
-                                       0, num_samplers, samplers);
-}
-
-static void
-galahad_context_bind_geometry_sampler_states(struct pipe_context *_pipe,
-                                             unsigned num_samplers,
-                                             void **samplers)
-{
-   galahad_context_bind_sampler_states(_pipe, PIPE_SHADER_GEOMETRY,
-                                       0, num_samplers, samplers);
-}
-
-
-static void
 galahad_context_delete_sampler_state(struct pipe_context *_pipe,
                               void *sampler)
 {
@@ -1064,10 +1024,7 @@ galahad_context_create(struct pipe_screen *_screen, struct pipe_context *pipe)
    GLHD_PIPE_INIT(bind_blend_state);
    GLHD_PIPE_INIT(delete_blend_state);
    GLHD_PIPE_INIT(create_sampler_state);
-   GLHD_PIPE_INIT(bind_fragment_sampler_states);
-   GLHD_PIPE_INIT(bind_vertex_sampler_states);
-   GLHD_PIPE_INIT(bind_geometry_sampler_states);
-   //GLHD_PIPE_INIT(bind_compute_sampler_states);
+   GLHD_PIPE_INIT(bind_sampler_states);
    GLHD_PIPE_INIT(delete_sampler_state);
    GLHD_PIPE_INIT(create_rasterizer_state);
    GLHD_PIPE_INIT(bind_rasterizer_state);
diff --git a/src/gallium/drivers/i915/i915_context.h b/src/gallium/drivers/i915/i915_context.h
index 0c0555c..c786fef 100644
--- a/src/gallium/drivers/i915/i915_context.h
+++ b/src/gallium/drivers/i915/i915_context.h
@@ -227,8 +227,8 @@ struct i915_context {
    /* The most recent drawing state as set by the driver:
     */
    const struct i915_blend_state           *blend;
-   const struct i915_sampler_state         *sampler[PIPE_MAX_SAMPLERS];
-   struct pipe_sampler_state *vertex_samplers[PIPE_MAX_SAMPLERS];
+   const struct i915_sampler_state         *fragment_sampler[PIPE_MAX_SAMPLERS];
+   struct pipe_sampler_state               *vertex_samplers[PIPE_MAX_SAMPLERS];
    const struct i915_depth_stencil_state   *depth_stencil;
    const struct i915_rasterizer_state      *rasterizer;
 
diff --git a/src/gallium/drivers/i915/i915_state.c b/src/gallium/drivers/i915/i915_state.c
index 8ca69fc..f722e2d 100644
--- a/src/gallium/drivers/i915/i915_state.c
+++ b/src/gallium/drivers/i915/i915_state.c
@@ -293,25 +293,31 @@ i915_create_sampler_state(struct pipe_context *pipe,
 
 static void
 i915_bind_vertex_sampler_states(struct pipe_context *pipe,
-                                unsigned num_samplers,
+                                unsigned start,
+                                unsigned num,
                                 void **samplers)
 {
    struct i915_context *i915 = i915_context(pipe);
    unsigned i;
 
-   assert(num_samplers <= Elements(i915->vertex_samplers));
+   assert(start + num <= Elements(i915->vertex_samplers));
 
    /* Check for no-op */
-   if (num_samplers == i915->num_vertex_samplers &&
-       !memcmp(i915->vertex_samplers, samplers, num_samplers * sizeof(void *)))
+   if (num == i915->num_vertex_samplers &&
+       !memcmp(i915->vertex_samplers + start, samplers,
+	       num * sizeof(void *)))
       return;
 
-   for (i = 0; i < num_samplers; ++i)
-      i915->vertex_samplers[i] = samplers[i];
-   for (i = num_samplers; i < Elements(i915->vertex_samplers); ++i)
-      i915->vertex_samplers[i] = NULL;
+   for (i = 0; i < num; ++i)
+      i915->vertex_samplers[i + start] = samplers[i];
 
-   i915->num_vertex_samplers = num_samplers;
+   /* find highest non-null samplers[] entry */
+   {
+      unsigned j = MAX2(i915->num_vertex_samplers, start + num);
+      while (j > 0 && i915->vertex_samplers[j - 1] == NULL)
+         j--;
+      i915->num_vertex_samplers = j;
+   }
 
    draw_set_samplers(i915->draw,
                      PIPE_SHADER_VERTEX,
@@ -322,26 +328,52 @@ i915_bind_vertex_sampler_states(struct pipe_context *pipe,
 
 
 static void i915_bind_fragment_sampler_states(struct pipe_context *pipe,
-                                     unsigned num, void **sampler)
+                                              unsigned start,
+                                              unsigned num,
+                                              void **samplers)
 {
    struct i915_context *i915 = i915_context(pipe);
    unsigned i;
 
    /* Check for no-op */
    if (num == i915->num_samplers &&
-       !memcmp(i915->sampler, sampler, num * sizeof(void *)))
+       !memcmp(i915->fragment_sampler + start, samplers,
+               num * sizeof(void *)))
       return;
 
    for (i = 0; i < num; ++i)
-      i915->sampler[i] = sampler[i];
-   for (i = num; i < PIPE_MAX_SAMPLERS; ++i)
-      i915->sampler[i] = NULL;
+      i915->fragment_sampler[i + start] = samplers[i];
 
-   i915->num_samplers = num;
+   /* find highest non-null samplers[] entry */
+   {
+      unsigned j = MAX2(i915->num_samplers, start + num);
+      while (j > 0 && i915->fragment_sampler[j - 1] == NULL)
+         j--;
+      i915->num_samplers = j;
+   }
 
    i915->dirty |= I915_NEW_SAMPLER;
 }
 
+
+static void
+i915_bind_sampler_states(struct pipe_context *pipe, unsigned shader,
+                         unsigned start, unsigned num_samplers,
+                         void **samplers)
+{
+   switch (shader) {
+   case PIPE_SHADER_VERTEX:
+      i915_bind_vertex_sampler_states(pipe, start, num_samplers, samplers);
+      break;
+   case PIPE_SHADER_FRAGMENT:
+      i915_bind_fragment_sampler_states(pipe, start, num_samplers, samplers);
+      break;
+   default:
+      ;
+   }
+}
+
+
 static void i915_delete_sampler_state(struct pipe_context *pipe,
                                       void *sampler)
 {
@@ -1015,8 +1047,7 @@ i915_init_state_functions( struct i915_context *i915 )
    i915->base.delete_blend_state = i915_delete_blend_state;
 
    i915->base.create_sampler_state = i915_create_sampler_state;
-   i915->base.bind_fragment_sampler_states = i915_bind_fragment_sampler_states;
-   i915->base.bind_vertex_sampler_states = i915_bind_vertex_sampler_states;
+   i915->base.bind_sampler_states = i915_bind_sampler_states;
    i915->base.delete_sampler_state = i915_delete_sampler_state;
 
    i915->base.create_depth_stencil_alpha_state = i915_create_depth_stencil_state;
diff --git a/src/gallium/drivers/i915/i915_state_sampler.c b/src/gallium/drivers/i915/i915_state_sampler.c
index a6e4724..86234fc 100644
--- a/src/gallium/drivers/i915/i915_state_sampler.c
+++ b/src/gallium/drivers/i915/i915_state_sampler.c
@@ -161,13 +161,13 @@ static void update_samplers(struct i915_context *i915)
 
          update_sampler(i915,
                         unit,
-                        i915->sampler[unit],          /* sampler state */
+                        i915->fragment_sampler[unit], /* sampler state */
                         texture,                      /* texture */
                         i915->current.sampler[unit]); /* the result */
          update_map(i915,
                     unit,
                     texture,                             /* texture */
-                    i915->sampler[unit],                 /* sampler state */
+                    i915->fragment_sampler[unit],        /* sampler state */
                     i915->fragment_sampler_views[unit],  /* sampler view */
                     i915->current.texbuffer[unit]);      /* the result */
 
@@ -357,7 +357,7 @@ static void update_maps(struct i915_context *i915)
          update_map(i915,
                     unit,
                     texture,                            /* texture */
-                    i915->sampler[unit],                /* sampler state */
+                    i915->fragment_sampler[unit],       /* sampler state */
                     i915->fragment_sampler_views[unit], /* sampler view */
                     i915->current.texbuffer[unit]);
       }
diff --git a/src/gallium/drivers/i915/i915_surface.c b/src/gallium/drivers/i915/i915_surface.c
index 48d4857..bd20a53 100644
--- a/src/gallium/drivers/i915/i915_surface.c
+++ b/src/gallium/drivers/i915/i915_surface.c
@@ -62,7 +62,7 @@ i915_util_blitter_save_states(struct i915_context *i915)
 
    util_blitter_save_fragment_sampler_states(i915->blitter,
                                              i915->num_samplers,
-                                             (void**)i915->sampler);
+                                             (void**)i915->fragment_sampler);
    util_blitter_save_fragment_sampler_views(i915->blitter,
                                             i915->num_fragment_sampler_views,
                                             i915->fragment_sampler_views);
diff --git a/src/gallium/drivers/identity/id_context.c b/src/gallium/drivers/identity/id_context.c
index 6cb7bdf..0aff75f 100644
--- a/src/gallium/drivers/identity/id_context.c
+++ b/src/gallium/drivers/identity/id_context.c
@@ -168,40 +168,7 @@ identity_bind_sampler_states(struct pipe_context *_pipe,
    struct identity_context *id_pipe = identity_context(_pipe);
    struct pipe_context *pipe = id_pipe->pipe;
 
-   /* remove this when we have pipe->bind_sampler_states(..., start, ...) */
-   assert(start == 0);
-
-   switch (shader) {
-   case PIPE_SHADER_VERTEX:
-      pipe->bind_vertex_sampler_states(pipe, num_samplers, samplers);
-      break;
-   case PIPE_SHADER_GEOMETRY:
-      pipe->bind_geometry_sampler_states(pipe, num_samplers, samplers);
-      break;
-   case PIPE_SHADER_FRAGMENT:
-      pipe->bind_fragment_sampler_states(pipe, num_samplers, samplers);
-      break;
-   default:
-      debug_error("Unexpected shader in identity_bind_sampler_states()");
-   }
-}
-
-static void
-identity_bind_fragment_sampler_states(struct pipe_context *_pipe,
-                                      unsigned num_samplers,
-                                      void **samplers)
-{
-   identity_bind_sampler_states(_pipe, PIPE_SHADER_FRAGMENT,
-                                0, num_samplers, samplers);
-}
-
-static void
-identity_bind_vertex_sampler_states(struct pipe_context *_pipe,
-                                    unsigned num_samplers,
-                                    void **samplers)
-{
-   identity_bind_sampler_states(_pipe, PIPE_SHADER_VERTEX,
-                                0, num_samplers, samplers);
+   pipe->bind_sampler_states(pipe, shader, start, num_samplers, samplers);
 }
 
 static void
@@ -901,8 +868,7 @@ identity_context_create(struct pipe_screen *_screen, struct pipe_context *pipe)
    id_pipe->base.bind_blend_state = identity_bind_blend_state;
    id_pipe->base.delete_blend_state = identity_delete_blend_state;
    id_pipe->base.create_sampler_state = identity_create_sampler_state;
-   id_pipe->base.bind_fragment_sampler_states = identity_bind_fragment_sampler_states;
-   id_pipe->base.bind_vertex_sampler_states = identity_bind_vertex_sampler_states;
+   id_pipe->base.bind_sampler_states = identity_bind_sampler_states;
    id_pipe->base.delete_sampler_state = identity_delete_sampler_state;
    id_pipe->base.create_rasterizer_state = identity_create_rasterizer_state;
    id_pipe->base.bind_rasterizer_state = identity_bind_rasterizer_state;
diff --git a/src/gallium/drivers/ilo/ilo_state.c b/src/gallium/drivers/ilo/ilo_state.c
index 1a0a08d..caad308 100644
--- a/src/gallium/drivers/ilo/ilo_state.c
+++ b/src/gallium/drivers/ilo/ilo_state.c
@@ -366,6 +366,26 @@ ilo_bind_compute_sampler_states(struct pipe_context *pipe,
 }
 
 static void
+ilo_bind_sampler_states2(struct pipe_context *pipe, unsigned shader,
+                         unsigned start, unsigned count, void **samplers)
+{
+   switch (shader) {
+   case PIPE_SHADER_VERTEX:
+      ilo_bind_vertex_sampler_states(pipe, count, samplers);
+      break;
+   case PIPE_SHADER_GEOMETRY:
+      ilo_bind_geometry_sampler_states(pipe, count, samplers);
+      break;
+   case PIPE_SHADER_FRAGMENT:
+      ilo_bind_fragment_sampler_states(pipe, count, samplers);
+      break;
+   case PIPE_SHADER_COMPUTE:
+      ilo_bind_compute_sampler_states(pipe, start, count, samplers);
+      break;
+   }
+}
+
+static void
 ilo_delete_sampler_state(struct pipe_context *pipe, void *state)
 {
    FREE(state);
@@ -1239,10 +1259,7 @@ ilo_init_state_functions(struct ilo_context *ilo)
    ilo->base.bind_blend_state = ilo_bind_blend_state;
    ilo->base.delete_blend_state = ilo_delete_blend_state;
    ilo->base.create_sampler_state = ilo_create_sampler_state;
-   ilo->base.bind_fragment_sampler_states = ilo_bind_fragment_sampler_states;
-   ilo->base.bind_vertex_sampler_states = ilo_bind_vertex_sampler_states;
-   ilo->base.bind_geometry_sampler_states = ilo_bind_geometry_sampler_states;
-   ilo->base.bind_compute_sampler_states = ilo_bind_compute_sampler_states;
+   ilo->base.bind_sampler_states = ilo_bind_sampler_states2;
    ilo->base.delete_sampler_state = ilo_delete_sampler_state;
    ilo->base.create_rasterizer_state = ilo_create_rasterizer_state;
    ilo->base.bind_rasterizer_state = ilo_bind_rasterizer_state;
diff --git a/src/gallium/drivers/llvmpipe/Makefile.am b/src/gallium/drivers/llvmpipe/Makefile.am
index f24bf71..1a1a575 100644
--- a/src/gallium/drivers/llvmpipe/Makefile.am
+++ b/src/gallium/drivers/llvmpipe/Makefile.am
@@ -26,7 +26,8 @@ include $(top_srcdir)/src/gallium/Automake.inc
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/gallium/drivers \
 	-I$(top_srcdir)/include \
-	$(GALLIUM_CFLAGS)
+	$(GALLIUM_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
 AM_CFLAGS = $(LLVM_CFLAGS)
 AM_CXXFLAGS= $(LLVM_CXXFLAGS)
 
diff --git a/src/gallium/drivers/llvmpipe/lp_limits.h b/src/gallium/drivers/llvmpipe/lp_limits.h
index af31b35..5ea0c83 100644
--- a/src/gallium/drivers/llvmpipe/lp_limits.h
+++ b/src/gallium/drivers/llvmpipe/lp_limits.h
@@ -77,9 +77,9 @@
 
 /**
  * Max number of instructions (for all fragment shaders combined per context)
- * that will be kept around.
+ * that will be kept around (counted in terms of llvm ir).
  */
-#define LP_MAX_SHADER_INSTRUCTIONS (128*1024)
+#define LP_MAX_SHADER_INSTRUCTIONS (512*LP_MAX_SHADER_VARIANTS)
 
 /**
  * Max number of setup variants that will be kept around.
diff --git a/src/gallium/drivers/llvmpipe/lp_rast.h b/src/gallium/drivers/llvmpipe/lp_rast.h
index c57f2ea..43c598d 100644
--- a/src/gallium/drivers/llvmpipe/lp_rast.h
+++ b/src/gallium/drivers/llvmpipe/lp_rast.h
@@ -46,9 +46,18 @@ struct lp_scene;
 struct lp_fence;
 struct cmd_bin;
 
+#define FIXED_TYPE_WIDTH 32
 /** For sub-pixel positioning */
 #define FIXED_ORDER 4
 #define FIXED_ONE (1<<FIXED_ORDER)
+/** Maximum length of an edge in a primitive in pixels.
+ *  If the framebuffer is large we have to think about fixed-point
+ *  integer overflow. Coordinates need ((FIXED_TYPE_WIDTH/2) - 1) bits
+ *  to be able to fit product of two such coordinates inside
+ *  FIXED_TYPE_WIDTH, any larger and we could overflow a
+ *  FIXED_TYPE_WIDTH_-bit int.
+ */
+#define MAX_FIXED_LENGTH (1 << (((FIXED_TYPE_WIDTH/2) - 1) - FIXED_ORDER))
 
 /* Rasterizer output size going to jit fs, width/height */
 #define LP_RASTER_BLOCK_SIZE 4
diff --git a/src/gallium/drivers/llvmpipe/lp_screen.c b/src/gallium/drivers/llvmpipe/lp_screen.c
index b3cd77f..723e40e 100644
--- a/src/gallium/drivers/llvmpipe/lp_screen.c
+++ b/src/gallium/drivers/llvmpipe/lp_screen.c
@@ -163,7 +163,7 @@ llvmpipe_get_param(struct pipe_screen *screen, enum pipe_cap param)
    case PIPE_CAP_PRIMITIVE_RESTART:
       return 1;
    case PIPE_CAP_DEPTH_CLIP_DISABLE:
-      return 0;
+      return 1;
    case PIPE_CAP_SHADER_STENCIL_EXPORT:
       return 0;
    case PIPE_CAP_TGSI_INSTANCEID:
diff --git a/src/gallium/drivers/llvmpipe/lp_setup.c b/src/gallium/drivers/llvmpipe/lp_setup.c
index c8199b4..9b277d3 100644
--- a/src/gallium/drivers/llvmpipe/lp_setup.c
+++ b/src/gallium/drivers/llvmpipe/lp_setup.c
@@ -1007,16 +1007,12 @@ try_update_scene_state( struct lp_setup_context *setup )
                                          &setup->draw_regions[i]);
          }
       }
-      /* If the framebuffer is large we have to think about fixed-point
-       * integer overflow.  For 2K by 2K images, coordinates need 15 bits
-       * (2^11 + 4 subpixel bits).  The product of two such numbers would
-       * use 30 bits.  Any larger and we could overflow a 32-bit int.
-       *
-       * To cope with this problem we check if triangles are large and
-       * subdivide them if needed.
+      /*
+       * Subdivide triangles if the framebuffer is larger than the
+       * MAX_FIXED_LENGTH.
        */
-      setup->subdivide_large_triangles = (setup->fb.width > 2048 ||
-                                          setup->fb.height > 2048);
+      setup->subdivide_large_triangles = (setup->fb.width > MAX_FIXED_LENGTH ||
+                                          setup->fb.height > MAX_FIXED_LENGTH);
    }
                                       
    setup->dirty = 0;
diff --git a/src/gallium/drivers/llvmpipe/lp_setup_tri.c b/src/gallium/drivers/llvmpipe/lp_setup_tri.c
index 051ffa0..2164f3a 100644
--- a/src/gallium/drivers/llvmpipe/lp_setup_tri.c
+++ b/src/gallium/drivers/llvmpipe/lp_setup_tri.c
@@ -988,7 +988,7 @@ check_subdivide_triangle(struct lp_setup_context *setup,
                          const float (*v2)[4],
                          triangle_func_t tri)
 {
-   const float maxLen = 2048.0f;  /* longest permissible edge, in pixels */
+   const float maxLen = (float) MAX_FIXED_LENGTH;  /* longest permissible edge, in pixels */
    float dx10, dy10, len10;
    float dx21, dy21, len21;
    float dx02, dy02, len02;
diff --git a/src/gallium/drivers/llvmpipe/lp_state_rasterizer.c b/src/gallium/drivers/llvmpipe/lp_state_rasterizer.c
index 6148337..2149ffc 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_rasterizer.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_rasterizer.c
@@ -78,8 +78,6 @@ llvmpipe_create_rasterizer_state(struct pipe_context *pipe,
     */
    need_pipeline = (rast->fill_front != PIPE_POLYGON_MODE_FILL ||
 		    rast->fill_back != PIPE_POLYGON_MODE_FILL ||
-                    rast->offset_point ||
-                    rast->offset_line ||
 		    rast->point_smooth ||
 		    rast->line_smooth ||
 		    rast->line_stipple_enable ||
diff --git a/src/gallium/drivers/llvmpipe/lp_state_sampler.c b/src/gallium/drivers/llvmpipe/lp_state_sampler.c
index ee2e444..6bf2fb8 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_sampler.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_sampler.c
@@ -111,29 +111,6 @@ llvmpipe_bind_sampler_states(struct pipe_context *pipe,
 
 
 static void
-llvmpipe_bind_fragment_sampler_states(struct pipe_context *pipe,
-                                      unsigned num, void **samplers)
-{
-   llvmpipe_bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0, num, samplers);
-}
-
-
-static void
-llvmpipe_bind_vertex_sampler_states(struct pipe_context *pipe,
-                                    unsigned num, void **samplers)
-{
-   llvmpipe_bind_sampler_states(pipe, PIPE_SHADER_VERTEX, 0, num, samplers);
-}
-
-
-static void
-llvmpipe_bind_geometry_sampler_states(struct pipe_context *pipe,
-                                      unsigned num, void **samplers)
-{
-   llvmpipe_bind_sampler_states(pipe, PIPE_SHADER_GEOMETRY, 0, num, samplers);
-}
-
-static void
 llvmpipe_set_sampler_views(struct pipe_context *pipe,
                            unsigned shader,
                            unsigned start,
@@ -417,9 +394,7 @@ llvmpipe_init_sampler_funcs(struct llvmpipe_context *llvmpipe)
 {
    llvmpipe->pipe.create_sampler_state = llvmpipe_create_sampler_state;
 
-   llvmpipe->pipe.bind_fragment_sampler_states  = llvmpipe_bind_fragment_sampler_states;
-   llvmpipe->pipe.bind_vertex_sampler_states  = llvmpipe_bind_vertex_sampler_states;
-   llvmpipe->pipe.bind_geometry_sampler_states  = llvmpipe_bind_geometry_sampler_states;
+   llvmpipe->pipe.bind_sampler_states = llvmpipe_bind_sampler_states;
    llvmpipe->pipe.set_fragment_sampler_views = llvmpipe_set_fragment_sampler_views;
    llvmpipe->pipe.set_vertex_sampler_views = llvmpipe_set_vertex_sampler_views;
    llvmpipe->pipe.set_geometry_sampler_views = llvmpipe_set_geometry_sampler_views;
diff --git a/src/gallium/drivers/noop/noop_state.c b/src/gallium/drivers/noop/noop_state.c
index 29eeda8..173e2cc 100644
--- a/src/gallium/drivers/noop/noop_state.c
+++ b/src/gallium/drivers/noop/noop_state.c
@@ -134,7 +134,9 @@ static void noop_set_ps_sampler_view(struct pipe_context *ctx, unsigned count,
 {
 }
 
-static void noop_bind_sampler(struct pipe_context *ctx, unsigned count, void **states)
+static void noop_bind_sampler_states(struct pipe_context *ctx, unsigned shader,
+                                     unsigned start, unsigned count,
+                                     void **states)
 {
 }
 
@@ -295,11 +297,10 @@ void noop_init_state_functions(struct pipe_context *ctx)
 	ctx->create_vs_state = noop_create_shader_state;
 	ctx->bind_blend_state = noop_bind_state;
 	ctx->bind_depth_stencil_alpha_state = noop_bind_state;
-	ctx->bind_fragment_sampler_states = noop_bind_sampler;
+	ctx->bind_sampler_states = noop_bind_sampler_states;
 	ctx->bind_fs_state = noop_bind_state;
 	ctx->bind_rasterizer_state = noop_bind_state;
 	ctx->bind_vertex_elements_state = noop_bind_state;
-	ctx->bind_vertex_sampler_states = noop_bind_sampler;
 	ctx->bind_vs_state = noop_bind_state;
 	ctx->delete_blend_state = noop_delete_state;
 	ctx->delete_depth_stencil_alpha_state = noop_delete_state;
diff --git a/src/gallium/drivers/nouveau/nv30/nv30_context.h b/src/gallium/drivers/nouveau/nv30/nv30_context.h
index 12ae0c7..292dcfe 100644
--- a/src/gallium/drivers/nouveau/nv30/nv30_context.h
+++ b/src/gallium/drivers/nouveau/nv30/nv30_context.h
@@ -187,6 +187,14 @@ void
 nv40_verttex_validate(struct nv30_context *nv30);
 
 void
+nv30_fragtex_sampler_states_bind(struct pipe_context *pipe,
+                                 unsigned nr, void **hwcso);
+
+void
+nv40_verttex_sampler_states_bind(struct pipe_context *pipe,
+                                 unsigned nr, void **hwcso);
+
+void
 nv30_push_vbo(struct nv30_context *nv30, const struct pipe_draw_info *info);
 
 void
diff --git a/src/gallium/drivers/nouveau/nv30/nv30_fragtex.c b/src/gallium/drivers/nouveau/nv30/nv30_fragtex.c
index 60ffb03..87e66cc 100644
--- a/src/gallium/drivers/nouveau/nv30/nv30_fragtex.c
+++ b/src/gallium/drivers/nouveau/nv30/nv30_fragtex.c
@@ -149,7 +149,7 @@ nv30_fragtex_validate(struct nv30_context *nv30)
    nv30->fragprog.dirty_samplers = 0;
 }
 
-static void
+void
 nv30_fragtex_sampler_states_bind(struct pipe_context *pipe,
                                  unsigned nr, void **hwcso)
 {
@@ -197,6 +197,5 @@ nv30_fragtex_set_sampler_views(struct pipe_context *pipe, unsigned nr,
 void
 nv30_fragtex_init(struct pipe_context *pipe)
 {
-   pipe->bind_fragment_sampler_states = nv30_fragtex_sampler_states_bind;
    pipe->set_fragment_sampler_views = nv30_fragtex_set_sampler_views;
 }
diff --git a/src/gallium/drivers/nouveau/nv30/nv30_texture.c b/src/gallium/drivers/nouveau/nv30/nv30_texture.c
index d3cffcf..c356721 100644
--- a/src/gallium/drivers/nouveau/nv30/nv30_texture.c
+++ b/src/gallium/drivers/nouveau/nv30/nv30_texture.c
@@ -186,6 +186,21 @@ nv30_sampler_state_delete(struct pipe_context *pipe, void *hwcso)
    FREE(hwcso);
 }
 
+static void
+nv30_bind_sampler_states(struct pipe_context *pipe,
+                         unsigned shader, unsigned start_slot,
+                         unsigned num_samplers, void **samplers)
+{
+   switch (shader) {
+   case PIPE_SHADER_VERTEX:
+      nv40_verttex_sampler_states_bind(pipe, num_samplers, samplers);
+      break;
+   case PIPE_SHADER_FRAGMENT:
+      nv30_fragtex_sampler_states_bind(pipe, num_samplers, samplers);
+      break;
+   }
+}
+
 static INLINE uint32_t
 swizzle(const struct nv30_texfmt *fmt, unsigned cmp, unsigned swz)
 {
@@ -301,6 +316,8 @@ nv30_texture_init(struct pipe_context *pipe)
 {
    pipe->create_sampler_state = nv30_sampler_state_create;
    pipe->delete_sampler_state = nv30_sampler_state_delete;
+   pipe->bind_sampler_states = nv30_bind_sampler_states;
+
    pipe->create_sampler_view = nv30_sampler_view_create;
    pipe->sampler_view_destroy = nv30_sampler_view_destroy;
 }
diff --git a/src/gallium/drivers/nouveau/nv30/nv40_verttex.c b/src/gallium/drivers/nouveau/nv30/nv40_verttex.c
index 9a7163c..48465cf 100644
--- a/src/gallium/drivers/nouveau/nv30/nv40_verttex.c
+++ b/src/gallium/drivers/nouveau/nv30/nv40_verttex.c
@@ -47,7 +47,7 @@ nv40_verttex_validate(struct nv30_context *nv30)
    nv30->vertprog.dirty_samplers = 0;
 }
 
-static void
+void
 nv40_verttex_sampler_states_bind(struct pipe_context *pipe,
                                  unsigned nr, void **hwcso)
 {
@@ -95,6 +95,5 @@ nv40_verttex_set_sampler_views(struct pipe_context *pipe, unsigned nr,
 void
 nv40_verttex_init(struct pipe_context *pipe)
 {
-   pipe->bind_vertex_sampler_states = nv40_verttex_sampler_states_bind;
    pipe->set_vertex_sampler_views = nv40_verttex_set_sampler_views;
 }
diff --git a/src/gallium/drivers/nouveau/nv50/nv50_state.c b/src/gallium/drivers/nouveau/nv50/nv50_state.c
index 7dceb51..aaea19f 100644
--- a/src/gallium/drivers/nouveau/nv50/nv50_state.c
+++ b/src/gallium/drivers/nouveau/nv50/nv50_state.c
@@ -606,6 +606,27 @@ nv50_gp_sampler_states_bind(struct pipe_context *pipe, unsigned nr, void **s)
    nv50_stage_sampler_states_bind(nv50_context(pipe), 1, nr, s);
 }
 
+static void
+nv50_bind_sampler_states(struct pipe_context *pipe,
+                         unsigned shader, unsigned start,
+                         unsigned num_samplers, void **samplers)
+{
+   assert(start == 0);
+   switch (shader) {
+   case PIPE_SHADER_VERTEX:
+      nv50_vp_sampler_states_bind(pipe, num_samplers, samplers);
+      break;
+   case PIPE_SHADER_GEOMETRY:
+      nv50_gp_sampler_states_bind(pipe, num_samplers, samplers);
+      break;
+   case PIPE_SHADER_FRAGMENT:
+      nv50_fp_sampler_states_bind(pipe, num_samplers, samplers);
+      break;
+   }
+}
+
+
+
 /* NOTE: only called when not referenced anywhere, won't be bound */
 static void
 nv50_sampler_view_destroy(struct pipe_context *pipe,
@@ -1067,9 +1088,7 @@ nv50_init_state_functions(struct nv50_context *nv50)
 
    pipe->create_sampler_state = nv50_sampler_state_create;
    pipe->delete_sampler_state = nv50_sampler_state_delete;
-   pipe->bind_vertex_sampler_states   = nv50_vp_sampler_states_bind;
-   pipe->bind_fragment_sampler_states = nv50_fp_sampler_states_bind;
-   pipe->bind_geometry_sampler_states = nv50_gp_sampler_states_bind;
+   pipe->bind_sampler_states   = nv50_bind_sampler_states;
 
    pipe->create_sampler_view = nv50_create_sampler_view;
    pipe->sampler_view_destroy = nv50_sampler_view_destroy;
diff --git a/src/gallium/drivers/nouveau/nvc0/nvc0_state.c b/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
index e56ef01..e0e6e13 100644
--- a/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
+++ b/src/gallium/drivers/nouveau/nvc0/nvc0_state.c
@@ -472,24 +472,6 @@ nvc0_stage_sampler_states_bind(struct nvc0_context *nvc0, int s,
 }
 
 static void
-nvc0_vp_sampler_states_bind(struct pipe_context *pipe, unsigned nr, void **s)
-{
-   nvc0_stage_sampler_states_bind(nvc0_context(pipe), 0, nr, s);
-}
-
-static void
-nvc0_fp_sampler_states_bind(struct pipe_context *pipe, unsigned nr, void **s)
-{
-   nvc0_stage_sampler_states_bind(nvc0_context(pipe), 4, nr, s);
-}
-
-static void
-nvc0_gp_sampler_states_bind(struct pipe_context *pipe, unsigned nr, void **s)
-{
-   nvc0_stage_sampler_states_bind(nvc0_context(pipe), 3, nr, s);
-}
-
-static void
 nvc0_stage_sampler_states_bind_range(struct nvc0_context *nvc0,
                                      const unsigned s,
                                      unsigned start, unsigned nr, void **cso)
@@ -532,14 +514,31 @@ nvc0_stage_sampler_states_bind_range(struct nvc0_context *nvc0,
 }
 
 static void
-nvc0_cp_sampler_states_bind(struct pipe_context *pipe,
-                            unsigned start, unsigned nr, void **cso)
+nvc0_bind_sampler_states(struct pipe_context *pipe, unsigned shader,
+                         unsigned start, unsigned nr, void **s)
 {
-   nvc0_stage_sampler_states_bind_range(nvc0_context(pipe), 5, start, nr, cso);
-
-   nvc0_context(pipe)->dirty_cp |= NVC0_NEW_CP_SAMPLERS;
+   switch (shader) {
+   case PIPE_SHADER_VERTEX:
+      assert(start == 0);
+      nvc0_stage_sampler_states_bind(nvc0_context(pipe), 0, nr, s);
+      break;
+   case PIPE_SHADER_GEOMETRY:
+      assert(start == 0);
+      nvc0_stage_sampler_states_bind(nvc0_context(pipe), 3, nr, s);
+      break;
+   case PIPE_SHADER_FRAGMENT:
+      assert(start == 0);
+      nvc0_stage_sampler_states_bind(nvc0_context(pipe), 4, nr, s);
+      break;
+   case PIPE_SHADER_COMPUTE:
+      nvc0_stage_sampler_states_bind_range(nvc0_context(pipe), 5,
+                                           start, nr, s);
+      nvc0_context(pipe)->dirty_cp |= NVC0_NEW_CP_SAMPLERS;
+      break;
+   }
 }
 
+
 /* NOTE: only called when not referenced anywhere, won't be bound */
 static void
 nvc0_sampler_view_destroy(struct pipe_context *pipe,
@@ -1194,10 +1193,7 @@ nvc0_init_state_functions(struct nvc0_context *nvc0)
 
    pipe->create_sampler_state = nv50_sampler_state_create;
    pipe->delete_sampler_state = nvc0_sampler_state_delete;
-   pipe->bind_vertex_sampler_states   = nvc0_vp_sampler_states_bind;
-   pipe->bind_fragment_sampler_states = nvc0_fp_sampler_states_bind;
-   pipe->bind_geometry_sampler_states = nvc0_gp_sampler_states_bind;
-   pipe->bind_compute_sampler_states = nvc0_cp_sampler_states_bind;
+   pipe->bind_sampler_states = nvc0_bind_sampler_states;
 
    pipe->create_sampler_view = nvc0_create_sampler_view;
    pipe->sampler_view_destroy = nvc0_sampler_view_destroy;
diff --git a/src/gallium/drivers/r300/r300_state.c b/src/gallium/drivers/r300/r300_state.c
index e69a605..6ce009e 100644
--- a/src/gallium/drivers/r300/r300_state.c
+++ b/src/gallium/drivers/r300/r300_state.c
@@ -1523,7 +1523,8 @@ static void*
 }
 
 static void r300_bind_sampler_states(struct pipe_context* pipe,
-                                     unsigned count,
+                                     unsigned shader,
+                                     unsigned start, unsigned count,
                                      void** states)
 {
     struct r300_context* r300 = r300_context(pipe);
@@ -1531,9 +1532,13 @@ static void r300_bind_sampler_states(struct pipe_context* pipe,
         (struct r300_textures_state*)r300->textures_state.state;
     unsigned tex_units = r300->screen->caps.num_tex_units;
 
-    if (count > tex_units) {
-        return;
-    }
+    assert(start == 0);
+
+    if (shader != PIPE_SHADER_FRAGMENT)
+       return;
+
+    if (count > tex_units)
+       return;
 
     memcpy(state->sampler_states, states, sizeof(void*) * count);
     state->sampler_state_count = count;
@@ -1541,12 +1546,6 @@ static void r300_bind_sampler_states(struct pipe_context* pipe,
     r300_mark_atom_dirty(r300, &r300->textures_state);
 }
 
-static void r300_lacks_vertex_textures(struct pipe_context* pipe,
-                                       unsigned count,
-                                       void** states)
-{
-}
-
 static void r300_delete_sampler_state(struct pipe_context* pipe, void* state)
 {
     FREE(state);
@@ -2157,8 +2156,7 @@ void r300_init_state_functions(struct r300_context* r300)
     r300->context.delete_rasterizer_state = r300_delete_rs_state;
 
     r300->context.create_sampler_state = r300_create_sampler_state;
-    r300->context.bind_fragment_sampler_states = r300_bind_sampler_states;
-    r300->context.bind_vertex_sampler_states = r300_lacks_vertex_textures;
+    r300->context.bind_sampler_states = r300_bind_sampler_states;
     r300->context.delete_sampler_state = r300_delete_sampler_state;
 
     r300->context.set_fragment_sampler_views = r300_set_fragment_sampler_views;
diff --git a/src/gallium/drivers/r300/r300_state_derived.c b/src/gallium/drivers/r300/r300_state_derived.c
index da86cd2..1013557 100644
--- a/src/gallium/drivers/r300/r300_state_derived.c
+++ b/src/gallium/drivers/r300/r300_state_derived.c
@@ -1079,7 +1079,6 @@ void r300_update_derived_state(struct r300_context* r300)
 
         if (r300->draw) {
             memset(&r300->vertex_info, 0, sizeof(struct vertex_info));
-            draw_prepare_shader_outputs(r300->draw);
             r300_draw_emit_all_attribs(r300);
             draw_compute_vertex_size(&r300->vertex_info);
             r300_swtcl_vertex_psc(r300);
diff --git a/src/gallium/drivers/r600/Makefile.am b/src/gallium/drivers/r600/Makefile.am
index cbe4a09..0490ba2 100644
--- a/src/gallium/drivers/r600/Makefile.am
+++ b/src/gallium/drivers/r600/Makefile.am
@@ -16,7 +16,8 @@ AM_CXXFLAGS = \
 	-I$(top_srcdir)/src/gallium/include \
 	-I$(top_srcdir)/src/gallium/auxiliary \
 	$(RADEON_CFLAGS) \
-	$(DEFINES)
+	$(DEFINES) \
+	$(VISIBILITY_CFLAGS)
 
 libr600_la_SOURCES = \
 	$(C_SOURCES) \
diff --git a/src/gallium/drivers/r600/compute_memory_pool.c b/src/gallium/drivers/r600/compute_memory_pool.c
index 75696d2..fd3a04c 100644
--- a/src/gallium/drivers/r600/compute_memory_pool.c
+++ b/src/gallium/drivers/r600/compute_memory_pool.c
@@ -161,8 +161,9 @@ struct compute_memory_item* compute_memory_postalloc_chunk(
 void compute_memory_grow_pool(struct compute_memory_pool* pool,
 	struct pipe_context * pipe, int new_size_in_dw)
 {
-	COMPUTE_DBG(pool->screen, "* compute_memory_grow_pool() new_size_in_dw = %d\n",
-		new_size_in_dw);
+	COMPUTE_DBG(pool->screen, "* compute_memory_grow_pool() "
+		"new_size_in_dw = %d (%d bytes)\n",
+		new_size_in_dw, new_size_in_dw * 4);
 
 	assert(new_size_in_dw >= pool->size_in_dw);
 
@@ -171,7 +172,8 @@ void compute_memory_grow_pool(struct compute_memory_pool* pool,
 	} else {
 		new_size_in_dw += 1024 - (new_size_in_dw % 1024);
 
-		COMPUTE_DBG(pool->screen, "  Aligned size = %d\n", new_size_in_dw);
+		COMPUTE_DBG(pool->screen, "  Aligned size = %d (%d bytes)\n",
+			new_size_in_dw, new_size_in_dw * 4);
 
 		compute_memory_shadow(pool, pipe, 1);
 		pool->shadow = realloc(pool->shadow, new_size_in_dw*4);
diff --git a/src/gallium/drivers/r600/evergreen_compute.c b/src/gallium/drivers/r600/evergreen_compute.c
index 3069236..bcb8a39 100644
--- a/src/gallium/drivers/r600/evergreen_compute.c
+++ b/src/gallium/drivers/r600/evergreen_compute.c
@@ -615,22 +615,6 @@ static void evergreen_set_cs_sampler_view(struct pipe_context *ctx_,
 	}
 }
 
-static void evergreen_bind_compute_sampler_states(
-	struct pipe_context *ctx_,
-	unsigned start_slot,
-	unsigned num_samplers,
-	void **samplers_)
-{
-	struct compute_sampler_state ** samplers =
-		(struct compute_sampler_state **)samplers_;
-
-	for (int i = 0; i < num_samplers; i++) {
-		if (samplers[i]) {
-			/* XXX: Implement */
-			assert(!"Compute samplers not implemented.");
-		}
-	}
-}
 
 static void evergreen_set_global_binding(
 	struct pipe_context *ctx_, unsigned first, unsigned n,
@@ -865,7 +849,6 @@ void evergreen_init_compute_state_functions(struct r600_context *ctx)
 //	 ctx->context.create_sampler_view = evergreen_compute_create_sampler_view;
 	ctx->b.b.set_compute_resources = evergreen_set_compute_resources;
 	ctx->b.b.set_compute_sampler_views = evergreen_set_cs_sampler_view;
-	ctx->b.b.bind_compute_sampler_states = evergreen_bind_compute_sampler_states;
 	ctx->b.b.set_global_binding = evergreen_set_global_binding;
 	ctx->b.b.launch_grid = evergreen_launch_grid;
 
@@ -874,7 +857,6 @@ void evergreen_init_compute_state_functions(struct r600_context *ctx)
 	ctx->cs_vertex_buffer_state.dirty_mask = 0x2;
 }
 
-
 struct pipe_resource *r600_compute_global_buffer_create(
 	struct pipe_screen *screen,
 	const struct pipe_resource *templ)
@@ -952,8 +934,8 @@ void *r600_compute_global_transfer_map(
 			"width = %u, height = %u, depth = %u)\n", level, usage,
 			box->x, box->y, box->z, box->width, box->height,
 			box->depth);
-	COMPUTE_DBG(rctx->screen, "Buffer: %u (buffer offset in global memory) "
-		"+ %u (box.x)\n", buffer->chunk->start_in_dw, box->x);
+	COMPUTE_DBG(rctx->screen, "Buffer id = %u offset = "
+		"%u (box.x)\n", buffer->chunk->id, box->x);
 
 
 	compute_memory_finalize_pending(pool, ctx_);
diff --git a/src/gallium/drivers/r600/evergreen_hw_context.c b/src/gallium/drivers/r600/evergreen_hw_context.c
index 2cefeca..c4fcaa0 100644
--- a/src/gallium/drivers/r600/evergreen_hw_context.c
+++ b/src/gallium/drivers/r600/evergreen_hw_context.c
@@ -91,8 +91,16 @@ void evergreen_cp_dma_clear_buffer(struct r600_context *rctx,
 	offset += r600_resource_va(&rctx->screen->b.b, dst);
 
 	/* Flush the cache where the resource is bound. */
-	r600_flag_resource_cache_flush(rctx, dst);
-        rctx->b.flags |= R600_CONTEXT_WAIT_3D_IDLE;
+	rctx->b.flags |= R600_CONTEXT_INV_CONST_CACHE |
+			 R600_CONTEXT_INV_VERTEX_CACHE |
+			 R600_CONTEXT_INV_TEX_CACHE |
+			 R600_CONTEXT_FLUSH_AND_INV |
+			 R600_CONTEXT_FLUSH_AND_INV_CB |
+			 R600_CONTEXT_FLUSH_AND_INV_DB |
+			 R600_CONTEXT_FLUSH_AND_INV_CB_META |
+			 R600_CONTEXT_FLUSH_AND_INV_DB_META |
+			 R600_CONTEXT_STREAMOUT_FLUSH |
+			 R600_CONTEXT_WAIT_3D_IDLE;
 
 	while (size) {
 		unsigned sync = 0;
@@ -129,9 +137,10 @@ void evergreen_cp_dma_clear_buffer(struct r600_context *rctx,
 		offset += byte_count;
 	}
 
-	/* Flush the cache again in case the 3D engine has been prefetching
-	 * the resource. */
-	r600_flag_resource_cache_flush(rctx, dst);
+	/* Invalidate the read caches. */
+	rctx->b.flags |= R600_CONTEXT_INV_CONST_CACHE |
+			 R600_CONTEXT_INV_VERTEX_CACHE |
+			 R600_CONTEXT_INV_TEX_CACHE;
 
 	util_range_add(&r600_resource(dst)->valid_buffer_range, offset,
 		       offset + size);
diff --git a/src/gallium/drivers/r600/evergreen_state.c b/src/gallium/drivers/r600/evergreen_state.c
index 83cb024..4535d21 100644
--- a/src/gallium/drivers/r600/evergreen_state.c
+++ b/src/gallium/drivers/r600/evergreen_state.c
@@ -3581,14 +3581,21 @@ void *evergreen_create_db_flush_dsa(struct r600_context *rctx)
 
 void evergreen_update_db_shader_control(struct r600_context * rctx)
 {
-	bool dual_export = rctx->framebuffer.export_16bpc &&
-			   !rctx->ps_shader->current->ps_depth_export;
-
-	unsigned db_shader_control = rctx->ps_shader->current->db_shader_control |
-			S_02880C_DUAL_EXPORT_ENABLE(dual_export) |
-			S_02880C_DB_SOURCE_FORMAT(dual_export ? V_02880C_EXPORT_DB_TWO :
-								V_02880C_EXPORT_DB_FULL) |
-			S_02880C_ALPHA_TO_MASK_DISABLE(rctx->framebuffer.cb0_is_integer);
+	bool dual_export;
+	unsigned db_shader_control;
+
+	if (!rctx->ps_shader) {
+		return;
+	}
+
+	dual_export = rctx->framebuffer.export_16bpc &&
+		      !rctx->ps_shader->current->ps_depth_export;
+
+	db_shader_control = rctx->ps_shader->current->db_shader_control |
+			    S_02880C_DUAL_EXPORT_ENABLE(dual_export) |
+			    S_02880C_DB_SOURCE_FORMAT(dual_export ? V_02880C_EXPORT_DB_TWO :
+								    V_02880C_EXPORT_DB_FULL) |
+			    S_02880C_ALPHA_TO_MASK_DISABLE(rctx->framebuffer.cb0_is_integer);
 
 	/* When alpha test is enabled we can't trust the hw to make the proper
 	 * decision on the order in which ztest should be run related to fragment
diff --git a/src/gallium/drivers/r600/r600_blit.c b/src/gallium/drivers/r600/r600_blit.c
index 5000eae..124efa5 100644
--- a/src/gallium/drivers/r600/r600_blit.c
+++ b/src/gallium/drivers/r600/r600_blit.c
@@ -611,16 +611,9 @@ void r600_copy_buffer(struct pipe_context *ctx, struct pipe_resource *dst, unsig
 		 /* Require 4-byte alignment. */
 		 dstx % 4 == 0 && src_box->x % 4 == 0 && src_box->width % 4 == 0) {
 
-		/* Flush both resources. */
-		r600_flag_resource_cache_flush(rctx, src);
-		r600_flag_resource_cache_flush(rctx, dst);
-
 		r600_blitter_begin(ctx, R600_COPY_BUFFER);
 		util_blitter_copy_buffer(rctx->blitter, dst, dstx, src, src_box->x, src_box->width);
 		r600_blitter_end(ctx);
-
-		/* Flush the dst in case the 3D engine has been prefetching the resource. */
-		r600_flag_resource_cache_flush(rctx, dst);
 	} else {
 		util_resource_copy_region(ctx, dst, 0, dstx, 0, 0, src, 0, src_box);
 	}
@@ -639,15 +632,10 @@ static void r600_clear_buffer(struct pipe_context *ctx, struct pipe_resource *ds
 		union pipe_color_union clear_value;
 		clear_value.ui[0] = value;
 
-		r600_flag_resource_cache_flush(rctx, dst);
-
 		r600_blitter_begin(ctx, R600_DISABLE_RENDER_COND);
 		util_blitter_clear_buffer(rctx->blitter, dst, offset, size,
 					  1, &clear_value);
 		r600_blitter_end(ctx);
-
-		/* Flush again in case the 3D engine has been prefetching the resource. */
-		r600_flag_resource_cache_flush(rctx, dst);
 	} else {
 		uint32_t *map = r600_buffer_map_sync_with_rings(&rctx->b, r600_resource(dst),
 								 PIPE_TRANSFER_WRITE);
diff --git a/src/gallium/drivers/r600/r600_hw_context.c b/src/gallium/drivers/r600/r600_hw_context.c
index d8ae30c..b127c7d 100644
--- a/src/gallium/drivers/r600/r600_hw_context.c
+++ b/src/gallium/drivers/r600/r600_hw_context.c
@@ -480,9 +480,16 @@ void r600_cp_dma_copy_buffer(struct r600_context *rctx,
 	src_offset += r600_resource_va(&rctx->screen->b.b, src);
 
 	/* Flush the caches where the resources are bound. */
-	r600_flag_resource_cache_flush(rctx, src);
-	r600_flag_resource_cache_flush(rctx, dst);
-        rctx->b.flags |= R600_CONTEXT_WAIT_3D_IDLE;
+	rctx->b.flags |= R600_CONTEXT_INV_CONST_CACHE |
+			 R600_CONTEXT_INV_VERTEX_CACHE |
+			 R600_CONTEXT_INV_TEX_CACHE |
+			 R600_CONTEXT_FLUSH_AND_INV |
+			 R600_CONTEXT_FLUSH_AND_INV_CB |
+			 R600_CONTEXT_FLUSH_AND_INV_DB |
+			 R600_CONTEXT_FLUSH_AND_INV_CB_META |
+			 R600_CONTEXT_FLUSH_AND_INV_DB_META |
+			 R600_CONTEXT_STREAMOUT_FLUSH |
+			 R600_CONTEXT_WAIT_3D_IDLE;
 
 	/* There are differences between R700 and EG in CP DMA,
 	 * but we only use the common bits here. */
@@ -524,9 +531,10 @@ void r600_cp_dma_copy_buffer(struct r600_context *rctx,
 		dst_offset += byte_count;
 	}
 
-	/* Flush the cache of the dst resource again in case the 3D engine
-	 * has been prefetching it. */
-	r600_flag_resource_cache_flush(rctx, dst);
+	/* Invalidate the read caches. */
+	rctx->b.flags |= R600_CONTEXT_INV_CONST_CACHE |
+			 R600_CONTEXT_INV_VERTEX_CACHE |
+			 R600_CONTEXT_INV_TEX_CACHE;
 
 	util_range_add(&r600_resource(dst)->valid_buffer_range, dst_offset,
 		       dst_offset + size);
@@ -580,117 +588,3 @@ void r600_dma_copy(struct r600_context *rctx,
 	util_range_add(&rdst->valid_buffer_range, dst_offset,
 		       dst_offset + size);
 }
-
-/* Flag the cache of the resource for it to be flushed later if the resource
- * is bound. Otherwise do nothing. Used for synchronization between engines.
- */
-void r600_flag_resource_cache_flush(struct r600_context *rctx,
-				    struct pipe_resource *res)
-{
-	/* Check vertex buffers. */
-	uint32_t mask = rctx->vertex_buffer_state.enabled_mask;
-	while (mask) {
-		uint32_t i = u_bit_scan(&mask);
-		if (rctx->vertex_buffer_state.vb[i].buffer == res) {
-			rctx->b.flags |= R600_CONTEXT_INV_VERTEX_CACHE;
-		}
-	}
-
-	/* Check vertex buffers for compute. */
-	mask = rctx->cs_vertex_buffer_state.enabled_mask;
-	while (mask) {
-		uint32_t i = u_bit_scan(&mask);
-		if (rctx->cs_vertex_buffer_state.vb[i].buffer == res) {
-			rctx->b.flags |= R600_CONTEXT_INV_VERTEX_CACHE;
-		}
-	}
-
-	/* Check constant buffers. */
-	unsigned shader;
-	for (shader = 0; shader < PIPE_SHADER_TYPES; shader++) {
-		struct r600_constbuf_state *state = &rctx->constbuf_state[shader];
-		uint32_t mask = state->enabled_mask;
-
-		while (mask) {
-			unsigned i = u_bit_scan(&mask);
-			if (state->cb[i].buffer == res) {
-				rctx->b.flags |= R600_CONTEXT_INV_CONST_CACHE;
-
-				shader = PIPE_SHADER_TYPES; /* break the outer loop */
-				break;
-			}
-		}
-	}
-
-	/* Check textures. */
-	for (shader = 0; shader < PIPE_SHADER_TYPES; shader++) {
-		struct r600_samplerview_state *state = &rctx->samplers[shader].views;
-		uint32_t mask = state->enabled_mask;
-
-		while (mask) {
-			uint32_t i = u_bit_scan(&mask);
-			if (&state->views[i]->tex_resource->b.b == res) {
-				rctx->b.flags |= R600_CONTEXT_INV_TEX_CACHE;
-
-				shader = PIPE_SHADER_TYPES; /* break the outer loop */
-				break;
-			}
-		}
-	}
-
-	/* Check streamout buffers. */
-	int i;
-	for (i = 0; i < rctx->b.streamout.num_targets; i++) {
-		if (rctx->b.streamout.targets[i]->b.buffer == res) {
-			rctx->b.flags |= R600_CONTEXT_STREAMOUT_FLUSH |
-				       R600_CONTEXT_FLUSH_AND_INV |
-				       R600_CONTEXT_WAIT_3D_IDLE;
-			break;
-		}
-	}
-
-	/* Check colorbuffers. */
-	for (i = 0; i < rctx->framebuffer.state.nr_cbufs; i++) {
-		struct r600_texture *tex;
-
-		if (rctx->framebuffer.state.cbufs[i] == NULL) {
-		    continue;
-		}
-
-		tex = (struct r600_texture*)rctx->framebuffer.state.cbufs[i]->texture;
-
-		if (rctx->framebuffer.state.cbufs[i]->texture == res) {
-			rctx->b.flags |= R600_CONTEXT_FLUSH_AND_INV_CB |
-				       R600_CONTEXT_FLUSH_AND_INV |
-				       R600_CONTEXT_WAIT_3D_IDLE;
-
-			if (tex->cmask.size || tex->fmask.size) {
-				rctx->b.flags |= R600_CONTEXT_FLUSH_AND_INV_CB_META;
-			}
-			break;
-		}
-
-		if (tex && tex->cmask_buffer && tex->cmask_buffer != &tex->resource && &tex->cmask_buffer->b.b == res) {
-			rctx->b.flags |= R600_CONTEXT_FLUSH_AND_INV_CB_META |
-				       R600_CONTEXT_FLUSH_AND_INV |
-				       R600_CONTEXT_WAIT_3D_IDLE;
-		}
-	}
-
-	/* Check a depth buffer. */
-	if (rctx->framebuffer.state.zsbuf) {
-		if (rctx->framebuffer.state.zsbuf->texture == res) {
-			rctx->b.flags |= R600_CONTEXT_FLUSH_AND_INV_DB |
-				       R600_CONTEXT_FLUSH_AND_INV |
-				       R600_CONTEXT_WAIT_3D_IDLE;
-		}
-
-		struct r600_texture *tex =
-			(struct r600_texture*)rctx->framebuffer.state.zsbuf->texture;
-		if (tex && tex->htile && &tex->htile->b.b == res) {
-			rctx->b.flags |= R600_CONTEXT_FLUSH_AND_INV_DB_META |
-				       R600_CONTEXT_FLUSH_AND_INV |
-				       R600_CONTEXT_WAIT_3D_IDLE;
-		}
-	}
-}
diff --git a/src/gallium/drivers/r600/r600_pipe.c b/src/gallium/drivers/r600/r600_pipe.c
index 6b31bd8..e091b08 100644
--- a/src/gallium/drivers/r600/r600_pipe.c
+++ b/src/gallium/drivers/r600/r600_pipe.c
@@ -1134,6 +1134,9 @@ struct pipe_screen *r600_screen_create(struct radeon_winsys *ws)
 		}
 	}
 
+	/* Create the auxiliary context. This must be done last. */
+	rscreen->b.aux_context = rscreen->b.b.context_create(&rscreen->b.b, NULL);
+
 #if 0 /* This is for testing whether aux_context and buffer clearing work correctly. */
 	struct pipe_resource templ = {};
 
diff --git a/src/gallium/drivers/r600/r600_pipe.h b/src/gallium/drivers/r600/r600_pipe.h
index 43fe080..0304d6a 100644
--- a/src/gallium/drivers/r600/r600_pipe.h
+++ b/src/gallium/drivers/r600/r600_pipe.h
@@ -685,8 +685,6 @@ void r600_dma_copy(struct r600_context *rctx,
 		uint64_t dst_offset,
 		uint64_t src_offset,
 		uint64_t size);
-void r600_flag_resource_cache_flush(struct r600_context *rctx,
-				    struct pipe_resource *res);
 
 /*
  * evergreen_hw_context.c
diff --git a/src/gallium/drivers/r600/r600_shader.c b/src/gallium/drivers/r600/r600_shader.c
index 206db04..aed2100 100644
--- a/src/gallium/drivers/r600/r600_shader.c
+++ b/src/gallium/drivers/r600/r600_shader.c
@@ -1638,15 +1638,22 @@ static int tgsi_op2_s(struct r600_shader_ctx *ctx, int swap, int trans_only)
 {
 	struct tgsi_full_instruction *inst = &ctx->parse.FullToken.FullInstruction;
 	struct r600_bytecode_alu alu;
-	int i, j, r;
-	int lasti = tgsi_last_instruction(inst->Dst[0].Register.WriteMask);
+	unsigned write_mask = inst->Dst[0].Register.WriteMask;
+	int i, j, r, lasti = tgsi_last_instruction(write_mask);
+	/* use temp register if trans_only and more than one dst component */
+	int use_tmp = trans_only && (write_mask ^ (1 << lasti));
 
-	for (i = 0; i < lasti + 1; i++) {
-		if (!(inst->Dst[0].Register.WriteMask & (1 << i)))
+	for (i = 0; i <= lasti; i++) {
+		if (!(write_mask & (1 << i)))
 			continue;
 
 		memset(&alu, 0, sizeof(struct r600_bytecode_alu));
-		tgsi_dst(ctx, &inst->Dst[0], i, &alu.dst);
+		if (use_tmp) {
+			alu.dst.sel = ctx->temp_reg;
+			alu.dst.chan = i;
+			alu.dst.write = 1;
+		} else
+			tgsi_dst(ctx, &inst->Dst[0], i, &alu.dst);
 
 		alu.op = ctx->inst_info->op;
 		if (!swap) {
@@ -1675,6 +1682,25 @@ static int tgsi_op2_s(struct r600_shader_ctx *ctx, int swap, int trans_only)
 		if (r)
 			return r;
 	}
+
+	if (use_tmp) {
+		/* move result from temp to dst */
+		for (i = 0; i <= lasti; i++) {
+			if (!(write_mask & (1 << i)))
+				continue;
+
+			memset(&alu, 0, sizeof(struct r600_bytecode_alu));
+			alu.op = ALU_OP1_MOV;
+			tgsi_dst(ctx, &inst->Dst[0], i, &alu.dst);
+			alu.src[0].sel = ctx->temp_reg;
+			alu.src[0].chan = i;
+			alu.last = (i == lasti);
+
+			r = r600_bytecode_add_alu(ctx->bc, &alu);
+			if (r)
+				return r;
+		}
+	}
 	return 0;
 }
 
@@ -3782,16 +3808,16 @@ static int tgsi_tex(struct r600_shader_ctx *ctx)
 		}
 	}
 
-	if (inst->Instruction.Opcode == TGSI_OPCODE_TXF) {
-		/* get offset values */
-		if (inst->Texture.NumOffsets) {
-			assert(inst->Texture.NumOffsets == 1);
+	/* get offset values */
+	if (inst->Texture.NumOffsets) {
+		assert(inst->Texture.NumOffsets == 1);
 
-			offset_x = ctx->literals[inst->TexOffsets[0].Index + inst->TexOffsets[0].SwizzleX] << 1;
-			offset_y = ctx->literals[inst->TexOffsets[0].Index + inst->TexOffsets[0].SwizzleY] << 1;
-			offset_z = ctx->literals[inst->TexOffsets[0].Index + inst->TexOffsets[0].SwizzleZ] << 1;
-		}
-	} else if (inst->Instruction.Opcode == TGSI_OPCODE_TXD) {
+		offset_x = ctx->literals[4 * inst->TexOffsets[0].Index + inst->TexOffsets[0].SwizzleX] << 1;
+		offset_y = ctx->literals[4 * inst->TexOffsets[0].Index + inst->TexOffsets[0].SwizzleY] << 1;
+		offset_z = ctx->literals[4 * inst->TexOffsets[0].Index + inst->TexOffsets[0].SwizzleZ] << 1;
+	}
+
+	if (inst->Instruction.Opcode == TGSI_OPCODE_TXD) {
 		/* TGSI moves the sampler to src reg 3 for TXD */
 		sampler_src_reg = 3;
 
diff --git a/src/gallium/drivers/r600/r600_state.c b/src/gallium/drivers/r600/r600_state.c
index b01ab9c..f148052 100644
--- a/src/gallium/drivers/r600/r600_state.c
+++ b/src/gallium/drivers/r600/r600_state.c
@@ -2972,11 +2972,18 @@ void *r600_create_db_flush_dsa(struct r600_context *rctx)
 
 void r600_update_db_shader_control(struct r600_context * rctx)
 {
-	bool dual_export = rctx->framebuffer.export_16bpc &&
-			   !rctx->ps_shader->current->ps_depth_export;
+	bool dual_export;
+	unsigned db_shader_control;
 
-	unsigned db_shader_control = rctx->ps_shader->current->db_shader_control |
-				     S_02880C_DUAL_EXPORT_ENABLE(dual_export);
+	if (!rctx->ps_shader) {
+		return;
+	}
+
+	dual_export = rctx->framebuffer.export_16bpc &&
+		      !rctx->ps_shader->current->ps_depth_export;
+
+	db_shader_control = rctx->ps_shader->current->db_shader_control |
+			    S_02880C_DUAL_EXPORT_ENABLE(dual_export);
 
 	/* When alpha test is enabled we can't trust the hw to make the proper
 	 * decision on the order in which ztest should be run related to fragment
diff --git a/src/gallium/drivers/r600/r600_state_common.c b/src/gallium/drivers/r600/r600_state_common.c
index 7371bd6..482eb44 100644
--- a/src/gallium/drivers/r600/r600_state_common.c
+++ b/src/gallium/drivers/r600/r600_state_common.c
@@ -394,6 +394,11 @@ static void r600_bind_sampler_states(struct pipe_context *pipe,
 
 	assert(start == 0); /* XXX fix below */
 
+	if (shader != PIPE_SHADER_VERTEX &&
+	    shader != PIPE_SHADER_FRAGMENT) {
+		return;
+	}
+
 	for (i = 0; i < count; i++) {
 		struct r600_pipe_sampler_state *rstate = rstates[i];
 
@@ -437,16 +442,6 @@ static void r600_bind_sampler_states(struct pipe_context *pipe,
 	}
 }
 
-static void r600_bind_vs_sampler_states(struct pipe_context *ctx, unsigned count, void **states)
-{
-	r600_bind_sampler_states(ctx, PIPE_SHADER_VERTEX, 0, count, states);
-}
-
-static void r600_bind_ps_sampler_states(struct pipe_context *ctx, unsigned count, void **states)
-{
-	r600_bind_sampler_states(ctx, PIPE_SHADER_FRAGMENT, 0, count, states);
-}
-
 static void r600_delete_sampler_state(struct pipe_context *ctx, void *state)
 {
 	free(state);
@@ -2085,11 +2080,10 @@ void r600_init_common_state_functions(struct r600_context *rctx)
 	rctx->b.b.create_vertex_elements_state = r600_create_vertex_fetch_shader;
 	rctx->b.b.bind_blend_state = r600_bind_blend_state;
 	rctx->b.b.bind_depth_stencil_alpha_state = r600_bind_dsa_state;
-	rctx->b.b.bind_fragment_sampler_states = r600_bind_ps_sampler_states;
+	rctx->b.b.bind_sampler_states = r600_bind_sampler_states;
 	rctx->b.b.bind_fs_state = r600_bind_ps_state;
 	rctx->b.b.bind_rasterizer_state = r600_bind_rs_state;
 	rctx->b.b.bind_vertex_elements_state = r600_bind_vertex_elements;
-	rctx->b.b.bind_vertex_sampler_states = r600_bind_vs_sampler_states;
 	rctx->b.b.bind_vs_state = r600_bind_vs_state;
 	rctx->b.b.delete_blend_state = r600_delete_blend_state;
 	rctx->b.b.delete_depth_stencil_alpha_state = r600_delete_dsa_state;
diff --git a/src/gallium/drivers/r600/r600_uvd.c b/src/gallium/drivers/r600/r600_uvd.c
index 05d2ad0..300bccb 100644
--- a/src/gallium/drivers/r600/r600_uvd.c
+++ b/src/gallium/drivers/r600/r600_uvd.c
@@ -77,7 +77,7 @@ struct pipe_video_buffer *r600_video_buffer_create(struct pipe_context *pipe,
 
 	vl_video_buffer_template(&templ, &template, resource_formats[0], 1, array_size, PIPE_USAGE_STATIC, 0);
 	if (ctx->b.chip_class < EVERGREEN || tmpl->interlaced)
-		templ.flags = R600_RESOURCE_FLAG_TRANSFER;
+		templ.bind = PIPE_BIND_LINEAR;
 	resources[0] = (struct r600_texture *)
 		pipe->screen->resource_create(pipe->screen, &templ);
 	if (!resources[0])
@@ -86,7 +86,7 @@ struct pipe_video_buffer *r600_video_buffer_create(struct pipe_context *pipe,
 	if (resource_formats[1] != PIPE_FORMAT_NONE) {
 		vl_video_buffer_template(&templ, &template, resource_formats[1], 1, array_size, PIPE_USAGE_STATIC, 1);
 		if (ctx->b.chip_class < EVERGREEN || tmpl->interlaced)
-			templ.flags = R600_RESOURCE_FLAG_TRANSFER;
+			templ.bind = PIPE_BIND_LINEAR;
 		resources[1] = (struct r600_texture *)
 			pipe->screen->resource_create(pipe->screen, &templ);
 		if (!resources[1])
@@ -96,7 +96,7 @@ struct pipe_video_buffer *r600_video_buffer_create(struct pipe_context *pipe,
 	if (resource_formats[2] != PIPE_FORMAT_NONE) {
 		vl_video_buffer_template(&templ, &template, resource_formats[2], 1, array_size, PIPE_USAGE_STATIC, 2);
 		if (ctx->b.chip_class < EVERGREEN || tmpl->interlaced)
-			templ.flags = R600_RESOURCE_FLAG_TRANSFER;
+			templ.bind = PIPE_BIND_LINEAR;
 		resources[2] = (struct r600_texture *)
 			pipe->screen->resource_create(pipe->screen, &templ);
 		if (!resources[2])
diff --git a/src/gallium/drivers/r600/sb/sb_core.cpp b/src/gallium/drivers/r600/sb/sb_core.cpp
index b5dd88e..9fd9d9a 100644
--- a/src/gallium/drivers/r600/sb/sb_core.cpp
+++ b/src/gallium/drivers/r600/sb/sb_core.cpp
@@ -184,6 +184,8 @@ int r600_sb_bytecode_process(struct r600_context *rctx,
 		SB_RUN_PASS(psi_ops,		1);
 
 	SB_RUN_PASS(liveness,			0);
+
+	sh->dce_flags = DF_REMOVE_DEAD | DF_EXPAND;
 	SB_RUN_PASS(dce_cleanup,		0);
 	SB_RUN_PASS(def_use,			0);
 
@@ -201,9 +203,10 @@ int r600_sb_bytecode_process(struct r600_context *rctx,
 
 	SB_RUN_PASS(gvn,				1);
 
-	SB_RUN_PASS(liveness,			0);
+	SB_RUN_PASS(def_use,			1);
+
+	sh->dce_flags = DF_REMOVE_DEAD | DF_REMOVE_UNUSED;
 	SB_RUN_PASS(dce_cleanup,		1);
-	SB_RUN_PASS(def_use,			0);
 
 	SB_RUN_PASS(ra_split,			0);
 	SB_RUN_PASS(def_use,			0);
@@ -217,6 +220,9 @@ int r600_sb_bytecode_process(struct r600_context *rctx,
 	sh->compute_interferences = true;
 	SB_RUN_PASS(liveness,			0);
 
+	sh->dce_flags = DF_REMOVE_DEAD;
+	SB_RUN_PASS(dce_cleanup,		1);
+
 	SB_RUN_PASS(ra_coalesce,		1);
 	SB_RUN_PASS(ra_init,			1);
 
diff --git a/src/gallium/drivers/r600/sb/sb_dce_cleanup.cpp b/src/gallium/drivers/r600/sb/sb_dce_cleanup.cpp
index f879395..79aef91 100644
--- a/src/gallium/drivers/r600/sb/sb_dce_cleanup.cpp
+++ b/src/gallium/drivers/r600/sb/sb_dce_cleanup.cpp
@@ -56,7 +56,8 @@ bool dce_cleanup::visit(cf_node& n, bool enter) {
 		else
 			cleanup_dst(n);
 	} else {
-		if (n.bc.op_ptr->flags & (CF_CLAUSE | CF_BRANCH | CF_LOOP))
+		if ((sh.dce_flags & DF_EXPAND) &&
+				(n.bc.op_ptr->flags & (CF_CLAUSE | CF_BRANCH | CF_LOOP)))
 			n.expand();
 	}
 	return true;
@@ -107,19 +108,20 @@ bool dce_cleanup::visit(region_node& n, bool enter) {
 }
 
 void dce_cleanup::cleanup_dst(node& n) {
-	cleanup_dst_vec(n.dst);
+	if (!cleanup_dst_vec(n.dst) && remove_unused &&
+			!n.dst.empty() && !(n.flags & NF_DONT_KILL) && n.parent)
+		n.remove();
 }
 
 bool dce_cleanup::visit(container_node& n, bool enter) {
-	if (enter) {
+	if (enter)
 		cleanup_dst(n);
-	} else {
-
-	}
 	return true;
 }
 
-void dce_cleanup::cleanup_dst_vec(vvec& vv) {
+bool dce_cleanup::cleanup_dst_vec(vvec& vv) {
+	bool alive = false;
+
 	for (vvec::iterator I = vv.begin(), E = vv.end(); I != E; ++I) {
 		value* &v = *I;
 		if (!v)
@@ -128,9 +130,13 @@ void dce_cleanup::cleanup_dst_vec(vvec& vv) {
 		if (v->gvn_source && v->gvn_source->is_dead())
 			v->gvn_source = NULL;
 
-		if (v->is_dead())
+		if (v->is_dead() || (remove_unused && !v->is_rel() && !v->uses))
 			v = NULL;
+		else
+			alive = true;
 	}
+
+	return alive;
 }
 
 } // namespace r600_sb
diff --git a/src/gallium/drivers/r600/sb/sb_pass.h b/src/gallium/drivers/r600/sb/sb_pass.h
index 95d2a20..a3f8515 100644
--- a/src/gallium/drivers/r600/sb/sb_pass.h
+++ b/src/gallium/drivers/r600/sb/sb_pass.h
@@ -119,9 +119,12 @@ public:
 class dce_cleanup : public vpass {
 	using vpass::visit;
 
+	bool remove_unused;
+
 public:
 
-	dce_cleanup(shader &s) : vpass(s) {}
+	dce_cleanup(shader &s) : vpass(s),
+		remove_unused(s.dce_flags & DF_REMOVE_UNUSED) {}
 
 	virtual bool visit(node &n, bool enter);
 	virtual bool visit(alu_group_node &n, bool enter);
@@ -135,7 +138,7 @@ public:
 private:
 
 	void cleanup_dst(node &n);
-	void cleanup_dst_vec(vvec &vv);
+	bool cleanup_dst_vec(vvec &vv);
 
 };
 
diff --git a/src/gallium/drivers/r600/sb/sb_shader.h b/src/gallium/drivers/r600/sb/sb_shader.h
index e515d31..7955bba 100644
--- a/src/gallium/drivers/r600/sb/sb_shader.h
+++ b/src/gallium/drivers/r600/sb/sb_shader.h
@@ -71,6 +71,16 @@ enum chunk_flags {
 	RCF_PREALLOC = (1 << 4)
 };
 
+enum dce_flags {
+	DF_REMOVE_DEAD  = (1 << 0),
+	DF_REMOVE_UNUSED = (1 << 1),
+	DF_EXPAND = (1 << 2),
+};
+
+inline dce_flags operator |(dce_flags l, dce_flags r) {
+	return (dce_flags)((unsigned)l|(unsigned)r);
+}
+
 inline chunk_flags operator |(chunk_flags l, chunk_flags r) {
 	return (chunk_flags)((unsigned)l|(unsigned)r);
 }
@@ -297,6 +307,8 @@ public:
 
 	unsigned ngpr, nstack;
 
+	unsigned dce_flags;
+
 	shader(sb_context &sctx, shader_target t, unsigned id);
 
 	~shader();
diff --git a/src/gallium/drivers/radeon/Makefile.am b/src/gallium/drivers/radeon/Makefile.am
index d5a6ff2..a54a3aa 100644
--- a/src/gallium/drivers/radeon/Makefile.am
+++ b/src/gallium/drivers/radeon/Makefile.am
@@ -3,7 +3,7 @@ include $(top_srcdir)/src/gallium/Automake.inc
 
 noinst_LTLIBRARIES = libradeon.la
 
-AM_CFLAGS = $(GALLIUM_CFLAGS) $(RADEON_CFLAGS)
+AM_CFLAGS = $(GALLIUM_CFLAGS) $(RADEON_CFLAGS) $(VISIBILITY_CFLAGS)
 
 libradeon_la_SOURCES = \
 	$(C_SOURCES)
@@ -17,11 +17,13 @@ noinst_LTLIBRARIES += libllvmradeon.la
 
 libllvmradeon_la_CXXFLAGS = \
 	$(GALLIUM_CFLAGS) \
-	$(DEFINES)
+	$(DEFINES) \
+	$(VISIBILITY_CFLAGS)
 
 libllvmradeon_la_CFLAGS = \
 	$(GALLIUM_CFLAGS) \
-	$(LLVM_CFLAGS)
+	$(LLVM_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
 
 libllvmradeon_la_SOURCES = \
 	$(LLVM_CPP_FILES) \
diff --git a/src/gallium/drivers/radeon/r600_pipe_common.c b/src/gallium/drivers/radeon/r600_pipe_common.c
index 852993c..f83c7e4 100644
--- a/src/gallium/drivers/radeon/r600_pipe_common.c
+++ b/src/gallium/drivers/radeon/r600_pipe_common.c
@@ -175,9 +175,7 @@ bool r600_common_screen_init(struct r600_common_screen *rscreen,
 
 	util_format_s3tc_init();
 
-	/* Create the auxiliary context. */
 	pipe_mutex_init(rscreen->aux_context_lock);
-	rscreen->aux_context = rscreen->b.context_create(&rscreen->b, NULL);
 	return true;
 }
 
@@ -249,6 +247,10 @@ static unsigned tgsi_get_processor_type(const struct tgsi_token *tokens)
 bool r600_can_dump_shader(struct r600_common_screen *rscreen,
 			  const struct tgsi_token *tokens)
 {
+	/* Compute shader don't have tgsi_tokens */
+	if (!tokens)
+		return (rscreen->debug_flags & DBG_CS) != 0;
+
 	switch (tgsi_get_processor_type(tokens)) {
 	case TGSI_PROCESSOR_VERTEX:
 		return (rscreen->debug_flags & DBG_VS) != 0;
diff --git a/src/gallium/drivers/radeon/r600_texture.c b/src/gallium/drivers/radeon/r600_texture.c
index e83ce83..9ba1e36 100644
--- a/src/gallium/drivers/radeon/r600_texture.c
+++ b/src/gallium/drivers/radeon/r600_texture.c
@@ -515,10 +515,6 @@ r600_texture_create_object(struct pipe_screen *screen,
 	/* don't include stencil-only formats which we don't support for rendering */
 	rtex->is_depth = util_format_has_depth(util_format_description(rtex->resource.b.b.format));
 
-	/* Tiled depth textures utilize the non-displayable tile order.
-	 * Applies to R600-Cayman. */
-	rtex->non_disp_tiling = rtex->is_depth && rtex->surface.level[0].mode >= RADEON_SURF_MODE_1D;
-
 	rtex->surface = *surface;
 	r = r600_setup_surface(screen, rtex, pitch_in_bytes_override);
 	if (r) {
@@ -526,6 +522,11 @@ r600_texture_create_object(struct pipe_screen *screen,
 		return NULL;
 	}
 
+	/* Tiled depth textures utilize the non-displayable tile order.
+	 * This must be done after r600_setup_surface.
+	 * Applies to R600-Cayman. */
+	rtex->non_disp_tiling = rtex->is_depth && rtex->surface.level[0].mode >= RADEON_SURF_MODE_1D;
+
 	if (base->nr_samples > 1 && !rtex->is_depth && !buf) {
 		r600_texture_allocate_fmask(rscreen, rtex);
 		r600_texture_allocate_cmask(rscreen, rtex);
@@ -851,6 +852,12 @@ static void *r600_texture_transfer_map(struct pipe_context *ctx,
 	if (rtex->surface.level[level].mode >= RADEON_SURF_MODE_1D)
 		use_staging_texture = TRUE;
 
+	/* Untiled buffers in VRAM, which is slow for CPU reads */
+	if ((usage & PIPE_TRANSFER_READ) && !(usage & PIPE_TRANSFER_MAP_DIRECTLY) &&
+	    (rtex->resource.domains == RADEON_DOMAIN_VRAM)) {
+		use_staging_texture = TRUE;
+	}
+
 	/* Use a staging texture for uploads if the underlying BO is busy. */
 	if (!(usage & PIPE_TRANSFER_READ) &&
 	    (r600_rings_is_buffer_referenced(rctx, rtex->resource.cs_buf, RADEON_USAGE_READWRITE) ||
diff --git a/src/gallium/drivers/radeon/radeon_llvm_emit.c b/src/gallium/drivers/radeon/radeon_llvm_emit.c
index 2dd7bf7..8bf278b 100644
--- a/src/gallium/drivers/radeon/radeon_llvm_emit.c
+++ b/src/gallium/drivers/radeon/radeon_llvm_emit.c
@@ -143,6 +143,7 @@ unsigned radeon_llvm_compile(LLVMModuleRef M, struct radeon_llvm_binary *binary,
 	elf = elf_memory(elf_buffer, buffer_size);
 
 	elf_getshdrstrndx(elf, &section_str_index);
+	binary->disassembled = 0;
 
 	while ((section = elf_nextscn(elf, section))) {
 		const char *name;
@@ -163,6 +164,12 @@ unsigned radeon_llvm_compile(LLVMModuleRef M, struct radeon_llvm_binary *binary,
 			binary->config_size = section_data->d_size;
 			binary->config = MALLOC(binary->config_size * sizeof(unsigned char));
 			memcpy(binary->config, section_data->d_buf, binary->config_size);
+		} else if (dump && !strcmp(name, ".AMDGPU.disasm")) {
+			binary->disassembled = 1;
+			section_data = elf_getdata(section, section_data);
+			fprintf(stderr, "\nShader Disassembly:\n\n");
+			fprintf(stderr, "%.*s\n", (int)section_data->d_size,
+						  (char *)section_data->d_buf);
 		}
 	}
 
diff --git a/src/gallium/drivers/radeon/radeon_llvm_emit.h b/src/gallium/drivers/radeon/radeon_llvm_emit.h
index 72c24c6..532b7b8 100644
--- a/src/gallium/drivers/radeon/radeon_llvm_emit.h
+++ b/src/gallium/drivers/radeon/radeon_llvm_emit.h
@@ -34,6 +34,7 @@ struct radeon_llvm_binary {
 	unsigned code_size;
 	unsigned char *config;
 	unsigned config_size;
+	int disassembled;
 };
 
 void radeon_llvm_shader_type(LLVMValueRef F, unsigned type);
diff --git a/src/gallium/drivers/radeon/radeon_uvd.c b/src/gallium/drivers/radeon/radeon_uvd.c
index 382b410..134ce4e 100644
--- a/src/gallium/drivers/radeon/radeon_uvd.c
+++ b/src/gallium/drivers/radeon/radeon_uvd.c
@@ -56,6 +56,7 @@
 
 #define NUM_MPEG2_REFS 6
 #define NUM_H264_REFS 17
+#define NUM_VC1_REFS 5
 
 /* UVD buffer representation */
 struct ruvd_buffer
@@ -79,6 +80,8 @@ struct ruvd_decoder {
 	unsigned			cur_buffer;
 
 	struct ruvd_buffer		msg_fb_buffers[NUM_BUFFERS];
+	struct ruvd_msg			*msg;
+
 	struct ruvd_buffer		bs_buffers[NUM_BUFFERS];
 	void*				bs_ptr;
 	unsigned			bs_size;
@@ -128,22 +131,31 @@ static void send_cmd(struct ruvd_decoder *dec, unsigned cmd,
 	set_reg(dec, RUVD_GPCOM_VCPU_CMD, cmd << 1);
 }
 
-/* send a message command to the VCPU */
-static void send_msg(struct ruvd_decoder *dec, struct ruvd_msg *msg)
+/* map the next available message buffer */
+static void map_msg_buf(struct ruvd_decoder *dec)
 {
 	struct ruvd_buffer* buf;
-	void *ptr;
 
-	/* grap a message buffer */
+	/* grap the current message buffer */
 	buf = &dec->msg_fb_buffers[dec->cur_buffer];
 
 	/* copy the message into it */
-	ptr = dec->ws->buffer_map(buf->cs_handle, dec->cs, PIPE_TRANSFER_WRITE);
-	if (!ptr)
+	dec->msg = dec->ws->buffer_map(buf->cs_handle, dec->cs, PIPE_TRANSFER_WRITE);
+}
+
+/* unmap and send a message command to the VCPU */
+static void send_msg_buf(struct ruvd_decoder *dec)
+{
+	struct ruvd_buffer* buf;
+
+	/* ignore the request if message buffer isn't mapped */
+	if (!dec->msg)
 		return;
 
-	memcpy(ptr, msg, sizeof(*msg));
-	memset(ptr + sizeof(*msg), 0, buf->buf->size - sizeof(*msg));
+	/* grap the current message buffer */
+	buf = &dec->msg_fb_buffers[dec->cur_buffer];
+
+	/* unmap the buffer */
 	dec->ws->buffer_unmap(buf->cs_handle);
 
 	/* and send it to the hardware */
@@ -293,6 +305,9 @@ static unsigned calc_dpb_size(const struct pipe_video_codec *templ)
 		break;
 
 	case PIPE_VIDEO_FORMAT_VC1:
+		// the firmware seems to allways assume a minimum of ref frames
+		max_references = MAX2(NUM_VC1_REFS, max_references);
+
 		// reference picture buffer
 		dpb_size = image_size * max_references;
 
@@ -420,60 +435,62 @@ static struct ruvd_vc1 get_vc1_msg(struct pipe_vc1_picture_desc *pic)
 	struct ruvd_vc1 result;
 
 	memset(&result, 0, sizeof(result));
+
 	switch(pic->base.profile) {
 	case PIPE_VIDEO_PROFILE_VC1_SIMPLE:
 		result.profile = RUVD_VC1_PROFILE_SIMPLE;
+		result.level = 1;
 		break;
 
 	case PIPE_VIDEO_PROFILE_VC1_MAIN:
 		result.profile = RUVD_VC1_PROFILE_MAIN;
+		result.level = 2;
 		break;
-		
+
 	case PIPE_VIDEO_PROFILE_VC1_ADVANCED:
 		result.profile = RUVD_VC1_PROFILE_ADVANCED;
+		result.level = 4;
 		break;
+
 	default:
 		assert(0);
 	}
 
-	if (pic->base.profile == PIPE_VIDEO_PROFILE_VC1_ADVANCED) {
-		result.level = 0;
-
-		result.sps_info_flags |= pic->postprocflag << 7;
-		result.sps_info_flags |= pic->pulldown << 6;
-		result.sps_info_flags |= pic->interlace << 5;
-		result.sps_info_flags |= pic->tfcntrflag << 4;
-		result.sps_info_flags |= pic->psf << 1;
-
-		result.pps_info_flags |= pic->panscan_flag << 7;
-		result.pps_info_flags |= pic->refdist_flag << 6;
-		result.pps_info_flags |= pic->extended_dmv << 8;
-		result.pps_info_flags |= pic->range_mapy_flag << 31;
-		result.pps_info_flags |= pic->range_mapy << 28;
-		result.pps_info_flags |= pic->range_mapuv_flag << 27;
-		result.pps_info_flags |= pic->range_mapuv << 24;
+	/* fields common for all profiles */
+	result.sps_info_flags |= pic->postprocflag << 7;
+	result.sps_info_flags |= pic->pulldown << 6;
+	result.sps_info_flags |= pic->interlace << 5;
+	result.sps_info_flags |= pic->tfcntrflag << 4;
+	result.sps_info_flags |= pic->finterpflag << 3;
+	result.sps_info_flags |= pic->psf << 1;
+
+	result.pps_info_flags |= pic->range_mapy_flag << 31;
+	result.pps_info_flags |= pic->range_mapy << 28;
+	result.pps_info_flags |= pic->range_mapuv_flag << 27;
+	result.pps_info_flags |= pic->range_mapuv << 24;
+	result.pps_info_flags |= pic->multires << 21;
+	result.pps_info_flags |= pic->maxbframes << 16;
+	result.pps_info_flags |= pic->overlap << 11;
+	result.pps_info_flags |= pic->quantizer << 9;
+	result.pps_info_flags |= pic->panscan_flag << 7;
+	result.pps_info_flags |= pic->refdist_flag << 6;
+	result.pps_info_flags |= pic->vstransform << 0;
 
-	} else {
-		result.level = 0;
-		result.pps_info_flags |= pic->multires << 21;
+	/* some fields only apply to main/advanced profile */
+	if (pic->base.profile != PIPE_VIDEO_PROFILE_VC1_SIMPLE) {
 		result.pps_info_flags |= pic->syncmarker << 20;
 		result.pps_info_flags |= pic->rangered << 19;
-		result.pps_info_flags |= pic->maxbframes << 16;
+		result.pps_info_flags |= pic->loopfilter << 5;
+		result.pps_info_flags |= pic->fastuvmc << 4;
+		result.pps_info_flags |= pic->extended_mv << 3;
+		result.pps_info_flags |= pic->extended_dmv << 8;
+		result.pps_info_flags |= pic->dquant << 1;
 	}
 
-	result.sps_info_flags |= pic->finterpflag << 3;
-	//(((unsigned int)(pPicParams->advance.reserved1))        << SPS_INFO_VC1_RESERVED_SHIFT)
-
-	result.pps_info_flags |= pic->loopfilter << 5;
-	result.pps_info_flags |= pic->fastuvmc << 4;
-	result.pps_info_flags |= pic->extended_mv << 3;
-	result.pps_info_flags |= pic->dquant << 1;
-	result.pps_info_flags |= pic->vstransform << 0;
-	result.pps_info_flags |= pic->overlap << 11;
-	result.pps_info_flags |= pic->quantizer << 9;
-
+	result.chroma_format = 1;
 
 #if 0
+//(((unsigned int)(pPicParams->advance.reserved1))        << SPS_INFO_VC1_RESERVED_SHIFT)
 uint32_t 	slice_count
 uint8_t 	picture_type
 uint8_t 	frame_coding_mode
@@ -481,7 +498,6 @@ uint8_t 	deblockEnable
 uint8_t 	pquant
 #endif
 
-        result.chroma_format  = 1;
 	return result;
 }
 
@@ -611,16 +627,16 @@ static struct ruvd_mpeg4 get_mpeg4_msg(struct ruvd_decoder *dec,
 static void ruvd_destroy(struct pipe_video_codec *decoder)
 {
 	struct ruvd_decoder *dec = (struct ruvd_decoder*)decoder;
-	struct ruvd_msg msg;
 	unsigned i;
 
 	assert(decoder);
 
-	memset(&msg, 0, sizeof(msg));
-	msg.size = sizeof(msg);
-	msg.msg_type = RUVD_MSG_DESTROY;
-	msg.stream_handle = dec->stream_handle;
-	send_msg(dec, &msg);
+	map_msg_buf(dec);
+	memset(dec->msg, 0, sizeof(*dec->msg));
+	dec->msg->size = sizeof(*dec->msg);
+	dec->msg->msg_type = RUVD_MSG_DESTROY;
+	dec->msg->stream_handle = dec->stream_handle;
+	send_msg_buf(dec);
 
 	flush(dec);
 
@@ -730,7 +746,6 @@ static void ruvd_end_frame(struct pipe_video_codec *decoder,
 	struct ruvd_decoder *dec = (struct ruvd_decoder*)decoder;
 	struct radeon_winsys_cs_handle *dt;
 	struct ruvd_buffer *msg_fb_buf, *bs_buf;
-	struct ruvd_msg msg;
 	unsigned bs_size;
 
 	assert(decoder);
@@ -745,37 +760,37 @@ static void ruvd_end_frame(struct pipe_video_codec *decoder,
 	memset(dec->bs_ptr, 0, bs_size - dec->bs_size);
 	dec->ws->buffer_unmap(bs_buf->cs_handle);
 
-	memset(&msg, 0, sizeof(msg));
-	msg.size = sizeof(msg);
-	msg.msg_type = RUVD_MSG_DECODE;
-	msg.stream_handle = dec->stream_handle;
-	msg.status_report_feedback_number = dec->frame_number;
+	map_msg_buf(dec);
+	dec->msg->size = sizeof(*dec->msg);
+	dec->msg->msg_type = RUVD_MSG_DECODE;
+	dec->msg->stream_handle = dec->stream_handle;
+	dec->msg->status_report_feedback_number = dec->frame_number;
 
-	msg.body.decode.stream_type = profile2stream_type(dec->base.profile);
-	msg.body.decode.decode_flags = 0x1;
-	msg.body.decode.width_in_samples = dec->base.width;
-	msg.body.decode.height_in_samples = dec->base.height;
+	dec->msg->body.decode.stream_type = profile2stream_type(dec->base.profile);
+	dec->msg->body.decode.decode_flags = 0x1;
+	dec->msg->body.decode.width_in_samples = dec->base.width;
+	dec->msg->body.decode.height_in_samples = dec->base.height;
 
-	msg.body.decode.dpb_size = dec->dpb.buf->size;
-	msg.body.decode.bsd_size = bs_size;
+	dec->msg->body.decode.dpb_size = dec->dpb.buf->size;
+	dec->msg->body.decode.bsd_size = bs_size;
 
-	dt = dec->set_dtb(&msg, (struct vl_video_buffer *)target);
+	dt = dec->set_dtb(dec->msg, (struct vl_video_buffer *)target);
 
 	switch (u_reduce_video_profile(picture->profile)) {
 	case PIPE_VIDEO_FORMAT_MPEG4_AVC:
-		msg.body.decode.codec.h264 = get_h264_msg(dec, (struct pipe_h264_picture_desc*)picture);
+		dec->msg->body.decode.codec.h264 = get_h264_msg(dec, (struct pipe_h264_picture_desc*)picture);
 		break;
 
 	case PIPE_VIDEO_FORMAT_VC1:
-		msg.body.decode.codec.vc1 = get_vc1_msg((struct pipe_vc1_picture_desc*)picture);
+		dec->msg->body.decode.codec.vc1 = get_vc1_msg((struct pipe_vc1_picture_desc*)picture);
 		break;
 
 	case PIPE_VIDEO_FORMAT_MPEG12:
-		msg.body.decode.codec.mpeg2 = get_mpeg2_msg(dec, (struct pipe_mpeg12_picture_desc*)picture);
+		dec->msg->body.decode.codec.mpeg2 = get_mpeg2_msg(dec, (struct pipe_mpeg12_picture_desc*)picture);
 		break;
 
 	case PIPE_VIDEO_FORMAT_MPEG4:
-		msg.body.decode.codec.mpeg4 = get_mpeg4_msg(dec, (struct pipe_mpeg4_picture_desc*)picture);
+		dec->msg->body.decode.codec.mpeg4 = get_mpeg4_msg(dec, (struct pipe_mpeg4_picture_desc*)picture);
 		break;
 
 	default:
@@ -783,10 +798,10 @@ static void ruvd_end_frame(struct pipe_video_codec *decoder,
 		return;
 	}
 
-	msg.body.decode.db_surf_tile_config = msg.body.decode.dt_surf_tile_config;
-	msg.body.decode.extension_support = 0x1;
+	dec->msg->body.decode.db_surf_tile_config = dec->msg->body.decode.dt_surf_tile_config;
+	dec->msg->body.decode.extension_support = 0x1;
+	send_msg_buf(dec);
 
-	send_msg(dec, &msg);
 	send_cmd(dec, RUVD_CMD_DPB_BUFFER, dec->dpb.cs_handle, 0,
 		 RADEON_USAGE_READWRITE, RADEON_DOMAIN_VRAM);
 	send_cmd(dec, RUVD_CMD_BITSTREAM_BUFFER, bs_buf->cs_handle,
@@ -821,7 +836,6 @@ struct pipe_video_codec *ruvd_create_decoder(struct pipe_context *context,
 	unsigned bs_buf_size;
 	struct radeon_info info;
 	struct ruvd_decoder *dec;
-	struct ruvd_msg msg;
 	int i;
 
 	ws->query_info(ws, &info);
@@ -893,15 +907,15 @@ struct pipe_video_codec *ruvd_create_decoder(struct pipe_context *context,
 
 	clear_buffer(dec, &dec->dpb);
 
-	memset(&msg, 0, sizeof(msg));
-	msg.size = sizeof(msg);
-	msg.msg_type = RUVD_MSG_CREATE;
-	msg.stream_handle = dec->stream_handle;
-	msg.body.create.stream_type = profile2stream_type(dec->base.profile);
-	msg.body.create.width_in_samples = dec->base.width;
-	msg.body.create.height_in_samples = dec->base.height;
-	msg.body.create.dpb_size = dec->dpb.buf->size;
-	send_msg(dec, &msg);
+	map_msg_buf(dec);
+	dec->msg->size = sizeof(*dec->msg);
+	dec->msg->msg_type = RUVD_MSG_CREATE;
+	dec->msg->stream_handle = dec->stream_handle;
+	dec->msg->body.create.stream_type = profile2stream_type(dec->base.profile);
+	dec->msg->body.create.width_in_samples = dec->base.width;
+	dec->msg->body.create.height_in_samples = dec->base.height;
+	dec->msg->body.create.dpb_size = dec->dpb.buf->size;
+	send_msg_buf(dec);
 	flush(dec);
 	next_buffer(dec);
 
@@ -1101,8 +1115,10 @@ int ruvd_get_video_param(struct pipe_screen *screen,
 		case PIPE_VIDEO_FORMAT_MPEG12:
 		case PIPE_VIDEO_FORMAT_MPEG4:
 		case PIPE_VIDEO_FORMAT_MPEG4_AVC:
-		case PIPE_VIDEO_FORMAT_VC1:
 			return true;
+		case PIPE_VIDEO_FORMAT_VC1:
+			/* FIXME: VC-1 simple/main profile is broken */
+			return profile == PIPE_VIDEO_PROFILE_VC1_ADVANCED;
 		default:
 			return false;
 		}
@@ -1154,6 +1170,9 @@ boolean ruvd_is_format_supported(struct pipe_screen *screen,
 				 enum pipe_video_profile profile,
 				 enum pipe_video_entrypoint entrypoint)
 {
-	/* we can only handle this one anyway */
-	return format == PIPE_FORMAT_NV12;
+	/* we can only handle this one with UVD */
+	if (profile != PIPE_VIDEO_PROFILE_UNKNOWN)
+		return format == PIPE_FORMAT_NV12;
+
+	return vl_video_buffer_is_format_supported(screen, format, profile, entrypoint);
 }
diff --git a/src/gallium/drivers/radeonsi/Makefile.am b/src/gallium/drivers/radeonsi/Makefile.am
index 0c27973..9aaab8f 100644
--- a/src/gallium/drivers/radeonsi/Makefile.am
+++ b/src/gallium/drivers/radeonsi/Makefile.am
@@ -31,7 +31,9 @@ AM_CPPFLAGS = \
 	-I$(top_srcdir)/include \
 	$(GALLIUM_CFLAGS) \
 	$(RADEON_CFLAGS)
-AM_CFLAGS = $(LLVM_CFLAGS)
+AM_CFLAGS = \
+	$(LLVM_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
 
 libradeonsi_la_SOURCES = $(C_SOURCES)
 libradeonsi_la_LIBADD = \
diff --git a/src/gallium/drivers/radeonsi/radeonsi_compute.c b/src/gallium/drivers/radeonsi/radeonsi_compute.c
index 4135480..d3f5a23 100644
--- a/src/gallium/drivers/radeonsi/radeonsi_compute.c
+++ b/src/gallium/drivers/radeonsi/radeonsi_compute.c
@@ -244,11 +244,6 @@ static void si_set_cs_sampler_view(struct pipe_context *ctx_,
 		unsigned start_slot, unsigned count,
 		struct pipe_sampler_view **views) { }
 
-static void si_bind_compute_sampler_states(
-	struct pipe_context *ctx_,
-	unsigned start_slot,
-	unsigned num_samplers,
-	void **samplers_) { }
 void si_init_compute_functions(struct r600_context *rctx)
 {
 	rctx->b.b.create_compute_state = radeonsi_create_compute_state;
@@ -257,7 +252,6 @@ void si_init_compute_functions(struct r600_context *rctx)
 /*	 ctx->context.create_sampler_view = evergreen_compute_create_sampler_view; */
 	rctx->b.b.set_compute_resources = si_set_compute_resources;
 	rctx->b.b.set_compute_sampler_views = si_set_cs_sampler_view;
-	rctx->b.b.bind_compute_sampler_states = si_bind_compute_sampler_states;
 	rctx->b.b.set_global_binding = radeonsi_set_global_binding;
 	rctx->b.b.launch_grid = radeonsi_launch_grid;
 }
diff --git a/src/gallium/drivers/radeonsi/radeonsi_pipe.c b/src/gallium/drivers/radeonsi/radeonsi_pipe.c
index a929270..121fd18 100644
--- a/src/gallium/drivers/radeonsi/radeonsi_pipe.c
+++ b/src/gallium/drivers/radeonsi/radeonsi_pipe.c
@@ -307,11 +307,15 @@ const char *r600_get_llvm_processor_name(enum radeon_family family)
 		case CHIP_PITCAIRN: return "pitcairn";
 		case CHIP_VERDE: return "verde";
 		case CHIP_OLAND: return "oland";
+#if HAVE_LLVM <= 0x0303
+		default: return "SI";
+#else
 		case CHIP_HAINAN: return "hainan";
 		case CHIP_BONAIRE: return "bonaire";
 		case CHIP_KABINI: return "kabini";
 		case CHIP_KAVERI: return "kaveri";
 		default: return "";
+#endif
 	}
 }
 
@@ -819,5 +823,8 @@ struct pipe_screen *radeonsi_screen_create(struct radeon_winsys *ws)
 	}
 #endif
 
+	/* Create the auxiliary context. This must be done last. */
+	rscreen->b.aux_context = rscreen->b.b.context_create(&rscreen->b.b, NULL);
+
 	return &rscreen->b.b;
 }
diff --git a/src/gallium/drivers/radeonsi/radeonsi_shader.c b/src/gallium/drivers/radeonsi/radeonsi_shader.c
index 7ed3d26..80ee325 100644
--- a/src/gallium/drivers/radeonsi/radeonsi_shader.c
+++ b/src/gallium/drivers/radeonsi/radeonsi_shader.c
@@ -114,8 +114,12 @@ static LLVMValueRef build_indexed_load(
 {
 	struct lp_build_context * base = &si_shader_ctx->radeon_bld.soa.bld_base.base;
 
+	LLVMValueRef indices[2] = {
+		LLVMConstInt(LLVMInt64TypeInContext(base->gallivm->context), 0, false),
+		offset
+	};
 	LLVMValueRef computed_ptr = LLVMBuildGEP(
-		base->gallivm->builder, base_ptr, &offset, 1, "");
+		base->gallivm->builder, base_ptr, indices, 2, "");
 
 	LLVMValueRef result = LLVMBuildLoad(base->gallivm->builder, computed_ptr, "");
 	LLVMSetMetadata(result, 1, si_shader_ctx->const_md);
@@ -570,11 +574,14 @@ static void si_alpha_test(struct lp_build_tgsi_context *bld_base,
 
 	if (si_shader_ctx->shader->key.ps.alpha_func != PIPE_FUNC_NEVER) {
 		LLVMValueRef out_ptr = si_shader_ctx->radeon_bld.soa.outputs[index][3];
+		LLVMValueRef alpha_ref = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn,
+				SI_PARAM_ALPHA_REF);
+
 		LLVMValueRef alpha_pass =
 			lp_build_cmp(&bld_base->base,
 				     si_shader_ctx->shader->key.ps.alpha_func,
 				     LLVMBuildLoad(gallivm->builder, out_ptr, ""),
-				     lp_build_const_float(gallivm, si_shader_ctx->shader->key.ps.alpha_ref));
+				     alpha_ref);
 		LLVMValueRef arg =
 			lp_build_select(&bld_base->base,
 					alpha_pass,
@@ -1569,7 +1576,7 @@ static void create_function(struct si_shader_context *si_shader_ctx)
 {
 	struct lp_build_tgsi_context *bld_base = &si_shader_ctx->radeon_bld.soa.bld_base;
 	struct gallivm_state *gallivm = bld_base->base.gallivm;
-	LLVMTypeRef params[20], f32, i8, i32, v2i32, v3i32;
+	LLVMTypeRef params[21], f32, i8, i32, v2i32, v3i32;
 	unsigned i, last_sgpr, num_params;
 
 	i8 = LLVMInt8TypeInContext(gallivm->context);
@@ -1578,9 +1585,14 @@ static void create_function(struct si_shader_context *si_shader_ctx)
 	v2i32 = LLVMVectorType(i32, 2);
 	v3i32 = LLVMVectorType(i32, 3);
 
-	params[SI_PARAM_CONST] = LLVMPointerType(LLVMVectorType(i8, 16), CONST_ADDR_SPACE);
-	params[SI_PARAM_SAMPLER] = params[SI_PARAM_CONST];
-	params[SI_PARAM_RESOURCE] = LLVMPointerType(LLVMVectorType(i8, 32), CONST_ADDR_SPACE);
+	params[SI_PARAM_CONST] = LLVMPointerType(
+		LLVMArrayType(LLVMVectorType(i8, 16), NUM_CONST_BUFFERS), CONST_ADDR_SPACE);
+	/* We assume at most 16 textures per program at the moment.
+	 * This need probably need to be changed to support bindless textures */
+	params[SI_PARAM_SAMPLER] = LLVMPointerType(
+		LLVMArrayType(LLVMVectorType(i8, 16), NUM_SAMPLER_VIEWS), CONST_ADDR_SPACE);
+	params[SI_PARAM_RESOURCE] = LLVMPointerType(
+		LLVMArrayType(LLVMVectorType(i8, 32), NUM_SAMPLER_STATES), CONST_ADDR_SPACE);
 
 	switch (si_shader_ctx->type) {
 	case TGSI_PROCESSOR_VERTEX:
@@ -1614,6 +1626,7 @@ static void create_function(struct si_shader_context *si_shader_ctx)
 		break;
 
 	case TGSI_PROCESSOR_FRAGMENT:
+		params[SI_PARAM_ALPHA_REF] = f32;
 		params[SI_PARAM_PRIM_MASK] = i32;
 		last_sgpr = SI_PARAM_PRIM_MASK;
 		params[SI_PARAM_PERSP_SAMPLE] = v2i32;
@@ -1646,7 +1659,20 @@ static void create_function(struct si_shader_context *si_shader_ctx)
 
 	for (i = 0; i <= last_sgpr; ++i) {
 		LLVMValueRef P = LLVMGetParam(si_shader_ctx->radeon_bld.main_fn, i);
-		LLVMAddAttribute(P, LLVMInRegAttribute);
+		switch (i) {
+		default:
+			LLVMAddAttribute(P, LLVMInRegAttribute);
+			break;
+#if HAVE_LLVM >= 0x0304
+		/* We tell llvm that array inputs are passed by value to allow Sinking pass
+		 * to move load. Inputs are constant so this is fine. */
+		case SI_PARAM_CONST:
+		case SI_PARAM_SAMPLER:
+		case SI_PARAM_RESOURCE:
+			LLVMAddAttribute(P, LLVMByValAttribute);
+			break;
+#endif
+		}
 	}
 
 #if HAVE_LLVM >= 0x0304
@@ -1759,12 +1785,12 @@ int si_compile_llvm(struct r600_context *rctx, struct si_pipe_shader *shader,
 	unsigned i;
 	uint32_t *ptr;
 	struct radeon_llvm_binary binary;
-	bool dump = r600_can_dump_shader(&rctx->screen->b, shader->selector->tokens);
-
+	bool dump = r600_can_dump_shader(&rctx->screen->b,
+			shader->selector ? shader->selector->tokens : NULL);
 	memset(&binary, 0, sizeof(binary));
 	radeon_llvm_compile(mod, &binary,
 		r600_get_llvm_processor_name(rctx->screen->b.family), dump);
-	if (dump) {
+	if (dump && ! binary.disassembled) {
 		fprintf(stderr, "SI CODE:\n");
 		for (i = 0; i < binary.code_size; i+=4 ) {
 			fprintf(stderr, "%02x%02x%02x%02x\n", binary.code[i + 3],
diff --git a/src/gallium/drivers/radeonsi/radeonsi_shader.h b/src/gallium/drivers/radeonsi/radeonsi_shader.h
index 1db8bb8..c9e851a 100644
--- a/src/gallium/drivers/radeonsi/radeonsi_shader.h
+++ b/src/gallium/drivers/radeonsi/radeonsi_shader.h
@@ -37,9 +37,10 @@
 #define SI_SGPR_VERTEX_BUFFER	6  /* VS only */
 #define SI_SGPR_SO_BUFFER	8  /* VS only, stream-out */
 #define SI_SGPR_START_INSTANCE	10 /* VS only */
+#define SI_SGPR_ALPHA_REF	6  /* PS only */
 
 #define SI_VS_NUM_USER_SGPR	11
-#define SI_PS_NUM_USER_SGPR	6
+#define SI_PS_NUM_USER_SGPR	7
 
 /* LLVM function parameter indices */
 #define SI_PARAM_CONST		0
@@ -53,23 +54,24 @@
 /* the other VS parameters are assigned dynamically */
 
 /* PS only parameters */
-#define SI_PARAM_PRIM_MASK		3
-#define SI_PARAM_PERSP_SAMPLE		4
-#define SI_PARAM_PERSP_CENTER		5
-#define SI_PARAM_PERSP_CENTROID		6
-#define SI_PARAM_PERSP_PULL_MODEL	7
-#define SI_PARAM_LINEAR_SAMPLE		8
-#define SI_PARAM_LINEAR_CENTER		9
-#define SI_PARAM_LINEAR_CENTROID	10
-#define SI_PARAM_LINE_STIPPLE_TEX	11
-#define SI_PARAM_POS_X_FLOAT		12
-#define SI_PARAM_POS_Y_FLOAT		13
-#define SI_PARAM_POS_Z_FLOAT		14
-#define SI_PARAM_POS_W_FLOAT		15
-#define SI_PARAM_FRONT_FACE		16
-#define SI_PARAM_ANCILLARY		17
-#define SI_PARAM_SAMPLE_COVERAGE	18
-#define SI_PARAM_POS_FIXED_PT		19
+#define SI_PARAM_ALPHA_REF		3
+#define SI_PARAM_PRIM_MASK		4
+#define SI_PARAM_PERSP_SAMPLE		5
+#define SI_PARAM_PERSP_CENTER		6
+#define SI_PARAM_PERSP_CENTROID		7
+#define SI_PARAM_PERSP_PULL_MODEL	8
+#define SI_PARAM_LINEAR_SAMPLE		9
+#define SI_PARAM_LINEAR_CENTER		10
+#define SI_PARAM_LINEAR_CENTROID	11
+#define SI_PARAM_LINE_STIPPLE_TEX	12
+#define SI_PARAM_POS_X_FLOAT		13
+#define SI_PARAM_POS_Y_FLOAT		14
+#define SI_PARAM_POS_Z_FLOAT		15
+#define SI_PARAM_POS_W_FLOAT		16
+#define SI_PARAM_FRONT_FACE		17
+#define SI_PARAM_ANCILLARY		18
+#define SI_PARAM_SAMPLE_COVERAGE	19
+#define SI_PARAM_POS_FIXED_PT		20
 
 struct si_shader_io {
 	unsigned		name;
@@ -124,7 +126,6 @@ union si_shader_key {
 		unsigned	alpha_func:3;
 		unsigned	flatshade:1;
 		unsigned	alpha_to_one:1;
-		float		alpha_ref;
 	} ps;
 	struct {
 		unsigned	instance_divisors[PIPE_MAX_ATTRIBS];
diff --git a/src/gallium/drivers/radeonsi/radeonsi_uvd.c b/src/gallium/drivers/radeonsi/radeonsi_uvd.c
index 1cb3be0..6ecb17c 100644
--- a/src/gallium/drivers/radeonsi/radeonsi_uvd.c
+++ b/src/gallium/drivers/radeonsi/radeonsi_uvd.c
@@ -76,8 +76,8 @@ struct pipe_video_buffer *radeonsi_video_buffer_create(struct pipe_context *pipe
 	template.height = align(tmpl->height / array_size, VL_MACROBLOCK_HEIGHT);
 
 	vl_video_buffer_template(&templ, &template, resource_formats[0], 1, array_size, PIPE_USAGE_STATIC, 0);
-	/* TODO: Setting the transfer flag is only a workaround till we get tiling working */
-	templ.flags = R600_RESOURCE_FLAG_TRANSFER;
+	/* TODO: get tiling working */
+	templ.bind = PIPE_BIND_LINEAR;
 	resources[0] = (struct r600_texture *)
 		pipe->screen->resource_create(pipe->screen, &templ);
 	if (!resources[0])
@@ -85,7 +85,7 @@ struct pipe_video_buffer *radeonsi_video_buffer_create(struct pipe_context *pipe
 
 	if (resource_formats[1] != PIPE_FORMAT_NONE) {
 		vl_video_buffer_template(&templ, &template, resource_formats[1], 1, array_size, PIPE_USAGE_STATIC, 1);
-		templ.flags = R600_RESOURCE_FLAG_TRANSFER;
+		templ.bind = PIPE_BIND_LINEAR;
 		resources[1] = (struct r600_texture *)
 			pipe->screen->resource_create(pipe->screen, &templ);
 		if (!resources[1])
@@ -94,7 +94,7 @@ struct pipe_video_buffer *radeonsi_video_buffer_create(struct pipe_context *pipe
 
 	if (resource_formats[2] != PIPE_FORMAT_NONE) {
 		vl_video_buffer_template(&templ, &template, resource_formats[2], 1, array_size, PIPE_USAGE_STATIC, 2);
-		templ.flags = R600_RESOURCE_FLAG_TRANSFER;
+		templ.bind = PIPE_BIND_LINEAR;
 		resources[2] = (struct r600_texture *)
 			pipe->screen->resource_create(pipe->screen, &templ);
 		if (!resources[2])
diff --git a/src/gallium/drivers/radeonsi/si_state.c b/src/gallium/drivers/radeonsi/si_state.c
index 1d5f4b7..da7c3d0 100644
--- a/src/gallium/drivers/radeonsi/si_state.c
+++ b/src/gallium/drivers/radeonsi/si_state.c
@@ -744,6 +744,9 @@ static void *si_create_dsa_state(struct pipe_context *ctx,
 	if (state->alpha.enabled) {
 		dsa->alpha_func = state->alpha.func;
 		dsa->alpha_ref = state->alpha.ref_value;
+
+		si_pm4_set_reg(pm4, R_00B030_SPI_SHADER_USER_DATA_PS_0 +
+		               SI_SGPR_ALPHA_REF * 4, fui(dsa->alpha_ref));
 	} else {
 		dsa->alpha_func = PIPE_FUNC_ALWAYS;
 	}
@@ -2116,10 +2119,6 @@ static INLINE void si_shader_selector_key(struct pipe_context *ctx,
 			    rctx->framebuffer.cbufs[0] &&
 			    util_format_is_pure_integer(rctx->framebuffer.cbufs[0]->texture->format))
 				key->ps.alpha_func = PIPE_FUNC_ALWAYS;
-
-			if (key->ps.alpha_func != PIPE_FUNC_ALWAYS &&
-			    key->ps.alpha_func != PIPE_FUNC_NEVER)
-				key->ps.alpha_ref = rctx->queued.named.dsa->alpha_ref;
 		} else {
 			key->ps.alpha_func = PIPE_FUNC_ALWAYS;
 		}
@@ -2678,7 +2677,7 @@ static void si_set_ps_sampler_views(struct pipe_context *ctx, unsigned count,
 	si_set_sampler_views(rctx, PIPE_SHADER_FRAGMENT, count, views);
 }
 
-static struct si_pm4_state *si_bind_sampler_states(struct r600_context *rctx, unsigned count,
+static struct si_pm4_state *si_set_sampler_states(struct r600_context *rctx, unsigned count,
 						   void **states,
 						   struct r600_textures_info *samplers,
 						   unsigned user_data_reg)
@@ -2757,7 +2756,7 @@ static void si_bind_vs_sampler_states(struct pipe_context *ctx, unsigned count,
 	struct r600_context *rctx = (struct r600_context *)ctx;
 	struct si_pm4_state *pm4;
 
-	pm4 = si_bind_sampler_states(rctx, count, states, &rctx->samplers[PIPE_SHADER_VERTEX],
+	pm4 = si_set_sampler_states(rctx, count, states, &rctx->samplers[PIPE_SHADER_VERTEX],
 			      R_00B130_SPI_SHADER_USER_DATA_VS_0);
 	si_pm4_set_state(rctx, vs_sampler, pm4);
 }
@@ -2767,11 +2766,32 @@ static void si_bind_ps_sampler_states(struct pipe_context *ctx, unsigned count,
 	struct r600_context *rctx = (struct r600_context *)ctx;
 	struct si_pm4_state *pm4;
 
-	pm4 = si_bind_sampler_states(rctx, count, states, &rctx->samplers[PIPE_SHADER_FRAGMENT],
+	pm4 = si_set_sampler_states(rctx, count, states, &rctx->samplers[PIPE_SHADER_FRAGMENT],
 			      R_00B030_SPI_SHADER_USER_DATA_PS_0);
 	si_pm4_set_state(rctx, ps_sampler, pm4);
 }
 
+
+static void si_bind_sampler_states(struct pipe_context *ctx, unsigned shader,
+                                   unsigned start, unsigned count,
+                                   void **states)
+{
+   assert(start == 0);
+
+   switch (shader) {
+   case PIPE_SHADER_VERTEX:
+      si_bind_vs_sampler_states(ctx, count, states);
+      break;
+   case PIPE_SHADER_FRAGMENT:
+      si_bind_ps_sampler_states(ctx, count, states);
+      break;
+   default:
+      ;
+   }
+}
+
+
+
 static void si_set_sample_mask(struct pipe_context *ctx, unsigned sample_mask)
 {
 	struct r600_context *rctx = (struct r600_context *)ctx;
@@ -3009,8 +3029,7 @@ void si_init_state_functions(struct r600_context *rctx)
 	rctx->b.b.delete_fs_state = si_delete_ps_shader;
 
 	rctx->b.b.create_sampler_state = si_create_sampler_state;
-	rctx->b.b.bind_vertex_sampler_states = si_bind_vs_sampler_states;
-	rctx->b.b.bind_fragment_sampler_states = si_bind_ps_sampler_states;
+	rctx->b.b.bind_sampler_states = si_bind_sampler_states;
 	rctx->b.b.delete_sampler_state = si_delete_sampler_state;
 
 	rctx->b.b.create_sampler_view = si_create_sampler_view;
@@ -3064,10 +3083,12 @@ void si_init_config(struct r600_context *rctx)
 	si_pm4_set_reg(pm4, R_028B28_VGT_STRMOUT_DRAW_OPAQUE_OFFSET, 0);
 	si_pm4_set_reg(pm4, R_028B94_VGT_STRMOUT_CONFIG, 0x0);
 	si_pm4_set_reg(pm4, R_028B98_VGT_STRMOUT_BUFFER_CONFIG, 0x0);
-	si_pm4_set_reg(pm4, R_028AA8_IA_MULTI_VGT_PARAM,
-		       S_028AA8_SWITCH_ON_EOP(1) |
-		       S_028AA8_PARTIAL_VS_WAVE_ON(1) |
-		       S_028AA8_PRIMGROUP_SIZE(63));
+	if (rctx->b.chip_class == SI) {
+		si_pm4_set_reg(pm4, R_028AA8_IA_MULTI_VGT_PARAM,
+			       S_028AA8_SWITCH_ON_EOP(1) |
+			       S_028AA8_PARTIAL_VS_WAVE_ON(1) |
+			       S_028AA8_PRIMGROUP_SIZE(63));
+	}
 	si_pm4_set_reg(pm4, R_028AB4_VGT_REUSE_OFF, 0x00000000);
 	si_pm4_set_reg(pm4, R_028AB8_VGT_VTX_CNT_EN, 0x0);
 	if (rctx->b.chip_class < CIK)
diff --git a/src/gallium/drivers/radeonsi/si_state.h b/src/gallium/drivers/radeonsi/si_state.h
index 94a1521..6dbf880 100644
--- a/src/gallium/drivers/radeonsi/si_state.h
+++ b/src/gallium/drivers/radeonsi/si_state.h
@@ -107,6 +107,7 @@ union si_state {
  */
 #define FMASK_TEX_OFFSET	NUM_TEX_UNITS
 #define NUM_SAMPLER_VIEWS	(FMASK_TEX_OFFSET+NUM_TEX_UNITS)
+#define NUM_SAMPLER_STATES	NUM_TEX_UNITS
 
 #define NUM_CONST_BUFFERS 2
 
diff --git a/src/gallium/drivers/radeonsi/si_state_draw.c b/src/gallium/drivers/radeonsi/si_state_draw.c
index 0213523..d20658e 100644
--- a/src/gallium/drivers/radeonsi/si_state_draw.c
+++ b/src/gallium/drivers/radeonsi/si_state_draw.c
@@ -302,7 +302,8 @@ static unsigned r600_conv_prim_to_gs_out(unsigned mode)
 }
 
 static bool si_update_draw_info_state(struct r600_context *rctx,
-			       const struct pipe_draw_info *info)
+				      const struct pipe_draw_info *info,
+				      const struct pipe_index_buffer *ib)
 {
 	struct si_pm4_state *pm4 = si_pm4_alloc_state(rctx);
 	struct si_shader *vs = &rctx->vs_shader->current->shader;
@@ -318,12 +319,27 @@ static bool si_update_draw_info_state(struct r600_context *rctx,
 		return false;
 	}
 
-	if (rctx->b.chip_class >= CIK)
+	if (rctx->b.chip_class >= CIK) {
+		bool wd_switch_on_eop = prim == V_008958_DI_PT_POLYGON ||
+					prim == V_008958_DI_PT_LINELOOP ||
+					prim == V_008958_DI_PT_TRIFAN ||
+					prim == V_008958_DI_PT_TRISTRIP_ADJ ||
+					info->primitive_restart;
+
+		si_pm4_set_reg(pm4, R_028AA8_IA_MULTI_VGT_PARAM,
+			       S_028AA8_SWITCH_ON_EOP(1) |
+			       S_028AA8_PARTIAL_VS_WAVE_ON(1) |
+			       S_028AA8_PRIMGROUP_SIZE(63) |
+			       S_028AA8_WD_SWITCH_ON_EOP(wd_switch_on_eop));
+		si_pm4_set_reg(pm4, R_028B74_VGT_DISPATCH_DRAW_INDEX,
+			       ib->index_size == 4 ? 0xFC000000 : 0xFC00);
+
 		si_pm4_set_reg(pm4, R_030908_VGT_PRIMITIVE_TYPE, prim);
-	else {
+	} else {
 		si_pm4_set_reg(pm4, R_008958_VGT_PRIMITIVE_TYPE, prim);
-		si_pm4_set_reg(pm4, R_028A6C_VGT_GS_OUT_PRIM_TYPE, gs_out_prim);
 	}
+
+	si_pm4_set_reg(pm4, R_028A6C_VGT_GS_OUT_PRIM_TYPE, gs_out_prim);
 	si_pm4_set_reg(pm4, R_028400_VGT_MAX_VTX_INDX, ~0);
 	si_pm4_set_reg(pm4, R_028404_VGT_MIN_VTX_INDX, 0);
 	si_pm4_set_reg(pm4, R_028408_VGT_INDX_OFFSET,
@@ -554,9 +570,18 @@ static void si_state_draw(struct r600_context *rctx,
 	if (rctx->num_cs_dw_nontimer_queries_suspend) {
 		struct si_state_dsa *dsa = rctx->queued.named.dsa;
 
-		si_pm4_set_reg(pm4, R_028004_DB_COUNT_CONTROL,
-			       S_028004_PERFECT_ZPASS_COUNTS(1) |
-			       S_028004_SAMPLE_RATE(rctx->fb_log_samples));
+		if (rctx->b.chip_class >= CIK) {
+			si_pm4_set_reg(pm4, R_028004_DB_COUNT_CONTROL,
+				       S_028004_PERFECT_ZPASS_COUNTS(1) |
+				       S_028004_SAMPLE_RATE(rctx->fb_log_samples) |
+				       S_028004_ZPASS_ENABLE(1) |
+				       S_028004_SLICE_EVEN_ENABLE(1) |
+				       S_028004_SLICE_ODD_ENABLE(1));
+		} else {
+			si_pm4_set_reg(pm4, R_028004_DB_COUNT_CONTROL,
+				       S_028004_PERFECT_ZPASS_COUNTS(1) |
+				       S_028004_SAMPLE_RATE(rctx->fb_log_samples));
+		}
 		si_pm4_set_reg(pm4, R_02800C_DB_RENDER_OVERRIDE,
 			       dsa->db_render_override |
 			       S_02800C_NOOP_CULL_DISABLE(1));
@@ -721,7 +746,7 @@ void si_draw_vbo(struct pipe_context *ctx, const struct pipe_draw_info *info)
 		}
 	}
 
-	if (!si_update_draw_info_state(rctx, info))
+	if (!si_update_draw_info_state(rctx, info, &ib))
 		return;
 
 	si_state_draw(rctx, info, &ib);
diff --git a/src/gallium/drivers/rbug/rbug_context.c b/src/gallium/drivers/rbug/rbug_context.c
index a103dfb..083d372 100644
--- a/src/gallium/drivers/rbug/rbug_context.c
+++ b/src/gallium/drivers/rbug/rbug_context.c
@@ -263,32 +263,15 @@ rbug_create_sampler_state(struct pipe_context *_pipe,
 }
 
 static void
-rbug_bind_fragment_sampler_states(struct pipe_context *_pipe,
-                                  unsigned num_samplers,
-                                  void **samplers)
+rbug_bind_sampler_states(struct pipe_context *_pipe, unsigned shader,
+                         unsigned start, unsigned count,
+                         void **samplers)
 {
    struct rbug_context *rb_pipe = rbug_context(_pipe);
    struct pipe_context *pipe = rb_pipe->pipe;
 
    pipe_mutex_lock(rb_pipe->call_mutex);
-   pipe->bind_fragment_sampler_states(pipe,
-                                      num_samplers,
-                                      samplers);
-   pipe_mutex_unlock(rb_pipe->call_mutex);
-}
-
-static void
-rbug_bind_vertex_sampler_states(struct pipe_context *_pipe,
-                                unsigned num_samplers,
-                                void **samplers)
-{
-   struct rbug_context *rb_pipe = rbug_context(_pipe);
-   struct pipe_context *pipe = rb_pipe->pipe;
-
-   pipe_mutex_lock(rb_pipe->call_mutex);
-   pipe->bind_vertex_sampler_states(pipe,
-                                    num_samplers,
-                                    samplers);
+   pipe->bind_sampler_states(pipe, shader, start, count, samplers);
    pipe_mutex_unlock(rb_pipe->call_mutex);
 }
 
@@ -1160,8 +1143,7 @@ rbug_context_create(struct pipe_screen *_screen, struct pipe_context *pipe)
    rb_pipe->base.bind_blend_state = rbug_bind_blend_state;
    rb_pipe->base.delete_blend_state = rbug_delete_blend_state;
    rb_pipe->base.create_sampler_state = rbug_create_sampler_state;
-   rb_pipe->base.bind_fragment_sampler_states = rbug_bind_fragment_sampler_states;
-   rb_pipe->base.bind_vertex_sampler_states = rbug_bind_vertex_sampler_states;
+   rb_pipe->base.bind_sampler_states = rbug_bind_sampler_states;
    rb_pipe->base.delete_sampler_state = rbug_delete_sampler_state;
    rb_pipe->base.create_rasterizer_state = rbug_create_rasterizer_state;
    rb_pipe->base.bind_rasterizer_state = rbug_bind_rasterizer_state;
diff --git a/src/gallium/drivers/softpipe/Makefile.am b/src/gallium/drivers/softpipe/Makefile.am
index 432fe7d..1048d85 100644
--- a/src/gallium/drivers/softpipe/Makefile.am
+++ b/src/gallium/drivers/softpipe/Makefile.am
@@ -26,7 +26,8 @@ include $(top_srcdir)/src/gallium/Automake.inc
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/gallium/drivers \
 	-I$(top_srcdir)/include \
-	$(GALLIUM_CFLAGS)
+	$(GALLIUM_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
 
 noinst_LTLIBRARIES = libsoftpipe.la
 
diff --git a/src/gallium/drivers/softpipe/sp_state_sampler.c b/src/gallium/drivers/softpipe/sp_state_sampler.c
index aeb2b9d..be9d645 100644
--- a/src/gallium/drivers/softpipe/sp_state_sampler.c
+++ b/src/gallium/drivers/softpipe/sp_state_sampler.c
@@ -90,34 +90,6 @@ softpipe_bind_sampler_states(struct pipe_context *pipe,
 }
 
 
-
-static void
-softpipe_bind_fragment_sampler_states(struct pipe_context *pipe,
-                                      unsigned num, void **samplers)
-{
-   softpipe_bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0, num, samplers);
-}
-
-
-static void
-softpipe_bind_vertex_sampler_states(struct pipe_context *pipe,
-                                    unsigned num,
-                                    void **samplers)
-{
-   softpipe_bind_sampler_states(pipe, PIPE_SHADER_VERTEX, 0, num, samplers);
-}
-
-
-static void
-softpipe_bind_geometry_sampler_states(struct pipe_context *pipe,
-                                      unsigned num,
-                                      void **samplers)
-{
-   softpipe_bind_sampler_states(pipe, PIPE_SHADER_GEOMETRY, 0, num, samplers);
-}
-
-
-
 static void
 softpipe_sampler_view_destroy(struct pipe_context *pipe,
                               struct pipe_sampler_view *view)
@@ -232,9 +204,7 @@ void
 softpipe_init_sampler_funcs(struct pipe_context *pipe)
 {
    pipe->create_sampler_state = softpipe_create_sampler_state;
-   pipe->bind_fragment_sampler_states  = softpipe_bind_fragment_sampler_states;
-   pipe->bind_vertex_sampler_states = softpipe_bind_vertex_sampler_states;
-   pipe->bind_geometry_sampler_states = softpipe_bind_geometry_sampler_states;
+   pipe->bind_sampler_states = softpipe_bind_sampler_states;
    pipe->delete_sampler_state = softpipe_delete_sampler_state;
 
    pipe->set_fragment_sampler_views = softpipe_set_fragment_sampler_views;
diff --git a/src/gallium/drivers/softpipe/sp_tex_sample.c b/src/gallium/drivers/softpipe/sp_tex_sample.c
index 8dcc297..0c24cf8 100644
--- a/src/gallium/drivers/softpipe/sp_tex_sample.c
+++ b/src/gallium/drivers/softpipe/sp_tex_sample.c
@@ -608,6 +608,48 @@ get_texel_2d(const struct sp_sampler_view *sp_sview,
    }
 }
 
+
+/*
+ * Here's the complete logic (HOLY CRAP) for finding next face and doing the
+ * corresponding coord wrapping, implemented by get_next_face,
+ * get_next_xcoord, get_next_ycoord.
+ * Read like that (first line):
+ * If face is +x and s coord is below zero, then
+ * new face is +z, new s is max , new t is old t
+ * (max is always cube size - 1).
+ *
+ * +x s- -> +z: s = max,   t = t
+ * +x s+ -> -z: s = 0,     t = t
+ * +x t- -> +y: s = max,   t = max-s
+ * +x t+ -> -y: s = max,   t = s
+ *
+ * -x s- -> -z: s = max,   t = t
+ * -x s+ -> +z: s = 0,     t = t
+ * -x t- -> +y: s = 0,     t = s
+ * -x t+ -> -y: s = 0,     t = max-s
+ *
+ * +y s- -> -x: s = t,     t = 0
+ * +y s+ -> +x: s = max-t, t = 0
+ * +y t- -> -z: s = max-s, t = 0
+ * +y t+ -> +z: s = s,     t = 0
+ *
+ * -y s- -> -x: s = max-t, t = max
+ * -y s+ -> +x: s = t,     t = max
+ * -y t- -> +z: s = s,     t = max
+ * -y t+ -> -z: s = max-s, t = max
+
+ * +z s- -> -x: s = max,   t = t
+ * +z s+ -> +x: s = 0,     t = t
+ * +z t- -> +y: s = s,     t = max
+ * +z t+ -> -y: s = s,     t = 0
+
+ * -z s- -> +x: s = max,   t = t
+ * -z s+ -> -x: s = 0,     t = t
+ * -z t- -> +y: s = max-s, t = 0
+ * -z t+ -> -y: s = max-s, t = max
+ */
+
+
 /*
  * seamless cubemap neighbour array.
  * this array is used to find the adjacent face in each of 4 directions,
@@ -617,49 +659,104 @@ static const unsigned face_array[PIPE_TEX_FACE_MAX][4] = {
    /* pos X first then neg X is Z different, Y the same */
    /* PIPE_TEX_FACE_POS_X,*/
    { PIPE_TEX_FACE_POS_Z, PIPE_TEX_FACE_NEG_Z,
-     PIPE_TEX_FACE_NEG_Y, PIPE_TEX_FACE_POS_Y },
+     PIPE_TEX_FACE_POS_Y, PIPE_TEX_FACE_NEG_Y },
    /* PIPE_TEX_FACE_NEG_X */
    { PIPE_TEX_FACE_NEG_Z, PIPE_TEX_FACE_POS_Z,
-     PIPE_TEX_FACE_NEG_Y, PIPE_TEX_FACE_POS_Y },
+     PIPE_TEX_FACE_POS_Y, PIPE_TEX_FACE_NEG_Y },
 
    /* pos Y first then neg Y is X different, X the same */
    /* PIPE_TEX_FACE_POS_Y */
    { PIPE_TEX_FACE_NEG_X, PIPE_TEX_FACE_POS_X,
-     PIPE_TEX_FACE_POS_Z, PIPE_TEX_FACE_NEG_Z },
+     PIPE_TEX_FACE_NEG_Z, PIPE_TEX_FACE_POS_Z },
 
    /* PIPE_TEX_FACE_NEG_Y */
    { PIPE_TEX_FACE_NEG_X, PIPE_TEX_FACE_POS_X,
-     PIPE_TEX_FACE_NEG_Z, PIPE_TEX_FACE_POS_Z },
+     PIPE_TEX_FACE_POS_Z, PIPE_TEX_FACE_NEG_Z },
 
    /* pos Z first then neg Y is X different, X the same */
    /* PIPE_TEX_FACE_POS_Z */
    { PIPE_TEX_FACE_NEG_X, PIPE_TEX_FACE_POS_X,
-     PIPE_TEX_FACE_NEG_Y, PIPE_TEX_FACE_POS_Y },
+     PIPE_TEX_FACE_POS_Y, PIPE_TEX_FACE_NEG_Y },
 
    /* PIPE_TEX_FACE_NEG_Z */
    { PIPE_TEX_FACE_POS_X, PIPE_TEX_FACE_NEG_X,
-     PIPE_TEX_FACE_NEG_Y, PIPE_TEX_FACE_POS_Y }
+     PIPE_TEX_FACE_POS_Y, PIPE_TEX_FACE_NEG_Y }
 };
 
 static INLINE unsigned
-get_next_face(unsigned face, int x, int y)
+get_next_face(unsigned face, int idx)
 {
-   int idx = 0;
+   return face_array[face][idx];
+}
 
-   if (x == 0 && y == 0)
-      return face;
-   if (x == -1)
-      idx = 0;
-   else if (x == 1)
-      idx = 1;
-   else if (y == -1)
-      idx = 2;
-   else if (y == 1)
-      idx = 3;
+/*
+ * return a new xcoord based on old face, old coords, cube size
+ * and fall_off_index (0 for x-, 1 for x+, 2 for y-, 3 for y+)
+ */
+static INLINE int
+get_next_xcoord(unsigned face, unsigned fall_off_index, int max, int xc, int yc)
+{
+   if ((face == 0 && fall_off_index != 1) ||
+       (face == 1 && fall_off_index == 0) ||
+       (face == 4 && fall_off_index == 0) ||
+       (face == 5 && fall_off_index == 0)) {
+      return max;
+   }
+   if ((face == 1 && fall_off_index != 0) ||
+       (face == 0 && fall_off_index == 1) ||
+       (face == 4 && fall_off_index == 1) ||
+       (face == 5 && fall_off_index == 1)) {
+      return 0;
+   }
+   if ((face == 4 && fall_off_index >= 2) ||
+       (face == 2 && fall_off_index == 3) ||
+       (face == 3 && fall_off_index == 2)) {
+      return xc;
+   }
+   if ((face == 5 && fall_off_index >= 2) ||
+       (face == 2 && fall_off_index == 2) ||
+       (face == 3 && fall_off_index == 3)) {
+      return max - xc;
+   }
+   if ((face == 2 && fall_off_index == 0) ||
+       (face == 3 && fall_off_index == 1)) {
+      return yc;
+   }
+   /* (face == 2 && fall_off_index == 1) ||
+      (face == 3 && fall_off_index == 0)) */
+   return max - yc;
+}
 
-   return face_array[face][idx];
+/*
+ * return a new ycoord based on old face, old coords, cube size
+ * and fall_off_index (0 for x-, 1 for x+, 2 for y-, 3 for y+)
+ */
+static INLINE int
+get_next_ycoord(unsigned face, unsigned fall_off_index, int max, int xc, int yc)
+{
+   if ((fall_off_index <= 1) && (face <= 1 || face >= 4)) {
+      return yc;
+   }
+   if (face == 2 ||
+       (face == 4 && fall_off_index == 3) ||
+       (face == 5 && fall_off_index == 2)) {
+      return 0;
+   }
+   if (face == 3 ||
+       (face == 4 && fall_off_index == 2) ||
+       (face == 5 && fall_off_index == 3)) {
+      return max;
+   }
+   if ((face == 0 && fall_off_index == 3) ||
+       (face == 1 && fall_off_index == 2)) {
+      return xc;
+   }
+   /* (face == 0 && fall_off_index == 2) ||
+      (face == 1 && fall_off_index == 3) */
+   return max - xc;
 }
 
+
 static INLINE const float *
 get_texel_cube_seamless(const struct sp_sampler_view *sp_sview,
                         union tex_tile_address addr, int x, int y,
@@ -668,44 +765,47 @@ get_texel_cube_seamless(const struct sp_sampler_view *sp_sview,
    const struct pipe_resource *texture = sp_sview->base.texture;
    unsigned level = addr.bits.level;
    unsigned face = addr.bits.face;
-   int new_x, new_y;
-   int max_x, max_y;
-   int c;
+   int new_x, new_y, max_x;
 
    max_x = (int) u_minify(texture->width0, level);
-   max_y = (int) u_minify(texture->height0, level);
+
+   assert(texture->width0 == texture->height0);
    new_x = x;
    new_y = y;
 
-   /* the corner case */
-   if ((x < 0 || x >= max_x) &&
-       (y < 0 || y >= max_y)) {
-      const float *c1, *c2, *c3;
-      int fx = x < 0 ? 0 : max_x - 1;
-      int fy = y < 0 ? 0 : max_y - 1;
-      c1 = get_texel_2d_no_border( sp_sview, addr, fx, fy);
-      addr.bits.face = get_next_face(face, (x < 0) ? -1 : 1, 0);
-      c2 = get_texel_2d_no_border( sp_sview, addr, (x < 0) ? max_x - 1 : 0, fy);
-      addr.bits.face = get_next_face(face, 0, (y < 0) ? -1 : 1);
-      c3 = get_texel_2d_no_border( sp_sview, addr, fx, (y < 0) ?  max_y - 1 : 0);
-      for (c = 0; c < TGSI_QUAD_SIZE; c++)
-         corner[c] = CLAMP((c1[c] + c2[c] + c3[c]), 0.0F, 1.0F) / 3;
-
-      return corner;
-   }
    /* change the face */
    if (x < 0) {
-      new_x = max_x - 1;
-      face = get_next_face(face, -1, 0);
+      /*
+       * Cheat with corners. They are difficult and I believe because we don't get
+       * per-pixel faces we can actually have multiple corner texels per pixel,
+       * which screws things up majorly in any case (as the per spec behavior is
+       * to average the 3 remaining texels, which we might not have).
+       * Hence just make sure that the 2nd coord is clamped, will simply pick the
+       * sample which would have fallen off the x coord, but not y coord.
+       * So the filter weight of the samples will be wrong, but at least this
+       * ensures that only valid texels near the corner are used.
+       */
+      if (y < 0 || y >= max_x) {
+         y = CLAMP(y, 0, max_x - 1);
+      }
+      new_x = get_next_xcoord(face, 0, max_x -1, x, y);
+      new_y = get_next_ycoord(face, 0, max_x -1, x, y);
+      face = get_next_face(face, 0);
    } else if (x >= max_x) {
-      new_x = 0;
-      face = get_next_face(face, 1, 0);
+      if (y < 0 || y >= max_x) {
+         y = CLAMP(y, 0, max_x - 1);
+      }
+      new_x = get_next_xcoord(face, 1, max_x -1, x, y);
+      new_y = get_next_ycoord(face, 1, max_x -1, x, y);
+      face = get_next_face(face, 1);
    } else if (y < 0) {
-      new_y = max_y - 1;
-      face = get_next_face(face, 0, -1);
-   } else if (y >= max_y) {
-      new_y = 0;
-      face = get_next_face(face, 0, 1);
+      new_x = get_next_xcoord(face, 2, max_x -1, x, y);
+      new_y = get_next_ycoord(face, 2, max_x -1, x, y);
+      face = get_next_face(face, 2);
+   } else if (y >= max_x) {
+      new_x = get_next_xcoord(face, 3, max_x -1, x, y);
+      new_y = get_next_ycoord(face, 3, max_x -1, x, y);
+      face = get_next_face(face, 3);
    }
 
    addr.bits.face = face;
@@ -1241,6 +1341,7 @@ img_filter_cube_nearest(struct sp_sampler_view *sp_sview,
       wrap_nearest_clamp_to_edge(s, width, &x);
       wrap_nearest_clamp_to_edge(t, height, &y);
    } else {
+      /* Would probably make sense to ignore mode and just do edge clamp */
       sp_samp->nearest_texcoord_s(s, width, &x);
       sp_samp->nearest_texcoord_t(t, height, &y);
    }
@@ -1525,9 +1626,11 @@ img_filter_cube_linear(struct sp_sampler_view *sp_sview,
     * always apply wrap mode CLAMP_TO_BORDER.
     */
    if (sp_samp->base.seamless_cube_map) {
+      /* Note this is a bit overkill, actual clamping is not required */
       wrap_linear_clamp_to_border(s, width, &x0, &x1, &xw);
       wrap_linear_clamp_to_border(t, height, &y0, &y1, &yw);
    } else {
+      /* Would probably make sense to ignore mode and just do edge clamp */
       sp_samp->linear_texcoord_s(s, width,  &x0, &x1, &xw);
       sp_samp->linear_texcoord_t(t, height, &y0, &y1, &yw);
    }
diff --git a/src/gallium/drivers/svga/svga_pipe_rasterizer.c b/src/gallium/drivers/svga/svga_pipe_rasterizer.c
index a9a2396..61e13fa 100644
--- a/src/gallium/drivers/svga/svga_pipe_rasterizer.c
+++ b/src/gallium/drivers/svga/svga_pipe_rasterizer.c
@@ -138,11 +138,11 @@ svga_create_rasterizer_state(struct pipe_context *pipe,
       int fill = PIPE_POLYGON_MODE_FILL;
       boolean offset_front = util_get_offset(templ, fill_front);
       boolean offset_back = util_get_offset(templ, fill_back);
-      boolean offset  = 0;
+      boolean offset = FALSE;
 
       switch (templ->cull_face) {
       case PIPE_FACE_FRONT_AND_BACK:
-         offset = 0;
+         offset = FALSE;
          fill = PIPE_POLYGON_MODE_FILL;
          break;
 
diff --git a/src/gallium/drivers/svga/svga_pipe_sampler.c b/src/gallium/drivers/svga/svga_pipe_sampler.c
index 03d604d..b64e813 100644
--- a/src/gallium/drivers/svga/svga_pipe_sampler.c
+++ b/src/gallium/drivers/svga/svga_pipe_sampler.c
@@ -187,14 +187,6 @@ svga_bind_sampler_states(struct pipe_context *pipe,
 }
 
 
-static void
-svga_bind_fragment_sampler_states(struct pipe_context *pipe,
-                                  unsigned num, void **sampler)
-{
-   svga_bind_sampler_states(pipe, PIPE_SHADER_FRAGMENT, 0, num, sampler);
-}
-
-
 static void svga_delete_sampler_state(struct pipe_context *pipe,
                                       void *sampler)
 {
@@ -309,7 +301,7 @@ svga_set_fragment_sampler_views(struct pipe_context *pipe,
 void svga_init_sampler_functions( struct svga_context *svga )
 {
    svga->pipe.create_sampler_state = svga_create_sampler_state;
-   svga->pipe.bind_fragment_sampler_states = svga_bind_fragment_sampler_states;
+   svga->pipe.bind_sampler_states = svga_bind_sampler_states;
    svga->pipe.delete_sampler_state = svga_delete_sampler_state;
    svga->pipe.set_fragment_sampler_views = svga_set_fragment_sampler_views;
    svga->pipe.create_sampler_view = svga_create_sampler_view;
diff --git a/src/gallium/drivers/svga/svga_resource_buffer_upload.c b/src/gallium/drivers/svga/svga_resource_buffer_upload.c
index 55e6613..e6bbc00 100644
--- a/src/gallium/drivers/svga/svga_resource_buffer_upload.c
+++ b/src/gallium/drivers/svga/svga_resource_buffer_upload.c
@@ -502,7 +502,7 @@ svga_buffer_upload_piecewise(struct svga_screen *ss,
                                PIPE_TRANSFER_DISCARD_RANGE);
          assert(map);
          if (map) {
-            memcpy(map, sbuf->swbuf, size);
+            memcpy(map, (const char *) sbuf->swbuf + offset, size);
             sws->buffer_unmap(sws, hwbuf);
          }
 
diff --git a/src/gallium/drivers/svga/svga_screen.c b/src/gallium/drivers/svga/svga_screen.c
index a1108c6..93d1612 100644
--- a/src/gallium/drivers/svga/svga_screen.c
+++ b/src/gallium/drivers/svga/svga_screen.c
@@ -334,7 +334,7 @@ static int svga_get_shader_param(struct pipe_screen *screen, unsigned shader, en
       case PIPE_SHADER_CAP_MAX_TEXTURE_SAMPLERS:
          return 16;
       default:
-         debug_printf("Unexpected vertex shader query %u\n", param);
+         debug_printf("Unexpected fragment shader query %u\n", param);
          return 0;
       }
       break;
@@ -389,7 +389,8 @@ static int svga_get_shader_param(struct pipe_screen *screen, unsigned shader, en
       }
       break;
    case PIPE_SHADER_GEOMETRY:
-      /* no support for geometry shaders at this time */
+   case PIPE_SHADER_COMPUTE:
+      /* no support for geometry or compute shaders at this time */
       return 0;
    default:
       debug_printf("Unexpected shader type (%u) query\n", shader);
diff --git a/src/gallium/drivers/trace/tr_context.c b/src/gallium/drivers/trace/tr_context.c
index fdd5a7a..1b34986 100644
--- a/src/gallium/drivers/trace/tr_context.c
+++ b/src/gallium/drivers/trace/tr_context.c
@@ -302,73 +302,21 @@ trace_context_bind_sampler_states(struct pipe_context *_pipe,
    /* remove this when we have pipe->bind_sampler_states(..., start, ...) */
    assert(start == 0);
 
-   switch (shader) {
-   case PIPE_SHADER_VERTEX:
-      trace_dump_call_begin("pipe_context", "bind_vertex_sampler_states");
-      break;
-   case PIPE_SHADER_GEOMETRY:
-      trace_dump_call_begin("pipe_context", "bind_geometry_sampler_states");
-      break;
-   case PIPE_SHADER_FRAGMENT:
-      trace_dump_call_begin("pipe_context", "bind_fragment_sampler_states");
-      break;
-   default:
-      debug_error("Unexpected shader in trace_context_bind_sampler_states()");
-   }
+   trace_dump_call_begin("pipe_context", "bind_sampler_states");
 
    trace_dump_arg(ptr, pipe);
+   trace_dump_arg(uint, shader);
+   trace_dump_arg(uint, start);
    trace_dump_arg(uint, num_states);
    trace_dump_arg_array(ptr, states, num_states);
 
-   switch (shader) {
-   case PIPE_SHADER_VERTEX:
-      pipe->bind_vertex_sampler_states(pipe, num_states, states);
-      break;
-   case PIPE_SHADER_GEOMETRY:
-      pipe->bind_geometry_sampler_states(pipe, num_states, states);
-      break;
-   case PIPE_SHADER_FRAGMENT:
-      pipe->bind_fragment_sampler_states(pipe, num_states, states);
-      break;
-   default:
-      debug_error("Unexpected shader in trace_context_bind_sampler_states()");
-   }
+   pipe->bind_sampler_states(pipe, shader, start, num_states, states);
 
    trace_dump_call_end();
 }
 
 
 static INLINE void
-trace_context_bind_fragment_sampler_states(struct pipe_context *_pipe,
-                                           unsigned num,
-                                           void **states)
-{
-   trace_context_bind_sampler_states(_pipe, PIPE_SHADER_FRAGMENT,
-                                     0, num, states);
-}
-
-
-static INLINE void
-trace_context_bind_vertex_sampler_states(struct pipe_context *_pipe,
-                                         unsigned num,
-                                         void **states)
-{
-   trace_context_bind_sampler_states(_pipe, PIPE_SHADER_VERTEX,
-                                     0, num, states);
-}
-
-
-static INLINE void
-trace_context_bind_geometry_sampler_states(struct pipe_context *_pipe,
-                                         unsigned num,
-                                         void **states)
-{
-   trace_context_bind_sampler_states(_pipe, PIPE_SHADER_GEOMETRY,
-                                     0, num, states);
-}
-
-
-static INLINE void
 trace_context_delete_sampler_state(struct pipe_context *_pipe,
                                    void *state)
 {
@@ -1579,9 +1527,7 @@ trace_context_create(struct trace_screen *tr_scr,
    TR_CTX_INIT(bind_blend_state);
    TR_CTX_INIT(delete_blend_state);
    TR_CTX_INIT(create_sampler_state);
-   TR_CTX_INIT(bind_fragment_sampler_states);
-   TR_CTX_INIT(bind_vertex_sampler_states);
-   TR_CTX_INIT(bind_geometry_sampler_states);
+   TR_CTX_INIT(bind_sampler_states);
    TR_CTX_INIT(delete_sampler_state);
    TR_CTX_INIT(create_rasterizer_state);
    TR_CTX_INIT(bind_rasterizer_state);
diff --git a/src/gallium/include/pipe/p_context.h b/src/gallium/include/pipe/p_context.h
index 7d09ce4..9d6b9b5 100644
--- a/src/gallium/include/pipe/p_context.h
+++ b/src/gallium/include/pipe/p_context.h
@@ -139,19 +139,9 @@ struct pipe_context {
 
    void * (*create_sampler_state)(struct pipe_context *,
                                   const struct pipe_sampler_state *);
-   void   (*bind_fragment_sampler_states)(struct pipe_context *,
-                                          unsigned num_samplers,
-                                          void **samplers);
-   void   (*bind_vertex_sampler_states)(struct pipe_context *,
-                                        unsigned num_samplers,
-                                        void **samplers);
-   void   (*bind_geometry_sampler_states)(struct pipe_context *,
-                                          unsigned num_samplers,
-                                          void **samplers);
-   void   (*bind_compute_sampler_states)(struct pipe_context *,
-                                         unsigned start_slot,
-                                         unsigned num_samplers,
-                                         void **samplers);
+   void   (*bind_sampler_states)(struct pipe_context *,
+                                 unsigned shader, unsigned start_slot,
+                                 unsigned num_samplers, void **samplers);
    void   (*delete_sampler_state)(struct pipe_context *, void *);
 
    void * (*create_rasterizer_state)(struct pipe_context *,
diff --git a/src/gallium/include/pipe/p_shader_tokens.h b/src/gallium/include/pipe/p_shader_tokens.h
index 1beec05..8010902 100644
--- a/src/gallium/include/pipe/p_shader_tokens.h
+++ b/src/gallium/include/pipe/p_shader_tokens.h
@@ -450,7 +450,10 @@ struct tgsi_property_data {
 #define TGSI_OPCODE_TXB2                178
 #define TGSI_OPCODE_TXL2                179
 
-#define TGSI_OPCODE_LAST                180
+#define TGSI_OPCODE_IMUL_HI             180
+#define TGSI_OPCODE_UMUL_HI             181
+
+#define TGSI_OPCODE_LAST                182
 
 #define TGSI_SAT_NONE            0  /* do not saturate */
 #define TGSI_SAT_ZERO_ONE        1  /* clamp to [0,1] */
diff --git a/src/gallium/state_trackers/clover/core/kernel.cpp b/src/gallium/state_trackers/clover/core/kernel.cpp
index 93d5410..53714b4 100644
--- a/src/gallium/state_trackers/clover/core/kernel.cpp
+++ b/src/gallium/state_trackers/clover/core/kernel.cpp
@@ -71,8 +71,10 @@ _cl_kernel::launch(clover::command_queue &q,
                         exec.g_handles.begin(), exec.g_handles.end());
 
    q.pipe->bind_compute_state(q.pipe, st);
-   q.pipe->bind_compute_sampler_states(q.pipe, 0, exec.samplers.size(),
-                                       exec.samplers.data());
+   q.pipe->bind_sampler_states(q.pipe, PIPE_SHADER_COMPUTE,
+                               0, exec.samplers.size(),
+                               exec.samplers.data());
+
    q.pipe->set_compute_sampler_views(q.pipe, 0, exec.sviews.size(),
                                      exec.sviews.data());
    q.pipe->set_compute_resources(q.pipe, 0, exec.resources.size(),
@@ -89,7 +91,8 @@ _cl_kernel::launch(clover::command_queue &q,
    q.pipe->set_global_binding(q.pipe, 0, exec.g_buffers.size(), NULL, NULL);
    q.pipe->set_compute_resources(q.pipe, 0, exec.resources.size(), NULL);
    q.pipe->set_compute_sampler_views(q.pipe, 0, exec.sviews.size(), NULL);
-   q.pipe->bind_compute_sampler_states(q.pipe, 0, exec.samplers.size(), NULL);
+   q.pipe->bind_sampler_states(q.pipe, PIPE_SHADER_COMPUTE, 0,
+                               exec.samplers.size(), NULL);
    exec.unbind();
 }
 
diff --git a/src/gallium/state_trackers/clover/llvm/invocation.cpp b/src/gallium/state_trackers/clover/llvm/invocation.cpp
index e6cd415..f14222b 100644
--- a/src/gallium/state_trackers/clover/llvm/invocation.cpp
+++ b/src/gallium/state_trackers/clover/llvm/invocation.cpp
@@ -121,6 +121,8 @@ namespace {
       clang::EmitLLVMOnlyAction act(&llvm::getGlobalContext());
       std::string log;
       llvm::raw_string_ostream s_log(log);
+      std::string libclc_path = LIBCLC_LIBEXECDIR + processor + "-"
+                                                  + triple + ".bc";
 
       // Parse the compiler options:
       std::vector<std::string> opts_array;
@@ -202,6 +204,15 @@ namespace {
       c.getPreprocessorOpts().addRemappedFile(name,
                                       llvm::MemoryBuffer::getMemBuffer(source));
 
+      // Setting this attribute tells clang to link this file before
+      // performing any optimizations.  This is required so that
+      // we can replace calls to the OpenCL C barrier() builtin
+      // with calls to target intrinsics that have the noduplicate
+      // attribute.  This attribute will prevent Clang from creating
+      // illegal uses of barrier() (e.g. Moving barrier() inside a conditional
+      // that is no executed by all threads) during its optimizaton passes.
+      c.getCodeGenOpts().LinkBitcodeFile = libclc_path;
+
       // Compile the code
       if (!c.ExecuteAction(act))
          throw build_error(log);
@@ -231,32 +242,10 @@ namespace {
    }
 
    void
-   link(llvm::Module *mod, const std::string &triple,
-        const std::string &processor,
+   internalize_functions(llvm::Module *mod,
         const std::vector<llvm::Function *> &kernels) {
 
       llvm::PassManager PM;
-      llvm::PassManagerBuilder Builder;
-      std::string libclc_path = LIBCLC_LIBEXECDIR + processor + "-"
-                                                  + triple + ".bc";
-      // Link the kernel with libclc
-#if HAVE_LLVM < 0x0303
-      bool isNative;
-      llvm::Linker linker("clover", mod);
-      linker.LinkInFile(llvm::sys::Path(libclc_path), isNative);
-      mod = linker.releaseModule();
-#else
-      std::string err_str;
-      llvm::SMDiagnostic err;
-      llvm::Module *libclc_mod = llvm::ParseIRFile(libclc_path, err,
-                                                   mod->getContext());
-      if (llvm::Linker::LinkModules(mod, libclc_mod,
-                                    llvm::Linker::DestroySource,
-                                    &err_str)) {
-         throw build_error(err_str);
-      }
-#endif
-
       // Add a function internalizer pass.
       //
       // By default, the function internalizer pass will look for a function
@@ -278,11 +267,12 @@ namespace {
          llvm::Function *kernel = *I;
          export_list.push_back(kernel->getName().data());
       }
+#if HAVE_LLVM < 0x0304
       PM.add(llvm::createInternalizePass(export_list));
-
-      // Run link time optimizations
-      Builder.OptLevel = 2;
-      Builder.populateLTOPassManager(PM, false, true);
+#else
+      std::vector<const char*> dso_list;
+      PM.add(llvm::createInternalizePass(export_list, dso_list));
+#endif
       PM.run(*mod);
    }
 
@@ -402,7 +392,7 @@ clover::compile_program_llvm(const compat::string &source,
 
    find_kernels(mod, kernels);
 
-   link(mod, triple, processor, kernels);
+   internalize_functions(mod, kernels);
 
    // Build the clover::module
    switch (ir) {
diff --git a/src/gallium/state_trackers/dri/common/dri_screen.c b/src/gallium/state_trackers/dri/common/dri_screen.c
index 779741e..92cac73 100644
--- a/src/gallium/state_trackers/dri/common/dri_screen.c
+++ b/src/gallium/state_trackers/dri/common/dri_screen.c
@@ -438,6 +438,19 @@ dri_init_screen_helper(struct dri_screen *screen,
 
    dri_postprocessing_init(screen);
 
+   /* gallium drivers don't declare what version of GL they support, so we
+    * check the computed Mesa context version after context creation and fail
+    * out then.
+    */
+   if (screen->st_api->profile_mask & ST_PROFILE_DEFAULT_MASK)
+      screen->sPriv->max_gl_compat_version = 30;
+   if (screen->st_api->profile_mask & ST_PROFILE_OPENGL_CORE_MASK)
+      screen->sPriv->max_gl_core_version = 32;
+   if (screen->st_api->profile_mask & ST_PROFILE_OPENGL_ES1_MASK)
+      screen->sPriv->max_gl_es1_version = 11;
+   if (screen->st_api->profile_mask & ST_PROFILE_OPENGL_ES2_MASK)
+      screen->sPriv->max_gl_es2_version = 30;
+
    return dri_fill_in_modes(screen);
 }
 
diff --git a/src/gallium/state_trackers/dri/drm/Makefile.am b/src/gallium/state_trackers/dri/drm/Makefile.am
index c90c463..f41f45d 100644
--- a/src/gallium/state_trackers/dri/drm/Makefile.am
+++ b/src/gallium/state_trackers/dri/drm/Makefile.am
@@ -31,7 +31,8 @@ AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/mesa/drivers/dri/common \
 	-I$(top_builddir)/src/mesa/drivers/dri/common \
 	$(GALLIUM_CFLAGS) \
-	$(LIBDRM_CFLAGS)
+	$(LIBDRM_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
 
 noinst_LTLIBRARIES = libdridrm.la
 
diff --git a/src/gallium/state_trackers/dri/drm/dri2.c b/src/gallium/state_trackers/dri/drm/dri2.c
index 919ba6d..5647968 100644
--- a/src/gallium/state_trackers/dri/drm/dri2.c
+++ b/src/gallium/state_trackers/dri/drm/dri2.c
@@ -897,14 +897,6 @@ dri2_init_screen(__DRIscreen * sPriv)
    if (!configs)
       goto fail;
 
-   sPriv->api_mask = 0;
-   if (screen->st_api->profile_mask & ST_PROFILE_DEFAULT_MASK)
-      sPriv->api_mask |= 1 << __DRI_API_OPENGL;
-   if (screen->st_api->profile_mask & ST_PROFILE_OPENGL_ES1_MASK)
-      sPriv->api_mask |= 1 << __DRI_API_GLES;
-   if (screen->st_api->profile_mask & ST_PROFILE_OPENGL_ES2_MASK)
-      sPriv->api_mask |= 1 << __DRI_API_GLES2;
-
    screen->auto_fake_front = dri_with_format(sPriv);
    screen->broken_invalidate = !sPriv->dri2.useInvalidate;
    screen->lookup_egl_image = dri2_lookup_egl_image;
diff --git a/src/gallium/state_trackers/dri/sw/Makefile.am b/src/gallium/state_trackers/dri/sw/Makefile.am
index f0377a8..555ea17 100644
--- a/src/gallium/state_trackers/dri/sw/Makefile.am
+++ b/src/gallium/state_trackers/dri/sw/Makefile.am
@@ -31,6 +31,7 @@ AM_CPPFLAGS = \
 	-I$(top_builddir)/src/mesa/drivers/dri/common \
 	$(GALLIUM_CFLAGS) \
 	$(LIBDRM_CFLAGS) \
+	$(VISIBILITY_CFLAGS) \
 	-D__NOT_HAVE_DRM_H
 
 noinst_LTLIBRARIES = libdrisw.la
diff --git a/src/gallium/state_trackers/egl/Makefile.am b/src/gallium/state_trackers/egl/Makefile.am
index 1d84d61..da360bb 100644
--- a/src/gallium/state_trackers/egl/Makefile.am
+++ b/src/gallium/state_trackers/egl/Makefile.am
@@ -37,7 +37,7 @@ libegl_la_SOURCES = $(common_SOURCES)
 if HAVE_EGL_PLATFORM_X11
 libegl_la_SOURCES += $(x11_SOURCES) $(x11_drm_SOURCES)
 AM_CFLAGS += \
-	$(X11_CFLAGS) \
+	$(X11_INCLUDES) \
 	$(LIBDRM_CFLAGS) \
 	$(DRI2PROTO_CFLAGS)
 AM_CPPFLAGS += \
diff --git a/src/gallium/state_trackers/egl/common/native_wayland_drm_bufmgr.c b/src/gallium/state_trackers/egl/common/native_wayland_drm_bufmgr.c
index 9b69cb9..f9acb2a 100644
--- a/src/gallium/state_trackers/egl/common/native_wayland_drm_bufmgr.c
+++ b/src/gallium/state_trackers/egl/common/native_wayland_drm_bufmgr.c
@@ -139,7 +139,11 @@ static struct pipe_resource *
 wayland_drm_bufmgr_wl_buffer_get_resource(struct native_display *ndpy,
                                           struct wl_resource *buffer_resource)
 {
-   struct wl_drm_buffer *buffer = wayland_drm_buffer_get(buffer_resource);
+   struct wayland_drm_bufmgr *bufmgr;
+   struct wl_drm_buffer *buffer;
+
+   bufmgr = wayland_drm_bufmgr(ndpy->wayland_bufmgr);
+   buffer = wayland_drm_buffer_get(bufmgr->wl_server_drm, buffer_resource);
 
    if (!buffer)
       return NULL;
@@ -147,16 +151,19 @@ wayland_drm_bufmgr_wl_buffer_get_resource(struct native_display *ndpy,
    return wayland_drm_buffer_get_buffer(buffer);
 }
 
-static EGLBoolean
+static boolean
 wayland_drm_bufmgr_query_buffer(struct native_display *ndpy,
                                 struct wl_resource *buffer_resource,
-                                EGLint attribute, EGLint *value)
+                                int attribute, int *value)
 {
-   struct wl_drm_buffer *buffer = wayland_drm_buffer_get(buffer_resource);
+   struct wayland_drm_bufmgr *bufmgr;
+   struct wl_drm_buffer *buffer;
    struct pipe_resource *resource;
 
+   bufmgr = wayland_drm_bufmgr(ndpy->wayland_bufmgr);
+   buffer = wayland_drm_buffer_get(bufmgr->wl_server_drm, buffer_resource);
    if (!buffer)
-      return EGL_FALSE;
+      return FALSE;
 
    resource = buffer->driver_buffer;
 
@@ -165,21 +172,21 @@ wayland_drm_bufmgr_query_buffer(struct native_display *ndpy,
       switch (resource->format) {
       case PIPE_FORMAT_B8G8R8A8_UNORM:
          *value = EGL_TEXTURE_RGBA;
-         return EGL_TRUE;
+         return TRUE;
       case PIPE_FORMAT_B8G8R8X8_UNORM:
          *value = EGL_TEXTURE_RGB;
-         return EGL_TRUE;
+         return TRUE;
       default:
-         return EGL_FALSE;
+         return FALSE;
       }
    case EGL_WIDTH:
       *value = buffer->width;
-      return EGL_TRUE;
+      return TRUE;
    case EGL_HEIGHT:
       *value = buffer->height;
-      return EGL_TRUE;
+      return TRUE;
    default:
-      return EGL_FALSE;
+      return FALSE;
    }
 }
 
diff --git a/src/gallium/state_trackers/glx/xlib/Makefile.am b/src/gallium/state_trackers/glx/xlib/Makefile.am
index 7a63594..0b2520a 100644
--- a/src/gallium/state_trackers/glx/xlib/Makefile.am
+++ b/src/gallium/state_trackers/glx/xlib/Makefile.am
@@ -25,7 +25,7 @@ include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CFLAGS = \
 	$(GALLIUM_CFLAGS) \
-	$(X11_CFLAGS)
+	$(X11_INCLUDES)
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/include \
 	-I$(top_srcdir)/src/mapi \
diff --git a/src/gallium/state_trackers/vdpau/mixer.c b/src/gallium/state_trackers/vdpau/mixer.c
index 8476329..f9b413e 100644
--- a/src/gallium/state_trackers/vdpau/mixer.c
+++ b/src/gallium/state_trackers/vdpau/mixer.c
@@ -768,22 +768,25 @@ vlVdpGenerateCSCMatrix(VdpProcamp *procamp,
    enum VL_CSC_COLOR_STANDARD vl_std;
    struct vl_procamp camp;
 
-   if (!(csc_matrix && procamp))
+   if (!csc_matrix)
       return VDP_STATUS_INVALID_POINTER;
 
-   if (procamp->struct_version > VDP_PROCAMP_VERSION)
-      return VDP_STATUS_INVALID_STRUCT_VERSION;
-
    switch (standard) {
       case VDP_COLOR_STANDARD_ITUR_BT_601: vl_std = VL_CSC_COLOR_STANDARD_BT_601; break;
       case VDP_COLOR_STANDARD_ITUR_BT_709: vl_std = VL_CSC_COLOR_STANDARD_BT_709; break;
       case VDP_COLOR_STANDARD_SMPTE_240M:  vl_std = VL_CSC_COLOR_STANDARD_SMPTE_240M; break;
       default: return VDP_STATUS_INVALID_COLOR_STANDARD;
    }
-   camp.brightness = procamp->brightness;
-   camp.contrast = procamp->contrast;
-   camp.saturation = procamp->saturation;
-   camp.hue = procamp->hue;
-   vl_csc_get_matrix(vl_std, &camp, true, csc_matrix);
+
+   if (procamp) {
+      if (procamp->struct_version > VDP_PROCAMP_VERSION)
+         return VDP_STATUS_INVALID_STRUCT_VERSION;
+      camp.brightness = procamp->brightness;
+      camp.contrast = procamp->contrast;
+      camp.saturation = procamp->saturation;
+      camp.hue = procamp->hue;
+   }
+
+   vl_csc_get_matrix(vl_std, procamp ? &camp : NULL, true, csc_matrix);
    return VDP_STATUS_OK;
 }
diff --git a/src/gallium/state_trackers/vdpau/output.c b/src/gallium/state_trackers/vdpau/output.c
index dd72f6f..cf77b53 100644
--- a/src/gallium/state_trackers/vdpau/output.c
+++ b/src/gallium/state_trackers/vdpau/output.c
@@ -442,7 +442,7 @@ vlVdpOutputSurfacePutBitsYCbCr(VdpOutputSurface surface,
    vlVdpResolveDelayedRendering(vlsurface->device, NULL, NULL);
    memset(&vtmpl, 0, sizeof(vtmpl));
    vtmpl.buffer_format = format;
-   vtmpl.chroma_format = PIPE_VIDEO_CHROMA_FORMAT_420;
+   vtmpl.chroma_format = FormatYCBCRToPipeChroma(source_ycbcr_format);
 
    if (destination_rect) {
       vtmpl.width = abs(destination_rect->x0-destination_rect->x1);
diff --git a/src/gallium/state_trackers/vdpau/presentation.c b/src/gallium/state_trackers/vdpau/presentation.c
index c9f8ea7..81e0328 100644
--- a/src/gallium/state_trackers/vdpau/presentation.c
+++ b/src/gallium/state_trackers/vdpau/presentation.c
@@ -325,7 +325,8 @@ vlVdpPresentationQueueBlockUntilSurfaceIdle(VdpPresentationQueue presentation_qu
    pipe_mutex_lock(pq->device->mutex);
    if (surf->fence) {
       screen = pq->device->vscreen->pscreen;
-      screen->fence_finish(screen, surf->fence, 0);
+      screen->fence_finish(screen, surf->fence, PIPE_TIMEOUT_INFINITE);
+      screen->fence_reference(screen, &surf->fence, NULL);
    }
    pipe_mutex_unlock(pq->device->mutex);
 
diff --git a/src/gallium/state_trackers/vdpau/surface.c b/src/gallium/state_trackers/vdpau/surface.c
index e371bca..074363b 100644
--- a/src/gallium/state_trackers/vdpau/surface.c
+++ b/src/gallium/state_trackers/vdpau/surface.c
@@ -38,6 +38,13 @@
 
 #include "vdpau_private.h"
 
+enum getbits_conversion {
+   CONVERSION_NONE,
+   CONVERSION_NV12_TO_YV12,
+   CONVERSION_YV12_TO_NV12,
+   CONVERSION_SWAP_YUYV_UYVY,
+};
+
 /**
  * Create a VdpVideoSurface.
  */
@@ -185,6 +192,80 @@ vlVdpVideoSurfaceSize(vlVdpSurface *p_surf, int component,
       *height /= 2;
 }
 
+static void
+vlVdpCopyNV12ToYV12(void *const *destination_data,
+                    uint32_t const *destination_pitches,
+                    int src_plane, int src_field,
+                    int src_stride, int num_fields,
+                    uint8_t const *src,
+                    int width, int height)
+{
+   int x, y;
+   unsigned u_stride = destination_pitches[2] * num_fields;
+   unsigned v_stride = destination_pitches[1] * num_fields;
+   uint8_t *u_dst = (uint8_t *)destination_data[2] + destination_pitches[2] * src_field;
+   uint8_t *v_dst = (uint8_t *)destination_data[1] + destination_pitches[1] * src_field;
+
+   /* TODO: SIMD */
+   for (y = 0; y < height; y++) {
+      for (x = 0; x < width; x++) {
+         u_dst[x] = src[2*x];
+         v_dst[x] = src[2*x+1];
+      }
+      u_dst += u_stride;
+      v_dst += v_stride;
+      src += src_stride;
+   }
+}
+
+static void
+vlVdpCopyYV12ToNV12(void *const *destination_data,
+                    uint32_t const *destination_pitches,
+                    int src_plane, int src_field,
+                    int src_stride, int num_fields,
+                    uint8_t const *src,
+                    int width, int height)
+{
+   int x, y;
+   unsigned offset = 2 - src_plane;
+   unsigned stride = destination_pitches[1] * num_fields;
+   uint8_t *dst = (uint8_t *)destination_data[1] + destination_pitches[1] * src_field;
+
+   /* TODO: SIMD */
+   for (y = 0; y < height; y++) {
+      for (x = 0; x < 2 * width; x += 2) {
+         dst[x+offset] = src[x>>1];
+      }
+      dst += stride;
+      src += src_stride;
+   }
+}
+
+static void
+vlVdpCopySwap422Packed(void *const *destination_data,
+                       uint32_t const *destination_pitches,
+                       int src_plane, int src_field,
+                       int src_stride, int num_fields,
+                       uint8_t const *src,
+                       int width, int height)
+{
+   int x, y;
+   unsigned stride = destination_pitches[0] * num_fields;
+   uint8_t *dst = (uint8_t *)destination_data[0] + destination_pitches[0] * src_field;
+
+   /* TODO: SIMD */
+   for (y = 0; y < height; y++) {
+      for (x = 0; x < 4 * width; x += 4) {
+         dst[x+0] = src[x+1];
+         dst[x+1] = src[x+0];
+         dst[x+2] = src[x+3];
+         dst[x+3] = src[x+2];
+      }
+      dst += stride;
+      src += src_stride;
+   }
+}
+
 /**
  * Copy image data from a VdpVideoSurface to application memory in a specified
  * YCbCr format.
@@ -197,8 +278,9 @@ vlVdpVideoSurfaceGetBitsYCbCr(VdpVideoSurface surface,
 {
    vlVdpSurface *vlsurface;
    struct pipe_context *pipe;
-   enum pipe_format format;
+   enum pipe_format format, buffer_format;
    struct pipe_sampler_view **sampler_views;
+   enum getbits_conversion conversion = CONVERSION_NONE;
    unsigned i, j;
 
    vlsurface = vlGetDataHTAB(surface);
@@ -211,10 +293,23 @@ vlVdpVideoSurfaceGetBitsYCbCr(VdpVideoSurface surface,
 
    format = FormatYCBCRToPipe(destination_ycbcr_format);
    if (format == PIPE_FORMAT_NONE)
-       return VDP_STATUS_INVALID_Y_CB_CR_FORMAT;
-
-   if (vlsurface->video_buffer == NULL || format != vlsurface->video_buffer->buffer_format)
-      return VDP_STATUS_NO_IMPLEMENTATION; /* TODO We don't support conversion (yet) */
+      return VDP_STATUS_INVALID_Y_CB_CR_FORMAT;
+
+   if (vlsurface->video_buffer == NULL)
+      return VDP_STATUS_INVALID_VALUE;
+
+   buffer_format = vlsurface->video_buffer->buffer_format;
+   if (format != buffer_format) {
+      if (format == PIPE_FORMAT_YV12 && buffer_format == PIPE_FORMAT_NV12)
+         conversion = CONVERSION_NV12_TO_YV12;
+      else if (format == PIPE_FORMAT_NV12 && buffer_format == PIPE_FORMAT_YV12)
+         conversion = CONVERSION_YV12_TO_NV12;
+      else if ((format == PIPE_FORMAT_YUYV && buffer_format == PIPE_FORMAT_UYVY) ||
+               (format == PIPE_FORMAT_UYVY && buffer_format == PIPE_FORMAT_YUYV))
+         conversion = CONVERSION_SWAP_YUYV_UYVY;
+      else
+         return VDP_STATUS_NO_IMPLEMENTATION;
+   }
 
    pipe_mutex_lock(vlsurface->device->mutex);
    sampler_views = vlsurface->video_buffer->get_sampler_view_planes(vlsurface->video_buffer);
@@ -245,9 +340,23 @@ vlVdpVideoSurfaceGetBitsYCbCr(VdpVideoSurface surface,
             return VDP_STATUS_RESOURCES;
          }
 
-         util_copy_rect(destination_data[i] + destination_pitches[i] * j, sv->texture->format,
-                        destination_pitches[i] * sv->texture->array_size, 0, 0,
-                        box.width, box.height, map, transfer->stride, 0, 0);
+         if (conversion == CONVERSION_NV12_TO_YV12 && i == 1) {
+            vlVdpCopyNV12ToYV12(destination_data, destination_pitches,
+                                i, j, transfer->stride, sv->texture->array_size,
+                                map, box.width, box.height);
+         } else if (conversion == CONVERSION_YV12_TO_NV12 && i > 0) {
+            vlVdpCopyYV12ToNV12(destination_data, destination_pitches,
+                                i, j, transfer->stride, sv->texture->array_size,
+                                map, box.width, box.height);
+         } else if (conversion == CONVERSION_SWAP_YUYV_UYVY) {
+            vlVdpCopySwap422Packed(destination_data, destination_pitches,
+                                   i, j, transfer->stride, sv->texture->array_size,
+                                   map, box.width, box.height);
+         } else {
+            util_copy_rect(destination_data[i] + destination_pitches[i] * j, sv->texture->format,
+                           destination_pitches[i] * sv->texture->array_size, 0, 0,
+                           box.width, box.height, map, transfer->stride, 0, 0);
+         }
 
          pipe_transfer_unmap(pipe, transfer);
       }
diff --git a/src/gallium/state_trackers/vdpau/vdpau_private.h b/src/gallium/state_trackers/vdpau/vdpau_private.h
index 0812767..bb91de1 100644
--- a/src/gallium/state_trackers/vdpau/vdpau_private.h
+++ b/src/gallium/state_trackers/vdpau/vdpau_private.h
@@ -89,6 +89,29 @@ PipeToChroma(enum pipe_video_chroma_format pipe_type)
    return -1;
 }
 
+static inline enum pipe_video_chroma_format
+FormatYCBCRToPipeChroma(VdpYCbCrFormat vdpau_format)
+{
+   switch (vdpau_format) {
+      case VDP_YCBCR_FORMAT_NV12:
+         return PIPE_VIDEO_CHROMA_FORMAT_420;
+      case VDP_YCBCR_FORMAT_YV12:
+         return PIPE_VIDEO_CHROMA_FORMAT_420;
+      case VDP_YCBCR_FORMAT_UYVY:
+         return PIPE_VIDEO_CHROMA_FORMAT_422;
+      case VDP_YCBCR_FORMAT_YUYV:
+         return PIPE_VIDEO_CHROMA_FORMAT_422;
+      case VDP_YCBCR_FORMAT_Y8U8V8A8:
+         return PIPE_VIDEO_CHROMA_FORMAT_444;
+      case VDP_YCBCR_FORMAT_V8U8Y8A8:
+         return PIPE_VIDEO_CHROMA_FORMAT_444;
+      default:
+         assert(0);
+   }
+
+   return PIPE_FORMAT_NONE;
+}
+
 static inline enum pipe_format
 FormatYCBCRToPipe(VdpYCbCrFormat vdpau_format)
 {
diff --git a/src/gallium/targets/SConscript.dri b/src/gallium/targets/SConscript.dri
index 04c8ec7..8b15532 100644
--- a/src/gallium/targets/SConscript.dri
+++ b/src/gallium/targets/SConscript.dri
@@ -3,9 +3,6 @@
 
 Import('*')
 
-if not env['dri']:
-    Return()
-
 drienv = env.Clone()
 
 drienv.Replace(CPPPATH = [
@@ -30,6 +27,11 @@ drienv.Replace(CPPPATH = [
     '#src/egl/drivers/dri',
 ])
 
+driswenv = drienv.Clone()
+driswenv.Append(CPPDEFINES = [
+    '__NOT_HAVE_DRM_H',
+])
+
 drienv.PkgUseModules('DRM')
 
 dri_common_utils = drienv.SharedObject(
@@ -47,9 +49,9 @@ dri_common_dri_util = drienv.SharedObject(
     source = '#src/mesa/drivers/dri/common/dri_util.c'
 )
 
-dri_common_drisw_util = drienv.SharedObject(
+dri_common_drisw_util = driswenv.SharedObject(
     target = 'drisw_util.o',
-    source = '#src/mesa/drivers/dri/common/drisw_util.c'
+    source = '#src/mesa/drivers/dri/common/dri_util.c'
 )
 
 
@@ -69,8 +71,13 @@ drienv.AppendUnique(LIBS = [
     'expat',
 ])
 
+driswenv.AppendUnique(LIBS = [
+    'expat',
+])
+
 Export([
     'drienv',
+    'driswenv',
     'COMMON_DRI_SW_OBJECTS',
     'COMMON_DRI_DRM_OBJECTS',
 ])
diff --git a/src/gallium/targets/dri-freedreno/Makefile.am b/src/gallium/targets/dri-freedreno/Makefile.am
index ac7460a..228fafc 100644
--- a/src/gallium/targets/dri-freedreno/Makefile.am
+++ b/src/gallium/targets/dri-freedreno/Makefile.am
@@ -39,7 +39,7 @@ AM_CPPFLAGS = \
 dridir = $(DRI_DRIVER_INSTALL_DIR)
 dri_LTLIBRARIES = kgsl_dri.la msm_dri.la
 
-COMMON_LDFLAGS = -module -avoid-version -shared -no-undefined
+COMMON_LDFLAGS = $(DRI_DRIVER_LDFLAGS)
 
 COMMON_LIBADD = \
 	$(top_builddir)/src/mesa/drivers/dri/common/libdricommon.la \
diff --git a/src/gallium/targets/dri-i915/Makefile.am b/src/gallium/targets/dri-i915/Makefile.am
index e1c6eca..851c412 100644
--- a/src/gallium/targets/dri-i915/Makefile.am
+++ b/src/gallium/targets/dri-i915/Makefile.am
@@ -42,7 +42,7 @@ dri_LTLIBRARIES = i915_dri.la
 
 i915_dri_la_SOURCES = target.c
 
-i915_dri_la_LDFLAGS = -module -avoid-version -shared -no-undefined
+i915_dri_la_LDFLAGS = $(DRI_DRIVER_LDFLAGS)
 
 i915_dri_la_LIBADD = \
 	$(top_builddir)/src/mesa/drivers/dri/common/libdricommon.la \
diff --git a/src/gallium/targets/dri-ilo/Makefile.am b/src/gallium/targets/dri-ilo/Makefile.am
index 88233f6..776c970 100644
--- a/src/gallium/targets/dri-ilo/Makefile.am
+++ b/src/gallium/targets/dri-ilo/Makefile.am
@@ -42,7 +42,7 @@ noinst_LTLIBRARIES = ilo_dri.la
 ilo_dri_la_SOURCES = target.c
 
 # need -rpath to create a noinst shared library
-ilo_dri_la_LDFLAGS = -module -avoid-version -shared -no-undefined \
+ilo_dri_la_LDFLAGS = $(DRI_DRIVER_LDFLAGS) \
 		     -rpath $(abs_builddir)
 
 ilo_dri_la_LIBADD = \
diff --git a/src/gallium/targets/dri-nouveau/Makefile.am b/src/gallium/targets/dri-nouveau/Makefile.am
index a02394e..17b2c4a 100644
--- a/src/gallium/targets/dri-nouveau/Makefile.am
+++ b/src/gallium/targets/dri-nouveau/Makefile.am
@@ -41,7 +41,7 @@ dri_LTLIBRARIES = nouveau_dri.la
 nodist_EXTRA_nouveau_dri_la_SOURCES = dummy.cpp
 nouveau_dri_la_SOURCES = target.c
 
-nouveau_dri_la_LDFLAGS = -module -avoid-version -shared -no-undefined
+nouveau_dri_la_LDFLAGS = $(DRI_DRIVER_LDFLAGS)
 
 nouveau_dri_la_LIBADD = \
 	$(top_builddir)/src/mesa/drivers/dri/common/libdricommon.la \
diff --git a/src/gallium/targets/dri-swrast/Makefile.am b/src/gallium/targets/dri-swrast/Makefile.am
index 1104379..6b629df 100644
--- a/src/gallium/targets/dri-swrast/Makefile.am
+++ b/src/gallium/targets/dri-swrast/Makefile.am
@@ -25,13 +25,15 @@ include $(top_srcdir)/src/gallium/Automake.inc
 AM_CFLAGS = \
 	$(GALLIUM_CFLAGS) \
 	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS)
+	$(LIBDRM_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/gallium/winsys/sw/dri \
 	-I$(top_srcdir)/src/gallium/drivers \
 	-I$(top_srcdir)/src/gallium/winsys \
 	-I$(top_srcdir)/src/mesa \
 	-I$(top_srcdir)/src/mapi \
+	-I$(top_builddir)/src/mesa/drivers/dri/common \
 	-DGALLIUM_RBUG \
 	-DGALLIUM_TRACE \
 	-DGALLIUM_SOFTPIPE \
@@ -43,10 +45,10 @@ dri_LTLIBRARIES = swrast_dri.la
 swrast_dri_la_SOURCES = \
 	swrast_drm_api.c \
 	$(top_srcdir)/src/mesa/drivers/dri/common/utils.c \
-	$(top_srcdir)/src/mesa/drivers/dri/common/drisw_util.c \
+	$(top_srcdir)/src/mesa/drivers/dri/common/dri_util.c \
 	$(top_srcdir)/src/mesa/drivers/dri/common/xmlconfig.c
 
-swrast_dri_la_LDFLAGS = -module -avoid-version -shared -no-undefined
+swrast_dri_la_LDFLAGS = $(DRI_DRIVER_LDFLAGS)
 
 swrast_dri_la_LIBADD = \
 	$(top_builddir)/src/mesa/libmesagallium.la \
diff --git a/src/gallium/targets/dri-swrast/SConscript b/src/gallium/targets/dri-swrast/SConscript
index 6b64c56..8ddd14e 100644
--- a/src/gallium/targets/dri-swrast/SConscript
+++ b/src/gallium/targets/dri-swrast/SConscript
@@ -1,6 +1,6 @@
 Import('*')
 
-env = drienv.Clone()
+env = driswenv.Clone()
 
 env.Append(CPPPATH = [
     '#/src/gallium/winsys/sw/dri',
diff --git a/src/gallium/targets/dri-vmwgfx/Makefile.am b/src/gallium/targets/dri-vmwgfx/Makefile.am
index f7008ab..5ff521e 100644
--- a/src/gallium/targets/dri-vmwgfx/Makefile.am
+++ b/src/gallium/targets/dri-vmwgfx/Makefile.am
@@ -42,7 +42,7 @@ vmwgfx_dri_la_SOURCES = \
 	target.c \
 	vmw_powf.c
 
-vmwgfx_dri_la_LDFLAGS = -module -avoid-version -shared -no-undefined
+vmwgfx_dri_la_LDFLAGS = $(DRI_DRIVER_LDFLAGS)
 
 vmwgfx_dri_la_LIBADD = \
 	$(top_builddir)/src/mesa/drivers/dri/common/libdricommon.la \
diff --git a/src/gallium/targets/haiku-softpipe/GalliumContext.cpp b/src/gallium/targets/haiku-softpipe/GalliumContext.cpp
new file mode 100644
index 0000000..ba76dda
--- /dev/null
+++ b/src/gallium/targets/haiku-softpipe/GalliumContext.cpp
@@ -0,0 +1,523 @@
+/*
+ * Copyright 2012, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Artur Wyszynski, harakash@gmail.com
+ *		Alexander von Gluck IV, kallisti5@unixzen.com
+ */
+
+
+#include "GalliumContext.h"
+
+#include "GLView.h"
+
+#include "bitmap_wrapper.h"
+extern "C" {
+#include "glapi/glapi.h"
+#include "main/context.h"
+#include "main/framebuffer.h"
+#include "main/renderbuffer.h"
+#include "pipe/p_format.h"
+#include "state_tracker/st_cb_fbo.h"
+#include "state_tracker/st_cb_flush.h"
+#include "state_tracker/st_context.h"
+#include "state_tracker/st_gl_api.h"
+#include "state_tracker/st_manager.h"
+#include "state_tracker/sw_winsys.h"
+#include "hgl_sw_winsys.h"
+
+#include "target-helpers/inline_sw_helper.h"
+#include "target-helpers/inline_debug_helper.h"
+}
+
+
+#ifdef DEBUG
+#	define TRACE(x...) printf("GalliumContext: " x)
+#	define CALLED() TRACE("CALLED: %s\n", __PRETTY_FUNCTION__)
+#else
+#	define TRACE(x...)
+#	define CALLED()
+#endif
+#define ERROR(x...) printf("GalliumContext: " x)
+
+
+static void
+hgl_viewport(struct gl_context* glContext, GLint x, GLint y,
+	GLsizei width, GLsizei height)
+{
+	TRACE("%s(glContext: %p, x: %d, y: %d, w: %d, h: %d\n", __func__,
+		glContext, x, y, width, height);
+
+	struct gl_framebuffer *draw = glContext->WinSysDrawBuffer;
+	struct gl_framebuffer *read = glContext->WinSysReadBuffer;
+
+	// TODO: SLOW! We need to check for changes in bitmap vs gl_framebuffer
+	// size before doing a _mesa_resize_framebuffer.
+	if (draw)
+		_mesa_resize_framebuffer(glContext, draw, width, height);
+	if (read)
+		_mesa_resize_framebuffer(glContext, read, width, height);
+}
+
+
+static st_visual*
+hgl_fill_st_visual(gl_config* glVisual)
+{
+	struct st_visual* stVisual = CALLOC_STRUCT(st_visual);
+	if (!stVisual) {
+		ERROR("%s: Couldn't allocate st_visual\n", __func__);
+		return NULL;
+	}
+
+	// Determine color format
+	if (glVisual->redBits == 8) {
+		if (glVisual->alphaBits == 8)
+			stVisual->color_format = PIPE_FORMAT_B8G8R8A8_UNORM;
+		else
+			stVisual->color_format = PIPE_FORMAT_B8G8R8X8_UNORM;
+	} else {
+		stVisual->color_format = PIPE_FORMAT_B5G6R5_UNORM;
+	}
+
+	// Determine depth stencil format
+	switch (glVisual->depthBits) {
+		default:
+		case 0:
+			stVisual->depth_stencil_format = PIPE_FORMAT_NONE;
+			break;
+		case 16:
+			stVisual->depth_stencil_format = PIPE_FORMAT_Z16_UNORM;
+			break;
+		case 24:
+			if (glVisual->stencilBits == 0) {
+				stVisual->depth_stencil_format = PIPE_FORMAT_Z24X8_UNORM;
+				// or PIPE_FORMAT_X8Z24_UNORM?
+			} else {
+				stVisual->depth_stencil_format = PIPE_FORMAT_Z24_UNORM_S8_UINT;
+				// or PIPE_FORMAT_S8_UINT_Z24_UNORM?
+			}
+			break;
+		case 32:
+			stVisual->depth_stencil_format = PIPE_FORMAT_Z32_UNORM;
+			break;
+	}
+
+	stVisual->accum_format = (glVisual->haveAccumBuffer)
+		? PIPE_FORMAT_R16G16B16A16_SNORM : PIPE_FORMAT_NONE;
+
+	stVisual->buffer_mask |= ST_ATTACHMENT_FRONT_LEFT_MASK;
+	stVisual->render_buffer = ST_ATTACHMENT_FRONT_LEFT;
+	if (glVisual->doubleBufferMode) {
+		stVisual->buffer_mask |= ST_ATTACHMENT_BACK_LEFT_MASK;
+		stVisual->render_buffer = ST_ATTACHMENT_BACK_LEFT;
+	}
+
+	if (glVisual->stereoMode) {
+		stVisual->buffer_mask |= ST_ATTACHMENT_FRONT_RIGHT_MASK;
+		if (glVisual->doubleBufferMode)
+			stVisual->buffer_mask |= ST_ATTACHMENT_BACK_RIGHT_MASK;
+	}
+
+	if (glVisual->haveDepthBuffer || glVisual->haveStencilBuffer)
+		stVisual->buffer_mask |= ST_ATTACHMENT_DEPTH_STENCIL_MASK;
+
+	return stVisual;
+}
+
+
+static INLINE unsigned
+round_up(unsigned n, unsigned multiple)
+{
+	return (n + multiple - 1) & ~(multiple - 1);
+}
+
+
+static int
+hook_stm_get_param(struct st_manager *smapi, enum st_manager_param param)
+{
+	CALLED();
+
+	switch (param) {
+		case ST_MANAGER_BROKEN_INVALIDATE:
+			TRACE("%s: TODO: How should we handle BROKEN_INVALIDATE calls?\n",
+				__func__);
+			// For now we force validation of the framebuffer.
+			return 1;
+	}
+
+	return 0;
+}
+
+
+GalliumContext::GalliumContext(ulong options)
+	:
+	fOptions(options),
+	fCurrentContext(0),
+	fScreen(NULL)
+{
+	CALLED();
+
+	// Make all contexts a known value
+	for (context_id i = 0; i < CONTEXT_MAX; i++)
+		fContext[i] = NULL;
+
+	CreateScreen();
+
+	pipe_mutex_init(fMutex);
+}
+
+
+GalliumContext::~GalliumContext()
+{
+	CALLED();
+
+	// Destroy our contexts
+	pipe_mutex_lock(fMutex);
+	for (context_id i = 0; i < CONTEXT_MAX; i++)
+		DestroyContext(i);
+	pipe_mutex_unlock(fMutex);
+
+	pipe_mutex_destroy(fMutex);
+
+	// TODO: Destroy fScreen
+}
+
+
+status_t
+GalliumContext::CreateScreen()
+{
+	CALLED();
+
+	// Allocate winsys and attach callback hooks
+	struct sw_winsys* winsys = hgl_create_sw_winsys();
+
+	if (!winsys) {
+		ERROR("%s: Couldn't allocate sw_winsys!\n", __func__);
+		return B_ERROR;
+	}
+
+	fScreen = sw_screen_create(winsys);
+
+	if (fScreen == NULL) {
+		ERROR("%s: Couldn't create screen!\n", __FUNCTION__);
+		FREE(winsys);
+		return B_ERROR;
+	}
+
+	debug_screen_wrap(fScreen);
+
+	const char* driverName = fScreen->get_name(fScreen);
+	ERROR("%s: Using %s driver.\n", __func__, driverName);
+
+	return B_OK;
+}
+
+
+context_id
+GalliumContext::CreateContext(Bitmap *bitmap)
+{
+	CALLED();
+
+	struct hgl_context* context = CALLOC_STRUCT(hgl_context);
+
+	if (!context) {
+		ERROR("%s: Couldn't create pipe context!\n", __FUNCTION__);
+		return 0;
+	}
+
+	// Set up the initial things our context needs
+	context->bitmap = bitmap;
+	context->colorSpace = get_bitmap_color_space(bitmap);
+	context->draw = NULL;
+	context->read = NULL;
+	context->st = NULL;
+
+	context->api = st_gl_api_create();
+	if (!context->api) {
+		ERROR("%s: Couldn't obtain Mesa state tracker API!\n", __func__);
+		return -1;
+	}
+
+	context->manager = CALLOC_STRUCT(st_manager);
+	if (!context->manager) {
+		ERROR("%s: Couldn't allocate Mesa state tracker manager!\n", __func__);
+		return -1;
+	}
+	context->manager->get_param = hook_stm_get_param;
+
+	// Calculate visual configuration
+	const GLboolean rgbFlag		= ((fOptions & BGL_INDEX) == 0);
+	const GLboolean alphaFlag	= ((fOptions & BGL_ALPHA) == BGL_ALPHA);
+	const GLboolean dblFlag		= ((fOptions & BGL_DOUBLE) == BGL_DOUBLE);
+	const GLboolean stereoFlag	= false;
+	const GLint depth			= (fOptions & BGL_DEPTH) ? 24 : 0;
+	const GLint stencil			= (fOptions & BGL_STENCIL) ? 8 : 0;
+	const GLint accum			= 0;		// (options & BGL_ACCUM) ? 16 : 0;
+	const GLint red				= rgbFlag ? 8 : 0;
+	const GLint green			= rgbFlag ? 8 : 0;
+	const GLint blue			= rgbFlag ? 8 : 0;
+	const GLint alpha			= alphaFlag ? 8 : 0;
+
+	TRACE("rgb      :\t%d\n", (bool)rgbFlag);
+	TRACE("alpha    :\t%d\n", (bool)alphaFlag);
+	TRACE("dbl      :\t%d\n", (bool)dblFlag);
+	TRACE("stereo   :\t%d\n", (bool)stereoFlag);
+	TRACE("depth    :\t%d\n", depth);
+	TRACE("stencil  :\t%d\n", stencil);
+	TRACE("accum    :\t%d\n", accum);
+	TRACE("red      :\t%d\n", red);
+	TRACE("green    :\t%d\n", green);
+	TRACE("blue     :\t%d\n", blue);
+	TRACE("alpha    :\t%d\n", alpha);
+
+	gl_config* glVisual = _mesa_create_visual(dblFlag, stereoFlag, red, green,
+		blue, alpha, depth, stencil, accum, accum, accum, alpha ? accum : 0, 1);
+
+	if (!glVisual) {
+		ERROR("%s: Couldn't create Mesa visual!\n", __func__);
+		return -1;
+	}
+
+	TRACE("depthBits   :\t%d\n", glVisual->depthBits);
+	TRACE("stencilBits :\t%d\n", glVisual->stencilBits);
+
+	// Convert Mesa calculated visual into state tracker visual
+	context->stVisual = hgl_fill_st_visual(glVisual);
+
+	context->draw = new GalliumFramebuffer(context->stVisual, (void*)this);
+	context->read = new GalliumFramebuffer(context->stVisual, (void*)this);
+
+	if (!context->draw || !context->read) {
+		ERROR("%s: Problem allocating framebuffer!\n", __func__);
+		_mesa_destroy_visual(glVisual);
+		return -1;
+	}
+
+	// We need to assign the screen *before* calling st_api create_context
+	context->manager->screen = fScreen;
+
+	// Build state tracker attributes
+	struct st_context_attribs attribs;
+	memset(&attribs, 0, sizeof(attribs));
+	attribs.options.force_glsl_extensions_warn = false;
+	attribs.profile = ST_PROFILE_DEFAULT;
+	attribs.visual = *context->stVisual;
+	attribs.major = 1;
+	attribs.minor = 0;
+	//attribs.flags |= ST_CONTEXT_FLAG_DEBUG;
+
+	struct st_api* api = context->api;
+
+	// Create context using state tracker api call
+	enum st_context_error result;
+	context->st = api->create_context(api, context->manager, &attribs,
+		&result, context->st);
+
+	if (!context->st) {
+		ERROR("%s: Couldn't create mesa state tracker context!\n",
+			__func__);
+		switch (result) {
+			case ST_CONTEXT_SUCCESS:
+				ERROR("%s: State tracker error: SUCCESS?\n", __func__);
+				break;
+			case ST_CONTEXT_ERROR_NO_MEMORY:
+				ERROR("%s: State tracker error: NO_MEMORY\n", __func__);
+				break;
+			case ST_CONTEXT_ERROR_BAD_API:
+				ERROR("%s: State tracker error: BAD_API\n", __func__);
+				break;
+			case ST_CONTEXT_ERROR_BAD_VERSION:
+				ERROR("%s: State tracker error: BAD_VERSION\n", __func__);
+				break;
+			case ST_CONTEXT_ERROR_BAD_FLAG:
+				ERROR("%s: State tracker error: BAD_FLAG\n", __func__);
+				break;
+			case ST_CONTEXT_ERROR_UNKNOWN_ATTRIBUTE:
+				ERROR("%s: State tracker error: BAD_ATTRIBUTE\n", __func__);
+				break;
+			case ST_CONTEXT_ERROR_UNKNOWN_FLAG:
+				ERROR("%s: State tracker error: UNKNOWN_FLAG\n", __func__);
+				break;
+		}
+
+		FREE(context);
+		return -1;
+	}
+
+	// Init Gallium3D Post Processing
+	//context->postProcess = pp_init(fScreen, context->postProcessEnable);
+
+	assert(!context->st->st_manager_private);
+	context->st->st_manager_private = (void*)this;
+
+	struct st_context *stContext = (struct st_context*)context->st;
+	
+	stContext->ctx->Driver.Viewport = hgl_viewport;
+
+	// TODO: Closely review this next context logic...
+	context_id contextNext = -1;
+
+	pipe_mutex_lock(fMutex);
+	for (context_id i = 0; i < CONTEXT_MAX; i++) {
+		if (fContext[i] == NULL) {
+			fContext[i] = context;
+			contextNext = i;
+			break;
+		}
+	}
+	pipe_mutex_unlock(fMutex);
+
+	if (contextNext < 0) {
+		ERROR("%s: The next context is invalid... something went wrong!\n",
+			__func__);
+		//st_destroy_context(context->st);
+		FREE(context);
+		_mesa_destroy_visual(glVisual);
+		return -1;
+	}
+
+	TRACE("%s: context #%" B_PRIu64 " is the next available context\n",
+		__func__, contextNext);
+
+	return contextNext;
+}
+
+
+void
+GalliumContext::DestroyContext(context_id contextID)
+{
+	// fMutex should be locked *before* calling DestoryContext
+
+	// See if context is used
+	if (!fContext[contextID])
+		return;
+
+	if (fContext[contextID]->st) {
+		fContext[contextID]->st->flush(fContext[contextID]->st, 0, NULL);
+		fContext[contextID]->st->destroy(fContext[contextID]->st);
+	}
+
+	if (fContext[contextID]->postProcess)
+		pp_free(fContext[contextID]->postProcess);
+
+	// Delete framebuffer objects
+	if (fContext[contextID]->read)
+		delete fContext[contextID]->read;
+	if (fContext[contextID]->draw)
+		delete fContext[contextID]->draw;
+
+	if (fContext[contextID]->stVisual)
+		FREE(fContext[contextID]->stVisual);
+
+	if (fContext[contextID]->manager)
+		FREE(fContext[contextID]->manager);
+
+	FREE(fContext[contextID]);
+}
+
+
+status_t
+GalliumContext::SetCurrentContext(Bitmap *bitmap, context_id contextID)
+{
+	CALLED();
+
+	if (contextID < 0 || contextID > CONTEXT_MAX) {
+		ERROR("%s: Invalid context ID range!\n", __func__);
+		return B_ERROR;
+	}
+
+	pipe_mutex_lock(fMutex);
+	context_id oldContextID = fCurrentContext;
+	struct hgl_context* context = fContext[contextID];
+	pipe_mutex_unlock(fMutex);
+
+	if (!context) {
+		ERROR("%s: Invalid context provided (#%" B_PRIu64 ")!\n",
+			__func__, contextID);
+		return B_ERROR;
+	}
+
+	struct st_api* api = context->api;
+
+	if (!bitmap) {
+		api->make_current(context->api, NULL, NULL, NULL);
+		return B_OK;
+	}
+
+	// Everything seems valid, lets set the new context.
+	fCurrentContext = contextID;
+
+	if (oldContextID > 0 && oldContextID != contextID) {
+		fContext[oldContextID]->st->flush(fContext[oldContextID]->st,
+			ST_FLUSH_FRONT, NULL);
+	}
+
+	// We need to lock and unlock framebuffers before accessing them
+	context->draw->Lock();
+	context->read->Lock();
+	api->make_current(context->api, context->st, context->draw->fBuffer,
+		context->read->fBuffer);
+	context->draw->Unlock();
+	context->read->Unlock();
+
+	// TODO: Init textures before post-processing them
+	#if 0
+	pp_init_fbos(context->postProcess,
+		context->textures[ST_ATTACHMENT_BACK_LEFT]->width0,
+		context->textures[ST_ATTACHMENT_BACK_LEFT]->height0);
+	#endif
+
+	context->bitmap = bitmap;
+	//context->st->pipe->priv = context;
+
+	return B_OK;
+}
+
+
+status_t
+GalliumContext::SwapBuffers(context_id contextID)
+{
+	CALLED();
+
+	pipe_mutex_lock(fMutex);
+	struct hgl_context *context = fContext[contextID];
+	pipe_mutex_unlock(fMutex);
+
+	if (!context) {
+		ERROR("%s: context not found\n", __func__);
+		return B_ERROR;
+	}
+
+	// TODO: Where did st_notify_swapbuffers go?
+	//st_notify_swapbuffers(context->draw->stfb);
+
+	context->st->flush(context->st, ST_FLUSH_FRONT, NULL);
+
+	struct st_context *stContext = (struct st_context*)context->st;
+
+	unsigned nColorBuffers = stContext->state.framebuffer.nr_cbufs;
+	for (unsigned i = 0; i < nColorBuffers; i++) {
+		pipe_surface* surface = stContext->state.framebuffer.cbufs[i];
+		if (!surface) {
+			ERROR("%s: Color buffer %d invalid!\n", __func__, i);
+			continue;
+		}
+
+		TRACE("%s: Flushing color buffer #%d\n", __func__, i);
+
+		// We pass our destination bitmap to flush_fronbuffer which passes it
+		// to the private winsys display call.
+		fScreen->flush_frontbuffer(fScreen, surface->texture, 0, 0,
+			context->bitmap);
+	}
+
+	#if 0
+	// TODO... should we flush the z stencil buffer?
+	pipe_surface* zSurface = stContext->state.framebuffer.zsbuf;
+	fScreen->flush_frontbuffer(fScreen, surface->texture, 0, 0,
+		context->bitmap);
+	#endif
+
+	return B_OK;
+}
diff --git a/src/gallium/targets/haiku-softpipe/GalliumContext.h b/src/gallium/targets/haiku-softpipe/GalliumContext.h
new file mode 100644
index 0000000..88e9f81
--- /dev/null
+++ b/src/gallium/targets/haiku-softpipe/GalliumContext.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2009, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Alexander von Gluck IV, kallisti5@unixzen.com
+ */
+#ifndef GALLIUMCONTEXT_H
+#define GALLIUMCONTEXT_H
+
+
+#include <stddef.h>
+#include <kernel/image.h>
+
+extern "C" {
+#include "state_tracker/st_api.h"
+#include "pipe/p_compiler.h"
+#include "pipe/p_screen.h"
+#include "postprocess/filters.h"
+#include "os/os_thread.h"
+}
+#include "bitmap_wrapper.h"
+#include "GalliumFramebuffer.h"
+
+
+#define CONTEXT_MAX 32
+
+
+typedef int64 context_id;
+
+struct hgl_context
+{
+	struct st_api* api;
+		// State Tracker API
+	struct st_manager* manager;
+		// State Tracker Manager
+	struct st_context_iface* st;
+		// State Tracker Interface Object
+	struct st_visual* stVisual;
+		// State Tracker Visual
+
+	struct pipe_resource* textures[ST_ATTACHMENT_COUNT];
+
+	// Post processing
+	struct pp_queue_t* postProcess;
+	unsigned int postProcessEnable[PP_FILTERS];
+
+	Bitmap* bitmap;
+	color_space colorSpace;
+
+	GalliumFramebuffer* draw;
+	GalliumFramebuffer* read;
+};
+
+
+class GalliumContext {
+public:
+							GalliumContext(ulong options);
+							~GalliumContext();
+
+		context_id			CreateContext(Bitmap* bitmap);
+		void				DestroyContext(context_id contextID);
+		context_id			GetCurrentContext() { return fCurrentContext; };
+		status_t			SetCurrentContext(Bitmap *bitmap,
+								context_id contextID);
+
+		status_t			SwapBuffers(context_id contextID);
+
+private:
+		status_t			CreateScreen();
+		void				Flush();
+
+		ulong				fOptions;
+
+		struct hgl_context*	fContext[CONTEXT_MAX];
+		context_id			fCurrentContext;
+		
+		struct pipe_screen*	fScreen;
+		pipe_mutex			fMutex;
+};
+	
+
+#endif /* GALLIUMCONTEXT_H */
diff --git a/src/gallium/targets/haiku-softpipe/GalliumFramebuffer.cpp b/src/gallium/targets/haiku-softpipe/GalliumFramebuffer.cpp
new file mode 100644
index 0000000..7a33cc0
--- /dev/null
+++ b/src/gallium/targets/haiku-softpipe/GalliumFramebuffer.cpp
@@ -0,0 +1,115 @@
+/*
+ * Copyright 2012-2013, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *      Artur Wyszynski, harakash@gmail.com
+ *      Alexander von Gluck IV, kallisti5@unixzen.com
+ */
+
+
+#include "GalliumFramebuffer.h"
+
+extern "C" {
+#include "main/context.h"
+#include "main/framebuffer.h"
+#include "main/renderbuffer.h"
+#include "pipe/p_format.h"
+}
+
+
+#ifdef DEBUG
+#   define TRACE(x...) printf("GalliumFramebuffer: " x)
+#   define CALLED() TRACE("CALLED: %s\n", __PRETTY_FUNCTION__)
+#else
+#   define TRACE(x...)
+#   define CALLED()
+#endif
+#define ERROR(x...) printf("GalliumFramebuffer: " x)
+
+
+static boolean
+hgl_framebuffer_flush_front(struct st_context_iface *stctx,
+	struct st_framebuffer_iface* stfb, enum st_attachment_type statt)
+{
+	CALLED();
+	// TODO: I have *NO* idea how we are going to access this data...
+
+	#if 0
+	struct stw_st_framebuffer *stwfb = stw_st_framebuffer(stfb);
+	pipe_mutex_lock(stwfb->fb->mutex);
+
+	struct pipe_resource* resource = textures[statt];
+	if (resource)
+		stw_framebuffer_present_locked(...);
+	#endif
+
+	return TRUE;
+}
+
+
+static boolean
+hgl_framebuffer_validate(struct st_context_iface* stctx,
+	struct st_framebuffer_iface* stfb,
+	const enum st_attachment_type* statts, unsigned count,
+	struct pipe_resource** out)
+{
+	CALLED();
+
+	return TRUE;
+}
+
+
+GalliumFramebuffer::GalliumFramebuffer(struct st_visual* visual,
+	void* privateContext)
+	:
+	fBuffer(NULL)
+{
+	CALLED();
+	fBuffer = CALLOC_STRUCT(st_framebuffer_iface);
+	if (!fBuffer) {
+		ERROR("%s: Couldn't calloc framebuffer!\n", __func__);
+		return;
+	}
+	fBuffer->visual = visual;
+	fBuffer->flush_front = hgl_framebuffer_flush_front;
+	fBuffer->validate = hgl_framebuffer_validate;
+	fBuffer->st_manager_private = privateContext;
+
+	pipe_mutex_init(fMutex);
+}
+
+
+GalliumFramebuffer::~GalliumFramebuffer()
+{
+	CALLED();
+	// We lock and unlock to try and make sure we wait for anything
+	// using the framebuffer to finish
+	Lock();
+	if (!fBuffer) {
+		ERROR("%s: Strange, no Gallium Framebuffer to free?\n", __func__);
+		return;
+	}
+	FREE(fBuffer);
+	Unlock();
+
+	pipe_mutex_destroy(fMutex);
+}
+
+
+status_t
+GalliumFramebuffer::Lock()
+{
+	CALLED();
+	pipe_mutex_lock(fMutex);
+	return B_OK;
+}
+
+
+status_t
+GalliumFramebuffer::Unlock()
+{
+	CALLED();
+	pipe_mutex_unlock(fMutex);
+	return B_OK;
+}
diff --git a/src/gallium/targets/haiku-softpipe/GalliumFramebuffer.h b/src/gallium/targets/haiku-softpipe/GalliumFramebuffer.h
new file mode 100644
index 0000000..11e6b73
--- /dev/null
+++ b/src/gallium/targets/haiku-softpipe/GalliumFramebuffer.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2012, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *      Alexander von Gluck IV, kallisti5@unixzen.com
+ */
+#ifndef GALLIUMFRAMEBUFFER_H
+#define GALLIUMFRAMEBUFFER_H
+
+
+extern "C" {
+#include "os/os_thread.h"
+#include "pipe/p_screen.h"
+#include "state_tracker/st_api.h"
+}
+
+
+class GalliumFramebuffer {
+public:
+							GalliumFramebuffer(struct st_visual* visual,
+								void* privateContext);
+							~GalliumFramebuffer();
+		status_t			Lock();
+		status_t			Unlock();
+
+		struct st_framebuffer_iface* fBuffer;
+
+private:
+		pipe_mutex			fMutex;
+};
+
+
+#endif /* GALLIUMFRAMEBUFFER_H */
diff --git a/src/gallium/targets/haiku-softpipe/SConscript b/src/gallium/targets/haiku-softpipe/SConscript
index 72a5ba7..40bf03c 100644
--- a/src/gallium/targets/haiku-softpipe/SConscript
+++ b/src/gallium/targets/haiku-softpipe/SConscript
@@ -1,21 +1,43 @@
 Import('*')
 
+env.Prepend(LIBS = [
+    ws_haiku,
+    trace,
+    rbug,
+    mesa,
+    glsl,
+    gallium
+])
+
 if True:
     env.Append(CPPDEFINES = [
         'GALLIUM_SOFTPIPE',
         'GALLIUM_RBUG',
         'GALLIUM_TRACE',
     ])
+    env.Prepend(LIBS = [softpipe])
+
+env.Append(CPPPATH = [
+    '#/src/mapi',
+    '#/src/mesa',
+    '#/src/mesa/main',
+    '#/src/gallium/winsys/sw/hgl',
+    '/boot/system/develop/headers/private',
+])
 
 if env['llvm']:
-    env.Append(CPPDEFINES = 'HAVE_LLVMPIPE')
+    env.Append(CPPDEFINES = ['GALLIUM_LLVMPIPE'])
+    env.Prepend(LIBS = [llvmpipe])
 
 softpipe_sources = [
-    'haiku-softpipe.c'
+    'GalliumContext.cpp',
+    'GalliumFramebuffer.cpp',
+    'SoftwareRenderer.cpp'
 ]
 
-module = env.StaticLibrary(
-    target ='swpipe_haiku.a',
+# libswpipe gets turned into "Softpipe" by the haiku package system
+module = env.LoadableModule(
+    target ='swpipe',
     source = softpipe_sources,
-    SHLIBPREFIX = '',
 )
+
diff --git a/src/gallium/targets/haiku-softpipe/SoftwareRenderer.cpp b/src/gallium/targets/haiku-softpipe/SoftwareRenderer.cpp
new file mode 100644
index 0000000..ced2256
--- /dev/null
+++ b/src/gallium/targets/haiku-softpipe/SoftwareRenderer.cpp
@@ -0,0 +1,362 @@
+/*
+ * Copyright 2006-2012, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Jérôme Duval, korli@users.berlios.de
+ *		Philippe Houdoin, philippe.houdoin@free.fr
+ *		Artur Wyszynski, harakash@gmail.com
+ *		Alexander von Gluck IV, kallisti5@unixzen.com
+ */
+
+
+#include "SoftwareRenderer.h"
+
+#include <Autolock.h>
+#include <interface/DirectWindowPrivate.h>
+#include <GraphicsDefs.h>
+#include <Screen.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <new>
+
+
+#ifdef DEBUG
+#	define TRACE(x...) printf("SoftwareRenderer: " x)
+#	define CALLED() TRACE("CALLED: %s\n", __PRETTY_FUNCTION__)
+#else
+#	define TRACE(x...)
+#	define CALLED()
+#endif
+#define ERROR(x...)	printf("SoftwareRenderer: " x)
+
+
+extern const char* color_space_name(color_space space);
+
+
+extern "C" _EXPORT BGLRenderer*
+instantiate_gl_renderer(BGLView *view, ulong opts, BGLDispatcher *dispatcher)
+{
+	return new SoftwareRenderer(view, opts, dispatcher);
+}
+
+SoftwareRenderer::SoftwareRenderer(BGLView *view, ulong options,
+	BGLDispatcher* dispatcher)
+	:
+	BGLRenderer(view, options, dispatcher),
+	fBitmap(NULL),
+	fDirectModeEnabled(false),
+	fInfo(NULL),
+	fInfoLocker("info locker"),
+	fOptions(options),
+	fColorSpace(B_NO_COLOR_SPACE)
+{
+	CALLED();
+
+	// Disable double buffer for the moment.
+	options &= ~BGL_DOUBLE;
+
+	// Initialize the "Haiku Software GL Pipe"
+	time_t beg;
+	time_t end;
+	beg = time(NULL);
+	fContextObj = new GalliumContext(options);
+	end = time(NULL);
+	TRACE("Haiku Software GL Pipe initialization time: %f.\n",
+		difftime(end, beg));
+
+	// Allocate a bitmap
+	BRect b = view->Bounds();
+	fColorSpace = BScreen(view->Window()).ColorSpace();
+	TRACE("%s: Colorspace:\t%s\n", __func__, color_space_name(fColorSpace));
+
+	fWidth = (GLint)b.IntegerWidth();
+	fHeight = (GLint)b.IntegerHeight();
+	fNewWidth = fWidth;
+	fNewHeight = fHeight;
+
+	_AllocateBitmap();
+
+	// Initialize the first "Haiku Software GL Pipe" context
+	beg = time(NULL);
+	fContextID = fContextObj->CreateContext(fBitmap);
+	end = time(NULL);
+
+	if (fContextID < 0)
+		ERROR("%s: There was an error creating the context!\n", __func__);
+	else {
+		TRACE("%s: Haiku Software GL Pipe context creation time: %f.\n",
+			__func__, difftime(end, beg));
+	}
+
+	if (!fContextObj->GetCurrentContext())
+		LockGL();
+}
+
+
+SoftwareRenderer::~SoftwareRenderer()
+{
+	CALLED();
+
+	if (fContextObj)
+		delete fContextObj;
+	if (fBitmap)
+		delete fBitmap;
+}
+
+
+void
+SoftwareRenderer::LockGL()
+{
+//	CALLED();
+	BGLRenderer::LockGL();
+
+	color_space cs = BScreen(GLView()->Window()).ColorSpace();
+
+	BAutolock lock(fInfoLocker);
+	if (fDirectModeEnabled && fInfo != NULL) {
+		fNewWidth = fInfo->window_bounds.right - fInfo->window_bounds.left;
+			// + 1;
+		fNewHeight = fInfo->window_bounds.bottom - fInfo->window_bounds.top;
+			// + 1;
+	}
+
+	if (fBitmap && cs == fColorSpace && fNewWidth == fWidth
+		&& fNewHeight == fHeight) {
+		fContextObj->SetCurrentContext(fBitmap, fContextID);
+		return;
+	}
+
+	fColorSpace = cs;
+	fWidth = fNewWidth;
+	fHeight = fNewHeight;
+
+	_AllocateBitmap();
+	fContextObj->SetCurrentContext(fBitmap, fContextID);
+}
+
+
+void
+SoftwareRenderer::UnlockGL()
+{
+//	CALLED();
+	if ((fOptions & BGL_DOUBLE) == 0) {
+		SwapBuffers();
+	}
+	fContextObj->SetCurrentContext(NULL, fContextID);
+	BGLRenderer::UnlockGL();
+}
+
+
+void
+SoftwareRenderer::SwapBuffers(bool vsync)
+{
+//	CALLED();
+	if (!fBitmap)
+		return;
+
+	BScreen screen(GLView()->Window());
+
+	fContextObj->SwapBuffers(fContextID);
+
+	BAutolock lock(fInfoLocker);
+
+	if (!fDirectModeEnabled || fInfo == NULL) {
+		if (GLView()->LockLooperWithTimeout(1000) == B_OK) {
+			GLView()->DrawBitmap(fBitmap, B_ORIGIN);
+			GLView()->UnlockLooper();
+			if (vsync)
+				screen.WaitForRetrace();
+		}
+		return;
+	}
+
+	// check the bitmap size still matches the size
+	if (fInfo->window_bounds.bottom - fInfo->window_bounds.top
+			!= fBitmap->Bounds().IntegerHeight()
+			|| fInfo->window_bounds.right - fInfo->window_bounds.left
+			!= fBitmap->Bounds().IntegerWidth()) {
+		ERROR("%s: Bitmap size doesn't match size!\n", __func__);
+		return;
+	}
+	uint8 bytesPerPixel = fInfo->bits_per_pixel / 8;
+	uint32 bytesPerRow = fBitmap->BytesPerRow();
+	for (uint32 i = 0; i < fInfo->clip_list_count; i++) {
+		clipping_rect *clip = &fInfo->clip_list[i];
+		int32 height = clip->bottom - clip->top + 1;
+		int32 bytesWidth
+			= (clip->right - clip->left + 1) * bytesPerPixel;
+		bytesWidth -= bytesPerPixel;
+		uint8 *p = (uint8 *)fInfo->bits + clip->top
+			* fInfo->bytes_per_row + clip->left * bytesPerPixel;
+		uint8 *b = (uint8 *)fBitmap->Bits()
+			+ (clip->top - fInfo->window_bounds.top) * bytesPerRow
+			+ (clip->left - fInfo->window_bounds.left) * bytesPerPixel;
+
+		for (int y = 0; y < height - 1; y++) {
+			memcpy(p, b, bytesWidth);
+			p += fInfo->bytes_per_row;
+			b += bytesPerRow;
+		}
+	}
+
+	if (vsync)
+		screen.WaitForRetrace();
+}
+
+
+void
+SoftwareRenderer::Draw(BRect updateRect)
+{
+//	CALLED();
+	if ((!fDirectModeEnabled || fInfo == NULL) && fBitmap)
+		GLView()->DrawBitmap(fBitmap, updateRect, updateRect);
+}
+
+
+status_t
+SoftwareRenderer::CopyPixelsOut(BPoint location, BBitmap *bitmap)
+{
+	CALLED();
+	color_space scs = fBitmap->ColorSpace();
+	color_space dcs = bitmap->ColorSpace();
+
+	if (scs != dcs && (scs != B_RGBA32 || dcs != B_RGB32)) {
+		ERROR("%s::CopyPixelsOut(): incompatible color space: %s != %s\n",
+			__PRETTY_FUNCTION__, color_space_name(scs), color_space_name(dcs));
+		return B_BAD_TYPE;
+	}
+
+	BRect sr = fBitmap->Bounds();
+	BRect dr = bitmap->Bounds();
+
+//	int32 w1 = sr.IntegerWidth();
+//	int32 h1 = sr.IntegerHeight();
+//	int32 w2 = dr.IntegerWidth();
+//	int32 h2 = dr.IntegerHeight();
+
+	sr = sr & dr.OffsetBySelf(location);
+	dr = sr.OffsetByCopy(-location.x, -location.y);
+
+	uint8 *ps = (uint8 *) fBitmap->Bits();
+	uint8 *pd = (uint8 *) bitmap->Bits();
+	uint32 *s, *d;
+	uint32 y;
+	for (y = (uint32) sr.top; y <= (uint32) sr.bottom; y++) {
+		s = (uint32 *)(ps + y * fBitmap->BytesPerRow());
+		s += (uint32) sr.left;
+
+		d = (uint32 *)(pd + (y + (uint32)(dr.top - sr.top))
+			* bitmap->BytesPerRow());
+		d += (uint32) dr.left;
+		memcpy(d, s, dr.IntegerWidth() * 4);
+	}
+
+	return B_OK;
+}
+
+
+status_t
+SoftwareRenderer::CopyPixelsIn(BBitmap *bitmap, BPoint location)
+{
+	CALLED();
+
+	color_space sourceCS = bitmap->ColorSpace();
+	color_space destinationCS = fBitmap->ColorSpace();
+
+	if (sourceCS != destinationCS
+		&& (sourceCS != B_RGB32 || destinationCS != B_RGBA32)) {
+		ERROR("%s::CopyPixelsIn(): incompatible color space: %s != %s\n",
+			__PRETTY_FUNCTION__, color_space_name(sourceCS),
+			color_space_name(destinationCS));
+		return B_BAD_TYPE;
+	}
+
+	BRect sr = bitmap->Bounds();
+	BRect dr = fBitmap->Bounds();
+
+	sr = sr & dr.OffsetBySelf(location);
+	dr = sr.OffsetByCopy(-location.x, -location.y);
+
+	uint8 *ps = (uint8 *) bitmap->Bits();
+	uint8 *pd = (uint8 *) fBitmap->Bits();
+	uint32 *s, *d;
+	uint32 y;
+
+	for (y = (uint32) sr.top; y <= (uint32) sr.bottom; y++) {
+		s = (uint32 *)(ps + y * bitmap->BytesPerRow());
+		s += (uint32) sr.left;
+
+		d = (uint32 *)(pd + (y + (uint32)(dr.top - sr.top))
+			* fBitmap->BytesPerRow());
+		d += (uint32) dr.left;
+
+		memcpy(d, s, dr.IntegerWidth() * 4);
+	}
+
+	return B_OK;
+}
+
+
+void
+SoftwareRenderer::EnableDirectMode(bool enabled)
+{
+	fDirectModeEnabled = enabled;
+}
+
+
+void
+SoftwareRenderer::DirectConnected(direct_buffer_info *info)
+{
+//	CALLED();
+	BAutolock lock(fInfoLocker);
+	if (info) {
+		if (!fInfo) {
+			fInfo = (direct_buffer_info *)calloc(1,
+				DIRECT_BUFFER_INFO_AREA_SIZE);
+		}
+		memcpy(fInfo, info, DIRECT_BUFFER_INFO_AREA_SIZE);
+	} else if (fInfo) {
+		free(fInfo);
+		fInfo = NULL;
+	}
+}
+
+
+void
+SoftwareRenderer::FrameResized(float width, float height)
+{
+//	CALLED();
+	BAutolock lock(fInfoLocker);
+	fNewWidth = (GLuint)width;
+	fNewHeight = (GLuint)height;
+}
+
+
+void
+SoftwareRenderer::_AllocateBitmap()
+{
+//	CALLED();
+
+	// allocate new size of back buffer bitmap
+	BAutolock lock(fInfoLocker);
+	delete fBitmap;
+	fBitmap = NULL;
+	if (fWidth < 1 || fHeight < 1) {
+		TRACE("%s: Can't allocate bitmap of %dx%d\n", __func__,
+			fWidth, fHeight);
+		return;
+	}
+	BRect rect(0.0, 0.0, fWidth, fHeight);
+	fBitmap = new (std::nothrow) BBitmap(rect, fColorSpace);
+	if (fBitmap == NULL) {
+		TRACE("%s: Can't create bitmap!\n", __func__);
+		return;
+	}
+
+#if 0
+	// debug..
+	void *data = fBitmap->Bits();
+	memset(data, 0xcc, fBitmap->BitsLength());
+#endif
+}
diff --git a/src/gallium/targets/haiku-softpipe/SoftwareRenderer.h b/src/gallium/targets/haiku-softpipe/SoftwareRenderer.h
new file mode 100644
index 0000000..8427ce1
--- /dev/null
+++ b/src/gallium/targets/haiku-softpipe/SoftwareRenderer.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2006-2012, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Jérôme Duval, korli@users.berlios.de
+ * 		Philippe Houdoin, philippe.houdoin@free.fr
+ * 		Artur Wyszynski, harakash@gmail.com
+ *		Alexander von Gluck IV, kallisti5@unixzen.com
+ */
+#ifndef SOFTWARERENDERER_H
+#define SOFTWARERENDERER_H
+
+
+#include <kernel/image.h>
+
+#include "GLRenderer.h"
+#include "GalliumContext.h"
+
+
+class SoftwareRenderer : public BGLRenderer {
+public:
+								SoftwareRenderer(BGLView *view,
+									ulong bgl_options,
+									BGLDispatcher *dispatcher);
+	virtual						~SoftwareRenderer();
+
+	virtual	void				LockGL();
+	virtual	void				UnlockGL();
+
+	virtual	void				SwapBuffers(bool vsync = false);
+	virtual	void				Draw(BRect updateRect);
+	virtual	status_t			CopyPixelsOut(BPoint source, BBitmap *dest);
+	virtual	status_t			CopyPixelsIn(BBitmap *source, BPoint dest);
+	virtual	void				FrameResized(float width, float height);
+
+	virtual	void				EnableDirectMode(bool enabled);
+	virtual	void				DirectConnected(direct_buffer_info *info);
+
+private:
+
+			void				_AllocateBitmap();
+
+			GalliumContext*		fContextObj;
+			BBitmap*			fBitmap;
+			context_id			fContextID;
+
+			bool				fDirectModeEnabled;
+			direct_buffer_info*	fInfo;
+			BLocker				fInfoLocker;
+			ulong				fOptions;			
+			GLuint				fWidth;
+			GLuint				fHeight;
+			GLuint				fNewWidth;
+			GLuint				fNewHeight;
+			color_space			fColorSpace;
+};
+
+#endif	// SOFTPIPERENDERER_H
diff --git a/src/gallium/targets/haiku-softpipe/SoftwareRenderer.rdef b/src/gallium/targets/haiku-softpipe/SoftwareRenderer.rdef
new file mode 100644
index 0000000..f9d01b2
--- /dev/null
+++ b/src/gallium/targets/haiku-softpipe/SoftwareRenderer.rdef
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2012, Haiku, Inc. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+resource app_signature "application/x-vnd.Haiku-swpipe";
+
+resource app_version {
+    major  = 9,
+    middle = 0,
+    minor  = 0,
+    variety = 0,
+    internal = 0,
+    short_info = "Software Renderer",
+    long_info = "Haiku Gallium Software GL Renderer"
+};
+
+resource vector_icon {
+	$"6E6369660A0200140294A9FF18020014028DFFFF97058C0500020006023B10B7"
+	$"37F036BA1A993D466848C719BEBE2000919292FFD5D5D5020016023900000000"
+	$"000000003EE0004AE00048E0005EF884C702000203392E8D383001BAD97F3C12"
+	$"8B4786BD48B8AD0D97BBFFFF7B4168DBE9FF4168DB97020002023A0C1238D099"
+	$"BE44203F4BD14B38844678240DF56A7D9FE1EA064CC704016B0500090A044024"
+	$"2438404C5C380A044028243C40505C3C0A042438243B5C3C5C380608BFBE4D59"
+	$"4D59515957575659585560406044603C5E3A5C3CCB4FBFBA5E3ECA9DC11F564B"
+	$"584A544C504C0606AF0F2F3D2F3D393D4034BF593542324130432F42364432C0"
+	$"3FBC5A2F48354A2F480608AE9A22303EB5BD3AB42542B755422E412F3C29322D"
+	$"32223C0204263726372538263F253E263F304430443143303C313D303C02043D"
+	$"423D423C433D4A3C493D4A495049504A4F49474A484947060DAEAAAE014E445A"
+	$"3456365E325E3D5D3F5A3A5542544E4D573A4E364439463342324A2242310A0A"
+	$"0002020102403CA00C88888C8CC1401673C40D6544F2950A01010002403CA000"
+	$"0000000000401673C40D65446CF80A08020304023EC16A0000000000003EC16A"
+	$"45DD1844C6550A030105123EC16A0000000000003EC16A45DD1844C655011784"
+	$"22040A040105023EC16A0000000000003EC16A45DD1844C6550A030108123EC1"
+	$"6A0000000000003EC16A45DD1844C65501178422040A0503080706023EC16A00"
+	$"00000000003EC16A45DD1844C6550A030206071A3EC16A0000000000003EC16A"
+	$"45DD1844C65510FF0215810004178222040A060106023EC16A0000000000003E"
+	$"C16A45DD1844C6550A070107023EC16A0000000000003EC16A45DD1844C655"
+};
diff --git a/src/gallium/targets/haiku-softpipe/haiku-softpipe.c b/src/gallium/targets/haiku-softpipe/haiku-softpipe.c
deleted file mode 100644
index d0a427b..0000000
--- a/src/gallium/targets/haiku-softpipe/haiku-softpipe.c
+++ /dev/null
@@ -1,65 +0,0 @@
-/**************************************************************************
- *
- * Copyright 2013 Alexander von Gluck IV <kallisti5@unixzen.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
- * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
- * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
- * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
- * USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- **************************************************************************/
-
-
-#include "haiku-softpipe.h"
-
-#include "util/u_debug.h"
-#include "sw/hgl/hgl_sw_winsys.h"
-
-#include "softpipe/sp_texture.h"
-#include "softpipe/sp_screen.h"
-#include "softpipe/sp_public.h"
-
-#ifdef HAVE_LLVMPIPE
-#include "llvmpipe/lp_texture.h"
-#include "llvmpipe/lp_screen.h"
-#include "llvmpipe/lp_public.h"
-#endif
-
-
-struct pipe_screen*
-hgl_sw_screen_create(void)
-{
-	struct sw_winsys* winsys = hgl_create_sw_winsys();
-	struct pipe_screen* screen = NULL;
-
-	if (!winsys)
-		return NULL;
-
-	#ifdef HAVE_LLVMPIPE
-	screen = llvmpipe_create_screen(winsys);
-	#else
-	screen = softpipe_create_screen(winsys);
-	#endif
-	
-	if (!screen) {
-		winsys->destroy(winsys);
-		return NULL;
-	}
-	
-	return screen;
-}
diff --git a/src/gallium/targets/haiku-softpipe/haiku-softpipe.h b/src/gallium/targets/haiku-softpipe/haiku-softpipe.h
deleted file mode 100644
index 75bf6df..0000000
--- a/src/gallium/targets/haiku-softpipe/haiku-softpipe.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/**************************************************************************
- *
- * Copyright 2013 Alexander von Gluck IV <kallisti5@unixzen.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
- * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
- * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
- * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
- * USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- *
- **************************************************************************/
-#ifndef HAIKU_SOFTPIPE_H_
-#define HAIKU_SOFTPIPE_H_
-
-
-#include "pipe/p_context.h"
-
-
-struct pipe_screen* hgl_sw_screen_create(void);
-
-
-#endif
diff --git a/src/gallium/targets/libgl-haiku/GLDispatcher.cpp b/src/gallium/targets/libgl-haiku/GLDispatcher.cpp
new file mode 100644
index 0000000..46b91d5
--- /dev/null
+++ b/src/gallium/targets/libgl-haiku/GLDispatcher.cpp
@@ -0,0 +1,72 @@
+/*
+ * Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000-2012 Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Brian Paul <brian.e.paul@gmail.com>
+ *		Philippe Houdoin <philippe.houdoin@free.fr>
+ *		Alexander von Gluck IV <kallisti5@unixzen.com>
+ */
+
+
+extern "C" {
+#include "glapi/glapi.h"
+#include "glapi/glapi_priv.h"
+
+/*
+ * NOTE: this file portion implements C-based dispatch of the OpenGL entrypoints
+ * (glAccum, glBegin, etc).
+ * This code IS NOT USED if we're compiling on an x86 system and using
+ * the glapi_x86.S assembly code.
+ */
+#if !(defined(USE_X86_ASM) || defined(USE_SPARC_ASM))
+
+#define KEYWORD1 PUBLIC
+#define KEYWORD2
+#define NAME(func) gl##func
+
+#define DISPATCH(func, args, msg)					\
+	const struct _glapi_table* dispatch;					\
+	dispatch = _glapi_Dispatch ? _glapi_Dispatch : _glapi_get_dispatch();\
+	(dispatch->func) args
+
+#define RETURN_DISPATCH(func, args, msg) 				\
+	const struct _glapi_table* dispatch;					\
+	dispatch = _glapi_Dispatch ? _glapi_Dispatch : _glapi_get_dispatch();\
+	return (dispatch->func) args
+
+#endif
+}
+
+
+/* NOTE: this file portion implement a thin OpenGL entrypoints dispatching
+	C++ wrapper class
+ */
+
+#include "GLDispatcher.h"
+
+BGLDispatcher::BGLDispatcher()
+{
+}
+
+
+BGLDispatcher::~BGLDispatcher()
+{
+}
+
+
+status_t
+BGLDispatcher::CheckTable(const struct _glapi_table* table)
+{
+	_glapi_check_table(table ? table : _glapi_get_dispatch());
+	return B_OK;
+}
+
+
+status_t
+BGLDispatcher::SetTable(struct _glapi_table* table)
+{
+	_glapi_set_dispatch(table);
+	return B_OK;
+}
diff --git a/src/gallium/targets/libgl-haiku/GLDispatcher.h b/src/gallium/targets/libgl-haiku/GLDispatcher.h
new file mode 100644
index 0000000..44bca8c
--- /dev/null
+++ b/src/gallium/targets/libgl-haiku/GLDispatcher.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000-2012 Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Brian Paul <brian.e.paul@gmail.com>
+ *		Philippe Houdoin <philippe.houdoin@free.fr>
+ */
+#ifndef GLDISPATCHER_H
+#define GLDISPATCHER_H
+
+
+#include <BeBuild.h>
+#include <GL/gl.h>
+#include <SupportDefs.h>
+
+#include "glheader.h"
+
+extern "C" {
+#include "glapi/glapi.h"
+}
+
+
+class BGLDispatcher
+{
+		// Private unimplemented copy constructors
+		BGLDispatcher(const BGLDispatcher &);
+		BGLDispatcher & operator=(const BGLDispatcher &);
+
+	public:
+		BGLDispatcher();
+		~BGLDispatcher();
+
+		void 					SetCurrentContext(void* context);
+		void*					CurrentContext();
+
+		struct _glapi_table* 	Table();
+		status_t				CheckTable(
+									const struct _glapi_table* dispatch = NULL);
+		status_t				SetTable(struct _glapi_table* dispatch);
+		uint32					TableSize();
+
+		const _glapi_proc 		operator[](const char* functionName);
+		const char*				operator[](uint32 offset);
+
+		const _glapi_proc		AddressOf(const char* functionName);
+		uint32					OffsetOf(const char* functionName);
+};
+
+
+// Inlines methods
+inline void
+BGLDispatcher::SetCurrentContext(void* context)
+{
+	_glapi_set_context(context);
+}
+
+
+inline void*
+BGLDispatcher::CurrentContext()
+{
+	return _glapi_get_context();
+}
+
+
+inline struct _glapi_table*
+BGLDispatcher::Table()
+{
+	return _glapi_get_dispatch();
+}
+
+
+inline uint32
+BGLDispatcher::TableSize()
+{
+	return _glapi_get_dispatch_table_size();
+}
+
+
+inline const _glapi_proc
+BGLDispatcher::operator[](const char* functionName)
+{
+	return _glapi_get_proc_address(functionName);
+}
+
+
+inline const char*
+BGLDispatcher::operator[](uint32 offset)
+{
+	return _glapi_get_proc_name((GLuint) offset);
+}
+
+
+inline const _glapi_proc
+BGLDispatcher::AddressOf(const char* functionName)
+{
+	return _glapi_get_proc_address(functionName);
+}
+
+
+inline uint32
+BGLDispatcher::OffsetOf(const char* functionName)
+{
+	return (uint32) _glapi_get_proc_offset(functionName);
+}
+
+
+#endif	// GLDISPATCHER_H
diff --git a/src/gallium/targets/libgl-haiku/GLRenderer.cpp b/src/gallium/targets/libgl-haiku/GLRenderer.cpp
new file mode 100644
index 0000000..4573a64
--- /dev/null
+++ b/src/gallium/targets/libgl-haiku/GLRenderer.cpp
@@ -0,0 +1,106 @@
+/*
+ * Copyright 2006-2008, Philippe Houdoin. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ */
+
+
+#include <kernel/image.h>
+
+#include "GLRenderer.h"
+
+#include "GLDispatcher.h"
+
+
+BGLRenderer::BGLRenderer(BGLView* view, ulong glOptions,
+	BGLDispatcher* dispatcher)
+	:
+	fRefCount(1),
+	fView(view),
+	fOptions(glOptions),
+	fDispatcher(dispatcher)
+{
+}
+
+
+BGLRenderer::~BGLRenderer()
+{
+	delete fDispatcher;
+}
+
+
+void
+BGLRenderer::Acquire()
+{
+	atomic_add(&fRefCount, 1);
+}
+
+
+void
+BGLRenderer::Release()
+{
+	if (atomic_add(&fRefCount, -1) < 1)
+		delete this;
+}
+
+
+void
+BGLRenderer::LockGL()
+{
+}
+
+
+void
+BGLRenderer::UnlockGL()
+{
+}
+
+
+void
+BGLRenderer::SwapBuffers(bool VSync)
+{
+}
+
+
+void
+BGLRenderer::Draw(BRect updateRect)
+{
+}
+
+
+status_t
+BGLRenderer::CopyPixelsOut(BPoint source, BBitmap* dest)
+{
+	return B_ERROR;
+}
+
+
+status_t
+BGLRenderer::CopyPixelsIn(BBitmap* source, BPoint dest)
+{
+	return B_ERROR;
+}
+
+
+void
+BGLRenderer::FrameResized(float width, float height)
+{
+}
+
+
+void
+BGLRenderer::DirectConnected(direct_buffer_info* info)
+{
+}
+
+
+void
+BGLRenderer::EnableDirectMode(bool enabled)
+{
+}
+
+
+status_t BGLRenderer::_Reserved_Renderer_0(int32 n, void* p) { return B_ERROR; }
+status_t BGLRenderer::_Reserved_Renderer_1(int32 n, void* p) { return B_ERROR; }
+status_t BGLRenderer::_Reserved_Renderer_2(int32 n, void* p) { return B_ERROR; }
+status_t BGLRenderer::_Reserved_Renderer_3(int32 n, void* p) { return B_ERROR; }
+status_t BGLRenderer::_Reserved_Renderer_4(int32 n, void* p) { return B_ERROR; }
diff --git a/src/gallium/targets/libgl-haiku/GLRendererRoster.cpp b/src/gallium/targets/libgl-haiku/GLRendererRoster.cpp
new file mode 100644
index 0000000..1712a87
--- /dev/null
+++ b/src/gallium/targets/libgl-haiku/GLRendererRoster.cpp
@@ -0,0 +1,224 @@
+/*
+ * Copyright 2006-2012 Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Philippe Houdoin <philippe.houdoin@free.fr>
+ *		Alexander von Gluck IV <kallisti5@unixzen.com>
+ */
+
+
+#include <driver_settings.h>
+#include <image.h>
+
+#include <kernel/image.h>
+#include <system/safemode_defs.h>
+
+#include <Directory.h>
+#include <FindDirectory.h>
+#include <Path.h>
+#include <String.h>
+#include "GLDispatcher.h"
+#include "GLRendererRoster.h"
+
+#include <new>
+#include <string.h>
+
+
+extern "C" status_t _kern_get_safemode_option(const char* parameter,
+	char* buffer, size_t* _bufferSize);
+
+
+GLRendererRoster::GLRendererRoster(BGLView* view, ulong options)
+	:
+	fNextID(0),
+	fView(view),
+	fOptions(options),
+	fSafeMode(false),
+	fABISubDirectory(NULL)
+{
+	char parameter[32];
+	size_t parameterLength = sizeof(parameter);
+
+	if (_kern_get_safemode_option(B_SAFEMODE_SAFE_MODE,
+		parameter, &parameterLength) == B_OK) {
+		if (!strcasecmp(parameter, "enabled") || !strcasecmp(parameter, "on")
+			|| !strcasecmp(parameter, "true") || !strcasecmp(parameter, "yes")
+			|| !strcasecmp(parameter, "enable") || !strcmp(parameter, "1"))
+			fSafeMode = true;
+	}
+
+	if (_kern_get_safemode_option(B_SAFEMODE_DISABLE_USER_ADD_ONS,
+		parameter, &parameterLength) == B_OK) {
+		if (!strcasecmp(parameter, "enabled") || !strcasecmp(parameter, "on")
+			|| !strcasecmp(parameter, "true") || !strcasecmp(parameter, "yes")
+			|| !strcasecmp(parameter, "enable") || !strcmp(parameter, "1"))
+			fSafeMode = true;
+	}
+
+	// We might run in compatibility mode on a system with a different ABI. The
+	// renderers matching our ABI can usually be found in respective
+	// subdirectories of the opengl add-ons directories.
+	system_info info;
+	if (get_system_info(&info) == B_OK
+		&& (info.abi & B_HAIKU_ABI_MAJOR)
+			!= (B_HAIKU_ABI & B_HAIKU_ABI_MAJOR)) {
+			switch (B_HAIKU_ABI & B_HAIKU_ABI_MAJOR) {
+				case B_HAIKU_ABI_GCC_2:
+					fABISubDirectory = "gcc2";
+					break;
+				case B_HAIKU_ABI_GCC_4:
+					fABISubDirectory = "gcc4";
+					break;
+			}
+	}
+
+	AddDefaultPaths();
+}
+
+
+GLRendererRoster::~GLRendererRoster()
+{
+
+}
+
+
+BGLRenderer*
+GLRendererRoster::GetRenderer(int32 id)
+{
+	RendererMap::const_iterator iterator = fRenderers.find(id);
+	if (iterator == fRenderers.end())
+		return NULL;
+
+	struct renderer_item item = iterator->second;
+	return item.renderer;
+}
+
+
+void
+GLRendererRoster::AddDefaultPaths()
+{
+	// add user directories first, so that they can override system renderers
+	const directory_which paths[] = {
+		B_USER_NONPACKAGED_ADDONS_DIRECTORY,
+		B_USER_ADDONS_DIRECTORY,
+		B_SYSTEM_ADDONS_DIRECTORY,
+	};
+
+	for (uint32 i = fSafeMode ? 4 : 0;
+		i < sizeof(paths) / sizeof(paths[0]); i++) {
+		BPath path;
+		status_t status = find_directory(paths[i], &path, true);
+		if (status == B_OK && path.Append("opengl") == B_OK)
+			AddPath(path.Path());
+	}
+}
+
+
+status_t
+GLRendererRoster::AddPath(const char* path)
+{
+	BDirectory directory(path);
+	status_t status = directory.InitCheck();
+	if (status < B_OK)
+		return status;
+
+	// if a subdirectory for our ABI exists, use that instead
+	if (fABISubDirectory != NULL) {
+		BEntry entry(&directory, fABISubDirectory);
+		if (entry.IsDirectory()) {
+			status = directory.SetTo(&entry);
+			if (status != B_OK)
+				return status;
+		}
+	}
+
+	node_ref nodeRef;
+	status = directory.GetNodeRef(&nodeRef);
+	if (status < B_OK)
+		return status;
+
+	int32 count = 0;
+	int32 files = 0;
+
+	entry_ref ref;
+	BEntry entry;
+	while (directory.GetNextRef(&ref) == B_OK) {
+		entry.SetTo(&ref);
+		if (entry.InitCheck() == B_OK && !entry.IsFile())
+			continue;
+
+		if (CreateRenderer(ref) == B_OK)
+			count++;
+
+		files++;
+	}
+
+	if (files != 0 && count == 0)
+		return B_BAD_VALUE;
+
+	return B_OK;
+}
+
+
+status_t
+GLRendererRoster::AddRenderer(BGLRenderer* renderer,
+	image_id image, const entry_ref* ref, ino_t node)
+{
+	renderer_item item;
+	item.renderer = renderer;
+	item.image = image;
+	item.node = node;
+	if (ref != NULL)
+		item.ref = *ref;
+
+	try {
+		fRenderers[fNextID] = item;
+	} catch (...) {
+		return B_NO_MEMORY;
+	}
+
+	renderer->fOwningRoster = this;
+	renderer->fID = fNextID++;
+	return B_OK;
+}
+
+
+status_t
+GLRendererRoster::CreateRenderer(const entry_ref& ref)
+{
+	BEntry entry(&ref);
+	node_ref nodeRef;
+	status_t status = entry.GetNodeRef(&nodeRef);
+	if (status < B_OK)
+		return status;
+
+	BPath path(&ref);
+	image_id image = load_add_on(path.Path());
+	if (image < B_OK)
+		return image;
+
+	BGLRenderer* (*instantiate_renderer)
+		(BGLView* view, ulong options, BGLDispatcher* dispatcher);
+
+	status = get_image_symbol(image, "instantiate_gl_renderer",
+		B_SYMBOL_TYPE_TEXT, (void**)&instantiate_renderer);
+	if (status == B_OK) {
+		BGLRenderer* renderer
+			= instantiate_renderer(fView, fOptions, new BGLDispatcher());
+		if (!renderer) {
+			unload_add_on(image);
+			return B_UNSUPPORTED;
+		}
+
+		if (AddRenderer(renderer, image, &ref, nodeRef.node) != B_OK) {
+			renderer->Release();
+			// this will delete the renderer
+			unload_add_on(image);
+		}
+		return B_OK;
+	}
+	unload_add_on(image);
+
+	return status;
+}
diff --git a/src/gallium/targets/libgl-haiku/GLRendererRoster.h b/src/gallium/targets/libgl-haiku/GLRendererRoster.h
new file mode 100644
index 0000000..5c8da27
--- /dev/null
+++ b/src/gallium/targets/libgl-haiku/GLRendererRoster.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2006-2012, Haiku, Inc. All Rights Reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Philippe Houdoin <philippe.houdoin@free.fr>
+ */
+#ifndef _GLRENDERER_ROSTER_H
+#define _GLRENDERER_ROSTER_H
+
+
+#include <GLRenderer.h>
+
+#include <map>
+
+
+struct renderer_item {
+	BGLRenderer* renderer;
+	entry_ref	ref;
+	ino_t		node;
+	image_id	image;
+};
+
+typedef std::map<renderer_id, renderer_item> RendererMap;
+
+
+class GLRendererRoster {
+	public:
+		GLRendererRoster(BGLView* view, ulong options);
+		virtual ~GLRendererRoster();
+
+		BGLRenderer* GetRenderer(int32 id = 0);
+
+	private:
+		void AddDefaultPaths();
+		status_t AddPath(const char* path);
+		status_t AddRenderer(BGLRenderer* renderer,
+			image_id image, const entry_ref* ref, ino_t node);
+		status_t CreateRenderer(const entry_ref& ref);
+
+		RendererMap	fRenderers;
+		int32		fNextID;
+		BGLView*	fView;
+		ulong		fOptions;
+		bool		fSafeMode;
+		const char*	fABISubDirectory;
+
+};
+
+
+#endif	/* _GLRENDERER_ROSTER_H */
diff --git a/src/gallium/targets/libgl-haiku/GLView.cpp b/src/gallium/targets/libgl-haiku/GLView.cpp
new file mode 100644
index 0000000..9ae5b5c
--- /dev/null
+++ b/src/gallium/targets/libgl-haiku/GLView.cpp
@@ -0,0 +1,643 @@
+/*
+ * Copyright 2006-2012, Haiku. All rights reserved.
+ * Distributed under the terms of the MIT License.
+ *
+ * Authors:
+ *		Jérôme Duval, korli@users.berlios.de
+ *		Philippe Houdoin, philippe.houdoin@free.fr
+ *		Stefano Ceccherini, burton666@libero.it
+ */
+
+#include <kernel/image.h>
+
+#include <GLView.h>
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <DirectWindow.h>
+#include <GLRenderer.h>
+
+#include "interface/DirectWindowPrivate.h"
+#include "GLDispatcher.h"
+#include "GLRendererRoster.h"
+
+
+struct glview_direct_info {
+	direct_buffer_info* direct_info;
+	bool direct_connected;
+	bool enable_direct_mode;
+
+	glview_direct_info();
+	~glview_direct_info();
+};
+
+
+BGLView::BGLView(BRect rect, const char* name, ulong resizingMode, ulong mode,
+	ulong options)
+	:
+	BView(rect, name, B_FOLLOW_ALL_SIDES, mode | B_WILL_DRAW | B_FRAME_EVENTS),
+		//  | B_FULL_UPDATE_ON_RESIZE)
+	fGc(NULL),
+	fOptions(options),
+	fDitherCount(0),
+	fDrawLock("BGLView draw lock"),
+	fDisplayLock("BGLView display lock"),
+	fClipInfo(NULL),
+	fRenderer(NULL),
+	fRoster(NULL),
+	fDitherMap(NULL)
+{
+	fRoster = new GLRendererRoster(this, options);
+}
+
+
+BGLView::~BGLView()
+{
+	delete fClipInfo;
+	if (fRenderer)
+		fRenderer->Release();
+}
+
+
+void
+BGLView::LockGL()
+{
+	// TODO: acquire the OpenGL API lock it on this glview
+
+	fDisplayLock.Lock();
+	if (fRenderer)
+		fRenderer->LockGL();
+}
+
+
+void
+BGLView::UnlockGL()
+{
+	if (fRenderer)
+		fRenderer->UnlockGL();
+	fDisplayLock.Unlock();
+
+	// TODO: release the GL API lock to others glviews
+}
+
+
+void
+BGLView::SwapBuffers()
+{
+	SwapBuffers(false);
+}
+
+
+void
+BGLView::SwapBuffers(bool vSync)
+{
+	if (fRenderer) {
+		_LockDraw();
+		fRenderer->SwapBuffers(vSync);
+		_UnlockDraw();
+	}
+}
+
+
+BView*
+BGLView::EmbeddedView()
+{
+	return NULL;
+}
+
+
+void*
+BGLView::GetGLProcAddress(const char* procName)
+{
+	BGLDispatcher* glDispatcher = NULL;
+
+	if (fRenderer)
+		glDispatcher = fRenderer->GLDispatcher();
+
+	if (glDispatcher)
+		return (void*)glDispatcher->AddressOf(procName);
+
+	return NULL;
+}
+
+
+status_t
+BGLView::CopyPixelsOut(BPoint source, BBitmap* dest)
+{
+	if (!fRenderer)
+		return B_ERROR;
+
+	if (!dest || !dest->Bounds().IsValid())
+		return B_BAD_VALUE;
+
+	return fRenderer->CopyPixelsOut(source, dest);
+}
+
+
+status_t
+BGLView::CopyPixelsIn(BBitmap* source, BPoint dest)
+{
+	if (!fRenderer)
+		return B_ERROR;
+
+	if (!source || !source->Bounds().IsValid())
+		return B_BAD_VALUE;
+
+	return fRenderer->CopyPixelsIn(source, dest);
+}
+
+
+/*!	Mesa's GLenum is not ulong but uint, so we can't use GLenum
+	without breaking this method signature.
+	Instead, we have to use the effective BeOS's SGI OpenGL GLenum type:
+	unsigned long.
+ */
+void
+BGLView::ErrorCallback(unsigned long errorCode)
+{
+	char msg[32];
+	sprintf(msg, "GL: Error code $%04lx.", errorCode);
+	// TODO: under BeOS R5, it call debugger(msg);
+	fprintf(stderr, "%s\n", msg);
+}
+
+
+void
+BGLView::Draw(BRect updateRect)
+{
+	if (fRenderer) {
+		_LockDraw();
+		fRenderer->Draw(updateRect);
+		_UnlockDraw();
+		return;
+	}
+	// TODO: auto-size and center the string
+	MovePenTo(8, 32);
+	DrawString("No OpenGL renderer available!");
+}
+
+
+void
+BGLView::AttachedToWindow()
+{
+	BView::AttachedToWindow();
+
+	fBounds = Bounds();
+	for (BView* view = this; view != NULL; view = view->Parent())
+		view->ConvertToParent(&fBounds);
+
+	fRenderer = fRoster->GetRenderer();
+	if (fRenderer != NULL) {
+		// Jackburton: The following code was commented because it doesn't look
+		// good in "direct" mode:
+		// when the window is moved, the app_server doesn't paint the view's
+		// background, and the stuff behind the window itself shows up.
+		// Setting the view color to black, instead, looks a bit more elegant.
+#if 0
+		// Don't paint white window background when resized
+		SetViewColor(B_TRANSPARENT_32_BIT);
+#else
+		SetViewColor(0, 0, 0);
+#endif
+
+		// Set default OpenGL viewport:
+		LockGL();
+		glViewport(0, 0, Bounds().IntegerWidth(), Bounds().IntegerHeight());
+		UnlockGL();
+		fRenderer->FrameResized(Bounds().IntegerWidth(),
+			Bounds().IntegerHeight());
+
+		if (fClipInfo) {
+			fRenderer->DirectConnected(fClipInfo->direct_info);
+			fRenderer->EnableDirectMode(fClipInfo->enable_direct_mode);
+		}
+
+		return;
+	}
+
+	fprintf(stderr, "no renderer found! \n");
+
+	// No Renderer, no rendering. Setup a minimal "No Renderer" string drawing
+	// context
+	SetFont(be_bold_font);
+	// SetFontSize(16);
+}
+
+
+void
+BGLView::AllAttached()
+{
+	BView::AllAttached();
+}
+
+
+void
+BGLView::DetachedFromWindow()
+{
+	if (fRenderer)
+		fRenderer->Release();
+	fRenderer = NULL;
+
+	BView::DetachedFromWindow();
+}
+
+
+void
+BGLView::AllDetached()
+{
+	BView::AllDetached();
+}
+
+
+void
+BGLView::FrameResized(float width, float height)
+{
+	fBounds = Bounds();
+	for (BView* v = this; v; v = v->Parent())
+		v->ConvertToParent(&fBounds);
+
+	if (fRenderer) {
+		LockGL();
+		_LockDraw();
+		_CallDirectConnected();
+		fRenderer->FrameResized(width, height);
+		_UnlockDraw();
+		UnlockGL();
+	}
+
+	BView::FrameResized(width, height);
+}
+
+
+status_t
+BGLView::Perform(perform_code d, void* arg)
+{
+	return BView::Perform(d, arg);
+}
+
+
+status_t
+BGLView::Archive(BMessage* data, bool deep) const
+{
+	return BView::Archive(data, deep);
+}
+
+
+void
+BGLView::MessageReceived(BMessage* msg)
+{
+	BView::MessageReceived(msg);
+}
+
+
+void
+BGLView::SetResizingMode(uint32 mode)
+{
+	BView::SetResizingMode(mode);
+}
+
+
+void
+BGLView::GetPreferredSize(float* _width, float* _height)
+{
+	if (_width)
+		*_width = 0;
+	if (_height)
+		*_height = 0;
+}
+
+
+void
+BGLView::Show()
+{
+	BView::Show();
+}
+
+
+void
+BGLView::Hide()
+{
+	BView::Hide();
+}
+
+
+BHandler*
+BGLView::ResolveSpecifier(BMessage* msg, int32 index, BMessage* specifier,
+	int32 form, const char* property)
+{
+	return BView::ResolveSpecifier(msg, index, specifier, form, property);
+}
+
+
+status_t
+BGLView::GetSupportedSuites(BMessage* data)
+{
+	return BView::GetSupportedSuites(data);
+}
+
+
+void
+BGLView::DirectConnected(direct_buffer_info* info)
+{
+	if (fClipInfo == NULL) {
+		fClipInfo = new (std::nothrow) glview_direct_info();
+		if (fClipInfo == NULL)
+			return;
+	}
+
+	direct_buffer_info* localInfo = fClipInfo->direct_info;
+
+	switch (info->buffer_state & B_DIRECT_MODE_MASK) {
+		case B_DIRECT_START:
+			fClipInfo->direct_connected = true;
+			memcpy(localInfo, info, DIRECT_BUFFER_INFO_AREA_SIZE);
+			_UnlockDraw();
+			break;
+
+		case B_DIRECT_MODIFY:
+			_LockDraw();
+			memcpy(localInfo, info, DIRECT_BUFFER_INFO_AREA_SIZE);
+			_UnlockDraw();
+			break;
+
+		case B_DIRECT_STOP:
+			fClipInfo->direct_connected = false;
+			_LockDraw();
+			break;
+	}
+
+	if (fRenderer)
+		_CallDirectConnected();
+}
+
+
+void
+BGLView::EnableDirectMode(bool enabled)
+{
+	if (fRenderer)
+		fRenderer->EnableDirectMode(enabled);
+	if (fClipInfo == NULL) {
+		fClipInfo = new (std::nothrow) glview_direct_info();
+		if (fClipInfo == NULL)
+			return;
+	}
+
+	fClipInfo->enable_direct_mode = enabled;
+}
+
+
+void
+BGLView::_LockDraw()
+{
+	if (!fClipInfo || !fClipInfo->enable_direct_mode)
+		return;
+
+	fDrawLock.Lock();
+}
+
+
+void
+BGLView::_UnlockDraw()
+{
+	if (!fClipInfo || !fClipInfo->enable_direct_mode)
+		return;
+
+	fDrawLock.Unlock();
+}
+
+
+void
+BGLView::_CallDirectConnected()
+{
+	if (!fClipInfo)
+		return;
+
+	direct_buffer_info* localInfo = fClipInfo->direct_info;
+	direct_buffer_info* info = (direct_buffer_info*)malloc(
+		DIRECT_BUFFER_INFO_AREA_SIZE);
+	if (info == NULL)
+		return;
+
+	memcpy(info, localInfo, DIRECT_BUFFER_INFO_AREA_SIZE);
+
+	// Collect the rects into a BRegion, then clip to the view's bounds
+	BRegion region;
+	for (uint32 c = 0; c < localInfo->clip_list_count; c++)
+		region.Include(localInfo->clip_list[c]);
+	BRegion boundsRegion = fBounds.OffsetByCopy(localInfo->window_bounds.left,
+		localInfo->window_bounds.top);
+	info->window_bounds = boundsRegion.RectAtInt(0);
+		// window_bounds are now view bounds
+	region.IntersectWith(&boundsRegion);
+
+	info->clip_list_count = region.CountRects();
+	info->clip_bounds = region.FrameInt();
+
+	for (uint32 c = 0; c < info->clip_list_count; c++)
+		info->clip_list[c] = region.RectAtInt(c);
+	fRenderer->DirectConnected(info);
+	free(info);
+}
+
+
+//---- virtual reserved methods ----------
+
+
+void BGLView::_ReservedGLView1() {}
+void BGLView::_ReservedGLView2() {}
+void BGLView::_ReservedGLView3() {}
+void BGLView::_ReservedGLView4() {}
+void BGLView::_ReservedGLView5() {}
+void BGLView::_ReservedGLView6() {}
+void BGLView::_ReservedGLView7() {}
+void BGLView::_ReservedGLView8() {}
+
+
+// #pragma mark -
+
+
+// BeOS compatibility: contrary to others BView's contructors,
+// BGLView one wants a non-const name argument.
+BGLView::BGLView(BRect rect, char* name, ulong resizingMode, ulong mode,
+	ulong options)
+	:
+	BView(rect, name, B_FOLLOW_ALL_SIDES, mode | B_WILL_DRAW | B_FRAME_EVENTS),
+	fGc(NULL),
+	fOptions(options),
+	fDitherCount(0),
+	fDrawLock("BGLView draw lock"),
+	fDisplayLock("BGLView display lock"),
+	fClipInfo(NULL),
+	fRenderer(NULL),
+	fRoster(NULL),
+	fDitherMap(NULL)
+{
+	fRoster = new GLRendererRoster(this, options);
+}
+
+
+#if 0
+// TODO: implement BGLScreen class...
+
+
+BGLScreen::BGLScreen(char* name, ulong screenMode, ulong options,
+		status_t* error, bool debug)
+	:
+	BWindowScreen(name, screenMode, error, debug)
+{
+}
+
+
+BGLScreen::~BGLScreen()
+{
+}
+
+
+void
+BGLScreen::LockGL()
+{
+}
+
+
+void
+BGLScreen::UnlockGL()
+{
+}
+
+
+void
+BGLScreen::SwapBuffers()
+{
+}
+
+
+void
+BGLScreen::ErrorCallback(unsigned long errorCode)
+{
+	// Mesa's GLenum is not ulong but uint!
+	char msg[32];
+	sprintf(msg, "GL: Error code $%04lx.", errorCode);
+	// debugger(msg);
+	fprintf(stderr, "%s\n", msg);
+	return;
+}
+
+
+void
+BGLScreen::ScreenConnected(bool enabled)
+{
+}
+
+
+void
+BGLScreen::FrameResized(float width, float height)
+{
+	return BWindowScreen::FrameResized(width, height);
+}
+
+
+status_t
+BGLScreen::Perform(perform_code d, void* arg)
+{
+	return BWindowScreen::Perform(d, arg);
+}
+
+
+status_t
+BGLScreen::Archive(BMessage* data, bool deep) const
+{
+	return BWindowScreen::Archive(data, deep);
+}
+
+
+void
+BGLScreen::MessageReceived(BMessage* msg)
+{
+	BWindowScreen::MessageReceived(msg);
+}
+
+
+void
+BGLScreen::Show()
+{
+	BWindowScreen::Show();
+}
+
+
+void
+BGLScreen::Hide()
+{
+	BWindowScreen::Hide();
+}
+
+
+BHandler*
+BGLScreen::ResolveSpecifier(BMessage* msg, int32 index, BMessage* specifier,
+	int32 form, const char* property)
+{
+	return BWindowScreen::ResolveSpecifier(msg, index, specifier,
+		form, property);
+}
+
+
+status_t
+BGLScreen::GetSupportedSuites(BMessage* data)
+{
+	return BWindowScreen::GetSupportedSuites(data);
+}
+
+
+//---- virtual reserved methods ----------
+
+void BGLScreen::_ReservedGLScreen1() {}
+void BGLScreen::_ReservedGLScreen2() {}
+void BGLScreen::_ReservedGLScreen3() {}
+void BGLScreen::_ReservedGLScreen4() {}
+void BGLScreen::_ReservedGLScreen5() {}
+void BGLScreen::_ReservedGLScreen6() {}
+void BGLScreen::_ReservedGLScreen7() {}
+void BGLScreen::_ReservedGLScreen8() {}
+#endif
+
+
+const char* color_space_name(color_space space)
+{
+#define C2N(a)	case a:	return #a
+
+	switch (space) {
+	C2N(B_RGB24);
+	C2N(B_RGB32);
+	C2N(B_RGBA32);
+	C2N(B_RGB32_BIG);
+	C2N(B_RGBA32_BIG);
+	C2N(B_GRAY8);
+	C2N(B_GRAY1);
+	C2N(B_RGB16);
+	C2N(B_RGB15);
+	C2N(B_RGBA15);
+	C2N(B_CMAP8);
+	default:
+		return "Unknown!";
+	};
+
+#undef C2N
+};
+
+
+glview_direct_info::glview_direct_info()
+{
+	// TODO: See direct_window_data() in app_server's ServerWindow.cpp
+	direct_info = (direct_buffer_info*)calloc(1, DIRECT_BUFFER_INFO_AREA_SIZE);
+	direct_connected = false;
+	enable_direct_mode = false;
+}
+
+
+glview_direct_info::~glview_direct_info()
+{
+	free(direct_info);
+}
+
diff --git a/src/gallium/targets/libgl-haiku/SConscript b/src/gallium/targets/libgl-haiku/SConscript
new file mode 100644
index 0000000..2e6b628
--- /dev/null
+++ b/src/gallium/targets/libgl-haiku/SConscript
@@ -0,0 +1,34 @@
+#######################################################################
+# SConscript for Haiku OpenGL kit
+
+Import('*')
+
+env = env.Clone()
+
+env.Append(CPPPATH = [
+    '#/src/mapi',
+    '#/src/mesa',
+    '#/src/mesa/main',
+    '/boot/system/develop/headers/private',
+    Dir('../../../mapi'), # src/mapi build path for python-generated GL API files/headers
+])
+
+env.Prepend(LIBS = [
+    glapi
+])
+
+sources = [
+    'GLView.cpp',
+    'GLRenderer.cpp',
+    'GLRendererRoster.cpp',
+    'GLDispatcher.cpp',
+]
+
+# libGL.so
+libgl = env.SharedLibrary(
+    target ='GL',
+    source = sources,
+    SHLIBSUFFIX = env['SHLIBSUFFIX'],
+)
+
+env.Alias('libgl-haiku', libgl)
diff --git a/src/gallium/targets/libgl-xlib/Makefile.am b/src/gallium/targets/libgl-xlib/Makefile.am
index 89066c7..ecbf262 100644
--- a/src/gallium/targets/libgl-xlib/Makefile.am
+++ b/src/gallium/targets/libgl-xlib/Makefile.am
@@ -37,7 +37,7 @@ AM_CPPFLAGS = \
 	-DGALLIUM_RBUG \
 	-DGALLIUM_TRACE \
 	-DGALLIUM_GALAHAD
-AM_CFLAGS = $(X11_CFLAGS)
+AM_CFLAGS = $(X11_INCLUDES)
 
 lib_LTLIBRARIES = libGL.la
 
diff --git a/src/gallium/targets/r300/dri/Makefile.am b/src/gallium/targets/r300/dri/Makefile.am
index 5e49ab5..4b41c30 100644
--- a/src/gallium/targets/r300/dri/Makefile.am
+++ b/src/gallium/targets/r300/dri/Makefile.am
@@ -25,7 +25,8 @@ include $(top_srcdir)/src/gallium/Automake.inc
 AM_CFLAGS = \
 	$(GALLIUM_CFLAGS) \
 	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS)
+	$(LIBDRM_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/gallium/drivers \
 	-I$(top_srcdir)/src/gallium/winsys \
@@ -43,7 +44,7 @@ nodist_EXTRA_r300_dri_la_SOURCES = dummy.cpp
 r300_dri_la_SOURCES = \
 	../drm_target.c
 
-r300_dri_la_LDFLAGS = -module -avoid-version -shared -no-undefined
+r300_dri_la_LDFLAGS = $(DRI_DRIVER_LDFLAGS)
 
 r300_dri_la_LIBADD = \
 	$(top_builddir)/src/mesa/drivers/dri/common/libdricommon.la \
diff --git a/src/gallium/targets/r300/vdpau/Makefile.am b/src/gallium/targets/r300/vdpau/Makefile.am
index c928955..d4855b2 100644
--- a/src/gallium/targets/r300/vdpau/Makefile.am
+++ b/src/gallium/targets/r300/vdpau/Makefile.am
@@ -25,7 +25,8 @@ include $(top_srcdir)/src/gallium/Automake.inc
 AM_CFLAGS = \
 	$(GALLIUM_CFLAGS) \
 	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS)
+	$(LIBDRM_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/gallium/drivers \
 	-I$(top_srcdir)/src/gallium/winsys
@@ -33,6 +34,8 @@ AM_CPPFLAGS = \
 vdpaudir = $(VDPAU_LIB_INSTALL_DIR)
 vdpau_LTLIBRARIES = libvdpau_r300.la
 
+EXPORTS = '^(vdp_imp_device_create_x11|radeon_drm_winsys_create)$$'
+
 nodist_EXTRA_libvdpau_r300_la_SOURCES = dummy.cpp
 libvdpau_r300_la_SOURCES = \
 	../drm_target.c \
@@ -41,6 +44,7 @@ libvdpau_r300_la_SOURCES = \
 libvdpau_r300_la_LDFLAGS = \
 	-module \
 	-version-number $(VDPAU_MAJOR):$(VDPAU_MINOR) \
+	-export-symbols-regex $(EXPORTS) \
 	-shared \
 	-no-undefined
 
diff --git a/src/gallium/targets/r300/xvmc/Makefile.am b/src/gallium/targets/r300/xvmc/Makefile.am
index 7171b4d..079a0eb 100644
--- a/src/gallium/targets/r300/xvmc/Makefile.am
+++ b/src/gallium/targets/r300/xvmc/Makefile.am
@@ -25,7 +25,8 @@ include $(top_srcdir)/src/gallium/Automake.inc
 AM_CFLAGS = \
 	$(GALLIUM_CFLAGS) \
 	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS)
+	$(LIBDRM_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/gallium/drivers \
 	-I$(top_srcdir)/src/gallium/winsys
diff --git a/src/gallium/targets/r600/dri/Makefile.am b/src/gallium/targets/r600/dri/Makefile.am
index 5a1600c..c7fca32 100644
--- a/src/gallium/targets/r600/dri/Makefile.am
+++ b/src/gallium/targets/r600/dri/Makefile.am
@@ -25,7 +25,8 @@ include $(top_srcdir)/src/gallium/Automake.inc
 AM_CFLAGS = \
 	$(GALLIUM_CFLAGS) \
 	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS)
+	$(LIBDRM_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/gallium/drivers \
 	-I$(top_srcdir)/src/gallium/winsys \
@@ -42,7 +43,7 @@ dri_LTLIBRARIES = r600_dri.la
 r600_dri_la_SOURCES = \
 	../drm_target.c
 
-r600_dri_la_LDFLAGS = -module -avoid-version -shared -no-undefined
+r600_dri_la_LDFLAGS = $(DRI_DRIVER_LDFLAGS)
 
 r600_dri_la_LIBADD = \
 	$(top_builddir)/src/mesa/drivers/dri/common/libdricommon.la \
diff --git a/src/gallium/targets/r600/vdpau/Makefile.am b/src/gallium/targets/r600/vdpau/Makefile.am
index e45fd93..7c97585 100644
--- a/src/gallium/targets/r600/vdpau/Makefile.am
+++ b/src/gallium/targets/r600/vdpau/Makefile.am
@@ -25,7 +25,8 @@ include $(top_srcdir)/src/gallium/Automake.inc
 AM_CFLAGS = \
 	$(GALLIUM_CFLAGS) \
 	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS)
+	$(LIBDRM_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/gallium/drivers \
 	-I$(top_srcdir)/src/gallium/winsys
@@ -33,6 +34,8 @@ AM_CPPFLAGS = \
 vdpaudir = $(VDPAU_LIB_INSTALL_DIR)
 vdpau_LTLIBRARIES = libvdpau_r600.la
 
+EXPORTS = '^(vdp_imp_device_create_x11|radeon_drm_winsys_create)$$'
+
 libvdpau_r600_la_SOURCES = \
 	../drm_target.c \
 	$(top_srcdir)/src/gallium/auxiliary/vl/vl_winsys_dri.c
@@ -40,6 +43,7 @@ libvdpau_r600_la_SOURCES = \
 libvdpau_r600_la_LDFLAGS = \
 	-module \
 	-version-number $(VDPAU_MAJOR):$(VDPAU_MINOR) \
+	-export-symbols-regex $(EXPORTS) \
 	-shared \
 	-no-undefined
 
diff --git a/src/gallium/targets/r600/xorg/Makefile.am b/src/gallium/targets/r600/xorg/Makefile.am
index 90bcbd5..c3dee5a 100644
--- a/src/gallium/targets/r600/xorg/Makefile.am
+++ b/src/gallium/targets/r600/xorg/Makefile.am
@@ -25,7 +25,8 @@ include $(top_srcdir)/src/gallium/Automake.inc
 AM_CFLAGS = \
 	$(GALLIUM_CFLAGS) \
 	$(PTHREAD_CFLAGS) \
-	$(XORG_CFLAGS)
+	$(XORG_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/gallium/drivers \
 	-I$(top_srcdir)/src/gallium/winsys \
diff --git a/src/gallium/targets/r600/xvmc/Makefile.am b/src/gallium/targets/r600/xvmc/Makefile.am
index 8443e17..2083b87 100644
--- a/src/gallium/targets/r600/xvmc/Makefile.am
+++ b/src/gallium/targets/r600/xvmc/Makefile.am
@@ -25,7 +25,8 @@ include $(top_srcdir)/src/gallium/Automake.inc
 AM_CFLAGS = \
 	$(GALLIUM_CFLAGS) \
 	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS)
+	$(LIBDRM_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/gallium/drivers \
 	-I$(top_srcdir)/src/gallium/winsys
diff --git a/src/gallium/targets/radeonsi/dri/Makefile.am b/src/gallium/targets/radeonsi/dri/Makefile.am
index 257574c..8a78f1b 100644
--- a/src/gallium/targets/radeonsi/dri/Makefile.am
+++ b/src/gallium/targets/radeonsi/dri/Makefile.am
@@ -25,7 +25,8 @@ include $(top_srcdir)/src/gallium/Automake.inc
 AM_CFLAGS = \
 	$(GALLIUM_CFLAGS) \
 	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS)
+	$(LIBDRM_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/gallium/drivers \
 	-I$(top_srcdir)/src/gallium/winsys \
@@ -43,7 +44,7 @@ nodist_EXTRA_radeonsi_dri_la_SOURCES = dummy.cpp
 radeonsi_dri_la_SOURCES = \
 	../drm_target.c
 
-radeonsi_dri_la_LDFLAGS = -module -avoid-version -shared -no-undefined
+radeonsi_dri_la_LDFLAGS = $(DRI_DRIVER_LDFLAGS)
 
 radeonsi_dri_la_LIBADD = \
 	$(top_builddir)/src/mesa/drivers/dri/common/libdricommon.la \
diff --git a/src/gallium/targets/radeonsi/vdpau/Makefile.am b/src/gallium/targets/radeonsi/vdpau/Makefile.am
index bda88e6..f21b340 100644
--- a/src/gallium/targets/radeonsi/vdpau/Makefile.am
+++ b/src/gallium/targets/radeonsi/vdpau/Makefile.am
@@ -25,7 +25,8 @@ include $(top_srcdir)/src/gallium/Automake.inc
 AM_CFLAGS = \
 	$(GALLIUM_CFLAGS) \
 	$(PTHREAD_CFLAGS) \
-	$(LIBDRM_CFLAGS)
+	$(LIBDRM_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/gallium/drivers \
 	-I$(top_srcdir)/src/gallium/winsys
@@ -33,6 +34,8 @@ AM_CPPFLAGS = \
 vdpaudir = $(VDPAU_LIB_INSTALL_DIR)
 vdpau_LTLIBRARIES = libvdpau_radeonsi.la
 
+EXPORTS = '^(vdp_imp_device_create_x11|radeon_drm_winsys_create)$$'
+
 nodist_EXTRA_libvdpau_radeonsi_la_SOURCES = dummy.cpp
 libvdpau_radeonsi_la_SOURCES = \
 	../drm_target.c \
@@ -41,6 +44,7 @@ libvdpau_radeonsi_la_SOURCES = \
 libvdpau_radeonsi_la_LDFLAGS = \
 	-module \
 	-version-number $(VDPAU_MAJOR):$(VDPAU_MINOR) \
+	-export-symbols-regex $(EXPORTS) \
 	-shared \
 	-no-undefined
 
diff --git a/src/gallium/targets/radeonsi/xorg/Makefile.am b/src/gallium/targets/radeonsi/xorg/Makefile.am
index 2eddf02..5f098d5 100644
--- a/src/gallium/targets/radeonsi/xorg/Makefile.am
+++ b/src/gallium/targets/radeonsi/xorg/Makefile.am
@@ -25,7 +25,8 @@ include $(top_srcdir)/src/gallium/Automake.inc
 AM_CFLAGS = \
 	$(GALLIUM_CFLAGS) \
 	$(PTHREAD_CFLAGS) \
-	$(XORG_CFLAGS)
+	$(XORG_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
 AM_CPPFLAGS = \
 	-I$(top_srcdir)/src/gallium/drivers \
 	-I$(top_srcdir)/src/gallium/winsys \
diff --git a/src/gallium/tests/graw/fs-test.c b/src/gallium/tests/graw/fs-test.c
index 38a2c4b..d962791 100644
--- a/src/gallium/tests/graw/fs-test.c
+++ b/src/gallium/tests/graw/fs-test.c
@@ -371,7 +371,7 @@ static void init_tex( void )
    if (sampler == NULL)
       exit(6);
 
-   ctx->bind_fragment_sampler_states(ctx, 1, &sampler);
+   ctx->bind_sampler_states(ctx, PIPE_SHADER_FRAGMENT, 0, 1, &sampler);
    
 }
 
diff --git a/src/gallium/tests/graw/gs-test.c b/src/gallium/tests/graw/gs-test.c
index e4e4f61..2a8f26e 100644
--- a/src/gallium/tests/graw/gs-test.c
+++ b/src/gallium/tests/graw/gs-test.c
@@ -478,7 +478,7 @@ static void init_tex( void )
    if (sampler == NULL)
       exit(6);
 
-   ctx->bind_fragment_sampler_states(ctx, 1, &sampler);
+   ctx->bind_sampler_states(ctx, PIPE_SHADER_FRAGMENT, 0, 1, &sampler);
    
 }
 
diff --git a/src/gallium/tests/graw/quad-sample.c b/src/gallium/tests/graw/quad-sample.c
index 969ffa7..bfae2e0 100644
--- a/src/gallium/tests/graw/quad-sample.c
+++ b/src/gallium/tests/graw/quad-sample.c
@@ -286,7 +286,7 @@ static void init_tex( void )
    if (sampler == NULL)
       exit(6);
 
-   ctx->bind_fragment_sampler_states(ctx, 1, &sampler);
+   ctx->bind_sampler_states(ctx, PIPE_SHADER_FRAGMENT, 0, 1, &sampler);
    
 }
 
diff --git a/src/gallium/tests/graw/quad-tex.c b/src/gallium/tests/graw/quad-tex.c
index 6cfcea3..7802d8e 100644
--- a/src/gallium/tests/graw/quad-tex.c
+++ b/src/gallium/tests/graw/quad-tex.c
@@ -172,7 +172,8 @@ static void init_tex( void )
    sampler = graw_util_create_simple_sampler(&info, 
                                              PIPE_TEX_WRAP_REPEAT,
                                              PIPE_TEX_FILTER_NEAREST);
-   info.ctx->bind_fragment_sampler_states(info.ctx, 1, &sampler);
+   info.ctx->bind_sampler_states(info.ctx, PIPE_SHADER_FRAGMENT,
+                                 0, 1, &sampler);
 }
 
 
diff --git a/src/gallium/tests/graw/tex-srgb.c b/src/gallium/tests/graw/tex-srgb.c
index 296d22a..5035fa7 100644
--- a/src/gallium/tests/graw/tex-srgb.c
+++ b/src/gallium/tests/graw/tex-srgb.c
@@ -165,7 +165,8 @@ static void init_tex( void )
       sampler = graw_util_create_simple_sampler(&info,
                                                 PIPE_TEX_WRAP_REPEAT,
                                                 PIPE_TEX_FILTER_NEAREST);
-      info.ctx->bind_fragment_sampler_states(info.ctx, 1, &sampler);
+      info.ctx->bind_sampler_states(info.ctx, PIPE_SHADER_FRAGMENT,
+                                    0, 1, &sampler);
    }
 
    /* linear sampler view */
diff --git a/src/gallium/tests/graw/tex-swizzle.c b/src/gallium/tests/graw/tex-swizzle.c
index 4ee79ee..65c1d4d 100644
--- a/src/gallium/tests/graw/tex-swizzle.c
+++ b/src/gallium/tests/graw/tex-swizzle.c
@@ -152,7 +152,8 @@ init_tex(const unsigned swizzle[4])
                                              PIPE_TEX_WRAP_REPEAT,
                                              PIPE_TEX_FILTER_NEAREST);
 
-   info.ctx->bind_fragment_sampler_states(info.ctx, 1, &sampler);
+   info.ctx->bind_sampler_states(info.ctx, PIPE_SHADER_FRAGMENT,
+                                 0, 1, &sampler);
 #undef SIZE
 }
 
diff --git a/src/gallium/tests/graw/vertex-shader/vert-imul_hi.sh b/src/gallium/tests/graw/vertex-shader/vert-imul_hi.sh
new file mode 100644
index 0000000..60e2d80
--- /dev/null
+++ b/src/gallium/tests/graw/vertex-shader/vert-imul_hi.sh
@@ -0,0 +1,13 @@
+VERT
+DCL IN[0]
+DCL IN[1]
+DCL OUT[0], POSITION
+DCL OUT[1], COLOR
+DCL TEMP[0]
+DCL TEMP[1]
+IMM[0] INT32 {-2147483648, 2, 0, -1}
+MOV OUT[0], IN[0]
+IMUL_HI TEMP[0], IMM[0].xzzx, IMM[0].yzzy
+UMUL TEMP[0], TEMP[0], IMM[0].wwww
+I2F OUT[1], TEMP[0]
+END
diff --git a/src/gallium/tests/graw/vertex-shader/vert-umul_hi.sh b/src/gallium/tests/graw/vertex-shader/vert-umul_hi.sh
new file mode 100644
index 0000000..4aa79fe
--- /dev/null
+++ b/src/gallium/tests/graw/vertex-shader/vert-umul_hi.sh
@@ -0,0 +1,11 @@
+VERT
+DCL IN[0]
+DCL IN[1]
+DCL OUT[0], POSITION
+DCL OUT[1], COLOR
+DCL TEMP[0]
+IMM[0] INT32 {4, 1073741824, 0, 1}
+MOV OUT[0], IN[0]
+UMUL_HI TEMP[0], IMM[0].xzzx, IMM[0].yzzy
+I2F OUT[1], TEMP[0]
+END
diff --git a/src/gallium/tests/graw/vs-test.c b/src/gallium/tests/graw/vs-test.c
index 5a7d0a0..f351928 100644
--- a/src/gallium/tests/graw/vs-test.c
+++ b/src/gallium/tests/graw/vs-test.c
@@ -365,7 +365,7 @@ static void init_tex( void )
    if (sampler == NULL)
       exit(6);
 
-   ctx->bind_fragment_sampler_states(ctx, 1, &sampler);
+   ctx->bind_sampler_states(ctx, PIPE_SHADER_FRAGMENT, 0, 1, &sampler);
    
 }
 
diff --git a/src/gallium/tests/trivial/compute.c b/src/gallium/tests/trivial/compute.c
index 5337b86..339c264 100644
--- a/src/gallium/tests/trivial/compute.c
+++ b/src/gallium/tests/trivial/compute.c
@@ -380,7 +380,7 @@ static void init_sampler_states(struct context *ctx, int n)
                 assert(ctx->hwsmp[i]);
         }
 
-        pipe->bind_compute_sampler_states(pipe, 0, i, ctx->hwsmp);
+        pipe->bind_sampler_states(pipe, PIPE_SHADER_COMPUTE, 0, i, ctx->hwsmp);
 }
 
 static void destroy_sampler_states(struct context *ctx)
@@ -388,7 +388,8 @@ static void destroy_sampler_states(struct context *ctx)
         struct pipe_context *pipe = ctx->pipe;
         int i;
 
-        pipe->bind_compute_sampler_states(pipe, 0, MAX_RESOURCES, NULL);
+        pipe->bind_sampler_states(pipe, PIPE_SHADER_COMPUTE,
+				  0, MAX_RESOURCES, NULL);
 
         for (i = 0; i < MAX_RESOURCES; ++i) {
                 if (ctx->hwsmp[i]) {
diff --git a/src/gallium/tools/trace/dump_state.py b/src/gallium/tools/trace/dump_state.py
index e9b879c..d4df2e0 100755
--- a/src/gallium/tools/trace/dump_state.py
+++ b/src/gallium/tools/trace/dump_state.py
@@ -239,6 +239,7 @@ class Context(Dispatcher):
         self._state.vs.shader = None
         self._state.gs.shader = None
         self._state.fs.shader = None
+        self._state.sampler = {}
         self._state.vs.sampler = []
         self._state.gs.sampler = []
         self._state.fs.sampler = []
@@ -280,14 +281,8 @@ class Context(Dispatcher):
     def delete_sampler_state(self, state):
         pass
 
-    def bind_vertex_sampler_states(self, num_states, states):
-        self._state.vs.sampler = states
-        
-    def bind_geometry_sampler_states(self, num_states, states):
-        self._state.gs.sampler = states
-        
-    def bind_fragment_sampler_states(self, num_states, states):
-        self._state.fs.sampler = states
+    def bind_sampler_states(self, shader, start, num_states, states):
+        self._state.sampler[shader] = states
         
     def create_rasterizer_state(self, state):
         return state
diff --git a/src/gallium/winsys/radeon/drm/Makefile.am b/src/gallium/winsys/radeon/drm/Makefile.am
index 184d257..d5c5474 100644
--- a/src/gallium/winsys/radeon/drm/Makefile.am
+++ b/src/gallium/winsys/radeon/drm/Makefile.am
@@ -4,7 +4,8 @@ include $(top_srcdir)/src/gallium/Automake.inc
 AM_CFLAGS = \
 	-I$(top_srcdir)/include \
 	$(GALLIUM_CFLAGS) \
-	$(RADEON_CFLAGS)
+	$(RADEON_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
 
 noinst_LTLIBRARIES = libradeonwinsys.la
 
diff --git a/src/gallium/winsys/radeon/drm/radeon_drm_cs.c b/src/gallium/winsys/radeon/drm/radeon_drm_cs.c
index 62f7704..0782e10 100644
--- a/src/gallium/winsys/radeon/drm/radeon_drm_cs.c
+++ b/src/gallium/winsys/radeon/drm/radeon_drm_cs.c
@@ -178,7 +178,7 @@ static struct radeon_winsys_cs *radeon_drm_cs_create(struct radeon_winsys *rws,
     if (!cs) {
         return NULL;
     }
-    pipe_semaphore_init(&cs->flush_completed, 0);
+    pipe_semaphore_init(&cs->flush_completed, 1);
 
     cs->ws = ws;
     cs->trace_buf = (struct radeon_bo*)trace_buf;
@@ -453,9 +453,9 @@ void radeon_drm_cs_sync_flush(struct radeon_winsys_cs *rcs)
     struct radeon_drm_cs *cs = radeon_drm_cs(rcs);
 
     /* Wait for any pending ioctl to complete. */
-    if (cs->ws->thread && cs->flush_started) {
+    if (cs->ws->thread) {
         pipe_semaphore_wait(&cs->flush_completed);
-        cs->flush_started = 0;
+        pipe_semaphore_signal(&cs->flush_completed);
     }
 }
 
@@ -567,7 +567,7 @@ static void radeon_drm_cs_flush(struct radeon_winsys_cs *rcs, unsigned flags, ui
         }
 
         if (cs->ws->thread) {
-            cs->flush_started = 1;
+            pipe_semaphore_wait(&cs->flush_completed);
             radeon_drm_ws_queue_cs(cs->ws, cs);
             if (!(flags & RADEON_FLUSH_ASYNC))
                 radeon_drm_cs_sync_flush(rcs);
diff --git a/src/gallium/winsys/radeon/drm/radeon_drm_cs.h b/src/gallium/winsys/radeon/drm/radeon_drm_cs.h
index 7683e96..ebec161 100644
--- a/src/gallium/winsys/radeon/drm/radeon_drm_cs.h
+++ b/src/gallium/winsys/radeon/drm/radeon_drm_cs.h
@@ -76,7 +76,6 @@ struct radeon_drm_cs {
     void (*flush_cs)(void *ctx, unsigned flags);
     void *flush_data;
 
-    int flush_started;
     pipe_semaphore flush_completed;
     struct radeon_bo                    *trace_buf;
 };
diff --git a/src/gallium/winsys/sw/dri/Makefile.am b/src/gallium/winsys/sw/dri/Makefile.am
index e0f9451..d987c15 100644
--- a/src/gallium/winsys/sw/dri/Makefile.am
+++ b/src/gallium/winsys/sw/dri/Makefile.am
@@ -23,7 +23,8 @@
 include $(top_srcdir)/src/gallium/Automake.inc
 
 AM_CPPFLAGS = \
-	$(GALLIUM_CFLAGS)
+	$(GALLIUM_CFLAGS) \
+	$(VISIBILITY_CFLAGS)
 
 noinst_LTLIBRARIES = libswdri.la
 
diff --git a/src/gallium/winsys/sw/hgl/SConscript b/src/gallium/winsys/sw/hgl/SConscript
index e881257..44080a6 100644
--- a/src/gallium/winsys/sw/hgl/SConscript
+++ b/src/gallium/winsys/sw/hgl/SConscript
@@ -21,5 +21,4 @@ if env['platform'] in ('haiku'):
            'bitmap_wrapper.cpp',
         ]
     )
-    env.Alias('ws_haiku', ws_haiku)
     Export('ws_haiku')
diff --git a/src/gbm/backends/dri/gbm_dri.c b/src/gbm/backends/dri/gbm_dri.c
index f7da79c..661306c 100644
--- a/src/gbm/backends/dri/gbm_dri.c
+++ b/src/gbm/backends/dri/gbm_dri.c
@@ -376,7 +376,10 @@ gbm_dri_bo_import(struct gbm_device *gbm,
    {
       struct wl_drm_buffer *wb;
 
-      wb = wayland_drm_buffer_get((struct wl_resource *) buffer);
+      if (!dri->wl_drm)
+         return NULL;
+
+      wb = wayland_drm_buffer_get(dri->wl_drm, (struct wl_resource *) buffer);
       if (!wb)
          return NULL;
 
@@ -548,6 +551,12 @@ gbm_dri_bo_create(struct gbm_device *gbm,
    case GBM_FORMAT_ABGR8888:
       dri_format = __DRI_IMAGE_FORMAT_ABGR8888;
       break;
+   case GBM_FORMAT_ARGB2101010:
+      dri_format = __DRI_IMAGE_FORMAT_ARGB2101010;
+      break;
+   case GBM_FORMAT_XRGB2101010:
+      dri_format = __DRI_IMAGE_FORMAT_XRGB2101010;
+      break;
    default:
       return NULL;
    }
diff --git a/src/gbm/backends/dri/gbm_driint.h b/src/gbm/backends/dri/gbm_driint.h
index 18fc3c0..90d764f 100644
--- a/src/gbm/backends/dri/gbm_driint.h
+++ b/src/gbm/backends/dri/gbm_driint.h
@@ -66,6 +66,8 @@ struct gbm_dri_device {
 			     int *width, int *height,
 			     unsigned int *attachments, int count,
 			     int *out_count, void *data);
+
+   struct wl_drm *wl_drm;
 };
 
 struct gbm_dri_bo {
diff --git a/src/glsl/.dir-locals.el b/src/glsl/.dir-locals.el
deleted file mode 100644
index be19e29..0000000
--- a/src/glsl/.dir-locals.el
+++ /dev/null
@@ -1,3 +0,0 @@
-((c-mode . ((c-basic-offset . 3)))
- (c++-mode . ((c-basic-offset . 3)))
-)
diff --git a/src/glsl/Makefile.am b/src/glsl/Makefile.am
index 2e161b8..cbf253c 100644
--- a/src/glsl/Makefile.am
+++ b/src/glsl/Makefile.am
@@ -49,6 +49,8 @@ check_PROGRAMS =					\
 	tests/sampler-types-test			\
 	tests/uniform-initializer-test
 
+noinst_PROGRAMS = glsl_compiler
+
 tests_uniform_initializer_test_SOURCES =		\
 	$(top_srcdir)/src/mesa/main/hash_table.c	\
 	$(top_srcdir)/src/mesa/main/imports.c		\
@@ -99,6 +101,15 @@ libglsl_la_SOURCES =					\
 	glsl_parser.cpp					\
 	$(LIBGLSL_FILES)
 
+glsl_compiler_SOURCES = \
+	$(top_srcdir)/src/mesa/main/hash_table.c \
+	$(top_srcdir)/src/mesa/main/imports.c \
+	$(top_srcdir)/src/mesa/program/prog_hash_table.c \
+	$(top_srcdir)/src/mesa/program/symbol_table.c \
+	$(GLSL_COMPILER_CXX_FILES)
+
+glsl_compiler_LDADD = libglsl.la
+
 glsl_test_SOURCES = \
 	$(top_srcdir)/src/mesa/main/hash_table.c \
 	$(top_srcdir)/src/mesa/main/imports.c \
diff --git a/src/glsl/SConscript b/src/glsl/SConscript
index e386bdf..fe9d507 100644
--- a/src/glsl/SConscript
+++ b/src/glsl/SConscript
@@ -98,11 +98,11 @@ if env['platform'] == 'windows':
 
 env.Prepend(LIBS = [glsl])
 
-glsl2 = env.Program(
-    target = 'glsl2',
+glsl_compiler = env.Program(
+    target = 'glsl_compiler',
     source = compiler_objs,
 )
-env.Alias('glsl2', glsl2)
+env.Alias('glsl_compiler', glsl_compiler)
 
 glcpp = env.Program(
     target = 'glcpp/glcpp',
diff --git a/src/glsl/ast_array_index.cpp b/src/glsl/ast_array_index.cpp
index 51f6b10..b457ec8 100644
--- a/src/glsl/ast_array_index.cpp
+++ b/src/glsl/ast_array_index.cpp
@@ -25,6 +25,71 @@
 #include "glsl_types.h"
 #include "ir.h"
 
+
+/**
+ * If \c ir is a reference to an array for which we are tracking the max array
+ * element accessed, track that the given element has been accessed.
+ * Otherwise do nothing.
+ *
+ * This function also checks whether the array is a built-in array whose
+ * maximum size is too small to accommodate the given index, and if so uses
+ * loc and state to report the error.
+ */
+static void
+update_max_array_access(ir_rvalue *ir, unsigned idx, YYLTYPE *loc,
+                        struct _mesa_glsl_parse_state *state)
+{
+   if (ir_dereference_variable *deref_var = ir->as_dereference_variable()) {
+      ir_variable *var = deref_var->var;
+      if (idx > var->max_array_access) {
+         var->max_array_access = idx;
+
+         /* Check whether this access will, as a side effect, implicitly cause
+          * the size of a built-in array to be too large.
+          */
+         check_builtin_array_max_size(var->name, idx+1, *loc, state);
+      }
+   } else if (ir_dereference_record *deref_record =
+              ir->as_dereference_record()) {
+      /* There are two possibilities we need to consider:
+       *
+       * - Accessing an element of an array that is a member of a named
+       *   interface block (e.g. ifc.foo[i])
+       *
+       * - Accessing an element of an array that is a member of a named
+       *   interface block array (e.g. ifc[j].foo[i]).
+       */
+      ir_dereference_variable *deref_var =
+         deref_record->record->as_dereference_variable();
+      if (deref_var == NULL) {
+         if (ir_dereference_array *deref_array =
+             deref_record->record->as_dereference_array()) {
+            deref_var = deref_array->array->as_dereference_variable();
+         }
+      }
+
+      if (deref_var != NULL) {
+         if (deref_var->var->is_interface_instance()) {
+            const glsl_type *interface_type =
+               deref_var->var->get_interface_type();
+            unsigned field_index =
+               deref_record->record->type->field_index(deref_record->field);
+            assert(field_index < interface_type->length);
+            if (idx > deref_var->var->max_ifc_array_access[field_index]) {
+               deref_var->var->max_ifc_array_access[field_index] = idx;
+
+               /* Check whether this access will, as a side effect, implicitly
+                * cause the size of a built-in array to be too large.
+                */
+               check_builtin_array_max_size(deref_record->field, idx+1, *loc,
+                                            state);
+            }
+         }
+      }
+   }
+}
+
+
 ir_rvalue *
 _mesa_ast_array_index_to_hir(void *mem_ctx,
 			     struct _mesa_glsl_parse_state *state,
@@ -97,23 +162,8 @@ _mesa_ast_array_index_to_hir(void *mem_ctx,
 			  type_name);
       }
 
-      if (array->type->is_array()) {
-	 /* If the array is a variable dereference, it dereferences the
-	  * whole array, by definition.  Use this to get the variable.
-	  *
-	  * FINISHME: Should some methods for getting / setting / testing
-	  * FINISHME: array access limits be added to ir_dereference?
-	  */
-	 ir_variable *const v = array->whole_variable_referenced();
-	 if ((v != NULL) && (unsigned(idx) > v->max_array_access)) {
-	    v->max_array_access = idx;
-
-	    /* Check whether this access will, as a side effect, implicitly
-	     * cause the size of a built-in array to be too large.
-	     */
-	    check_builtin_array_max_size(v->name, idx+1, loc, state);
-	 }
-      }
+      if (array->type->is_array())
+         update_max_array_access(array, idx, &loc, state);
    } else if (const_index == NULL && array->type->is_array()) {
       if (array->type->array_size() == 0) {
 	 _mesa_glsl_error(&loc, state, "unsized array index must be constant");
diff --git a/src/glsl/ast_to_hir.cpp b/src/glsl/ast_to_hir.cpp
index 0859d9e..dfa32d9 100644
--- a/src/glsl/ast_to_hir.cpp
+++ b/src/glsl/ast_to_hir.cpp
@@ -2326,9 +2326,10 @@ apply_type_qualifier_to_variable(const struct ast_type_qualifier *qual,
  * A pointer to an existing variable in the current scope if the declaration
  * is a redeclaration, \c NULL otherwise.
  */
-ir_variable *
-get_variable_being_redeclared(ir_variable *var, ast_declaration *decl,
-			      struct _mesa_glsl_parse_state *state)
+static ir_variable *
+get_variable_being_redeclared(ir_variable *var, YYLTYPE loc,
+                              struct _mesa_glsl_parse_state *state,
+                              bool allow_all_redeclarations)
 {
    /* Check if this declaration is actually a re-declaration, either to
     * resize an array or add qualifiers to an existing variable.
@@ -2336,16 +2337,14 @@ get_variable_being_redeclared(ir_variable *var, ast_declaration *decl,
     * This is allowed for variables in the current scope, or when at
     * global scope (for built-ins in the implicit outer scope).
     */
-   ir_variable *earlier = state->symbols->get_variable(decl->identifier);
+   ir_variable *earlier = state->symbols->get_variable(var->name);
    if (earlier == NULL ||
        (state->current_function != NULL &&
-	!state->symbols->name_declared_this_scope(decl->identifier))) {
+	!state->symbols->name_declared_this_scope(var->name))) {
       return NULL;
    }
 
 
-   YYLTYPE loc = decl->get_location();
-
    /* From page 24 (page 30 of the PDF) of the GLSL 1.50 spec,
     *
     * "It is legal to declare an array without a size and then
@@ -2433,8 +2432,18 @@ get_variable_being_redeclared(ir_variable *var, ast_declaration *decl,
 
       earlier->depth_layout = var->depth_layout;
 
+   } else if (allow_all_redeclarations) {
+      if (earlier->mode != var->mode) {
+         _mesa_glsl_error(&loc, state,
+                          "redeclaration of `%s' with incorrect qualifiers",
+                          var->name);
+      } else if (earlier->type != var->type) {
+         _mesa_glsl_error(&loc, state,
+                          "redeclaration of `%s' has incorrect type",
+                          var->name);
+      }
    } else {
-      _mesa_glsl_error(&loc, state, "`%s' redeclared", decl->identifier);
+      _mesa_glsl_error(&loc, state, "`%s' redeclared", var->name);
    }
 
    return earlier;
@@ -2649,6 +2658,36 @@ handle_geometry_shader_input_decl(struct _mesa_glsl_parse_state *state,
    }
 }
 
+
+void
+validate_identifier(const char *identifier, YYLTYPE loc,
+                    struct _mesa_glsl_parse_state *state)
+{
+   /* From page 15 (page 21 of the PDF) of the GLSL 1.10 spec,
+    *
+    *   "Identifiers starting with "gl_" are reserved for use by
+    *   OpenGL, and may not be declared in a shader as either a
+    *   variable or a function."
+    */
+   if (strncmp(identifier, "gl_", 3) == 0) {
+      _mesa_glsl_error(&loc, state,
+                       "identifier `%s' uses reserved `gl_' prefix",
+                       identifier);
+   } else if (strstr(identifier, "__")) {
+      /* From page 14 (page 20 of the PDF) of the GLSL 1.10
+       * spec:
+       *
+       *     "In addition, all identifiers containing two
+       *      consecutive underscores (__) are reserved as
+       *      possible future keywords."
+       */
+      _mesa_glsl_error(&loc, state,
+                       "identifier `%s' uses reserved `__' string",
+                       identifier);
+   }
+}
+
+
 ir_rvalue *
 ast_declarator_list::hir(exec_list *instructions,
 			 struct _mesa_glsl_parse_state *state)
@@ -3191,7 +3230,9 @@ ast_declarator_list::hir(exec_list *instructions,
        * instruction stream.
        */
       exec_list initializer_instructions;
-      ir_variable *earlier = get_variable_being_redeclared(var, decl, state);
+      ir_variable *earlier =
+         get_variable_being_redeclared(var, decl->get_location(), state,
+                                       false /* allow_all_redeclarations */);
 
       if (decl->initializer != NULL) {
 	 result = process_initializer((earlier == NULL) ? var : earlier,
@@ -3243,28 +3284,7 @@ ast_declarator_list::hir(exec_list *instructions,
        * created for the declaration should be added to the IR stream.
        */
       if (earlier == NULL) {
-	 /* From page 15 (page 21 of the PDF) of the GLSL 1.10 spec,
-	  *
-	  *   "Identifiers starting with "gl_" are reserved for use by
-	  *   OpenGL, and may not be declared in a shader as either a
-	  *   variable or a function."
-	  */
-	 if (strncmp(decl->identifier, "gl_", 3) == 0)
-	    _mesa_glsl_error(& loc, state,
-			     "identifier `%s' uses reserved `gl_' prefix",
-			     decl->identifier);
-	 else if (strstr(decl->identifier, "__")) {
-	    /* From page 14 (page 20 of the PDF) of the GLSL 1.10
-	     * spec:
-	     *
-	     *     "In addition, all identifiers containing two
-	     *      consecutive underscores (__) are reserved as
-	     *      possible future keywords."
-	     */
-	    _mesa_glsl_error(& loc, state,
-			     "identifier `%s' uses reserved `__' string",
-			     decl->identifier);
-	 }
+         validate_identifier(decl->identifier, loc, state);
 
 	 /* Add the variable to the symbol table.  Note that the initializer's
 	  * IR was already processed earlier (though it hasn't been emitted
@@ -3505,17 +3525,7 @@ ast_function::hir(exec_list *instructions,
 		       "function body", name);
    }
 
-   /* From page 15 (page 21 of the PDF) of the GLSL 1.10 spec,
-    *
-    *   "Identifiers starting with "gl_" are reserved for use by
-    *   OpenGL, and may not be declared in a shader as either a
-    *   variable or a function."
-    */
-   if (strncmp(name, "gl_", 3) == 0) {
-      YYLTYPE loc = this->get_location();
-      _mesa_glsl_error(&loc, state,
-		       "identifier `%s' uses reserved `gl_' prefix", name);
-   }
+   validate_identifier(name, this->get_location(), state);
 
    /* Convert the list of function parameters to HIR now so that they can be
     * used below to compare this function's signature with previously seen
@@ -4411,7 +4421,8 @@ ast_process_structure_or_interface_block(exec_list *instructions,
 					 YYLTYPE &loc,
 					 glsl_struct_field **fields_ret,
                                          bool is_interface,
-                                         bool block_row_major)
+                                         bool block_row_major,
+                                         bool allow_reserved_names)
 {
    unsigned decl_count = 0;
 
@@ -4453,6 +4464,9 @@ ast_process_structure_or_interface_block(exec_list *instructions,
 
       foreach_list_typed (ast_declaration, decl, link,
 			  &decl_list->declarations) {
+         if (!allow_reserved_names)
+            validate_identifier(decl->identifier, loc, state);
+
          /* From the GL_ARB_uniform_buffer_object spec:
           *
           *     "Sampler types are not allowed inside of uniform
@@ -4491,6 +4505,7 @@ ast_process_structure_or_interface_block(exec_list *instructions,
 	 }
          fields[i].type = field_type;
 	 fields[i].name = decl->identifier;
+         fields[i].location = -1;
 
          if (qual->flags.q.row_major || qual->flags.q.column_major) {
             if (!qual->flags.q.uniform) {
@@ -4568,7 +4583,10 @@ ast_struct_specifier::hir(exec_list *instructions,
 					       loc,
 					       &fields,
                                                false,
-                                               false);
+                                               false,
+                                               false /* allow_reserved_names */);
+
+   validate_identifier(this->name, loc, state);
 
    const glsl_type *t =
       glsl_type::get_record_instance(fields, decl_count, this->name);
@@ -4593,6 +4611,39 @@ ast_struct_specifier::hir(exec_list *instructions,
    return NULL;
 }
 
+
+/**
+ * Visitor class which detects whether a given interface block has been used.
+ */
+class interface_block_usage_visitor : public ir_hierarchical_visitor
+{
+public:
+   interface_block_usage_visitor(ir_variable_mode mode, const glsl_type *block)
+      : mode(mode), block(block), found(false)
+   {
+   }
+
+   virtual ir_visitor_status visit(ir_dereference_variable *ir)
+   {
+      if (ir->var->mode == mode && ir->var->get_interface_type() == block) {
+         found = true;
+         return visit_stop;
+      }
+      return visit_continue;
+   }
+
+   bool usage_found() const
+   {
+      return this->found;
+   }
+
+private:
+   ir_variable_mode mode;
+   const glsl_type *block;
+   bool found;
+};
+
+
 ir_rvalue *
 ast_interface_block::hir(exec_list *instructions,
 		          struct _mesa_glsl_parse_state *state)
@@ -4614,6 +4665,7 @@ ast_interface_block::hir(exec_list *instructions,
       packing = GLSL_INTERFACE_PACKING_STD140;
    }
 
+   bool redeclaring_per_vertex = strcmp(this->block_name, "gl_PerVertex") == 0;
    bool block_row_major = this->layout.flags.q.row_major;
    exec_list declared_variables;
    glsl_struct_field *fields;
@@ -4624,7 +4676,8 @@ ast_interface_block::hir(exec_list *instructions,
                                                loc,
                                                &fields,
                                                true,
-                                               block_row_major);
+                                               block_row_major,
+                                               redeclaring_per_vertex);
 
    ir_variable_mode var_mode;
    const char *iface_type_name;
@@ -4643,6 +4696,102 @@ ast_interface_block::hir(exec_list *instructions,
       assert(!"interface block layout qualifier not found!");
    }
 
+   if (!redeclaring_per_vertex)
+      validate_identifier(this->block_name, loc, state);
+
+   const glsl_type *earlier_per_vertex = NULL;
+   if (redeclaring_per_vertex) {
+      /* Find the previous declaration of gl_PerVertex.  If we're redeclaring
+       * the named interface block gl_in, we can find it by looking at the
+       * previous declaration of gl_in.  Otherwise we can find it by looking
+       * at the previous decalartion of any of the built-in outputs,
+       * e.g. gl_Position.
+       *
+       * Also check that the instance name and array-ness of the redeclaration
+       * are correct.
+       */
+      switch (var_mode) {
+      case ir_var_shader_in:
+         if (ir_variable *earlier_gl_in =
+             state->symbols->get_variable("gl_in")) {
+            earlier_per_vertex = earlier_gl_in->get_interface_type();
+         } else {
+            _mesa_glsl_error(&loc, state,
+                             "redeclaration of gl_PerVertex input not allowed "
+                             "in the %s shader",
+                             _mesa_glsl_shader_target_name(state->target));
+         }
+         if (this->instance_name == NULL ||
+             strcmp(this->instance_name, "gl_in") != 0 || !this->is_array) {
+            _mesa_glsl_error(&loc, state,
+                             "gl_PerVertex input must be redeclared as "
+                             "gl_in[]");
+         }
+         break;
+      case ir_var_shader_out:
+         if (ir_variable *earlier_gl_Position =
+             state->symbols->get_variable("gl_Position")) {
+            earlier_per_vertex = earlier_gl_Position->get_interface_type();
+         } else {
+            _mesa_glsl_error(&loc, state,
+                             "redeclaration of gl_PerVertex output not "
+                             "allowed in the %s shader",
+                             _mesa_glsl_shader_target_name(state->target));
+         }
+         if (this->instance_name != NULL) {
+            _mesa_glsl_error(&loc, state,
+                             "gl_PerVertex input may not be redeclared with "
+                             "an instance name");
+         }
+         break;
+      default:
+         _mesa_glsl_error(&loc, state,
+                          "gl_PerVertex must be declared as an input or an "
+                          "output");
+         break;
+      }
+
+      if (earlier_per_vertex == NULL) {
+         /* An error has already been reported.  Bail out to avoid null
+          * dereferences later in this function.
+          */
+         return NULL;
+      }
+
+      /* Copy locations from the old gl_PerVertex interface block. */
+      for (unsigned i = 0; i < num_variables; i++) {
+         int j = earlier_per_vertex->field_index(fields[i].name);
+         if (j == -1) {
+            _mesa_glsl_error(&loc, state,
+                             "redeclaration of gl_PerVertex must be a subset "
+                             "of the built-in members of gl_PerVertex");
+         } else {
+            fields[i].location =
+               earlier_per_vertex->fields.structure[j].location;
+         }
+      }
+
+      /* From section 7.1 ("Built-in Language Variables") of the GLSL 4.10
+       * spec:
+       *
+       *     If a built-in interface block is redeclared, it must appear in
+       *     the shader before any use of any member included in the built-in
+       *     declaration, or a compilation error will result.
+       *
+       * This appears to be a clarification to the behaviour established for
+       * gl_PerVertex by GLSL 1.50, therefore we implement this behaviour
+       * regardless of GLSL version.
+       */
+      interface_block_usage_visitor v(var_mode, earlier_per_vertex);
+      v.run(instructions);
+      if (v.usage_found()) {
+         _mesa_glsl_error(&loc, state,
+                          "redeclaration of a built-in interface block must "
+                          "appear before any use of any member of the "
+                          "interface block");
+      }
+   }
+
    const glsl_type *block_type =
       glsl_type::get_interface_instance(fields,
                                         num_variables,
@@ -4682,6 +4831,9 @@ ast_interface_block::hir(exec_list *instructions,
     *     field selector ( . ) operator (analogously to structures)."
     */
    if (this->instance_name) {
+      if (!redeclaring_per_vertex)
+         validate_identifier(this->instance_name, loc, state);
+
       ir_variable *var;
 
       if (this->is_array) {
@@ -4724,11 +4876,23 @@ ast_interface_block::hir(exec_list *instructions,
                                       var_mode);
       }
 
-      var->interface_type = block_type;
+      var->init_interface_type(block_type);
       if (state->target == geometry_shader && var_mode == ir_var_shader_in)
          handle_geometry_shader_input_decl(state, loc, var);
-      state->symbols->add_variable(var);
-      instructions->push_tail(var);
+
+      if (ir_variable *earlier =
+          state->symbols->get_variable(this->instance_name)) {
+         if (!redeclaring_per_vertex) {
+            _mesa_glsl_error(&loc, state, "`%s' redeclared",
+                             this->instance_name);
+         }
+         earlier->type = var->type;
+         earlier->reinit_interface_type(block_type);
+         delete var;
+      } else {
+         state->symbols->add_variable(var);
+         instructions->push_tail(var);
+      }
    } else {
       /* In order to have an array size, the block must also be declared with
        * an instane name.
@@ -4740,7 +4904,24 @@ ast_interface_block::hir(exec_list *instructions,
             new(state) ir_variable(fields[i].type,
                                    ralloc_strdup(state, fields[i].name),
                                    var_mode);
-         var->interface_type = block_type;
+         var->init_interface_type(block_type);
+
+         if (redeclaring_per_vertex) {
+            ir_variable *earlier =
+               get_variable_being_redeclared(var, loc, state,
+                                             true /* allow_all_redeclarations */);
+            if (strncmp(var->name, "gl_", 3) != 0 || earlier == NULL) {
+               _mesa_glsl_error(&loc, state,
+                                "redeclaration of gl_PerVertex can only "
+                                "include built-in variables");
+            } else {
+               earlier->reinit_interface_type(block_type);
+            }
+            continue;
+         }
+
+         if (state->symbols->get_variable(var->name) != NULL)
+            _mesa_glsl_error(&loc, state, "`%s' redeclared", var->name);
 
          /* Propagate the "binding" keyword into this UBO's fields;
           * the UBO declaration itself doesn't get an ir_variable unless it
@@ -4752,6 +4933,38 @@ ast_interface_block::hir(exec_list *instructions,
          state->symbols->add_variable(var);
          instructions->push_tail(var);
       }
+
+      if (redeclaring_per_vertex && block_type != earlier_per_vertex) {
+         /* From section 7.1 ("Built-in Language Variables") of the GLSL 4.10 spec:
+          *
+          *     It is also a compilation error ... to redeclare a built-in
+          *     block and then use a member from that built-in block that was
+          *     not included in the redeclaration.
+          *
+          * This appears to be a clarification to the behaviour established
+          * for gl_PerVertex by GLSL 1.50, therefore we implement this
+          * behaviour regardless of GLSL version.
+          *
+          * To prevent the shader from using a member that was not included in
+          * the redeclaration, we disable any ir_variables that are still
+          * associated with the old declaration of gl_PerVertex (since we've
+          * already updated all of the variables contained in the new
+          * gl_PerVertex to point to it).
+          *
+          * As a side effect this will prevent
+          * validate_intrastage_interface_blocks() from getting confused and
+          * thinking there are conflicting definitions of gl_PerVertex in the
+          * shader.
+          */
+         foreach_list_safe(node, instructions) {
+            ir_variable *const var = ((ir_instruction *) node)->as_variable();
+            if (var != NULL &&
+                var->get_interface_type() == earlier_per_vertex) {
+               state->symbols->disable_variable(var->name);
+               var->remove();
+            }
+         }
+      }
    }
 
    return NULL;
diff --git a/src/glsl/builtin_functions.cpp b/src/glsl/builtin_functions.cpp
index df735ef..d40888d 100644
--- a/src/glsl/builtin_functions.cpp
+++ b/src/glsl/builtin_functions.cpp
@@ -256,6 +256,13 @@ texture_cube_map_array(const _mesa_glsl_parse_state *state)
 }
 
 static bool
+texture_query_levels(const _mesa_glsl_parse_state *state)
+{
+   return state->is_version(430, 0) ||
+          state->ARB_texture_query_levels_enable;
+}
+
+static bool
 texture_query_lod(const _mesa_glsl_parse_state *state)
 {
    return state->target == fragment_shader &&
@@ -266,7 +273,8 @@ static bool
 texture_gather(const _mesa_glsl_parse_state *state)
 {
    return state->is_version(400, 0) ||
-          state->ARB_texture_gather_enable;
+          state->ARB_texture_gather_enable ||
+          state->ARB_gpu_shader5_enable;
 }
 
 /* Desktop GL or OES_standard_derivatives + fragment shader only */
@@ -486,6 +494,7 @@ private:
 /** Flags to _texture() */
 #define TEX_PROJECT 1
 #define TEX_OFFSET  2
+#define TEX_COMPONENT 4
 
    ir_function_signature *_texture(ir_texture_opcode opcode,
                                    builtin_available_predicate avail,
@@ -504,6 +513,7 @@ private:
    B0(EndPrimitive)
 
    B2(textureQueryLod);
+   B1(textureQueryLevels);
    B1(dFdx);
    B1(dFdy);
    B1(fwidth);
@@ -521,6 +531,9 @@ private:
    B1(fma)
    B2(ldexp)
    B2(frexp)
+   B1(uaddCarry)
+   B1(usubBorrow)
+   B1(mulExtended)
 #undef B0
 #undef B1
 #undef B2
@@ -1603,6 +1616,39 @@ builtin_builder::create_builtins()
                 _textureQueryLod(glsl_type::samplerCubeArrayShadow_type, glsl_type::vec3_type),
                 NULL);
 
+   add_function("textureQueryLevels",
+                _textureQueryLevels(glsl_type::sampler1D_type),
+                _textureQueryLevels(glsl_type::sampler2D_type),
+                _textureQueryLevels(glsl_type::sampler3D_type),
+                _textureQueryLevels(glsl_type::samplerCube_type),
+                _textureQueryLevels(glsl_type::sampler1DArray_type),
+                _textureQueryLevels(glsl_type::sampler2DArray_type),
+                _textureQueryLevels(glsl_type::samplerCubeArray_type),
+                _textureQueryLevels(glsl_type::sampler1DShadow_type),
+                _textureQueryLevels(glsl_type::sampler2DShadow_type),
+                _textureQueryLevels(glsl_type::samplerCubeShadow_type),
+                _textureQueryLevels(glsl_type::sampler1DArrayShadow_type),
+                _textureQueryLevels(glsl_type::sampler2DArrayShadow_type),
+                _textureQueryLevels(glsl_type::samplerCubeArrayShadow_type),
+
+                _textureQueryLevels(glsl_type::isampler1D_type),
+                _textureQueryLevels(glsl_type::isampler2D_type),
+                _textureQueryLevels(glsl_type::isampler3D_type),
+                _textureQueryLevels(glsl_type::isamplerCube_type),
+                _textureQueryLevels(glsl_type::isampler1DArray_type),
+                _textureQueryLevels(glsl_type::isampler2DArray_type),
+                _textureQueryLevels(glsl_type::isamplerCubeArray_type),
+
+                _textureQueryLevels(glsl_type::usampler1D_type),
+                _textureQueryLevels(glsl_type::usampler2D_type),
+                _textureQueryLevels(glsl_type::usampler3D_type),
+                _textureQueryLevels(glsl_type::usamplerCube_type),
+                _textureQueryLevels(glsl_type::usampler1DArray_type),
+                _textureQueryLevels(glsl_type::usampler2DArray_type),
+                _textureQueryLevels(glsl_type::usamplerCubeArray_type),
+
+                NULL);
+
    add_function("texture1D",
                 _texture(ir_tex, v110,         glsl_type::vec4_type,  glsl_type::sampler1D_type, glsl_type::float_type),
                 _texture(ir_txb, v110_fs_only, glsl_type::vec4_type,  glsl_type::sampler1D_type, glsl_type::float_type),
@@ -1828,6 +1874,10 @@ builtin_builder::create_builtins()
                 _texture(ir_tg4, texture_gather, glsl_type::ivec4_type, glsl_type::isampler2D_type, glsl_type::vec2_type),
                 _texture(ir_tg4, texture_gather, glsl_type::uvec4_type, glsl_type::usampler2D_type, glsl_type::vec2_type),
 
+                _texture(ir_tg4, gpu_shader5, glsl_type::vec4_type, glsl_type::sampler2DRect_type, glsl_type::vec2_type),
+                _texture(ir_tg4, gpu_shader5, glsl_type::ivec4_type, glsl_type::isampler2DRect_type, glsl_type::vec2_type),
+                _texture(ir_tg4, gpu_shader5, glsl_type::uvec4_type, glsl_type::usampler2DRect_type, glsl_type::vec2_type),
+
                 _texture(ir_tg4, texture_gather, glsl_type::vec4_type, glsl_type::sampler2DArray_type, glsl_type::vec3_type),
                 _texture(ir_tg4, texture_gather, glsl_type::ivec4_type, glsl_type::isampler2DArray_type, glsl_type::vec3_type),
                 _texture(ir_tg4, texture_gather, glsl_type::uvec4_type, glsl_type::usampler2DArray_type, glsl_type::vec3_type),
@@ -1839,6 +1889,26 @@ builtin_builder::create_builtins()
                 _texture(ir_tg4, texture_gather, glsl_type::vec4_type, glsl_type::samplerCubeArray_type, glsl_type::vec4_type),
                 _texture(ir_tg4, texture_gather, glsl_type::ivec4_type, glsl_type::isamplerCubeArray_type, glsl_type::vec4_type),
                 _texture(ir_tg4, texture_gather, glsl_type::uvec4_type, glsl_type::usamplerCubeArray_type, glsl_type::vec4_type),
+
+                _texture(ir_tg4, gpu_shader5, glsl_type::vec4_type, glsl_type::sampler2D_type, glsl_type::vec2_type, TEX_COMPONENT),
+                _texture(ir_tg4, gpu_shader5, glsl_type::ivec4_type, glsl_type::isampler2D_type, glsl_type::vec2_type, TEX_COMPONENT),
+                _texture(ir_tg4, gpu_shader5, glsl_type::uvec4_type, glsl_type::usampler2D_type, glsl_type::vec2_type, TEX_COMPONENT),
+
+                _texture(ir_tg4, gpu_shader5, glsl_type::vec4_type, glsl_type::sampler2DRect_type, glsl_type::vec2_type, TEX_COMPONENT),
+                _texture(ir_tg4, gpu_shader5, glsl_type::ivec4_type, glsl_type::isampler2DRect_type, glsl_type::vec2_type, TEX_COMPONENT),
+                _texture(ir_tg4, gpu_shader5, glsl_type::uvec4_type, glsl_type::usampler2DRect_type, glsl_type::vec2_type, TEX_COMPONENT),
+
+                _texture(ir_tg4, gpu_shader5, glsl_type::vec4_type, glsl_type::sampler2DArray_type, glsl_type::vec3_type, TEX_COMPONENT),
+                _texture(ir_tg4, gpu_shader5, glsl_type::ivec4_type, glsl_type::isampler2DArray_type, glsl_type::vec3_type, TEX_COMPONENT),
+                _texture(ir_tg4, gpu_shader5, glsl_type::uvec4_type, glsl_type::usampler2DArray_type, glsl_type::vec3_type, TEX_COMPONENT),
+
+                _texture(ir_tg4, gpu_shader5, glsl_type::vec4_type, glsl_type::samplerCube_type, glsl_type::vec3_type, TEX_COMPONENT),
+                _texture(ir_tg4, gpu_shader5, glsl_type::ivec4_type, glsl_type::isamplerCube_type, glsl_type::vec3_type, TEX_COMPONENT),
+                _texture(ir_tg4, gpu_shader5, glsl_type::uvec4_type, glsl_type::usamplerCube_type, glsl_type::vec3_type, TEX_COMPONENT),
+
+                _texture(ir_tg4, gpu_shader5, glsl_type::vec4_type, glsl_type::samplerCubeArray_type, glsl_type::vec4_type, TEX_COMPONENT),
+                _texture(ir_tg4, gpu_shader5, glsl_type::ivec4_type, glsl_type::isamplerCubeArray_type, glsl_type::vec4_type, TEX_COMPONENT),
+                _texture(ir_tg4, gpu_shader5, glsl_type::uvec4_type, glsl_type::usamplerCubeArray_type, glsl_type::vec4_type, TEX_COMPONENT),
                 NULL);
 
    add_function("textureGatherOffset",
@@ -1880,6 +1950,30 @@ builtin_builder::create_builtins()
                 _frexp(glsl_type::vec3_type,  glsl_type::ivec3_type),
                 _frexp(glsl_type::vec4_type,  glsl_type::ivec4_type),
                 NULL);
+   add_function("uaddCarry",
+                _uaddCarry(glsl_type::uint_type),
+                _uaddCarry(glsl_type::uvec2_type),
+                _uaddCarry(glsl_type::uvec3_type),
+                _uaddCarry(glsl_type::uvec4_type),
+                NULL);
+   add_function("usubBorrow",
+                _usubBorrow(glsl_type::uint_type),
+                _usubBorrow(glsl_type::uvec2_type),
+                _usubBorrow(glsl_type::uvec3_type),
+                _usubBorrow(glsl_type::uvec4_type),
+                NULL);
+   add_function("imulExtended",
+                _mulExtended(glsl_type::int_type),
+                _mulExtended(glsl_type::ivec2_type),
+                _mulExtended(glsl_type::ivec3_type),
+                _mulExtended(glsl_type::ivec4_type),
+                NULL);
+   add_function("umulExtended",
+                _mulExtended(glsl_type::uint_type),
+                _mulExtended(glsl_type::uvec2_type),
+                _mulExtended(glsl_type::uvec3_type),
+                _mulExtended(glsl_type::uvec4_type),
+                NULL);
 #undef F
 #undef FI
 #undef FIU
@@ -3281,6 +3375,18 @@ builtin_builder::_texture(ir_texture_opcode opcode,
       tex->offset = var_ref(offset);
    }
 
+   if (opcode == ir_tg4) {
+      if (flags & TEX_COMPONENT) {
+         ir_variable *component =
+            new(mem_ctx) ir_variable(glsl_type::int_type, "comp", ir_var_const_in);
+         sig->parameters.push_tail(component);
+         tex->lod_info.component = var_ref(component);
+      }
+      else {
+         tex->lod_info.component = imm(0);
+      }
+   }
+
    /* The "bias" parameter comes /after/ the "offset" parameter, which is
     * inconsistent with both textureLodOffset and textureGradOffset.
     */
@@ -3393,6 +3499,21 @@ builtin_builder::_textureQueryLod(const glsl_type *sampler_type,
    return sig;
 }
 
+ir_function_signature *
+builtin_builder::_textureQueryLevels(const glsl_type *sampler_type)
+{
+   ir_variable *s = in_var(sampler_type, "sampler");
+   const glsl_type *return_type = glsl_type::int_type;
+   MAKE_SIG(return_type, texture_query_levels, 1, s);
+
+   ir_texture *tex = new(mem_ctx) ir_texture(ir_query_levels);
+   tex->set_sampler(var_ref(s), return_type);
+
+   body.emit(ret(tex));
+
+   return sig;
+}
+
 UNOP(dFdx, ir_unop_dFdx, fs_oes_derivatives)
 UNOP(dFdy, ir_unop_dFdy, fs_oes_derivatives)
 
@@ -3626,6 +3747,52 @@ builtin_builder::_frexp(const glsl_type *x_type, const glsl_type *exp_type)
 
    return sig;
 }
+
+ir_function_signature *
+builtin_builder::_uaddCarry(const glsl_type *type)
+{
+   ir_variable *x = in_var(type, "x");
+   ir_variable *y = in_var(type, "y");
+   ir_variable *carry = out_var(type, "carry");
+   MAKE_SIG(type, gpu_shader5, 3, x, y, carry);
+
+   body.emit(assign(carry, ir_builder::carry(x, y)));
+   body.emit(ret(add(x, y)));
+
+   return sig;
+}
+
+ir_function_signature *
+builtin_builder::_usubBorrow(const glsl_type *type)
+{
+   ir_variable *x = in_var(type, "x");
+   ir_variable *y = in_var(type, "y");
+   ir_variable *borrow = out_var(type, "borrow");
+   MAKE_SIG(type, gpu_shader5, 3, x, y, borrow);
+
+   body.emit(assign(borrow, ir_builder::borrow(x, y)));
+   body.emit(ret(sub(x, y)));
+
+   return sig;
+}
+
+/**
+ * For both imulExtended() and umulExtended() built-ins.
+ */
+ir_function_signature *
+builtin_builder::_mulExtended(const glsl_type *type)
+{
+   ir_variable *x = in_var(type, "x");
+   ir_variable *y = in_var(type, "y");
+   ir_variable *msb = out_var(type, "msb");
+   ir_variable *lsb = out_var(type, "lsb");
+   MAKE_SIG(glsl_type::void_type, gpu_shader5, 4, x, y, msb, lsb);
+
+   body.emit(assign(msb, imul_high(x, y)));
+   body.emit(assign(lsb, mul(x, y)));
+
+   return sig;
+}
 /** @} */
 
 /******************************************************************************/
diff --git a/src/glsl/builtin_types.cpp b/src/glsl/builtin_types.cpp
index 722eda2..1a5e5a1 100644
--- a/src/glsl/builtin_types.cpp
+++ b/src/glsl/builtin_types.cpp
@@ -53,64 +53,64 @@
       &glsl_type::_struct_##NAME##_type;
 
 static const struct glsl_struct_field gl_DepthRangeParameters_fields[] = {
-   { glsl_type::float_type, "near", false },
-   { glsl_type::float_type, "far",  false },
-   { glsl_type::float_type, "diff", false },
+   { glsl_type::float_type, "near", false, -1 },
+   { glsl_type::float_type, "far",  false, -1 },
+   { glsl_type::float_type, "diff", false, -1 },
 };
 
 static const struct glsl_struct_field gl_PointParameters_fields[] = {
-   { glsl_type::float_type, "size", false },
-   { glsl_type::float_type, "sizeMin", false },
-   { glsl_type::float_type, "sizeMax", false },
-   { glsl_type::float_type, "fadeThresholdSize", false },
-   { glsl_type::float_type, "distanceConstantAttenuation", false },
-   { glsl_type::float_type, "distanceLinearAttenuation", false },
-   { glsl_type::float_type, "distanceQuadraticAttenuation", false },
+   { glsl_type::float_type, "size", false, -1 },
+   { glsl_type::float_type, "sizeMin", false, -1 },
+   { glsl_type::float_type, "sizeMax", false, -1 },
+   { glsl_type::float_type, "fadeThresholdSize", false, -1 },
+   { glsl_type::float_type, "distanceConstantAttenuation", false, -1 },
+   { glsl_type::float_type, "distanceLinearAttenuation", false, -1 },
+   { glsl_type::float_type, "distanceQuadraticAttenuation", false, -1 },
 };
 
 static const struct glsl_struct_field gl_MaterialParameters_fields[] = {
-   { glsl_type::vec4_type, "emission", false },
-   { glsl_type::vec4_type, "ambient", false },
-   { glsl_type::vec4_type, "diffuse", false },
-   { glsl_type::vec4_type, "specular", false },
-   { glsl_type::float_type, "shininess", false },
+   { glsl_type::vec4_type, "emission", false, -1 },
+   { glsl_type::vec4_type, "ambient", false, -1 },
+   { glsl_type::vec4_type, "diffuse", false, -1 },
+   { glsl_type::vec4_type, "specular", false, -1 },
+   { glsl_type::float_type, "shininess", false, -1 },
 };
 
 static const struct glsl_struct_field gl_LightSourceParameters_fields[] = {
-   { glsl_type::vec4_type, "ambient", false },
-   { glsl_type::vec4_type, "diffuse", false },
-   { glsl_type::vec4_type, "specular", false },
-   { glsl_type::vec4_type, "position", false },
-   { glsl_type::vec4_type, "halfVector", false },
-   { glsl_type::vec3_type, "spotDirection", false },
-   { glsl_type::float_type, "spotExponent", false },
-   { glsl_type::float_type, "spotCutoff", false },
-   { glsl_type::float_type, "spotCosCutoff", false },
-   { glsl_type::float_type, "constantAttenuation", false },
-   { glsl_type::float_type, "linearAttenuation", false },
-   { glsl_type::float_type, "quadraticAttenuation", false },
+   { glsl_type::vec4_type, "ambient", false, -1 },
+   { glsl_type::vec4_type, "diffuse", false, -1 },
+   { glsl_type::vec4_type, "specular", false, -1 },
+   { glsl_type::vec4_type, "position", false, -1 },
+   { glsl_type::vec4_type, "halfVector", false, -1 },
+   { glsl_type::vec3_type, "spotDirection", false, -1 },
+   { glsl_type::float_type, "spotExponent", false, -1 },
+   { glsl_type::float_type, "spotCutoff", false, -1 },
+   { glsl_type::float_type, "spotCosCutoff", false, -1 },
+   { glsl_type::float_type, "constantAttenuation", false, -1 },
+   { glsl_type::float_type, "linearAttenuation", false, -1 },
+   { glsl_type::float_type, "quadraticAttenuation", false, -1 },
 };
 
 static const struct glsl_struct_field gl_LightModelParameters_fields[] = {
-   { glsl_type::vec4_type, "ambient", false },
+   { glsl_type::vec4_type, "ambient", false, -1 },
 };
 
 static const struct glsl_struct_field gl_LightModelProducts_fields[] = {
-   { glsl_type::vec4_type, "sceneColor", false },
+   { glsl_type::vec4_type, "sceneColor", false, -1 },
 };
 
 static const struct glsl_struct_field gl_LightProducts_fields[] = {
-   { glsl_type::vec4_type, "ambient", false },
-   { glsl_type::vec4_type, "diffuse", false },
-   { glsl_type::vec4_type, "specular", false },
+   { glsl_type::vec4_type, "ambient", false, -1 },
+   { glsl_type::vec4_type, "diffuse", false, -1 },
+   { glsl_type::vec4_type, "specular", false, -1 },
 };
 
 static const struct glsl_struct_field gl_FogParameters_fields[] = {
-   { glsl_type::vec4_type, "color", false },
-   { glsl_type::float_type, "density", false },
-   { glsl_type::float_type, "start", false },
-   { glsl_type::float_type, "end", false },
-   { glsl_type::float_type, "scale", false },
+   { glsl_type::vec4_type, "color", false, -1 },
+   { glsl_type::float_type, "density", false, -1 },
+   { glsl_type::float_type, "start", false, -1 },
+   { glsl_type::float_type, "end", false, -1 },
+   { glsl_type::float_type, "scale", false, -1 },
 };
 
 #include "builtin_type_macros.h"
diff --git a/src/glsl/builtin_variables.cpp b/src/glsl/builtin_variables.cpp
index 6a808c0..64f3406 100644
--- a/src/glsl/builtin_variables.cpp
+++ b/src/glsl/builtin_variables.cpp
@@ -293,6 +293,52 @@ static const struct gl_builtin_uniform_desc _mesa_builtin_uniform_desc[] = {
 
 namespace {
 
+/**
+ * Data structure that accumulates fields for the gl_PerVertex interface
+ * block.
+ */
+class per_vertex_accumulator
+{
+public:
+   per_vertex_accumulator();
+   void add_field(int slot, const glsl_type *type, const char *name);
+   const glsl_type *construct_interface_instance() const;
+
+private:
+   glsl_struct_field fields[10];
+   unsigned num_fields;
+};
+
+
+per_vertex_accumulator::per_vertex_accumulator()
+   : fields(),
+     num_fields(0)
+{
+}
+
+
+void
+per_vertex_accumulator::add_field(int slot, const glsl_type *type,
+                                  const char *name)
+{
+   assert(this->num_fields < ARRAY_SIZE(this->fields));
+   this->fields[this->num_fields].type = type;
+   this->fields[this->num_fields].name = name;
+   this->fields[this->num_fields].row_major = false;
+   this->fields[this->num_fields].location = slot;
+   this->num_fields++;
+}
+
+
+const glsl_type *
+per_vertex_accumulator::construct_interface_instance() const
+{
+   return glsl_type::get_interface_instance(this->fields, this->num_fields,
+                                            GLSL_INTERFACE_PACKING_STD140,
+                                            "gl_PerVertex");
+}
+
+
 class builtin_variable_generator
 {
 public:
@@ -358,6 +404,9 @@ private:
    const glsl_type * const vec4_t;
    const glsl_type * const mat3_t;
    const glsl_type * const mat4_t;
+
+   per_vertex_accumulator per_vertex_in;
+   per_vertex_accumulator per_vertex_out;
 };
 
 
@@ -497,11 +546,12 @@ builtin_variable_generator::generate_constants()
        */
       if (state->is_version(0, 300)) {
          add_const("gl_MaxVertexOutputVectors",
-                   state->Const.MaxVaryingFloats / 4);
+                   state->ctx->Const.VertexProgram.MaxOutputComponents / 4);
          add_const("gl_MaxFragmentInputVectors",
-                   state->Const.MaxVaryingFloats / 4);
+                   state->ctx->Const.FragmentProgram.MaxInputComponents / 4);
       } else {
-         add_const("gl_MaxVaryingVectors", state->Const.MaxVaryingFloats / 4);
+         add_const("gl_MaxVaryingVectors",
+                   state->ctx->Const.MaxVarying);
       }
    } else {
       add_const("gl_MaxVertexUniformComponents",
@@ -510,7 +560,7 @@ builtin_variable_generator::generate_constants()
       /* Note: gl_MaxVaryingFloats was deprecated in GLSL 1.30+, but not
        * removed
        */
-      add_const("gl_MaxVaryingFloats", state->Const.MaxVaryingFloats);
+      add_const("gl_MaxVaryingFloats", state->ctx->Const.MaxVarying * 4);
 
       add_const("gl_MaxFragmentUniformComponents",
                 state->Const.MaxFragmentUniformComponents);
@@ -531,7 +581,38 @@ builtin_variable_generator::generate_constants()
 
    if (state->is_version(130, 0)) {
       add_const("gl_MaxClipDistances", state->Const.MaxClipPlanes);
-      add_const("gl_MaxVaryingComponents", state->Const.MaxVaryingFloats);
+      add_const("gl_MaxVaryingComponents", state->ctx->Const.MaxVarying * 4);
+   }
+
+   if (state->is_version(150, 0)) {
+      add_const("gl_MaxVertexOutputComponents",
+                state->Const.MaxVertexOutputComponents);
+      add_const("gl_MaxGeometryInputComponents",
+                state->Const.MaxGeometryInputComponents);
+      add_const("gl_MaxGeometryOutputComponents",
+                state->Const.MaxGeometryOutputComponents);
+      add_const("gl_MaxFragmentInputComponents",
+                state->Const.MaxFragmentInputComponents);
+      add_const("gl_MaxGeometryTextureImageUnits",
+                state->Const.MaxGeometryTextureImageUnits);
+      add_const("gl_MaxGeometryOutputVertices",
+                state->Const.MaxGeometryOutputVertices);
+      add_const("gl_MaxGeometryTotalOutputComponents",
+                state->Const.MaxGeometryTotalOutputComponents);
+      add_const("gl_MaxGeometryUniformComponents",
+                state->Const.MaxGeometryUniformComponents);
+
+      /* Note: the GLSL 1.50-4.40 specs require
+       * gl_MaxGeometryVaryingComponents to be present, and to be at least 64.
+       * But they do not define what it means (and there does not appear to be
+       * any corresponding constant in the GL specs).  However,
+       * ARB_geometry_shader4 defines MAX_GEOMETRY_VARYING_COMPONENTS_ARB to
+       * be the maximum number of components available for use as geometry
+       * outputs.  So we assume this is a synonym for
+       * gl_MaxGeometryOutputComponents.
+       */
+      add_const("gl_MaxGeometryVaryingComponents",
+                state->Const.MaxGeometryOutputComponents);
    }
 
    if (compatibility) {
@@ -756,10 +837,10 @@ builtin_variable_generator::add_varying(int slot, const glsl_type *type,
 {
    switch (state->target) {
    case geometry_shader:
-      add_input(slot, array(type, 0), name_as_gs_input);
+      this->per_vertex_in.add_field(slot, type, name);
       /* FALLTHROUGH */
    case vertex_shader:
-      add_output(slot, type, name);
+      this->per_vertex_out.add_field(slot, type, name);
       break;
    case fragment_shader:
       add_input(slot, type, name);
@@ -803,6 +884,25 @@ builtin_variable_generator::generate_varyings()
          ADD_VARYING(VARYING_SLOT_BFC1, vec4_t, "gl_BackSecondaryColor");
       }
    }
+
+   if (state->target == geometry_shader) {
+      const glsl_type *per_vertex_in_type =
+         this->per_vertex_in.construct_interface_instance();
+      ir_variable *var = add_variable("gl_in", array(per_vertex_in_type, 0),
+                                      ir_var_shader_in, -1);
+      var->init_interface_type(per_vertex_in_type);
+   }
+   if (state->target == vertex_shader || state->target == geometry_shader) {
+      const glsl_type *per_vertex_out_type =
+         this->per_vertex_out.construct_interface_instance();
+      const glsl_struct_field *fields = per_vertex_out_type->fields.structure;
+      for (unsigned i = 0; i < per_vertex_out_type->length; i++) {
+         ir_variable *var =
+            add_variable(fields[i].name, fields[i].type, ir_var_shader_out,
+                         fields[i].location);
+         var->init_interface_type(per_vertex_out_type);
+      }
+   }
 }
 
 
diff --git a/src/glsl/glcpp/glcpp-parse.y b/src/glsl/glcpp/glcpp-parse.y
index c7ad3e9..02100ab 100644
--- a/src/glsl/glcpp/glcpp-parse.y
+++ b/src/glsl/glcpp/glcpp-parse.y
@@ -1234,6 +1234,9 @@ glcpp_parser_create (const struct gl_extensions *extensions, int api)
 	      if (extensions->ARB_texture_multisample)
 	         add_builtin_define(parser, "GL_ARB_texture_multisample", 1);
 
+              if (extensions->ARB_texture_query_levels)
+                 add_builtin_define(parser, "GL_ARB_texture_query_levels", 1);
+
 	      if (extensions->ARB_texture_query_lod)
 	         add_builtin_define(parser, "GL_ARB_texture_query_lod", 1);
 
diff --git a/src/glsl/glsl_parser.yy b/src/glsl/glsl_parser.yy
index 912931a..00589e2 100644
--- a/src/glsl/glsl_parser.yy
+++ b/src/glsl/glsl_parser.yy
@@ -43,6 +43,38 @@ _mesa_glsl_lex(YYSTYPE *val, YYLTYPE *loc, _mesa_glsl_parse_state *state)
 {
    return _mesa_glsl_lexer_lex(val, loc, state->scanner);
 }
+
+static bool match_layout_qualifier(const char *s1, const char *s2,
+                                   _mesa_glsl_parse_state *state)
+{
+   /* From the GLSL 1.50 spec, section 4.3.8 (Layout Qualifiers):
+    *
+    *     "The tokens in any layout-qualifier-id-list ... are not case
+    *     sensitive, unless explicitly noted otherwise."
+    *
+    * The text "unless explicitly noted otherwise" appears to be
+    * vacuous--no desktop GLSL spec (up through GLSL 4.40) notes
+    * otherwise.
+    *
+    * However, the GLSL ES 3.00 spec says, in section 4.3.8 (Layout
+    * Qualifiers):
+    *
+    *     "As for other identifiers, they are case sensitive."
+    *
+    * So we need to do a case-sensitive or a case-insensitive match,
+    * depending on whether we are compiling for GLSL ES.
+    */
+   if (state->es_shader)
+      return strcmp(s1, s2);
+   else {
+#if defined(_MSC_VER)
+      /* MSVC doesn't have a strcasecmp() function; instead it has _stricmp. */
+      return _stricmp(s1, s2);
+#else
+      return strcasecmp(s1, s2);
+#endif
+   }
+}
 %}
 
 %expect 0
@@ -1160,9 +1192,10 @@ layout_qualifier_id:
       /* Layout qualifiers for ARB_fragment_coord_conventions. */
       if (!$$.flags.i && (state->ARB_fragment_coord_conventions_enable ||
                           state->is_version(150, 0))) {
-         if (strcmp($1, "origin_upper_left") == 0) {
+         if (match_layout_qualifier($1, "origin_upper_left", state) == 0) {
             $$.flags.q.origin_upper_left = 1;
-         } else if (strcmp($1, "pixel_center_integer") == 0) {
+         } else if (match_layout_qualifier($1, "pixel_center_integer",
+                                           state) == 0) {
             $$.flags.q.pixel_center_integer = 1;
          }
 
@@ -1177,13 +1210,14 @@ layout_qualifier_id:
       if (!$$.flags.i &&
           (state->AMD_conservative_depth_enable ||
            state->ARB_conservative_depth_enable)) {
-         if (strcmp($1, "depth_any") == 0) {
+         if (match_layout_qualifier($1, "depth_any", state) == 0) {
             $$.flags.q.depth_any = 1;
-         } else if (strcmp($1, "depth_greater") == 0) {
+         } else if (match_layout_qualifier($1, "depth_greater", state) == 0) {
             $$.flags.q.depth_greater = 1;
-         } else if (strcmp($1, "depth_less") == 0) {
+         } else if (match_layout_qualifier($1, "depth_less", state) == 0) {
             $$.flags.q.depth_less = 1;
-         } else if (strcmp($1, "depth_unchanged") == 0) {
+         } else if (match_layout_qualifier($1, "depth_unchanged",
+                                           state) == 0) {
             $$.flags.q.depth_unchanged = 1;
          }
 
@@ -1201,20 +1235,32 @@ layout_qualifier_id:
 
       /* See also interface_block_layout_qualifier. */
       if (!$$.flags.i && state->has_uniform_buffer_objects()) {
-         if (strcmp($1, "std140") == 0) {
+         if (match_layout_qualifier($1, "std140", state) == 0) {
             $$.flags.q.std140 = 1;
-         } else if (strcmp($1, "shared") == 0) {
+         } else if (match_layout_qualifier($1, "shared", state) == 0) {
             $$.flags.q.shared = 1;
-         } else if (strcmp($1, "column_major") == 0) {
+         } else if (match_layout_qualifier($1, "column_major", state) == 0) {
             $$.flags.q.column_major = 1;
          /* "row_major" is a reserved word in GLSL 1.30+. Its token is parsed
           * below in the interface_block_layout_qualifier rule.
           *
           * It is not a reserved word in GLSL ES 3.00, so it's handled here as
           * an identifier.
+          *
+          * Also, this takes care of alternate capitalizations of
+          * "row_major" (which is necessary because layout qualifiers
+          * are case-insensitive in desktop GLSL).
           */
-         } else if (strcmp($1, "row_major") == 0) {
+         } else if (match_layout_qualifier($1, "row_major", state) == 0) {
             $$.flags.q.row_major = 1;
+         /* "packed" is a reserved word in GLSL, and its token is
+          * parsed below in the interface_block_layout_qualifier rule.
+          * However, we must take care of alternate capitalizations of
+          * "packed", because layout qualifiers are case-insensitive
+          * in desktop GLSL.
+          */
+         } else if (match_layout_qualifier($1, "packed", state) == 0) {
+           $$.flags.q.packed = 1;
          }
 
          if ($$.flags.i && state->ARB_uniform_buffer_object_warn) {
@@ -1239,7 +1285,7 @@ layout_qualifier_id:
                  { "triangle_strip", GL_TRIANGLE_STRIP },
          };
          for (unsigned i = 0; i < Elements(map); i++) {
-            if (strcmp($1, map[i].s) == 0) {
+            if (match_layout_qualifier($1, map[i].s, state) == 0) {
                $$.flags.q.prim_type = 1;
                $$.prim_type = map[i].e;
                break;
@@ -1263,7 +1309,7 @@ layout_qualifier_id:
       memset(& $$, 0, sizeof($$));
 
       if (state->has_explicit_attrib_location()) {
-         if (strcmp("location", $1) == 0) {
+         if (match_layout_qualifier("location", $1, state) == 0) {
             $$.flags.q.explicit_location = 1;
 
             if ($3 >= 0) {
@@ -1275,7 +1321,7 @@ layout_qualifier_id:
             }
          }
 
-         if (strcmp("index", $1) == 0) {
+         if (match_layout_qualifier("index", $1, state) == 0) {
             $$.flags.q.explicit_index = 1;
 
             if ($3 >= 0) {
@@ -1289,12 +1335,12 @@ layout_qualifier_id:
       }
 
       if (state->ARB_shading_language_420pack_enable &&
-          strcmp("binding", $1) == 0) {
+          match_layout_qualifier("binding", $1, state) == 0) {
          $$.flags.q.explicit_binding = 1;
          $$.binding = $3;
       }
 
-      if (strcmp("max_vertices", $1) == 0) {
+      if (match_layout_qualifier("max_vertices", $1, state) == 0) {
          $$.flags.q.max_vertices = 1;
 
          if ($3 < 0) {
@@ -1344,6 +1390,10 @@ layout_qualifier_id:
  * (due to them being reserved keywords) instead of identifiers like
  * most qualifiers.  See the any_identifier path of
  * layout_qualifier_id for the others.
+ *
+ * Note that since layout qualifiers are case-insensitive in desktop
+ * GLSL, all of these qualifiers need to be handled as identifiers as
+ * well (by the any_identifier path of layout_qualifier_id).
  */
 interface_block_layout_qualifier:
    ROW_MAJOR
@@ -1752,6 +1802,12 @@ struct_declarator:
       $$ = new(ctx) ast_declaration($1, false, NULL, NULL);
       $$->set_location(yylloc);
    }
+   | any_identifier '[' ']'
+   {
+      void *ctx = state;
+      $$ = new(ctx) ast_declaration($1, true, NULL, NULL);
+      $$->set_location(yylloc);
+   }
    | any_identifier '[' constant_expression ']'
    {
       void *ctx = state;
diff --git a/src/glsl/glsl_parser_extras.cpp b/src/glsl/glsl_parser_extras.cpp
index 7368a71..be17109 100644
--- a/src/glsl/glsl_parser_extras.cpp
+++ b/src/glsl/glsl_parser_extras.cpp
@@ -99,7 +99,6 @@ _mesa_glsl_parse_state::_mesa_glsl_parse_state(struct gl_context *_ctx,
    this->Const.MaxTextureCoords = ctx->Const.MaxTextureCoordUnits;
    this->Const.MaxVertexAttribs = ctx->Const.VertexProgram.MaxAttribs;
    this->Const.MaxVertexUniformComponents = ctx->Const.VertexProgram.MaxUniformComponents;
-   this->Const.MaxVaryingFloats = ctx->Const.MaxVarying * 4;
    this->Const.MaxVertexTextureImageUnits = ctx->Const.VertexProgram.MaxTextureImageUnits;
    this->Const.MaxCombinedTextureImageUnits = ctx->Const.MaxCombinedTextureImageUnits;
    this->Const.MaxTextureImageUnits = ctx->Const.FragmentProgram.MaxTextureImageUnits;
@@ -109,6 +108,16 @@ _mesa_glsl_parse_state::_mesa_glsl_parse_state(struct gl_context *_ctx,
 
    this->Const.MaxDrawBuffers = ctx->Const.MaxDrawBuffers;
 
+   /* 1.50 constants */
+   this->Const.MaxVertexOutputComponents = ctx->Const.VertexProgram.MaxOutputComponents;
+   this->Const.MaxGeometryInputComponents = ctx->Const.GeometryProgram.MaxInputComponents;
+   this->Const.MaxGeometryOutputComponents = ctx->Const.GeometryProgram.MaxOutputComponents;
+   this->Const.MaxFragmentInputComponents = ctx->Const.FragmentProgram.MaxInputComponents;
+   this->Const.MaxGeometryTextureImageUnits = ctx->Const.GeometryProgram.MaxTextureImageUnits;
+   this->Const.MaxGeometryOutputVertices = ctx->Const.MaxGeometryOutputVertices;
+   this->Const.MaxGeometryTotalOutputComponents = ctx->Const.MaxGeometryTotalOutputComponents;
+   this->Const.MaxGeometryUniformComponents = ctx->Const.GeometryProgram.MaxUniformComponents;
+
    this->current_function = NULL;
    this->toplevel_ir = NULL;
    this->found_return = false;
@@ -518,6 +527,7 @@ static const _mesa_glsl_extension _mesa_glsl_supported_extensions[] = {
    EXT(ARB_shading_language_packing,   true,  false,     ARB_shading_language_packing),
    EXT(ARB_shading_language_420pack,   true,  false,     ARB_shading_language_420pack),
    EXT(ARB_texture_multisample,        true,  false,     ARB_texture_multisample),
+   EXT(ARB_texture_query_levels,       true,  false,     ARB_texture_query_levels),
    EXT(ARB_texture_query_lod,          true,  false,     ARB_texture_query_lod),
    EXT(ARB_gpu_shader5,                true,  false,     ARB_gpu_shader5),
    EXT(AMD_vertex_shader_layer,        true,  false,     AMD_vertex_shader_layer),
diff --git a/src/glsl/glsl_parser_extras.h b/src/glsl/glsl_parser_extras.h
index 9c3e887..a674384 100644
--- a/src/glsl/glsl_parser_extras.h
+++ b/src/glsl/glsl_parser_extras.h
@@ -208,7 +208,6 @@ struct _mesa_glsl_parse_state {
       unsigned MaxTextureCoords;
       unsigned MaxVertexAttribs;
       unsigned MaxVertexUniformComponents;
-      unsigned MaxVaryingFloats;
       unsigned MaxVertexTextureImageUnits;
       unsigned MaxCombinedTextureImageUnits;
       unsigned MaxTextureImageUnits;
@@ -220,6 +219,16 @@ struct _mesa_glsl_parse_state {
       /* 3.00 ES */
       int MinProgramTexelOffset;
       int MaxProgramTexelOffset;
+
+      /* 1.50 */
+      unsigned MaxVertexOutputComponents;
+      unsigned MaxGeometryInputComponents;
+      unsigned MaxGeometryOutputComponents;
+      unsigned MaxFragmentInputComponents;
+      unsigned MaxGeometryTextureImageUnits;
+      unsigned MaxGeometryOutputVertices;
+      unsigned MaxGeometryTotalOutputComponents;
+      unsigned MaxGeometryUniformComponents;
    } Const;
 
    /**
@@ -304,6 +313,8 @@ struct _mesa_glsl_parse_state {
    bool ARB_shading_language_packing_warn;
    bool ARB_texture_multisample_enable;
    bool ARB_texture_multisample_warn;
+   bool ARB_texture_query_levels_enable;
+   bool ARB_texture_query_levels_warn;
    bool ARB_texture_query_lod_enable;
    bool ARB_texture_query_lod_warn;
    bool ARB_gpu_shader5_enable;
diff --git a/src/glsl/glsl_symbol_table.cpp b/src/glsl/glsl_symbol_table.cpp
index 6e916b4..11569f4 100644
--- a/src/glsl/glsl_symbol_table.cpp
+++ b/src/glsl/glsl_symbol_table.cpp
@@ -256,3 +256,18 @@ symbol_table_entry *glsl_symbol_table::get_entry(const char *name)
    return (symbol_table_entry *)
       _mesa_symbol_table_find_symbol(table, -1, name);
 }
+
+void
+glsl_symbol_table::disable_variable(const char *name)
+{
+   /* Ideally we would remove the variable's entry from the symbol table, but
+    * that would be difficult.  Fortunately, since this is only used for
+    * built-in variables, it won't be possible for the shader to re-introduce
+    * the variable later, so all we really need to do is to make sure that
+    * further attempts to access it using get_variable() will return NULL.
+    */
+   symbol_table_entry *entry = get_entry(name);
+   if (entry != NULL) {
+      entry->v = NULL;
+   }
+}
diff --git a/src/glsl/glsl_symbol_table.h b/src/glsl/glsl_symbol_table.h
index 62d26b8..0e62448 100644
--- a/src/glsl/glsl_symbol_table.h
+++ b/src/glsl/glsl_symbol_table.h
@@ -121,6 +121,14 @@ public:
                                   enum ir_variable_mode mode);
    /*@}*/
 
+   /**
+    * Disable a previously-added variable so that it no longer appears to be
+    * in the symbol table.  This is necessary when gl_PerVertex is redeclared,
+    * to ensure that previously-available built-in variables are no longer
+    * available.
+    */
+   void disable_variable(const char *name);
+
 private:
    symbol_table_entry *get_entry(const char *name);
 
diff --git a/src/glsl/glsl_types.cpp b/src/glsl/glsl_types.cpp
index 3c396dd..80a6e71 100644
--- a/src/glsl/glsl_types.cpp
+++ b/src/glsl/glsl_types.cpp
@@ -100,6 +100,7 @@ glsl_type::glsl_type(const glsl_struct_field *fields, unsigned num_fields,
       this->fields.structure[i].type = fields[i].type;
       this->fields.structure[i].name = ralloc_strdup(this->fields.structure,
 						     fields[i].name);
+      this->fields.structure[i].location = fields[i].location;
       this->fields.structure[i].row_major = fields[i].row_major;
    }
 }
@@ -124,6 +125,7 @@ glsl_type::glsl_type(const glsl_struct_field *fields, unsigned num_fields,
       this->fields.structure[i].type = fields[i].type;
       this->fields.structure[i].name = ralloc_strdup(this->fields.structure,
 						     fields[i].name);
+      this->fields.structure[i].location = fields[i].location;
       this->fields.structure[i].row_major = fields[i].row_major;
    }
 }
@@ -450,6 +452,9 @@ glsl_type::record_key_compare(const void *a, const void *b)
       if (key1->fields.structure[i].row_major
          != key2->fields.structure[i].row_major)
         return 1;
+      if (key1->fields.structure[i].location
+          != key2->fields.structure[i].location)
+         return 1;
    }
 
    return 0;
@@ -507,9 +512,9 @@ const glsl_type *
 glsl_type::get_interface_instance(const glsl_struct_field *fields,
 				  unsigned num_fields,
 				  enum glsl_interface_packing packing,
-				  const char *name)
+				  const char *block_name)
 {
-   const glsl_type key(fields, num_fields, packing, name);
+   const glsl_type key(fields, num_fields, packing, block_name);
 
    if (interface_types == NULL) {
       interface_types = hash_table_ctor(64, record_key_hash, record_key_compare);
@@ -517,14 +522,14 @@ glsl_type::get_interface_instance(const glsl_struct_field *fields,
 
    const glsl_type *t = (glsl_type *) hash_table_find(interface_types, & key);
    if (t == NULL) {
-      t = new glsl_type(fields, num_fields, packing, name);
+      t = new glsl_type(fields, num_fields, packing, block_name);
 
       hash_table_insert(interface_types, (void *) t, t);
    }
 
    assert(t->base_type == GLSL_TYPE_INTERFACE);
    assert(t->length == num_fields);
-   assert(strcmp(t->name, name) == 0);
+   assert(strcmp(t->name, block_name) == 0);
 
    return t;
 }
diff --git a/src/glsl/glsl_types.h b/src/glsl/glsl_types.h
index 9f61eee..e60c191 100644
--- a/src/glsl/glsl_types.h
+++ b/src/glsl/glsl_types.h
@@ -234,7 +234,7 @@ struct glsl_type {
    static const glsl_type *get_interface_instance(const glsl_struct_field *fields,
 						  unsigned num_fields,
 						  enum glsl_interface_packing packing,
-						  const char *name);
+						  const char *block_name);
 
    /**
     * Query the total number of scalars that make up a scalar, vector or matrix
@@ -581,6 +581,15 @@ struct glsl_struct_field {
    const struct glsl_type *type;
    const char *name;
    bool row_major;
+
+   /**
+    * For interface blocks, gl_varying_slot corresponding to the input/output
+    * if this is a built-in input/output (i.e. a member of the built-in
+    * gl_PerVertex interface block); -1 otherwise.
+    *
+    * Ignored for structs.
+    */
+   int location;
 };
 
 static inline unsigned int
diff --git a/src/glsl/ir.cpp b/src/glsl/ir.cpp
index 81c6380..de9613e 100644
--- a/src/glsl/ir.cpp
+++ b/src/glsl/ir.cpp
@@ -398,6 +398,9 @@ ir_expression::ir_expression(int op, ir_rvalue *op0, ir_rvalue *op1)
       this->type = glsl_type::uint_type;
       break;
 
+   case ir_binop_imul_high:
+   case ir_binop_carry:
+   case ir_binop_borrow:
    case ir_binop_lshift:
    case ir_binop_rshift:
    case ir_binop_bfm:
@@ -527,7 +530,10 @@ static const char *const operator_strs[] = {
    "+",
    "-",
    "*",
+   "imul_high",
    "/",
+   "carry",
+   "borrow",
    "%",
    "<",
    ">",
@@ -1374,7 +1380,7 @@ ir_dereference::is_lvalue() const
 }
 
 
-static const char *tex_opcode_strs[] = { "tex", "txb", "txl", "txd", "txf", "txf_ms", "txs", "lod", "tg4" };
+static const char *tex_opcode_strs[] = { "tex", "txb", "txl", "txd", "txf", "txf_ms", "txs", "lod", "tg4", "query_levels" };
 
 const char *ir_texture::opcode_string()
 {
@@ -1403,7 +1409,7 @@ ir_texture::set_sampler(ir_dereference *sampler, const glsl_type *type)
    this->sampler = sampler;
    this->type = type;
 
-   if (this->op == ir_txs) {
+   if (this->op == ir_txs || this->op == ir_query_levels) {
       assert(type->base_type == GLSL_TYPE_INT);
    } else if (this->op == ir_lod) {
       assert(type->vector_elements == 2);
@@ -1578,7 +1584,8 @@ ir_swizzle::variable_referenced() const
 
 ir_variable::ir_variable(const struct glsl_type *type, const char *name,
 			 ir_variable_mode mode)
-   : max_array_access(0), read_only(false), centroid(false), invariant(false),
+   : max_array_access(0), max_ifc_array_access(NULL),
+     read_only(false), centroid(false), invariant(false),
      mode(mode), interpolation(INTERP_QUALIFIER_NONE)
 {
    this->ir_type = ir_type_variable;
diff --git a/src/glsl/ir.h b/src/glsl/ir.h
index 885837a..aac8cbb 100644
--- a/src/glsl/ir.h
+++ b/src/glsl/ir.h
@@ -392,6 +392,65 @@ public:
     }
 
    /**
+    * Set this->interface_type on a newly created variable.
+    */
+   void init_interface_type(const struct glsl_type *type)
+   {
+      assert(this->interface_type == NULL);
+      this->interface_type = type;
+      if (this->is_interface_instance()) {
+         this->max_ifc_array_access =
+            rzalloc_array(this, unsigned, type->length);
+      }
+   }
+
+   /**
+    * Change this->interface_type on a variable that previously had a
+    * different, but compatible, interface_type.  This is used during linking
+    * to set the size of arrays in interface blocks.
+    */
+   void change_interface_type(const struct glsl_type *type)
+   {
+      if (this->max_ifc_array_access != NULL) {
+         /* max_ifc_array_access has already been allocated, so make sure the
+          * new interface has the same number of fields as the old one.
+          */
+         assert(this->interface_type->length == type->length);
+      }
+      this->interface_type = type;
+   }
+
+   /**
+    * Change this->interface_type on a variable that previously had a
+    * different, and incompatible, interface_type. This is used during
+    * compilation to handle redeclaration of the built-in gl_PerVertex
+    * interface block.
+    */
+   void reinit_interface_type(const struct glsl_type *type)
+   {
+      if (this->max_ifc_array_access != NULL) {
+#ifndef _NDEBUG
+         /* Redeclaring gl_PerVertex is only allowed if none of the built-ins
+          * it defines have been accessed yet; so it's safe to throw away the
+          * old max_ifc_array_access pointer, since all of its values are
+          * zero.
+          */
+         for (unsigned i = 0; i < this->interface_type->length; i++)
+            assert(this->max_ifc_array_access[i] == 0);
+#endif
+         ralloc_free(this->max_ifc_array_access);
+         this->max_ifc_array_access = NULL;
+      }
+      this->interface_type = NULL;
+      init_interface_type(type);
+   }
+
+   const glsl_type *get_interface_type() const
+   {
+      return this->interface_type;
+   }
+
+   /**
     * Declared type of the variable
     */
    const struct glsl_type *type;
@@ -409,6 +468,19 @@ public:
    unsigned max_array_access;
 
    /**
+    * For variables which satisfy the is_interface_instance() predicate, this
+    * points to an array of integers such that if the ith member of the
+    * interface block is an array, max_ifc_array_access[i] is the maximum
+    * array element of that member that has been accessed.  If the ith member
+    * of the interface block is not an array, max_ifc_array_access[i] is
+    * unused.
+    *
+    * For variables whose type is not an interface block, this pointer is
+    * NULL.
+    */
+   unsigned *max_ifc_array_access;
+
+   /**
     * Is the variable read-only?
     *
     * This is set for variables declared as \c const, shader inputs,
@@ -582,6 +654,7 @@ public:
     */
    ir_constant *constant_initializer;
 
+private:
    /**
     * For variables that are in an interface block or are an instance of an
     * interface block, this is the \c GLSL_TYPE_INTERFACE type for that block.
@@ -1091,10 +1164,26 @@ enum ir_expression_operation {
 
    ir_binop_add,
    ir_binop_sub,
-   ir_binop_mul,
+   ir_binop_mul,       /**< Floating-point or low 32-bit integer multiply. */
+   ir_binop_imul_high, /**< Calculates the high 32-bits of a 64-bit multiply. */
    ir_binop_div,
 
    /**
+    * Returns the carry resulting from the addition of the two arguments.
+    */
+   /*@{*/
+   ir_binop_carry,
+   /*@}*/
+
+   /**
+    * Returns the borrow resulting from the subtraction of the second argument
+    * from the first argument.
+    */
+   /*@{*/
+   ir_binop_borrow,
+   /*@}*/
+
+   /**
     * Takes one of two combinations of arguments:
     *
     * - mod(vecN, vecN)
@@ -1560,7 +1649,8 @@ enum ir_texture_opcode {
    ir_txf_ms,           /**< Multisample texture fetch */
    ir_txs,		/**< Texture size */
    ir_lod,		/**< Texture lod query */
-   ir_tg4		/**< Texture gather */
+   ir_tg4,		/**< Texture gather */
+   ir_query_levels      /**< Texture levels query */
 };
 
 
@@ -1585,7 +1675,8 @@ enum ir_texture_opcode {
  *      <type> <sampler> <coordinate>         <sample_index>)
  * (txs <type> <sampler> <lod>)
  * (lod <type> <sampler> <coordinate>)
- * (tg4 <type> <sampler> <coordinate> 0)
+ * (tg4 <type> <sampler> <coordinate> <offset> <component>)
+ * (query_levels <type> <sampler>)
  */
 class ir_texture : public ir_rvalue {
 public:
@@ -1653,6 +1744,7 @@ public:
       ir_rvalue *lod;		/**< Floating point LOD */
       ir_rvalue *bias;		/**< Floating point LOD bias */
       ir_rvalue *sample_index;  /**< MSAA sample index */
+      ir_rvalue *component;     /**< Gather component selector */
       struct {
 	 ir_rvalue *dPdx;	/**< Partial derivative of coordinate wrt X */
 	 ir_rvalue *dPdy;	/**< Partial derivative of coordinate wrt Y */
diff --git a/src/glsl/ir_builder.cpp b/src/glsl/ir_builder.cpp
index 98b4322..6c49734 100644
--- a/src/glsl/ir_builder.cpp
+++ b/src/glsl/ir_builder.cpp
@@ -216,11 +216,26 @@ ir_expression *mul(operand a, operand b)
    return expr(ir_binop_mul, a, b);
 }
 
+ir_expression *imul_high(operand a, operand b)
+{
+   return expr(ir_binop_imul_high, a, b);
+}
+
 ir_expression *div(operand a, operand b)
 {
    return expr(ir_binop_div, a, b);
 }
 
+ir_expression *carry(operand a, operand b)
+{
+   return expr(ir_binop_carry, a, b);
+}
+
+ir_expression *borrow(operand a, operand b)
+{
+   return expr(ir_binop_borrow, a, b);
+}
+
 ir_expression *round_even(operand a)
 {
    return expr(ir_unop_round_even, a);
diff --git a/src/glsl/ir_builder.h b/src/glsl/ir_builder.h
index 6a5f771..1f07788 100644
--- a/src/glsl/ir_builder.h
+++ b/src/glsl/ir_builder.h
@@ -133,7 +133,10 @@ ir_expression *expr(ir_expression_operation op, operand a, operand b, operand c)
 ir_expression *add(operand a, operand b);
 ir_expression *sub(operand a, operand b);
 ir_expression *mul(operand a, operand b);
+ir_expression *imul_high(operand a, operand b);
 ir_expression *div(operand a, operand b);
+ir_expression *carry(operand a, operand b);
+ir_expression *borrow(operand a, operand b);
 ir_expression *round_even(operand a);
 ir_expression *dot(operand a, operand b);
 ir_expression *dotlike(operand a, operand b);
diff --git a/src/glsl/ir_clone.cpp b/src/glsl/ir_clone.cpp
index fe531a8..105f906 100644
--- a/src/glsl/ir_clone.cpp
+++ b/src/glsl/ir_clone.cpp
@@ -44,6 +44,12 @@ ir_variable::clone(void *mem_ctx, struct hash_table *ht) const
 					       (ir_variable_mode) this->mode);
 
    var->max_array_access = this->max_array_access;
+   if (this->is_interface_instance()) {
+      var->max_ifc_array_access =
+         rzalloc_array(var, unsigned, this->interface_type->length);
+      memcpy(var->max_ifc_array_access, this->max_ifc_array_access,
+             this->interface_type->length * sizeof(unsigned));
+   }
    var->read_only = this->read_only;
    var->centroid = this->centroid;
    var->invariant = this->invariant;
@@ -248,7 +254,7 @@ ir_texture::clone(void *mem_ctx, struct hash_table *ht) const
    switch (this->op) {
    case ir_tex:
    case ir_lod:
-   case ir_tg4:
+   case ir_query_levels:
       break;
    case ir_txb:
       new_tex->lod_info.bias = this->lod_info.bias->clone(mem_ctx, ht);
@@ -265,6 +271,9 @@ ir_texture::clone(void *mem_ctx, struct hash_table *ht) const
       new_tex->lod_info.grad.dPdx = this->lod_info.grad.dPdx->clone(mem_ctx, ht);
       new_tex->lod_info.grad.dPdy = this->lod_info.grad.dPdy->clone(mem_ctx, ht);
       break;
+   case ir_tg4:
+      new_tex->lod_info.component = this->lod_info.component->clone(mem_ctx, ht);
+      break;
    }
 
    return new_tex;
diff --git a/src/glsl/ir_constant_expression.cpp b/src/glsl/ir_constant_expression.cpp
index 12641e5..0efd1d5 100644
--- a/src/glsl/ir_constant_expression.cpp
+++ b/src/glsl/ir_constant_expression.cpp
@@ -45,6 +45,12 @@ static int isnormal(double x)
 {
    return _fpclass(x) == _FPCLASS_NN || _fpclass(x) == _FPCLASS_PN;
 }
+#elif defined(__SUNPRO_CC)
+#include <ieeefp.h>
+static int isnormal(double x)
+{
+   return fpclass(x) == FP_NORMAL;
+}
 #endif
 
 #if defined(_MSC_VER)
diff --git a/src/glsl/ir_hv_accept.cpp b/src/glsl/ir_hv_accept.cpp
index 3877e72..941b25e 100644
--- a/src/glsl/ir_hv_accept.cpp
+++ b/src/glsl/ir_hv_accept.cpp
@@ -214,7 +214,7 @@ ir_texture::accept(ir_hierarchical_visitor *v)
    switch (this->op) {
    case ir_tex:
    case ir_lod:
-   case ir_tg4:
+   case ir_query_levels:
       break;
    case ir_txb:
       s = this->lod_info.bias->accept(v);
@@ -242,6 +242,11 @@ ir_texture::accept(ir_hierarchical_visitor *v)
       if (s != visit_continue)
 	 return (s == visit_continue_with_parent) ? visit_continue : s;
       break;
+   case ir_tg4:
+      s = this->lod_info.component->accept(v);
+      if (s != visit_continue)
+         return (s == visit_continue_with_parent) ? visit_continue : s;
+      break;
    }
 
    return (s == visit_stop) ? s : v->visit_leave(this);
diff --git a/src/glsl/ir_print_visitor.cpp b/src/glsl/ir_print_visitor.cpp
index 2c06b95..f85e573 100644
--- a/src/glsl/ir_print_visitor.cpp
+++ b/src/glsl/ir_print_visitor.cpp
@@ -252,7 +252,7 @@ void ir_print_visitor::visit(ir_texture *ir)
    ir->sampler->accept(this);
    printf(" ");
 
-   if (ir->op != ir_txs) {
+   if (ir->op != ir_txs && ir->op != ir_query_levels) {
       ir->coordinate->accept(this);
 
       printf(" ");
@@ -266,7 +266,9 @@ void ir_print_visitor::visit(ir_texture *ir)
       printf(" ");
    }
 
-   if (ir->op != ir_txf && ir->op != ir_txf_ms && ir->op != ir_txs && ir->op != ir_tg4) {
+   if (ir->op != ir_txf && ir->op != ir_txf_ms &&
+       ir->op != ir_txs && ir->op != ir_tg4 &&
+       ir->op != ir_query_levels) {
       if (ir->projector)
 	 ir->projector->accept(this);
       else
@@ -285,7 +287,7 @@ void ir_print_visitor::visit(ir_texture *ir)
    {
    case ir_tex:
    case ir_lod:
-   case ir_tg4:
+   case ir_query_levels:
       break;
    case ir_txb:
       ir->lod_info.bias->accept(this);
@@ -305,6 +307,9 @@ void ir_print_visitor::visit(ir_texture *ir)
       ir->lod_info.grad.dPdy->accept(this);
       printf(")");
       break;
+   case ir_tg4:
+      ir->lod_info.component->accept(this);
+      break;
    };
    printf(")");
 }
diff --git a/src/glsl/ir_reader.cpp b/src/glsl/ir_reader.cpp
index 8038b8f..00e2db9 100644
--- a/src/glsl/ir_reader.cpp
+++ b/src/glsl/ir_reader.cpp
@@ -934,6 +934,7 @@ ir_reader::read_texture(s_expression *expr)
    s_list *s_shadow = NULL;
    s_expression *s_lod = NULL;
    s_expression *s_sample_index = NULL;
+   s_expression *s_component = NULL;
 
    ir_texture_opcode op = ir_tex; /* silence warning */
 
@@ -948,7 +949,9 @@ ir_reader::read_texture(s_expression *expr)
    s_pattern txs_pattern[] =
       { "txs", s_type, s_sampler, s_lod };
    s_pattern tg4_pattern[] =
-      { "tg4", s_type, s_sampler, s_coord, s_offset };
+      { "tg4", s_type, s_sampler, s_coord, s_offset, s_component };
+   s_pattern query_levels_pattern[] =
+      { "query_levels", s_type, s_sampler };
    s_pattern other_pattern[] =
       { tag, s_type, s_sampler, s_coord, s_offset, s_proj, s_shadow, s_lod };
 
@@ -964,6 +967,8 @@ ir_reader::read_texture(s_expression *expr)
       op = ir_txs;
    } else if (MATCH(expr, tg4_pattern)) {
       op = ir_tg4;
+   } else if (MATCH(expr, query_levels_pattern)) {
+      op = ir_query_levels;
    } else if (MATCH(expr, other_pattern)) {
       op = ir_texture::get_opcode(tag->value());
       if (op == -1)
@@ -1014,7 +1019,9 @@ ir_reader::read_texture(s_expression *expr)
       }
    }
 
-   if (op != ir_txf && op != ir_txf_ms && op != ir_txs && op != ir_lod && op != ir_tg4) {
+   if (op != ir_txf && op != ir_txf_ms &&
+       op != ir_txs && op != ir_lod && op != ir_tg4 &&
+       op != ir_query_levels) {
       s_int *proj_as_int = SX_AS_INT(s_proj);
       if (proj_as_int && proj_as_int->value() == 1) {
 	 tex->projector = NULL;
@@ -1083,6 +1090,13 @@ ir_reader::read_texture(s_expression *expr)
       }
       break;
    }
+   case ir_tg4:
+      tex->lod_info.component = read_rvalue(s_component);
+      if (tex->lod_info.component == NULL) {
+         ir_read_error(NULL, "when reading component in (tg4 ...)");
+         return NULL;
+      }
+      break;
    default:
       // tex and lod don't have any extra parameters.
       break;
diff --git a/src/glsl/ir_rvalue_visitor.cpp b/src/glsl/ir_rvalue_visitor.cpp
index 4c3d813..9d8ccd9 100644
--- a/src/glsl/ir_rvalue_visitor.cpp
+++ b/src/glsl/ir_rvalue_visitor.cpp
@@ -57,7 +57,7 @@ ir_rvalue_base_visitor::rvalue_visit(ir_texture *ir)
    switch (ir->op) {
    case ir_tex:
    case ir_lod:
-   case ir_tg4:
+   case ir_query_levels:
       break;
    case ir_txb:
       handle_rvalue(&ir->lod_info.bias);
@@ -74,6 +74,9 @@ ir_rvalue_base_visitor::rvalue_visit(ir_texture *ir)
       handle_rvalue(&ir->lod_info.grad.dPdx);
       handle_rvalue(&ir->lod_info.grad.dPdy);
       break;
+   case ir_tg4:
+      handle_rvalue(&ir->lod_info.component);
+      break;
    }
 
    return visit_continue;
diff --git a/src/glsl/ir_validate.cpp b/src/glsl/ir_validate.cpp
index 2c64f4e..13e41a0 100644
--- a/src/glsl/ir_validate.cpp
+++ b/src/glsl/ir_validate.cpp
@@ -429,6 +429,19 @@ ir_validate::visit_leave(ir_expression *ir)
       }
       break;
 
+   case ir_binop_imul_high:
+      assert(ir->type == ir->operands[0]->type);
+      assert(ir->type == ir->operands[1]->type);
+      assert(ir->type->is_integer());
+      break;
+
+   case ir_binop_carry:
+   case ir_binop_borrow:
+      assert(ir->type == ir->operands[0]->type);
+      assert(ir->type == ir->operands[1]->type);
+      assert(ir->type->base_type == GLSL_TYPE_UINT);
+      break;
+
    case ir_binop_less:
    case ir_binop_greater:
    case ir_binop_lequal:
@@ -674,6 +687,26 @@ ir_validate::visit(ir_variable *ir)
       }
    }
 
+   /* If a variable is an interface block (or an array of interface blocks),
+    * verify that the maximum array index for each interface member is in
+    * bounds.
+    */
+   if (ir->is_interface_instance()) {
+      const glsl_struct_field *fields =
+         ir->get_interface_type()->fields.structure;
+      for (unsigned i = 0; i < ir->get_interface_type()->length; i++) {
+         if (fields[i].type->array_size() > 0) {
+            if (ir->max_ifc_array_access[i] >= fields[i].type->length) {
+               printf("ir_variable has maximum access out of bounds for "
+                      "field %s (%d vs %d)\n", fields[i].name,
+                      ir->max_ifc_array_access[i], fields[i].type->length);
+               ir->print();
+               abort();
+            }
+         }
+      }
+   }
+
    if (ir->constant_initializer != NULL && !ir->has_initializer) {
       printf("ir_variable didn't have an initializer, but has a constant "
 	     "initializer value.\n");
diff --git a/src/glsl/link_functions.cpp b/src/glsl/link_functions.cpp
index b1a68fd..fd80099 100644
--- a/src/glsl/link_functions.cpp
+++ b/src/glsl/link_functions.cpp
@@ -223,18 +223,31 @@ public:
 	    var = ir->var->clone(linked, NULL);
 	    linked->symbols->add_variable(var);
 	    linked->ir->push_head(var);
-	 } else if (var->type->is_array()) {
-	    /* It is possible to have a global array declared in multiple
-	     * shaders without a size.  The array is implicitly sized by the
-	     * maximal access to it in *any* shader.  Because of this, we
-	     * need to track the maximal access to the array as linking pulls
-	     * more functions in that access the array.
-	     */
-	    var->max_array_access =
-	       MAX2(var->max_array_access, ir->var->max_array_access);
-
-	    if (var->type->length == 0 && ir->var->type->length != 0)
-	       var->type = ir->var->type;
+	 } else {
+            if (var->type->is_array()) {
+               /* It is possible to have a global array declared in multiple
+                * shaders without a size.  The array is implicitly sized by
+                * the maximal access to it in *any* shader.  Because of this,
+                * we need to track the maximal access to the array as linking
+                * pulls more functions in that access the array.
+                */
+               var->max_array_access =
+                  MAX2(var->max_array_access, ir->var->max_array_access);
+
+               if (var->type->length == 0 && ir->var->type->length != 0)
+                  var->type = ir->var->type;
+            }
+            if (var->is_interface_instance()) {
+               /* Similarly, we need implicit sizes of arrays within interface
+                * blocks to be sized by the maximal access in *any* shader.
+                */
+               for (unsigned i = 0; i < var->get_interface_type()->length;
+                    i++) {
+                  var->max_ifc_array_access[i] =
+                     MAX2(var->max_ifc_array_access[i],
+                          ir->var->max_ifc_array_access[i]);
+               }
+            }
 	 }
 
 	 ir->var = var;
diff --git a/src/glsl/link_interface_blocks.cpp b/src/glsl/link_interface_blocks.cpp
index 928a88e..4f1c9d3 100644
--- a/src/glsl/link_interface_blocks.cpp
+++ b/src/glsl/link_interface_blocks.cpp
@@ -47,7 +47,7 @@ validate_intrastage_interface_blocks(struct gl_shader_program *prog,
          if (!var)
             continue;
 
-         const glsl_type *iface_type = var->interface_type;
+         const glsl_type *iface_type = var->get_interface_type();
 
          if (iface_type == NULL)
             continue;
@@ -81,32 +81,33 @@ validate_interstage_interface_blocks(struct gl_shader_program *prog,
    /* Add non-output interfaces from the consumer to the symbol table. */
    foreach_list(node, consumer->ir) {
       ir_variable *var = ((ir_instruction *) node)->as_variable();
-      if (!var || !var->interface_type || var->mode == ir_var_shader_out)
+      if (!var || !var->get_interface_type() || var->mode == ir_var_shader_out)
          continue;
 
-      interfaces.add_interface(var->interface_type->name,
-                               var->interface_type,
+      interfaces.add_interface(var->get_interface_type()->name,
+                               var->get_interface_type(),
                                (enum ir_variable_mode) var->mode);
    }
 
    /* Verify that the producer's interfaces match. */
    foreach_list(node, producer->ir) {
       ir_variable *var = ((ir_instruction *) node)->as_variable();
-      if (!var || !var->interface_type || var->mode == ir_var_shader_in)
+      if (!var || !var->get_interface_type() || var->mode == ir_var_shader_in)
          continue;
 
       enum ir_variable_mode consumer_mode =
          var->mode == ir_var_uniform ? ir_var_uniform : ir_var_shader_in;
       const glsl_type *expected_type =
-         interfaces.get_interface(var->interface_type->name, consumer_mode);
+         interfaces.get_interface(var->get_interface_type()->name,
+                                  consumer_mode);
 
       /* The consumer doesn't use this output block.  Ignore it. */
       if (expected_type == NULL)
          continue;
 
-      if (var->interface_type != expected_type) {
+      if (var->get_interface_type() != expected_type) {
          linker_error(prog, "definitions of interface block `%s' do not "
-                      "match\n", var->interface_type->name);
+                      "match\n", var->get_interface_type()->name);
          return;
       }
    }
diff --git a/src/glsl/link_uniform_block_active_visitor.cpp b/src/glsl/link_uniform_block_active_visitor.cpp
index 56a8384..f2f46a2 100644
--- a/src/glsl/link_uniform_block_active_visitor.cpp
+++ b/src/glsl/link_uniform_block_active_visitor.cpp
@@ -27,12 +27,12 @@
 link_uniform_block_active *
 process_block(void *mem_ctx, struct hash_table *ht, ir_variable *var)
 {
-   const uint32_t h = _mesa_hash_string(var->interface_type->name);
+   const uint32_t h = _mesa_hash_string(var->get_interface_type()->name);
    const hash_entry *const existing_block =
-      _mesa_hash_table_search(ht, h, var->interface_type->name);
+      _mesa_hash_table_search(ht, h, var->get_interface_type()->name);
 
    const glsl_type *const block_type = var->is_interface_instance()
-      ? var->type : var->interface_type;
+      ? var->type : var->get_interface_type();
 
 
    /* If a block with this block-name has not previously been seen, add it.
@@ -46,7 +46,7 @@ process_block(void *mem_ctx, struct hash_table *ht, ir_variable *var)
       b->type = block_type;
       b->has_instance_name = var->is_interface_instance();
 
-      _mesa_hash_table_insert(ht, h, var->interface_type->name,
+      _mesa_hash_table_insert(ht, h, var->get_interface_type()->name,
 			      (void *) b);
       return b;
    } else {
@@ -90,7 +90,7 @@ link_uniform_block_active_visitor::visit_enter(ir_dereference_array *ir)
    if (b == NULL) {
       linker_error(prog,
 		   "uniform block `%s' has mismatching definitions",
-		   var->interface_type->name);
+		   var->get_interface_type()->name);
       this->success = false;
       return visit_stop;
    }
@@ -149,7 +149,7 @@ link_uniform_block_active_visitor::visit(ir_dereference_variable *ir)
    if (b == NULL) {
       linker_error(this->prog,
 		   "uniform block `%s' has mismatching definitions",
-		   var->interface_type->name);
+		   var->get_interface_type()->name);
       this->success = false;
       return visit_stop;
    }
diff --git a/src/glsl/link_uniforms.cpp b/src/glsl/link_uniforms.cpp
index 03cbcd1..4bd4034 100644
--- a/src/glsl/link_uniforms.cpp
+++ b/src/glsl/link_uniforms.cpp
@@ -140,8 +140,8 @@ program_resource_visitor::recursion(const glsl_type *t, char **name,
 	 /* Append the subscript to the current variable name */
 	 ralloc_asprintf_rewrite_tail(name, &new_length, "[%u]", i);
 
-         recursion(t->fields.array, name, new_length,
-                   t->fields.structure[i].row_major, record_type);
+         recursion(t->fields.array, name, new_length, row_major,
+                   record_type);
 
          /* Only the first leaf-field of the record gets called with the
           * record type pointer.
@@ -199,8 +199,8 @@ public:
    {
       this->is_ubo_var = var->is_in_uniform_block();
       if (var->is_interface_instance())
-         program_resource_visitor::process(var->interface_type,
-                                           var->interface_type->name);
+         program_resource_visitor::process(var->get_interface_type(),
+                                           var->get_interface_type()->name);
       else
          program_resource_visitor::process(var);
    }
@@ -317,10 +317,10 @@ public:
       ubo_block_index = -1;
       if (var->is_in_uniform_block()) {
          if (var->is_interface_instance() && var->type->is_array()) {
-            unsigned l = strlen(var->interface_type->name);
+            unsigned l = strlen(var->get_interface_type()->name);
 
             for (unsigned i = 0; i < prog->NumUniformBlocks; i++) {
-               if (strncmp(var->interface_type->name,
+               if (strncmp(var->get_interface_type()->name,
                            prog->UniformBlocks[i].Name,
                            l) == 0
                    && prog->UniformBlocks[i].Name[l] == '[') {
@@ -330,7 +330,7 @@ public:
             }
          } else {
             for (unsigned i = 0; i < prog->NumUniformBlocks; i++) {
-               if (strcmp(var->interface_type->name,
+               if (strcmp(var->get_interface_type()->name,
                           prog->UniformBlocks[i].Name) == 0) {
                   ubo_block_index = i;
                   break;
@@ -362,7 +362,8 @@ public:
          }
 
          if (var->is_interface_instance())
-            process(var->interface_type, var->interface_type->name);
+            process(var->get_interface_type(),
+                    var->get_interface_type()->name);
          else
             process(var);
       } else
diff --git a/src/glsl/link_varyings.cpp b/src/glsl/link_varyings.cpp
index 905621d..4ba6d8a 100644
--- a/src/glsl/link_varyings.cpp
+++ b/src/glsl/link_varyings.cpp
@@ -972,8 +972,8 @@ public:
       this->toplevel_var = var;
       this->varying_floats = 0;
       if (var->is_interface_instance())
-         program_resource_visitor::process(var->interface_type,
-                                           var->interface_type->name);
+         program_resource_visitor::process(var->get_interface_type(),
+                                           var->get_interface_type()->name);
       else
          program_resource_visitor::process(var);
    }
@@ -1083,10 +1083,10 @@ assign_varying_locations(struct gl_context *ctx,
             ((ir_instruction *) node)->as_variable();
 
          if ((input_var != NULL) && (input_var->mode == ir_var_shader_in)) {
-            if (input_var->interface_type != NULL) {
+            if (input_var->get_interface_type() != NULL) {
                char *const iface_field_name =
                   ralloc_asprintf(mem_ctx, "%s.%s",
-                                  input_var->interface_type->name,
+                                  input_var->get_interface_type()->name,
                                   input_var->name);
                hash_table_insert(consumer_interface_inputs, input_var,
                                  iface_field_name);
@@ -1108,10 +1108,10 @@ assign_varying_locations(struct gl_context *ctx,
       g.process(output_var);
 
       ir_variable *input_var;
-      if (output_var->interface_type != NULL) {
+      if (output_var->get_interface_type() != NULL) {
          char *const iface_field_name =
             ralloc_asprintf(mem_ctx, "%s.%s",
-                            output_var->interface_type->name,
+                            output_var->get_interface_type()->name,
                             output_var->name);
          input_var =
             (ir_variable *) hash_table_find(consumer_interface_inputs,
@@ -1220,39 +1220,98 @@ assign_varying_locations(struct gl_context *ctx,
 }
 
 bool
-check_against_varying_limit(struct gl_context *ctx,
-                            struct gl_shader_program *prog,
-                            gl_shader *consumer)
+check_against_output_limit(struct gl_context *ctx,
+                           struct gl_shader_program *prog,
+                           gl_shader *producer)
 {
-   unsigned varying_vectors = 0;
+   unsigned output_vectors = 0;
+
+   foreach_list(node, producer->ir) {
+      ir_variable *const var = ((ir_instruction *) node)->as_variable();
+
+      if (var && var->mode == ir_var_shader_out &&
+          is_varying_var(producer->Type, var)) {
+         output_vectors += var->type->count_attribute_slots();
+      }
+   }
+
+   unsigned max_output_components;
+   switch (producer->Type) {
+   case GL_VERTEX_SHADER:
+      max_output_components = ctx->Const.VertexProgram.MaxOutputComponents;
+      break;
+   case GL_GEOMETRY_SHADER:
+      max_output_components = ctx->Const.GeometryProgram.MaxOutputComponents;
+      break;
+   case GL_FRAGMENT_SHADER:
+   default:
+      assert(!"Should not get here.");
+      return false;
+   }
+
+   const unsigned output_components = output_vectors * 4;
+   if (output_components > max_output_components) {
+      if (ctx->API == API_OPENGLES2 || prog->IsES)
+         linker_error(prog, "shader uses too many output vectors "
+                      "(%u > %u)\n",
+                      output_vectors,
+                      max_output_components / 4);
+      else
+         linker_error(prog, "shader uses too many output components "
+                      "(%u > %u)\n",
+                      output_components,
+                      max_output_components);
+
+      return false;
+   }
+
+   return true;
+}
+
+bool
+check_against_input_limit(struct gl_context *ctx,
+                          struct gl_shader_program *prog,
+                          gl_shader *consumer)
+{
+   unsigned input_vectors = 0;
 
    foreach_list(node, consumer->ir) {
       ir_variable *const var = ((ir_instruction *) node)->as_variable();
 
       if (var && var->mode == ir_var_shader_in &&
           is_varying_var(consumer->Type, var)) {
-         /* The packing rules used for vertex shader inputs are also
-          * used for fragment shader inputs.
-          */
-         varying_vectors += var->type->count_attribute_slots();
+         input_vectors += var->type->count_attribute_slots();
       }
    }
 
-   if (ctx->API == API_OPENGLES2 || prog->IsES) {
-      if (varying_vectors > ctx->Const.MaxVarying) {
-         linker_error(prog, "shader uses too many varying vectors "
+   unsigned max_input_components;
+   switch (consumer->Type) {
+   case GL_GEOMETRY_SHADER:
+      max_input_components = ctx->Const.GeometryProgram.MaxInputComponents;
+      break;
+   case GL_FRAGMENT_SHADER:
+      max_input_components = ctx->Const.FragmentProgram.MaxInputComponents;
+      break;
+   case GL_VERTEX_SHADER:
+   default:
+      assert(!"Should not get here.");
+      return false;
+   }
+
+   const unsigned input_components = input_vectors * 4;
+   if (input_components > max_input_components) {
+      if (ctx->API == API_OPENGLES2 || prog->IsES)
+         linker_error(prog, "shader uses too many input vectors "
                       "(%u > %u)\n",
-                      varying_vectors, ctx->Const.MaxVarying);
-         return false;
-      }
-   } else {
-      const unsigned float_components = varying_vectors * 4;
-      if (float_components > ctx->Const.MaxVarying * 4) {
-         linker_error(prog, "shader uses too many varying components "
+                      input_vectors,
+                      max_input_components / 4);
+      else
+         linker_error(prog, "shader uses too many input components "
                       "(%u > %u)\n",
-                      float_components, ctx->Const.MaxVarying * 4);
-         return false;
-      }
+                      input_components,
+                      max_input_components);
+
+      return false;
    }
 
    return true;
diff --git a/src/glsl/link_varyings.h b/src/glsl/link_varyings.h
index 6264ef0..6fa2681 100644
--- a/src/glsl/link_varyings.h
+++ b/src/glsl/link_varyings.h
@@ -237,8 +237,13 @@ assign_varying_locations(struct gl_context *ctx,
                          unsigned gs_input_vertices);
 
 bool
-check_against_varying_limit(struct gl_context *ctx,
-                            struct gl_shader_program *prog,
-                            gl_shader *consumer);
+check_against_output_limit(struct gl_context *ctx,
+                           struct gl_shader_program *prog,
+                           gl_shader *producer);
+
+bool
+check_against_input_limit(struct gl_context *ctx,
+                          struct gl_shader_program *prog,
+                          gl_shader *consumer);
 
 #endif /* GLSL_LINK_VARYINGS_H */
diff --git a/src/glsl/linker.cpp b/src/glsl/linker.cpp
index c54b704..9095a40 100644
--- a/src/glsl/linker.cpp
+++ b/src/glsl/linker.cpp
@@ -1033,17 +1033,167 @@ get_main_function_signature(gl_shader *sh)
  */
 class array_sizing_visitor : public ir_hierarchical_visitor {
 public:
+   array_sizing_visitor()
+      : mem_ctx(ralloc_context(NULL)),
+        unnamed_interfaces(hash_table_ctor(0, hash_table_pointer_hash,
+                                           hash_table_pointer_compare))
+   {
+   }
+
+   ~array_sizing_visitor()
+   {
+      hash_table_dtor(this->unnamed_interfaces);
+      ralloc_free(this->mem_ctx);
+   }
+
    virtual ir_visitor_status visit(ir_variable *var)
    {
-      if (var->type->is_array() && (var->type->length == 0)) {
-         const glsl_type *type =
-            glsl_type::get_array_instance(var->type->fields.array,
-                                          var->max_array_access + 1);
-         assert(type != NULL);
-         var->type = type;
+      fixup_type(&var->type, var->max_array_access);
+      if (var->type->is_interface()) {
+         if (interface_contains_unsized_arrays(var->type)) {
+            const glsl_type *new_type =
+               resize_interface_members(var->type, var->max_ifc_array_access);
+            var->type = new_type;
+            var->change_interface_type(new_type);
+         }
+      } else if (var->type->is_array() &&
+                 var->type->fields.array->is_interface()) {
+         if (interface_contains_unsized_arrays(var->type->fields.array)) {
+            const glsl_type *new_type =
+               resize_interface_members(var->type->fields.array,
+                                        var->max_ifc_array_access);
+            var->change_interface_type(new_type);
+            var->type =
+               glsl_type::get_array_instance(new_type, var->type->length);
+         }
+      } else if (const glsl_type *ifc_type = var->get_interface_type()) {
+         /* Store a pointer to the variable in the unnamed_interfaces
+          * hashtable.
+          */
+         ir_variable **interface_vars = (ir_variable **)
+            hash_table_find(this->unnamed_interfaces, ifc_type);
+         if (interface_vars == NULL) {
+            interface_vars = rzalloc_array(mem_ctx, ir_variable *,
+                                           ifc_type->length);
+            hash_table_insert(this->unnamed_interfaces, interface_vars,
+                              ifc_type);
+         }
+         unsigned index = ifc_type->field_index(var->name);
+         assert(index < ifc_type->length);
+         assert(interface_vars[index] == NULL);
+         interface_vars[index] = var;
       }
       return visit_continue;
    }
+
+   /**
+    * For each unnamed interface block that was discovered while running the
+    * visitor, adjust the interface type to reflect the newly assigned array
+    * sizes, and fix up the ir_variable nodes to point to the new interface
+    * type.
+    */
+   void fixup_unnamed_interface_types()
+   {
+      hash_table_call_foreach(this->unnamed_interfaces,
+                              fixup_unnamed_interface_type, NULL);
+   }
+
+private:
+   /**
+    * If the type pointed to by \c type represents an unsized array, replace
+    * it with a sized array whose size is determined by max_array_access.
+    */
+   static void fixup_type(const glsl_type **type, unsigned max_array_access)
+   {
+      if ((*type)->is_array() && (*type)->length == 0) {
+         *type = glsl_type::get_array_instance((*type)->fields.array,
+                                               max_array_access + 1);
+         assert(*type != NULL);
+      }
+   }
+
+   /**
+    * Determine whether the given interface type contains unsized arrays (if
+    * it doesn't, array_sizing_visitor doesn't need to process it).
+    */
+   static bool interface_contains_unsized_arrays(const glsl_type *type)
+   {
+      for (unsigned i = 0; i < type->length; i++) {
+         const glsl_type *elem_type = type->fields.structure[i].type;
+         if (elem_type->is_array() && elem_type->length == 0)
+            return true;
+      }
+      return false;
+   }
+
+   /**
+    * Create a new interface type based on the given type, with unsized arrays
+    * replaced by sized arrays whose size is determined by
+    * max_ifc_array_access.
+    */
+   static const glsl_type *
+   resize_interface_members(const glsl_type *type,
+                            const unsigned *max_ifc_array_access)
+   {
+      unsigned num_fields = type->length;
+      glsl_struct_field *fields = new glsl_struct_field[num_fields];
+      memcpy(fields, type->fields.structure,
+             num_fields * sizeof(*fields));
+      for (unsigned i = 0; i < num_fields; i++) {
+         fixup_type(&fields[i].type, max_ifc_array_access[i]);
+      }
+      glsl_interface_packing packing =
+         (glsl_interface_packing) type->interface_packing;
+      const glsl_type *new_ifc_type =
+         glsl_type::get_interface_instance(fields, num_fields,
+                                           packing, type->name);
+      delete [] fields;
+      return new_ifc_type;
+   }
+
+   static void fixup_unnamed_interface_type(const void *key, void *data,
+                                            void *)
+   {
+      const glsl_type *ifc_type = (const glsl_type *) key;
+      ir_variable **interface_vars = (ir_variable **) data;
+      unsigned num_fields = ifc_type->length;
+      glsl_struct_field *fields = new glsl_struct_field[num_fields];
+      memcpy(fields, ifc_type->fields.structure,
+             num_fields * sizeof(*fields));
+      bool interface_type_changed = false;
+      for (unsigned i = 0; i < num_fields; i++) {
+         if (interface_vars[i] != NULL &&
+             fields[i].type != interface_vars[i]->type) {
+            fields[i].type = interface_vars[i]->type;
+            interface_type_changed = true;
+         }
+      }
+      if (!interface_type_changed) {
+         delete [] fields;
+         return;
+      }
+      glsl_interface_packing packing =
+         (glsl_interface_packing) ifc_type->interface_packing;
+      const glsl_type *new_ifc_type =
+         glsl_type::get_interface_instance(fields, num_fields, packing,
+                                           ifc_type->name);
+      delete [] fields;
+      for (unsigned i = 0; i < num_fields; i++) {
+         if (interface_vars[i] != NULL)
+            interface_vars[i]->change_interface_type(new_ifc_type);
+      }
+   }
+
+   /**
+    * Memory context used to allocate the data in \c unnamed_interfaces.
+    */
+   void *mem_ctx;
+
+   /**
+    * Hash table from const glsl_type * to an array of ir_variable *'s
+    * pointing to the ir_variables constituting each unnamed interface block.
+    */
+   hash_table *unnamed_interfaces;
 };
 
 /**
@@ -1318,6 +1468,7 @@ link_intrastage_shaders(void *mem_ctx,
     */
    array_sizing_visitor v;
    v.run(linked->ir);
+   v.fixup_unnamed_interface_types();
 
    return linked;
 }
@@ -2203,7 +2354,9 @@ link_shaders(struct gl_context *ctx, struct gl_shader_program *prog)
          ;
 
       /* This must be done after all dead varyings are eliminated. */
-      if (!check_against_varying_limit(ctx, prog, sh_next))
+      if (!check_against_output_limit(ctx, prog, sh_i))
+         goto done;
+      if (!check_against_input_limit(ctx, prog, sh_next))
          goto done;
 
       next = i;
diff --git a/src/glsl/lower_clip_distance.cpp b/src/glsl/lower_clip_distance.cpp
index 9ddd646..682c8fd 100644
--- a/src/glsl/lower_clip_distance.cpp
+++ b/src/glsl/lower_clip_distance.cpp
@@ -54,14 +54,17 @@ namespace {
 
 class lower_clip_distance_visitor : public ir_rvalue_visitor {
 public:
-   lower_clip_distance_visitor()
-      : progress(false), old_clip_distance_var(NULL),
-        new_clip_distance_var(NULL)
+   explicit lower_clip_distance_visitor(GLenum shader_type)
+      : progress(false), old_clip_distance_1d_var(NULL),
+        old_clip_distance_2d_var(NULL), new_clip_distance_1d_var(NULL),
+        new_clip_distance_2d_var(NULL), shader_type(shader_type)
    {
    }
 
    virtual ir_visitor_status visit(ir_variable *);
    void create_indices(ir_rvalue*, ir_rvalue *&, ir_rvalue *&);
+   bool is_clip_distance_vec8(ir_rvalue *ir);
+   ir_rvalue *lower_clip_distance_vec8(ir_rvalue *ir);
    virtual ir_visitor_status visit_leave(ir_assignment *);
    void visit_new_assignment(ir_assignment *ir);
    virtual ir_visitor_status visit_leave(ir_call *);
@@ -74,13 +77,28 @@ public:
 
    /**
     * Pointer to the declaration of gl_ClipDistance, if found.
+    *
+    * Note:
+    *
+    * - the 2d_var is for geometry shader input only.
+    *
+    * - since gl_ClipDistance is available in geometry shaders as both an
+    *   input and an output, it's possible for both old_clip_distance_1d_var
+    *   and old_clip_distance_2d_var to be non-null.
     */
-   ir_variable *old_clip_distance_var;
+   ir_variable *old_clip_distance_1d_var;
+   ir_variable *old_clip_distance_2d_var;
 
    /**
     * Pointer to the newly-created gl_ClipDistanceMESA variable.
     */
-   ir_variable *new_clip_distance_var;
+   ir_variable *new_clip_distance_1d_var;
+   ir_variable *new_clip_distance_2d_var;
+
+   /**
+    * Type of shader we are compiling (e.g. GL_VERTEX_SHADER)
+    */
+   const GLenum shader_type;
 };
 
 } /* anonymous namespace */
@@ -92,30 +110,61 @@ public:
 ir_visitor_status
 lower_clip_distance_visitor::visit(ir_variable *ir)
 {
-   /* No point in looking for the declaration of gl_ClipDistance if
-    * we've already found it.
-    */
-   if (this->old_clip_distance_var)
+   if (!ir->name || strcmp(ir->name, "gl_ClipDistance") != 0)
       return visit_continue;
+   assert (ir->type->is_array());
+
+   if (!ir->type->element_type()->is_array()) {
+      /* 1D gl_ClipDistance (used for vertex and geometry output, and fragment
+       * input).
+       */
+      if (this->old_clip_distance_1d_var)
+         return visit_continue;
 
-   if (ir->name && strcmp(ir->name, "gl_ClipDistance") == 0) {
       this->progress = true;
-      this->old_clip_distance_var = ir;
-      assert (ir->type->is_array());
+      this->old_clip_distance_1d_var = ir;
       assert (ir->type->element_type() == glsl_type::float_type);
       unsigned new_size = (ir->type->array_size() + 3) / 4;
 
       /* Clone the old var so that we inherit all of its properties */
-      this->new_clip_distance_var = ir->clone(ralloc_parent(ir), NULL);
+      this->new_clip_distance_1d_var = ir->clone(ralloc_parent(ir), NULL);
 
       /* And change the properties that we need to change */
-      this->new_clip_distance_var->name
-         = ralloc_strdup(this->new_clip_distance_var, "gl_ClipDistanceMESA");
-      this->new_clip_distance_var->type
+      this->new_clip_distance_1d_var->name
+         = ralloc_strdup(this->new_clip_distance_1d_var,
+                         "gl_ClipDistanceMESA");
+      this->new_clip_distance_1d_var->type
          = glsl_type::get_array_instance(glsl_type::vec4_type, new_size);
-      this->new_clip_distance_var->max_array_access = ir->max_array_access / 4;
+      this->new_clip_distance_1d_var->max_array_access
+         = ir->max_array_access / 4;
+
+      ir->replace_with(this->new_clip_distance_1d_var);
+   } else {
+      /* 2D gl_ClipDistance (used for geometry input). */
+      assert(ir->mode == ir_var_shader_in &&
+             this->shader_type == GL_GEOMETRY_SHADER_ARB);
+      if (this->old_clip_distance_2d_var)
+         return visit_continue;
+
+      this->progress = true;
+      this->old_clip_distance_2d_var = ir;
+      assert (ir->type->element_type()->element_type() == glsl_type::float_type);
+      unsigned new_size = (ir->type->element_type()->array_size() + 3) / 4;
+
+      /* Clone the old var so that we inherit all of its properties */
+      this->new_clip_distance_2d_var = ir->clone(ralloc_parent(ir), NULL);
 
-      ir->replace_with(this->new_clip_distance_var);
+      /* And change the properties that we need to change */
+      this->new_clip_distance_2d_var->name
+         = ralloc_strdup(this->new_clip_distance_2d_var, "gl_ClipDistanceMESA");
+      this->new_clip_distance_2d_var->type = glsl_type::get_array_instance(
+         glsl_type::get_array_instance(glsl_type::vec4_type,
+            new_size),
+         ir->type->array_size());
+      this->new_clip_distance_2d_var->max_array_access
+         = ir->max_array_access / 4;
+
+      ir->replace_with(this->new_clip_distance_2d_var);
    }
    return visit_continue;
 }
@@ -180,39 +229,111 @@ lower_clip_distance_visitor::create_indices(ir_rvalue *old_index,
 }
 
 
+/**
+ * Determine whether the given rvalue describes an array of 8 floats that
+ * needs to be lowered to an array of 2 vec4's; that is, determine whether it
+ * matches one of the following patterns:
+ *
+ * - gl_ClipDistance (if gl_ClipDistance is 1D)
+ * - gl_ClipDistance[i] (if gl_ClipDistance is 2D)
+ */
+bool
+lower_clip_distance_visitor::is_clip_distance_vec8(ir_rvalue *ir)
+{
+   /* Note that geometry shaders contain gl_ClipDistance both as an input
+    * (which is a 2D array) and an output (which is a 1D array), so it's
+    * possible for both this->old_clip_distance_1d_var and
+    * this->old_clip_distance_2d_var to be non-NULL in the same shader.
+    */
+
+   if (this->old_clip_distance_1d_var) {
+      ir_dereference_variable *var_ref = ir->as_dereference_variable();
+      if (var_ref && var_ref->var == this->old_clip_distance_1d_var)
+         return true;
+   }
+   if (this->old_clip_distance_2d_var) {
+      /* 2D clip distance is only possible as a geometry input */
+      assert(this->shader_type == GL_GEOMETRY_SHADER_ARB);
+
+      ir_dereference_array *array_ref = ir->as_dereference_array();
+      if (array_ref) {
+         ir_dereference_variable *var_ref =
+            array_ref->array->as_dereference_variable();
+         if (var_ref && var_ref->var == this->old_clip_distance_2d_var)
+            return true;
+      }
+   }
+   return false;
+}
+
+
+/**
+ * If the given ir satisfies is_clip_distance_vec8(), return new ir
+ * representing its lowered equivalent.  That is, map:
+ *
+ * - gl_ClipDistance    => gl_ClipDistanceMESA    (if gl_ClipDistance is 1D)
+ * - gl_ClipDistance[i] => gl_ClipDistanceMESA[i] (if gl_ClipDistance is 2D)
+ *
+ * Otherwise return NULL.
+ */
+ir_rvalue *
+lower_clip_distance_visitor::lower_clip_distance_vec8(ir_rvalue *ir)
+{
+   if (this->old_clip_distance_1d_var) {
+      ir_dereference_variable *var_ref = ir->as_dereference_variable();
+      if (var_ref && var_ref->var == this->old_clip_distance_1d_var) {
+         return new(ralloc_parent(ir))
+            ir_dereference_variable(this->new_clip_distance_1d_var);
+      }
+   }
+   if (this->old_clip_distance_2d_var) {
+      /* 2D clip distance is only possible as a geometry input */
+      assert(this->shader_type == GL_GEOMETRY_SHADER_ARB);
+
+      ir_dereference_array *array_ref = ir->as_dereference_array();
+      if (array_ref) {
+         ir_dereference_variable *var_ref =
+            array_ref->array->as_dereference_variable();
+         if (var_ref && var_ref->var == this->old_clip_distance_2d_var) {
+            return new(ralloc_parent(ir))
+               ir_dereference_array(this->new_clip_distance_2d_var,
+                                    array_ref->array_index);
+         }
+      }
+   }
+   return NULL;
+}
+
+
 void
 lower_clip_distance_visitor::handle_rvalue(ir_rvalue **rv)
 {
-   /* If the gl_ClipDistance var hasn't been declared yet, then
-    * there's no way this deref can refer to it.
-    */
-   if (!this->old_clip_distance_var || *rv == NULL)
+   if (*rv == NULL)
       return;
 
    ir_dereference_array *const array_deref = (*rv)->as_dereference_array();
    if (array_deref == NULL)
       return;
 
-   /* Replace any expression that indexes into the gl_ClipDistance array
+   /* Replace any expression that indexes one of the floats in gl_ClipDistance
     * with an expression that indexes into one of the vec4's in
     * gl_ClipDistanceMESA and accesses the appropriate component.
     */
-   ir_dereference_variable *old_var_ref =
-      array_deref->array->as_dereference_variable();
-   if (old_var_ref && old_var_ref->var == this->old_clip_distance_var) {
+   ir_rvalue *lowered_vec8 =
+      this->lower_clip_distance_vec8(array_deref->array);
+   if (lowered_vec8 != NULL) {
       this->progress = true;
       ir_rvalue *array_index;
       ir_rvalue *swizzle_index;
       this->create_indices(array_deref->array_index, array_index, swizzle_index);
       void *mem_ctx = ralloc_parent(array_deref);
 
-      ir_dereference_array *const ClipDistanceMESA_deref =
-         new(mem_ctx) ir_dereference_array(this->new_clip_distance_var,
-                                           array_index);
+      ir_dereference_array *const new_array_deref =
+         new(mem_ctx) ir_dereference_array(lowered_vec8, array_index);
 
       ir_expression *const expr =
          new(mem_ctx) ir_expression(ir_binop_vector_extract,
-                                    ClipDistanceMESA_deref,
+                                    new_array_deref,
                                     swizzle_index);
 
       *rv = expr;
@@ -246,30 +367,34 @@ lower_clip_distance_visitor::fix_lhs(ir_assignment *ir)
 }
 
 /**
- * Replace any assignment having gl_ClipDistance (undereferenced) as its LHS
- * or RHS with a sequence of assignments, one for each component of the array.
- * Each of these assignments is lowered to refer to gl_ClipDistanceMESA as
- * appropriate.
+ * Replace any assignment having the 1D gl_ClipDistance (undereferenced) as
+ * its LHS or RHS with a sequence of assignments, one for each component of
+ * the array.  Each of these assignments is lowered to refer to
+ * gl_ClipDistanceMESA as appropriate.
+ *
+ * We need to do a similar replacement for 2D gl_ClipDistance, however since
+ * it's an input, the only case we need to address is where a 1D slice of it
+ * is the entire RHS of an assignment, e.g.:
+ *
+ *     foo = gl_in[i].gl_ClipDistance
  */
 ir_visitor_status
 lower_clip_distance_visitor::visit_leave(ir_assignment *ir)
 {
-   ir_dereference_variable *lhs_var = ir->lhs->as_dereference_variable();
-   ir_dereference_variable *rhs_var = ir->rhs->as_dereference_variable();
-   if ((lhs_var && lhs_var->var == this->old_clip_distance_var)
-       || (rhs_var && rhs_var->var == this->old_clip_distance_var)) {
-      /* LHS or RHS of the assignment is the entire gl_ClipDistance array.
-       * Since we are reshaping gl_ClipDistance from an array of floats to an
-       * array of vec4's, this isn't going to work as a bulk assignment
-       * anymore, so unroll it to element-by-element assignments and lower
-       * each of them.
+   if (this->is_clip_distance_vec8(ir->lhs) ||
+       this->is_clip_distance_vec8(ir->rhs)) {
+      /* LHS or RHS of the assignment is the entire 1D gl_ClipDistance array
+       * (or a 1D slice of a 2D gl_ClipDistance input array).  Since we are
+       * reshaping gl_ClipDistance from an array of floats to an array of
+       * vec4's, this isn't going to work as a bulk assignment anymore, so
+       * unroll it to element-by-element assignments and lower each of them.
        *
        * Note: to unroll into element-by-element assignments, we need to make
        * clones of the LHS and RHS.  This is safe because expressions and
        * l-values are side-effect free.
        */
       void *ctx = ralloc_parent(ir);
-      int array_size = this->old_clip_distance_var->type->array_size();
+      int array_size = ir->lhs->type->array_size();
       for (int i = 0; i < array_size; ++i) {
          ir_dereference_array *new_lhs = new(ctx) ir_dereference_array(
             ir->lhs->clone(ctx, NULL), new(ctx) ir_constant(i));
@@ -329,11 +454,17 @@ lower_clip_distance_visitor::visit_new_assignment(ir_assignment *ir)
 
 
 /**
- * If gl_ClipDistance appears as an argument in an ir_call expression, replace
- * it with a temporary variable, and make sure the ir_call is preceded and/or
- * followed by assignments that copy the contents of the temporary variable to
- * and/or from gl_ClipDistance.  Each of these assignments is then lowered to
- * refer to gl_ClipDistanceMESA.
+ * If a 1D gl_ClipDistance variable appears as an argument in an ir_call
+ * expression, replace it with a temporary variable, and make sure the ir_call
+ * is preceded and/or followed by assignments that copy the contents of the
+ * temporary variable to and/or from gl_ClipDistance.  Each of these
+ * assignments is then lowered to refer to gl_ClipDistanceMESA.
+ *
+ * We need to do a similar replacement for 2D gl_ClipDistance, however since
+ * it's an input, the only case we need to address is where a 1D slice of it
+ * is passed as an "in" parameter to an ir_call, e.g.:
+ *
+ *     foo(gl_in[i].gl_ClipDistance)
  */
 ir_visitor_status
 lower_clip_distance_visitor::visit_leave(ir_call *ir)
@@ -352,12 +483,12 @@ lower_clip_distance_visitor::visit_leave(ir_call *ir)
       formal_param_node = formal_param_node->next;
       actual_param_node = actual_param_node->next;
 
-      ir_dereference_variable *deref = actual_param->as_dereference_variable();
-      if (deref && deref->var == this->old_clip_distance_var) {
-         /* User is trying to pass the whole gl_ClipDistance array to a
-          * function call.  Since we are reshaping gl_ClipDistance from an
-          * array of floats to an array of vec4's, this isn't going to work
-          * anymore, so use a temporary array instead.
+      if (this->is_clip_distance_vec8(actual_param)) {
+         /* User is trying to pass the whole 1D gl_ClipDistance array (or a 1D
+          * slice of a 2D gl_ClipDistance array) to a function call.  Since we
+          * are reshaping gl_ClipDistance from an array of floats to an array
+          * of vec4's, this isn't going to work anymore, so use a temporary
+          * array instead.
           */
          ir_variable *temp_clip_distance = new(ctx) ir_variable(
             actual_param->type, "temp_clip_distance", ir_var_temporary);
@@ -373,7 +504,7 @@ lower_clip_distance_visitor::visit_leave(ir_call *ir)
              */
             ir_assignment *new_assignment = new(ctx) ir_assignment(
                new(ctx) ir_dereference_variable(temp_clip_distance),
-               new(ctx) ir_dereference_variable(old_clip_distance_var));
+               actual_param->clone(ctx, NULL));
             this->base_ir->insert_before(new_assignment);
             this->visit_new_assignment(new_assignment);
          }
@@ -385,7 +516,7 @@ lower_clip_distance_visitor::visit_leave(ir_call *ir)
              * afterwards to make sure it gets lowered.
              */
             ir_assignment *new_assignment = new(ctx) ir_assignment(
-               new(ctx) ir_dereference_variable(old_clip_distance_var),
+               actual_param->clone(ctx, NULL),
                new(ctx) ir_dereference_variable(temp_clip_distance));
             this->base_ir->insert_after(new_assignment);
             this->visit_new_assignment(new_assignment);
@@ -400,12 +531,14 @@ lower_clip_distance_visitor::visit_leave(ir_call *ir)
 bool
 lower_clip_distance(gl_shader *shader)
 {
-   lower_clip_distance_visitor v;
+   lower_clip_distance_visitor v(shader->Type);
 
    visit_list_elements(&v, shader->ir);
 
-   if (v.new_clip_distance_var)
-      shader->symbols->add_variable(v.new_clip_distance_var);
+   if (v.new_clip_distance_1d_var)
+      shader->symbols->add_variable(v.new_clip_distance_1d_var);
+   if (v.new_clip_distance_2d_var)
+      shader->symbols->add_variable(v.new_clip_distance_2d_var);
 
    return v.progress;
 }
diff --git a/src/glsl/lower_named_interface_blocks.cpp b/src/glsl/lower_named_interface_blocks.cpp
index 7019185..f415252 100644
--- a/src/glsl/lower_named_interface_blocks.cpp
+++ b/src/glsl/lower_named_interface_blocks.cpp
@@ -150,8 +150,9 @@ flatten_named_interface_blocks_declarations::run(exec_list *instructions)
                                            var_name,
                                            (ir_variable_mode) var->mode);
             }
+            new_var->location = iface_t->fields.structure[i].location;
 
-            new_var->interface_type = iface_t;
+            new_var->init_interface_type(iface_t);
             hash_table_insert(interface_namespace, new_var,
                               iface_field_name);
             insert_pos->insert_after(new_var);
@@ -207,9 +208,9 @@ flatten_named_interface_blocks_declarations::handle_rvalue(ir_rvalue **rvalue)
    if (var->mode == ir_var_uniform)
       return;
 
-   if (var->interface_type != NULL) {
+   if (var->get_interface_type() != NULL) {
       char *iface_field_name =
-         ralloc_asprintf(mem_ctx, "%s.%s", var->interface_type->name,
+         ralloc_asprintf(mem_ctx, "%s.%s", var->get_interface_type()->name,
                          ir->field);
       /* Find the variable in the set of flattened interface blocks */
       ir_variable *found_var =
diff --git a/src/glsl/lower_ubo_reference.cpp b/src/glsl/lower_ubo_reference.cpp
index aade203..16b6801 100644
--- a/src/glsl/lower_ubo_reference.cpp
+++ b/src/glsl/lower_ubo_reference.cpp
@@ -132,7 +132,8 @@ lower_ubo_reference_visitor::handle_rvalue(ir_rvalue **rvalue)
    mem_ctx = ralloc_parent(*rvalue);
 
    const char *const field_name =
-      interface_field_name(mem_ctx, (char *) var->interface_type->name, deref);
+      interface_field_name(mem_ctx, (char *) var->get_interface_type()->name,
+                           deref);
 
    this->uniform_block = -1;
    for (unsigned i = 0; i < shader->NumUniformBlocks; i++) {
diff --git a/src/glsl/main.cpp b/src/glsl/main.cpp
index 57bec44..aa188b1 100644
--- a/src/glsl/main.cpp
+++ b/src/glsl/main.cpp
@@ -38,6 +38,8 @@
 #include "loop_analysis.h"
 #include "standalone_scaffolding.h"
 
+static int glsl_version = 330;
+
 static void
 initialize_context(struct gl_context *ctx, gl_api api)
 {
@@ -46,16 +48,150 @@ initialize_context(struct gl_context *ctx, gl_api api)
    /* The standalone compiler needs to claim support for almost
     * everything in order to compile the built-in functions.
     */
-   ctx->Const.GLSLVersion = 330;
+   ctx->Const.GLSLVersion = glsl_version;
    ctx->Extensions.ARB_ES3_compatibility = true;
 
-   ctx->Const.MaxClipPlanes = 8;
-   ctx->Const.MaxDrawBuffers = 2;
-
-   /* More than the 1.10 minimum to appease parser tests taken from
-    * apps that (hopefully) already checked the number of coords.
-    */
-   ctx->Const.MaxTextureCoordUnits = 4;
+   switch (ctx->Const.GLSLVersion) {
+   case 100:
+      ctx->Const.MaxClipPlanes = 0;
+      ctx->Const.MaxCombinedTextureImageUnits = 8;
+      ctx->Const.MaxDrawBuffers = 2;
+      ctx->Const.MinProgramTexelOffset = 0;
+      ctx->Const.MaxProgramTexelOffset = 0;
+      ctx->Const.MaxLights = 0;
+      ctx->Const.MaxTextureCoordUnits = 0;
+      ctx->Const.MaxTextureUnits = 8;
+
+      ctx->Const.VertexProgram.MaxAttribs = 8;
+      ctx->Const.VertexProgram.MaxTextureImageUnits = 0;
+      ctx->Const.VertexProgram.MaxUniformComponents = 128 * 4;
+      ctx->Const.VertexProgram.MaxInputComponents = 0; /* not used */
+      ctx->Const.VertexProgram.MaxOutputComponents = 32;
+
+      ctx->Const.FragmentProgram.MaxTextureImageUnits =
+         ctx->Const.MaxCombinedTextureImageUnits;
+      ctx->Const.FragmentProgram.MaxUniformComponents = 16 * 4;
+      ctx->Const.FragmentProgram.MaxInputComponents =
+         ctx->Const.VertexProgram.MaxOutputComponents;
+      ctx->Const.FragmentProgram.MaxOutputComponents = 0; /* not used */
+
+      ctx->Const.MaxVarying = ctx->Const.VertexProgram.MaxOutputComponents / 4;
+      break;
+   case 110:
+   case 120:
+      ctx->Const.MaxClipPlanes = 6;
+      ctx->Const.MaxCombinedTextureImageUnits = 2;
+      ctx->Const.MaxDrawBuffers = 1;
+      ctx->Const.MinProgramTexelOffset = 0;
+      ctx->Const.MaxProgramTexelOffset = 0;
+      ctx->Const.MaxLights = 8;
+      ctx->Const.MaxTextureCoordUnits = 2;
+      ctx->Const.MaxTextureUnits = 2;
+
+      ctx->Const.VertexProgram.MaxAttribs = 16;
+      ctx->Const.VertexProgram.MaxTextureImageUnits = 0;
+      ctx->Const.VertexProgram.MaxUniformComponents = 512;
+      ctx->Const.VertexProgram.MaxInputComponents = 0; /* not used */
+      ctx->Const.VertexProgram.MaxOutputComponents = 32;
+
+      ctx->Const.FragmentProgram.MaxTextureImageUnits =
+         ctx->Const.MaxCombinedTextureImageUnits;
+      ctx->Const.FragmentProgram.MaxUniformComponents = 64;
+      ctx->Const.FragmentProgram.MaxInputComponents =
+         ctx->Const.VertexProgram.MaxOutputComponents;
+      ctx->Const.FragmentProgram.MaxOutputComponents = 0; /* not used */
+
+      ctx->Const.MaxVarying = ctx->Const.VertexProgram.MaxOutputComponents / 4;
+      break;
+   case 130:
+   case 140:
+      ctx->Const.MaxClipPlanes = 8;
+      ctx->Const.MaxCombinedTextureImageUnits = 16;
+      ctx->Const.MaxDrawBuffers = 8;
+      ctx->Const.MinProgramTexelOffset = -8;
+      ctx->Const.MaxProgramTexelOffset = 7;
+      ctx->Const.MaxLights = 8;
+      ctx->Const.MaxTextureCoordUnits = 8;
+      ctx->Const.MaxTextureUnits = 2;
+
+      ctx->Const.VertexProgram.MaxAttribs = 16;
+      ctx->Const.VertexProgram.MaxTextureImageUnits = 16;
+      ctx->Const.VertexProgram.MaxUniformComponents = 1024;
+      ctx->Const.VertexProgram.MaxInputComponents = 0; /* not used */
+      ctx->Const.VertexProgram.MaxOutputComponents = 64;
+
+      ctx->Const.FragmentProgram.MaxTextureImageUnits = 16;
+      ctx->Const.FragmentProgram.MaxUniformComponents = 1024;
+      ctx->Const.FragmentProgram.MaxInputComponents =
+         ctx->Const.VertexProgram.MaxOutputComponents;
+      ctx->Const.FragmentProgram.MaxOutputComponents = 0; /* not used */
+
+      ctx->Const.MaxVarying = ctx->Const.VertexProgram.MaxOutputComponents / 4;
+      break;
+   case 150:
+   case 330:
+      ctx->Const.MaxClipPlanes = 8;
+      ctx->Const.MaxDrawBuffers = 8;
+      ctx->Const.MinProgramTexelOffset = -8;
+      ctx->Const.MaxProgramTexelOffset = 7;
+      ctx->Const.MaxLights = 8;
+      ctx->Const.MaxTextureCoordUnits = 8;
+      ctx->Const.MaxTextureUnits = 2;
+
+      ctx->Const.VertexProgram.MaxAttribs = 16;
+      ctx->Const.VertexProgram.MaxTextureImageUnits = 16;
+      ctx->Const.VertexProgram.MaxUniformComponents = 1024;
+      ctx->Const.VertexProgram.MaxInputComponents = 0; /* not used */
+      ctx->Const.VertexProgram.MaxOutputComponents = 64;
+
+      ctx->Const.GeometryProgram.MaxTextureImageUnits = 16;
+      ctx->Const.GeometryProgram.MaxUniformComponents = 1024;
+      ctx->Const.GeometryProgram.MaxInputComponents =
+         ctx->Const.VertexProgram.MaxOutputComponents;
+      ctx->Const.GeometryProgram.MaxOutputComponents = 128;
+
+      ctx->Const.FragmentProgram.MaxTextureImageUnits = 16;
+      ctx->Const.FragmentProgram.MaxUniformComponents = 1024;
+      ctx->Const.FragmentProgram.MaxInputComponents =
+         ctx->Const.GeometryProgram.MaxOutputComponents;
+      ctx->Const.FragmentProgram.MaxOutputComponents = 0; /* not used */
+
+      ctx->Const.MaxCombinedTextureImageUnits =
+         ctx->Const.VertexProgram.MaxTextureImageUnits
+         + ctx->Const.GeometryProgram.MaxTextureImageUnits
+         + ctx->Const.FragmentProgram.MaxTextureImageUnits;
+
+      ctx->Const.MaxGeometryOutputVertices = 256;
+      ctx->Const.MaxGeometryTotalOutputComponents = 1024;
+
+//      ctx->Const.MaxGeometryVaryingComponents = 64;
+
+      ctx->Const.MaxVarying = 60 / 4;
+      break;
+   case 300:
+      ctx->Const.MaxClipPlanes = 8;
+      ctx->Const.MaxCombinedTextureImageUnits = 32;
+      ctx->Const.MaxDrawBuffers = 4;
+      ctx->Const.MinProgramTexelOffset = -8;
+      ctx->Const.MaxProgramTexelOffset = 7;
+      ctx->Const.MaxLights = 0;
+      ctx->Const.MaxTextureCoordUnits = 0;
+      ctx->Const.MaxTextureUnits = 0;
+
+      ctx->Const.VertexProgram.MaxAttribs = 16;
+      ctx->Const.VertexProgram.MaxTextureImageUnits = 16;
+      ctx->Const.VertexProgram.MaxUniformComponents = 1024;
+      ctx->Const.VertexProgram.MaxInputComponents = 0; /* not used */
+      ctx->Const.VertexProgram.MaxOutputComponents = 16 * 4;
+
+      ctx->Const.FragmentProgram.MaxTextureImageUnits = 16;
+      ctx->Const.FragmentProgram.MaxUniformComponents = 224;
+      ctx->Const.FragmentProgram.MaxInputComponents = 15 * 4;
+      ctx->Const.FragmentProgram.MaxOutputComponents = 0; /* not used */
+
+      ctx->Const.MaxVarying = ctx->Const.FragmentProgram.MaxInputComponents / 4;
+      break;
+   }
 
    ctx->Driver.NewShader = _mesa_new_shader;
 }
@@ -103,18 +239,17 @@ load_text_file(void *ctx, const char *file_name)
 	return text;
 }
 
-int glsl_es = 0;
 int dump_ast = 0;
 int dump_hir = 0;
 int dump_lir = 0;
 int do_link = 0;
 
 const struct option compiler_opts[] = {
-   { "glsl-es",  0, &glsl_es,  1 },
-   { "dump-ast", 0, &dump_ast, 1 },
-   { "dump-hir", 0, &dump_hir, 1 },
-   { "dump-lir", 0, &dump_lir, 1 },
-   { "link",     0, &do_link,  1 },
+   { "dump-ast", no_argument, &dump_ast, 1 },
+   { "dump-hir", no_argument, &dump_hir, 1 },
+   { "dump-lir", no_argument, &dump_lir, 1 },
+   { "link",     no_argument, &do_link,  1 },
+   { "version",  required_argument, NULL, 'v' },
    { NULL, 0, NULL, 0 }
 };
 
@@ -159,11 +294,37 @@ main(int argc, char **argv)
    int status = EXIT_SUCCESS;
    struct gl_context local_ctx;
    struct gl_context *ctx = &local_ctx;
+   bool glsl_es = false;
 
    int c;
    int idx = 0;
-   while ((c = getopt_long(argc, argv, "", compiler_opts, &idx)) != -1)
-      /* empty */ ;
+   while ((c = getopt_long(argc, argv, "", compiler_opts, &idx)) != -1) {
+      switch (c) {
+      case 'v':
+         glsl_version = strtol(optarg, NULL, 10);
+         switch (glsl_version) {
+         case 100:
+         case 300:
+            glsl_es = true;
+            break;
+         case 110:
+         case 120:
+         case 130:
+         case 140:
+         case 150:
+         case 330:
+            glsl_es = false;
+            break;
+         default:
+            fprintf(stderr, "Unrecognized GLSL version `%s'\n", optarg);
+            usage_fail(argv[0]);
+            break;
+         }
+         break;
+      default:
+         break;
+      }
+   }
 
 
    if (argc <= optind)
@@ -210,8 +371,10 @@ main(int argc, char **argv)
 
       compile_shader(ctx, shader);
 
-      if (!shader->CompileStatus) {
+      if (strlen(shader->InfoLog) > 0)
 	 printf("Info log for %s:\n%s\n", argv[optind], shader->InfoLog);
+
+      if (!shader->CompileStatus) {
 	 status = EXIT_FAILURE;
 	 break;
       }
diff --git a/src/glsl/opt_algebraic.cpp b/src/glsl/opt_algebraic.cpp
index d706a6a..3e5802e 100644
--- a/src/glsl/opt_algebraic.cpp
+++ b/src/glsl/opt_algebraic.cpp
@@ -85,6 +85,12 @@ is_vec_one(ir_constant *ir)
 }
 
 static inline bool
+is_vec_negative_one(ir_constant *ir)
+{
+   return (ir == NULL) ? false : ir->is_negative_one();
+}
+
+static inline bool
 is_vec_basis(ir_constant *ir)
 {
    return (ir == NULL) ? false : ir->is_basis();
@@ -287,6 +293,23 @@ ir_algebraic_visitor::handle_expression(ir_expression *ir)
 	 this->progress = true;
 	 return ir_constant::zero(ir, ir->type);
       }
+      if (is_vec_negative_one(op_const[0])) {
+         this->progress = true;
+         temp = new(mem_ctx) ir_expression(ir_unop_neg,
+                                           ir->operands[1]->type,
+                                           ir->operands[1],
+                                           NULL);
+         return swizzle_if_required(ir, temp);
+      }
+      if (is_vec_negative_one(op_const[1])) {
+         this->progress = true;
+         temp = new(mem_ctx) ir_expression(ir_unop_neg,
+                                           ir->operands[0]->type,
+                                           ir->operands[0],
+                                           NULL);
+         return swizzle_if_required(ir, temp);
+      }
+
 
       /* Reassociate multiplication of constants so that we can do
        * constant folding.
diff --git a/src/glsl/opt_tree_grafting.cpp b/src/glsl/opt_tree_grafting.cpp
index 03b920d..46c06e6 100644
--- a/src/glsl/opt_tree_grafting.cpp
+++ b/src/glsl/opt_tree_grafting.cpp
@@ -275,7 +275,7 @@ ir_tree_grafting_visitor::visit_enter(ir_texture *ir)
    switch (ir->op) {
    case ir_tex:
    case ir_lod:
-   case ir_tg4:
+   case ir_query_levels:
       break;
    case ir_txb:
       if (do_graft(&ir->lod_info.bias))
@@ -296,6 +296,10 @@ ir_tree_grafting_visitor::visit_enter(ir_texture *ir)
 	  do_graft(&ir->lod_info.grad.dPdy))
 	 return visit_stop;
       break;
+   case ir_tg4:
+      if (do_graft(&ir->lod_info.component))
+         return visit_stop;
+      break;
    }
 
    return visit_continue;
diff --git a/src/glsl/standalone_scaffolding.cpp b/src/glsl/standalone_scaffolding.cpp
index b03734c..7a1cf68 100644
--- a/src/glsl/standalone_scaffolding.cpp
+++ b/src/glsl/standalone_scaffolding.cpp
@@ -90,22 +90,33 @@ void initialize_context_to_defaults(struct gl_context *ctx, gl_api api)
 
    ctx->Extensions.dummy_false = false;
    ctx->Extensions.dummy_true = true;
-   ctx->Extensions.ARB_ES2_compatibility = true;
-   ctx->Extensions.ARB_ES3_compatibility = false;
+   ctx->Extensions.ARB_conservative_depth = true;
    ctx->Extensions.ARB_draw_instanced = true;
+   ctx->Extensions.ARB_ES2_compatibility = true;
+   ctx->Extensions.ARB_ES3_compatibility = true;
+   ctx->Extensions.ARB_explicit_attrib_location = true;
    ctx->Extensions.ARB_fragment_coord_conventions = true;
-   ctx->Extensions.EXT_texture_array = true;
-   ctx->Extensions.NV_texture_rectangle = true;
-   ctx->Extensions.EXT_texture3D = true;
-   ctx->Extensions.OES_EGL_image_external = true;
+   ctx->Extensions.ARB_gpu_shader5 = true;
    ctx->Extensions.ARB_shader_bit_encoding = true;
+   ctx->Extensions.ARB_shader_stencil_export = true;
+   ctx->Extensions.ARB_shader_texture_lod = true;
+   ctx->Extensions.ARB_shading_language_420pack = true;
    ctx->Extensions.ARB_shading_language_packing = true;
-   ctx->Extensions.OES_standard_derivatives = true;
    ctx->Extensions.ARB_texture_cube_map_array = true;
+   ctx->Extensions.ARB_texture_gather = true;
    ctx->Extensions.ARB_texture_multisample = true;
+   ctx->Extensions.ARB_texture_query_levels = true;
    ctx->Extensions.ARB_texture_query_lod = true;
-   ctx->Extensions.ARB_gpu_shader5 = true;
-   ctx->Extensions.ARB_texture_gather = true;
+   ctx->Extensions.ARB_uniform_buffer_object = true;
+
+   ctx->Extensions.OES_EGL_image_external = true;
+   ctx->Extensions.OES_standard_derivatives = true;
+
+   ctx->Extensions.EXT_shader_integer_mix = true;
+   ctx->Extensions.EXT_texture3D = true;
+   ctx->Extensions.EXT_texture_array = true;
+
+   ctx->Extensions.NV_texture_rectangle = true;
 
    ctx->Const.GLSLVersion = 120;
 
diff --git a/src/glx/glxcurrent.c b/src/glx/glxcurrent.c
index 3d8893c..a6884cf 100644
--- a/src/glx/glxcurrent.c
+++ b/src/glx/glxcurrent.c
@@ -231,16 +231,6 @@ MakeContextCurrent(Display * dpy, GLXDrawable draw,
       return GL_FALSE;
    }
 
-   if (gc == NULL && (draw != None || read != None)) {
-      __glXGenerateError(dpy, (draw != None) ? draw : read,
-                         BadMatch, X_GLXMakeContextCurrent);
-      return False;
-   }
-   if (gc != NULL && (draw == None || read == None)) {
-      __glXGenerateError(dpy, None, BadMatch, X_GLXMakeContextCurrent);
-      return False;
-   }
-
    _glapi_check_multithread();
 
    __glXLock();
diff --git a/src/glx/indirect_glx.c b/src/glx/indirect_glx.c
index f8944a7..d27b019 100644
--- a/src/glx/indirect_glx.c
+++ b/src/glx/indirect_glx.c
@@ -59,8 +59,9 @@ static Bool
 SendMakeCurrentRequest(Display * dpy, CARD8 opcode,
                        GLXContextID gc_id, GLXContextTag gc_tag,
                        GLXDrawable draw, GLXDrawable read,
-                       xGLXMakeCurrentReply * reply)
+                       GLXContextTag *out_tag)
 {
+   xGLXMakeCurrentReply reply;
    Bool ret;
 
    LockDisplay(dpy);
@@ -112,7 +113,10 @@ SendMakeCurrentRequest(Display * dpy, CARD8 opcode,
       }
    }
 
-   ret = _XReply(dpy, (xReply *) reply, 0, False);
+   ret = _XReply(dpy, (xReply *) &reply, 0, False);
+
+   if (out_tag)
+      *out_tag = reply.contextTag;
 
    UnlockDisplay(dpy);
    SyncHandle();
@@ -124,11 +128,11 @@ static int
 indirect_bind_context(struct glx_context *gc, struct glx_context *old,
 		      GLXDrawable draw, GLXDrawable read)
 {
-   xGLXMakeCurrentReply reply;
    GLXContextTag tag;
    __GLXattribute *state;
    Display *dpy = gc->psc->dpy;
    int opcode = __glXSetupForCommand(dpy);
+   Bool ret;
 
    if (old != &dummyContext && !old->isDirect && old->psc->dpy == dpy) {
       tag = old->currentContextTag;
@@ -137,13 +141,13 @@ indirect_bind_context(struct glx_context *gc, struct glx_context *old,
       tag = 0;
    }
 
-   SendMakeCurrentRequest(dpy, opcode, gc->xid, tag, draw, read, &reply);
+   ret = SendMakeCurrentRequest(dpy, opcode, gc->xid, tag, draw, read,
+                                &gc->currentContextTag);
 
    if (!IndirectAPI)
       IndirectAPI = __glXNewIndirectAPI();
    _glapi_set_dispatch(IndirectAPI);
 
-   gc->currentContextTag = reply.contextTag;
    state = gc->client_state_private;
    if (state->array_state == NULL) {
       glGetString(GL_EXTENSIONS);
@@ -151,7 +155,7 @@ indirect_bind_context(struct glx_context *gc, struct glx_context *old,
       __glXInitVertexArrayState(gc);
    }
 
-   return Success;
+   return ret;
 }
 
 static void
@@ -159,7 +163,6 @@ indirect_unbind_context(struct glx_context *gc, struct glx_context *new)
 {
    Display *dpy = gc->psc->dpy;
    int opcode = __glXSetupForCommand(dpy);
-   xGLXMakeCurrentReply reply;
 
    if (gc == new)
       return;
@@ -170,7 +173,7 @@ indirect_unbind_context(struct glx_context *gc, struct glx_context *new)
     */
    if (!new || new->isDirect || new->psc->dpy != dpy) {
       SendMakeCurrentRequest(dpy, opcode, None,
-			     gc->currentContextTag, None, None, &reply);
+			     gc->currentContextTag, None, None, NULL);
       gc->currentContextTag = 0;
    }
 }
diff --git a/src/mapi/glapi/gen/ARB_texture_multisample.xml b/src/mapi/glapi/gen/ARB_texture_multisample.xml
index f0dd4f5..1f65a8b 100644
--- a/src/mapi/glapi/gen/ARB_texture_multisample.xml
+++ b/src/mapi/glapi/gen/ARB_texture_multisample.xml
@@ -37,7 +37,7 @@
    <function name="TexImage2DMultisample" offset="assign">
       <param name="target" type="GLenum"/>
       <param name="samples" type="GLsizei"/>
-      <param name="internalformat" type="GLint"/>
+      <param name="internalformat" type="GLenum"/>
       <param name="width" type="GLsizei"/>
       <param name="height" type="GLsizei"/>
       <param name="fixedsamplelocations" type="GLboolean"/>
@@ -46,7 +46,7 @@
    <function name="TexImage3DMultisample" offset="assign">
       <param name="target" type="GLenum"/>
       <param name="samples" type="GLsizei"/>
-      <param name="internalformat" type="GLint"/>
+      <param name="internalformat" type="GLenum"/>
       <param name="width" type="GLsizei"/>
       <param name="height" type="GLsizei"/>
       <param name="depth" type="GLsizei"/>
diff --git a/src/mapi/glapi/gen/Makefile.am b/src/mapi/glapi/gen/Makefile.am
index 6bb2f1e..d71d5d2 100644
--- a/src/mapi/glapi/gen/Makefile.am
+++ b/src/mapi/glapi/gen/Makefile.am
@@ -89,11 +89,13 @@ XORG_OUTPUTS = \
 API_XML = \
 	gl_API.xml \
 	ARB_base_instance.xml \
+	ARB_blend_func_extended.xml \
 	ARB_color_buffer_float.xml \
 	ARB_copy_buffer.xml \
 	ARB_debug_output.xml \
 	ARB_depth_buffer_float.xml \
 	ARB_depth_clamp.xml \
+	ARB_draw_buffers.xml \
 	ARB_draw_buffers_blend.xml \
 	ARB_draw_elements_base_vertex.xml \
 	ARB_draw_instanced.xml \
@@ -102,6 +104,8 @@ API_XML = \
 	ARB_framebuffer_object.xml \
 	ARB_geometry_shader4.xml \
 	ARB_instanced_arrays.xml \
+	ARB_internalformat_query.xml \
+	ARB_invalidate_subdata.xml \
 	ARB_map_buffer_range.xml \
 	ARB_robustness.xml \
 	ARB_sampler_objects.xml \
@@ -110,9 +114,13 @@ API_XML = \
 	ARB_texture_buffer_object.xml \
 	ARB_texture_buffer_range.xml \
 	ARB_texture_compression_rgtc.xml \
+	ARB_texture_cube_map_array.xml \
 	ARB_texture_float.xml \
 	ARB_texture_gather.xml \
+	ARB_texture_multisample.xml \
+	ARB_texture_rgb10_a2ui.xml \
 	ARB_texture_rg.xml \
+	ARB_texture_storage_multisample.xml \
 	ARB_texture_storage.xml \
 	ARB_vertex_array_object.xml \
 	AMD_draw_buffers_blend.xml \
diff --git a/src/mapi/glapi/gen/gl_API.xml b/src/mapi/glapi/gen/gl_API.xml
index 3ffa817..48fce36 100644
--- a/src/mapi/glapi/gen/gl_API.xml
+++ b/src/mapi/glapi/gen/gl_API.xml
@@ -5495,7 +5495,7 @@
     <function name="GetProgramiv" offset="assign" es2="2.0">
         <param name="program" type="GLuint"/>
         <param name="pname" type="GLenum"/>
-        <param name="params" type="GLint *"/>
+        <param name="params" type="GLint *" output="true"/>
         <glx ignore="true"/>
     </function>
 
diff --git a/src/mapi/glapi/gen/gl_gentable.py b/src/mapi/glapi/gen/gl_gentable.py
index 5c35271..fa96268 100644
--- a/src/mapi/glapi/gen/gl_gentable.py
+++ b/src/mapi/glapi/gen/gl_gentable.py
@@ -42,7 +42,7 @@ header = """/* GLXEXT is the define used in the xserver when the GLX extension i
 #endif
 
 #if (defined(GLXEXT) && defined(HAVE_BACKTRACE)) \\
-	|| (!defined(GLXEXT) && defined(DEBUG) && !defined(_WIN32_WCE) && !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__OpenBSD__))
+	|| (!defined(GLXEXT) && defined(DEBUG) && !defined(_WIN32_WCE) && !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__OpenBSD__) && !defined(__NetBSD__))
 #define USE_BACKTRACE
 #endif
 
diff --git a/src/mesa/drivers/SConscript b/src/mesa/drivers/SConscript
index 6dcc506..355e680 100644
--- a/src/mesa/drivers/SConscript
+++ b/src/mesa/drivers/SConscript
@@ -5,7 +5,7 @@ SConscript('osmesa/SConscript')
 if env['x11']:
     SConscript('x11/SConscript')
 
-if env['drm']:
+if env['dri']:
     SConscript('dri/common/xmlpool/SConscript')
 
 if env['platform'] == 'windows':
diff --git a/src/mesa/drivers/dri/Makefile.am b/src/mesa/drivers/dri/Makefile.am
index 48d3685..7fa0ad7 100644
--- a/src/mesa/drivers/dri/Makefile.am
+++ b/src/mesa/drivers/dri/Makefile.am
@@ -1,8 +1,6 @@
 SUBDIRS =
 
-if HAVE_COMMON_DRI
 SUBDIRS+=common
-endif
 
 if HAVE_I915_DRI
 SUBDIRS+=i915
diff --git a/src/mesa/drivers/dri/common/dri_util.c b/src/mesa/drivers/dri/common/dri_util.c
index fa520ea..db44eed 100644
--- a/src/mesa/drivers/dri/common/dri_util.c
+++ b/src/mesa/drivers/dri/common/dri_util.c
@@ -39,11 +39,17 @@
  */
 
 
+#include <stdbool.h>
+#ifndef __NOT_HAVE_DRM_H
 #include <xf86drm.h>
+#endif
 #include "dri_util.h"
 #include "utils.h"
 #include "xmlpool.h"
 #include "../glsl/glsl_parser_extras.h"
+#include "main/mtypes.h"
+#include "main/version.h"
+#include "main/macros.h"
 
 PUBLIC const char __dri2ConfigOptions[] =
    DRI_CONF_BEGIN
@@ -70,9 +76,18 @@ setupLoaderExtensions(__DRIscreen *psp,
 	    psp->dri2.image = (__DRIimageLookupExtension *) extensions[i];
 	if (strcmp(extensions[i]->name, __DRI_USE_INVALIDATE) == 0)
 	    psp->dri2.useInvalidate = (__DRIuseInvalidateExtension *) extensions[i];
+	if (strcmp(extensions[i]->name, __DRI_SWRAST_LOADER) == 0)
+	    psp->swrast_loader = (__DRIswrastLoaderExtension *) extensions[i];
     }
 }
 
+/**
+ * This is the first entrypoint in the driver called by the DRI driver loader
+ * after dlopen()ing it.
+ *
+ * It's used to create global state for the driver across contexts on the same
+ * Display.
+ */
 static __DRIscreen *
 dri2CreateNewScreen(int scrn, int fd,
 		    const __DRIextension **extensions,
@@ -80,21 +95,26 @@ dri2CreateNewScreen(int scrn, int fd,
 {
     static const __DRIextension *emptyExtensionList[] = { NULL };
     __DRIscreen *psp;
-    drmVersionPtr version;
 
     psp = calloc(1, sizeof(*psp));
     if (!psp)
 	return NULL;
 
+    psp->driver = &driDriverAPI;
+
     setupLoaderExtensions(psp, extensions);
 
-    version = drmGetVersion(fd);
-    if (version) {
-	psp->drm_version.major = version->version_major;
-	psp->drm_version.minor = version->version_minor;
-	psp->drm_version.patch = version->version_patchlevel;
-	drmFreeVersion(version);
+#ifndef __NOT_HAVE_DRM_H
+    if (fd != -1) {
+       drmVersionPtr version = drmGetVersion(fd);
+       if (version) {
+          psp->drm_version.major = version->version_major;
+          psp->drm_version.minor = version->version_minor;
+          psp->drm_version.patch = version->version_patchlevel;
+          drmFreeVersion(version);
+       }
     }
+#endif
 
     psp->loaderPrivate = data;
 
@@ -102,20 +122,46 @@ dri2CreateNewScreen(int scrn, int fd,
     psp->fd = fd;
     psp->myNum = scrn;
 
-    psp->api_mask = (1 << __DRI_API_OPENGL);
-
-    *driver_configs = driDriverAPI.InitScreen(psp);
+    *driver_configs = psp->driver->InitScreen(psp);
     if (*driver_configs == NULL) {
 	free(psp);
 	return NULL;
     }
 
+    int gl_version_override = _mesa_get_gl_version_override();
+    if (gl_version_override >= 31) {
+       psp->max_gl_core_version = MAX2(psp->max_gl_core_version,
+                                       gl_version_override);
+    } else {
+       psp->max_gl_compat_version = MAX2(psp->max_gl_compat_version,
+                                         gl_version_override);
+    }
+
+    psp->api_mask = (1 << __DRI_API_OPENGL);
+    if (psp->max_gl_core_version > 0)
+       psp->api_mask |= (1 << __DRI_API_OPENGL_CORE);
+    if (psp->max_gl_es1_version > 0)
+       psp->api_mask |= (1 << __DRI_API_GLES);
+    if (psp->max_gl_es2_version > 0)
+       psp->api_mask |= (1 << __DRI_API_GLES2);
+    if (psp->max_gl_es2_version >= 30)
+       psp->api_mask |= (1 << __DRI_API_GLES3);
+
     driParseOptionInfo(&psp->optionInfo, __dri2ConfigOptions);
     driParseConfigFiles(&psp->optionCache, &psp->optionInfo, psp->myNum, "dri2");
 
+
     return psp;
 }
 
+/** swrast driver createNewScreen entrypoint. */
+static __DRIscreen *
+driCreateNewScreen(int scrn, const __DRIextension **extensions,
+		   const __DRIconfig ***driver_configs, void *data)
+{
+   return dri2CreateNewScreen(scrn, -1, extensions, driver_configs, data);
+}
+
 /**
  * Destroy the per-screen private information.
  * 
@@ -133,7 +179,7 @@ static void driDestroyScreen(__DRIscreen *psp)
 
        _mesa_destroy_shader_compiler();
 
-	driDriverAPI.DestroyScreen(psp);
+	psp->driver->DestroyScreen(psp);
 
 	driDestroyOptionCache(&psp->optionCache);
 	driDestroyOptionInfo(&psp->optionInfo);
@@ -150,6 +196,45 @@ static const __DRIextension **driGetExtensions(__DRIscreen *psp)
 /*@}*/
 
 
+static bool
+validate_context_version(__DRIscreen *screen,
+                         int mesa_api,
+                         unsigned major_version,
+                         unsigned minor_version,
+                         unsigned *dri_ctx_error)
+{
+   unsigned req_version = 10 * major_version + minor_version;
+   unsigned max_version = 0;
+
+   switch (mesa_api) {
+   case API_OPENGL_COMPAT:
+      max_version = screen->max_gl_compat_version;
+      break;
+   case API_OPENGL_CORE:
+      max_version = screen->max_gl_core_version;
+      break;
+   case API_OPENGLES:
+      max_version = screen->max_gl_es1_version;
+      break;
+   case API_OPENGLES2:
+      max_version = screen->max_gl_es2_version;
+      break;
+   default:
+      max_version = 0;
+      break;
+   }
+
+   if (max_version == 0) {
+      *dri_ctx_error = __DRI_CTX_ERROR_BAD_API;
+      return false;
+   } else if (req_version > max_version) {
+      *dri_ctx_error = __DRI_CTX_ERROR_BAD_VERSION;
+      return false;
+   }
+
+   return true;
+}
+
 /*****************************************************************/
 /** \name Context handling functions                             */
 /*****************************************************************/
@@ -271,6 +356,10 @@ dri2CreateContextAttribs(__DRIscreen *screen, int api,
 	return NULL;
     }
 
+    if (!validate_context_version(screen, mesa_api,
+                                  major_version, minor_version, error))
+       return NULL;
+
     context = calloc(1, sizeof *context);
     if (!context) {
 	*error = __DRI_CTX_ERROR_NO_MEMORY;
@@ -283,13 +372,21 @@ dri2CreateContextAttribs(__DRIscreen *screen, int api,
     context->driDrawablePriv = NULL;
     context->driReadablePriv = NULL;
 
-    if (!driDriverAPI.CreateContext(mesa_api, modes, context,
-				    major_version, minor_version,
-				    flags, error, shareCtx) ) {
+    if (!screen->driver->CreateContext(mesa_api, modes, context,
+                                       major_version, minor_version,
+                                       flags, error, shareCtx) ) {
         free(context);
         return NULL;
     }
 
+    struct gl_context *ctx = context->driverPrivate;
+    if ((flags & __DRI_CTX_FLAG_FORWARD_COMPATIBLE) != 0)
+        ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT;
+    if ((flags & __DRI_CTX_FLAG_DEBUG) != 0) {
+        ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_DEBUG_BIT;
+        ctx->Debug.DebugOutput = GL_TRUE;
+    }
+
     *error = __DRI_CTX_ERROR_SUCCESS;
     return context;
 }
@@ -324,7 +421,7 @@ static void
 driDestroyContext(__DRIcontext *pcp)
 {
     if (pcp) {
-	driDriverAPI.DestroyContext(pcp);
+	pcp->driScreenPriv->driver->DestroyContext(pcp);
 	free(pcp);
     }
 }
@@ -377,7 +474,7 @@ static int driBindContext(__DRIcontext *pcp,
 	dri_get_drawable(prp);
     }
 
-    return driDriverAPI.MakeCurrent(pcp, pdp, prp);
+    return pcp->driScreenPriv->driver->MakeCurrent(pcp, pdp, prp);
 }
 
 /**
@@ -416,7 +513,7 @@ static int driUnbindContext(__DRIcontext *pcp)
     if (!pdp && !prp)
 	return GL_TRUE;
 
-    driDriverAPI.UnbindContext(pcp);
+    pcp->driScreenPriv->driver->UnbindContext(pcp);
 
     assert(pdp);
     if (pdp->refcount == 0) {
@@ -435,10 +532,6 @@ static int driUnbindContext(__DRIcontext *pcp)
 	dri_put_drawable(prp);
     }
 
-    /* XXX this is disabled so that if we call SwapBuffers on an unbound
-     * window we can determine the last context bound to the window and
-     * use that context's lock. (BrianP, 2-Dec-2000)
-     */
     pcp->driDrawablePriv = NULL;
     pcp->driReadablePriv = NULL;
 
@@ -460,7 +553,7 @@ static void dri_put_drawable(__DRIdrawable *pdp)
 	if (pdp->refcount)
 	    return;
 
-	driDriverAPI.DestroyBuffer(pdp);
+	pdp->driScreenPriv->driver->DestroyBuffer(pdp);
 	free(pdp);
     }
 }
@@ -487,7 +580,8 @@ dri2CreateNewDrawable(__DRIscreen *screen,
 
     dri_get_drawable(pdraw);
 
-    if (!driDriverAPI.CreateBuffer(screen, pdraw, &config->modes, GL_FALSE)) {
+    if (!screen->driver->CreateBuffer(screen, pdraw, &config->modes,
+                                      GL_FALSE)) {
        free(pdraw);
        return NULL;
     }
@@ -508,14 +602,14 @@ dri2AllocateBuffer(__DRIscreen *screen,
 		   unsigned int attachment, unsigned int format,
 		   int width, int height)
 {
-    return driDriverAPI.AllocateBuffer(screen, attachment, format,
-				       width, height);
+    return screen->driver->AllocateBuffer(screen, attachment, format,
+                                          width, height);
 }
 
 static void
 dri2ReleaseBuffer(__DRIscreen *screen, __DRIbuffer *buffer)
 {
-    driDriverAPI.ReleaseBuffer(screen, buffer);
+    screen->driver->ReleaseBuffer(screen, buffer);
 }
 
 
@@ -559,6 +653,19 @@ dri2GetAPIMask(__DRIscreen *screen)
     return screen->api_mask;
 }
 
+/**
+ * swrast swapbuffers entrypoint.
+ *
+ * DRI2 implements this inside the loader with only flushes handled by the
+ * driver.
+ */
+static void
+driSwapBuffers(__DRIdrawable *pdp)
+{
+    assert(pdp->driScreenPriv->swrast_loader);
+
+    pdp->driScreenPriv->driver->SwapBuffers(pdp);
+}
 
 /** Core interface */
 const __DRIcoreExtension driCoreExtension = {
@@ -571,8 +678,8 @@ const __DRIcoreExtension driCoreExtension = {
     .indexConfigAttrib          = driIndexConfigAttrib,
     .createNewDrawable          = NULL,
     .destroyDrawable            = driDestroyDrawable,
-    .swapBuffers                = NULL,
-    .createNewContext           = NULL,
+    .swapBuffers                = driSwapBuffers, /* swrast */
+    .createNewContext           = dri2CreateNewContext, /* swrast */
     .copyContext                = driCopyContext,
     .destroyContext             = driDestroyContext,
     .bindContext                = driBindContext,
@@ -593,6 +700,14 @@ const __DRIdri2Extension driDRI2Extension = {
     .createContextAttribs       = dri2CreateContextAttribs
 };
 
+const __DRIswrastExtension driSWRastExtension = {
+    { __DRI_SWRAST, __DRI_SWRAST_VERSION },
+    driCreateNewScreen,
+    dri2CreateNewDrawable,
+    dri2CreateNewContextForAPI,
+    dri2CreateContextAttribs
+};
+
 const __DRI2configQueryExtension dri2ConfigQueryExtension = {
    .base = { __DRI2_CONFIG_QUERY, __DRI2_CONFIG_QUERY_VERSION },
 
diff --git a/src/mesa/drivers/dri/common/dri_util.h b/src/mesa/drivers/dri/common/dri_util.h
index 900f048..61c80bc 100644
--- a/src/mesa/drivers/dri/common/dri_util.h
+++ b/src/mesa/drivers/dri/common/dri_util.h
@@ -123,6 +123,12 @@ extern const struct __DriverAPIRec driDriverAPI;
  */
 struct __DRIscreenRec {
     /**
+     * Driver-specific entrypoints provided by the driver's
+     * __DRIDriverVtableExtensionRec.
+     */
+    const struct __DriverAPIRec *driver;
+
+    /**
      * Current screen's number
      */
     int myNum;
@@ -151,6 +157,11 @@ struct __DRIscreenRec {
 
     void *loaderPrivate;
 
+    int max_gl_core_version;
+    int max_gl_compat_version;
+    int max_gl_es1_version;
+    int max_gl_es2_version;
+
     const __DRIextension **extensions;
 
     const __DRIswrastLoaderExtension *swrast_loader;
diff --git a/src/mesa/drivers/dri/common/drisw_util.c b/src/mesa/drivers/dri/common/drisw_util.c
deleted file mode 100644
index 89f03c3..0000000
--- a/src/mesa/drivers/dri/common/drisw_util.c
+++ /dev/null
@@ -1,375 +0,0 @@
-/*
- * Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- * Copyright 2010 George Sapountzis <gsapountzis@gmail.com>
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- */
-
-/**
- * \file drisw_util.c
- *
- * DRISW utility functions, i.e. dri_util.c stripped from drm-specific bits.
- */
-
-#include "dri_util.h"
-#include "utils.h"
-
-
-/**
- * Screen functions
- */
-
-static void
-setupLoaderExtensions(__DRIscreen *psp,
-		      const __DRIextension **extensions)
-{
-    int i;
-
-    for (i = 0; extensions[i]; i++) {
-	if (strcmp(extensions[i]->name, __DRI_SWRAST_LOADER) == 0)
-	    psp->swrast_loader = (__DRIswrastLoaderExtension *) extensions[i];
-    }
-}
-
-static __DRIscreen *
-driCreateNewScreen(int scrn, const __DRIextension **extensions,
-		   const __DRIconfig ***driver_configs, void *data)
-{
-    static const __DRIextension *emptyExtensionList[] = { NULL };
-    __DRIscreen *psp;
-
-    psp = CALLOC_STRUCT(__DRIscreenRec);
-    if (!psp)
-	return NULL;
-
-    setupLoaderExtensions(psp, extensions);
-
-    psp->loaderPrivate = data;
-
-    psp->extensions = emptyExtensionList;
-    psp->fd = -1;
-    psp->myNum = scrn;
-
-    *driver_configs = driDriverAPI.InitScreen(psp);
-    if (*driver_configs == NULL) {
-	free(psp);
-	return NULL;
-    }
-
-    return psp;
-}
-
-static void driDestroyScreen(__DRIscreen *psp)
-{
-    if (psp) {
-	driDriverAPI.DestroyScreen(psp);
-	free(psp);
-    }
-}
-
-static const __DRIextension **driGetExtensions(__DRIscreen *psp)
-{
-    return psp->extensions;
-}
-
-
-/**
- * Context functions
- */
-
-static __DRIcontext *
-driCreateContextAttribs(__DRIscreen *screen, int api,
-			const __DRIconfig *config,
-			__DRIcontext *shared,
-			unsigned num_attribs,
-			const uint32_t *attribs,
-			unsigned *error,
-			void *data)
-{
-    __DRIcontext *pcp;
-    const struct gl_config *modes = (config != NULL) ? &config->modes : NULL;
-    void * const shareCtx = (shared != NULL) ? shared->driverPrivate : NULL;
-    gl_api mesa_api;
-    unsigned major_version = 1;
-    unsigned minor_version = 0;
-    uint32_t flags = 0;
-
-    /* Either num_attribs is zero and attribs is NULL, or num_attribs is not
-     * zero and attribs is not NULL.
-     */
-    assert((num_attribs == 0) == (attribs == NULL));
-
-    switch (api) {
-    case __DRI_API_OPENGL:
-            mesa_api = API_OPENGL_COMPAT;
-            break;
-    case __DRI_API_GLES:
-            mesa_api = API_OPENGLES;
-            break;
-    case __DRI_API_GLES2:
-    case __DRI_API_GLES3:
-            mesa_api = API_OPENGLES2;
-            break;
-    case __DRI_API_OPENGL_CORE:
-            mesa_api = API_OPENGL_CORE;
-            break;
-    default:
-            *error = __DRI_CTX_ERROR_BAD_API;
-            return NULL;
-    }
-
-    for (unsigned i = 0; i < num_attribs; i++) {
-	switch (attribs[i * 2]) {
-	case __DRI_CTX_ATTRIB_MAJOR_VERSION:
-	    major_version = attribs[i * 2 + 1];
-	    break;
-	case __DRI_CTX_ATTRIB_MINOR_VERSION:
-	    minor_version = attribs[i * 2 + 1];
-	    break;
-	case __DRI_CTX_ATTRIB_FLAGS:
-	    flags = attribs[i * 2 + 1];
-	    break;
-	default:
-	    /* We can't create a context that satisfies the requirements of an
-	     * attribute that we don't understand.  Return failure.
-	     */
-	    return NULL;
-	}
-    }
-
-    /* Mesa does not support the GL_ARB_compatibilty extension or the
-     * compatibility profile.  This means that we treat a API_OPENGL_COMPAT 3.1 as
-     * API_OPENGL_CORE and reject API_OPENGL_COMPAT 3.2+.
-     */
-    if (mesa_api == API_OPENGL_COMPAT && major_version == 3 && minor_version == 1)
-       mesa_api = API_OPENGL_CORE;
-
-    if (mesa_api == API_OPENGL_COMPAT
-        && ((major_version > 3)
-            || (major_version == 3 && minor_version >= 2))) {
-       *error = __DRI_CTX_ERROR_BAD_API;
-       return NULL;
-    }
-    /* There are no forward-compatible contexts before OpenGL 3.0.  The
-     * GLX_ARB_create_context spec says:
-     *
-     *     "Forward-compatible contexts are defined only for OpenGL versions
-     *     3.0 and later."
-     *
-     * Moreover, Mesa can't fulfill the requirements of a forward-looking
-     * context.  Return failure if a forward-looking context is requested.
-     *
-     * In Mesa, a debug context is the same as a regular context.
-     */
-    if (major_version >= 3) {
-	if ((flags & ~__DRI_CTX_FLAG_DEBUG) != 0)
-	    return NULL;
-    }
-
-    pcp = CALLOC_STRUCT(__DRIcontextRec);
-    if (!pcp)
-        return NULL;
-
-    pcp->loaderPrivate = data;
-
-    pcp->driScreenPriv = screen;
-    pcp->driDrawablePriv = NULL;
-    pcp->driReadablePriv = NULL;
-
-    if (!driDriverAPI.CreateContext(mesa_api, modes, pcp,
-				    major_version, minor_version,
-				    flags, error, shareCtx)) {
-        free(pcp);
-        return NULL;
-    }
-
-    return pcp;
-}
-
-static __DRIcontext *
-driCreateNewContextForAPI(__DRIscreen *psp, int api,
-                          const __DRIconfig *config,
-                          __DRIcontext *shared, void *data)
-{
-    unsigned error;
-
-    return driCreateContextAttribs(psp, api, config, shared, 0, NULL,
-				   &error, data);
-}
-
-static __DRIcontext *
-driCreateNewContext(__DRIscreen *psp, const __DRIconfig *config,
-		    __DRIcontext *shared, void *data)
-{
-    return driCreateNewContextForAPI(psp, __DRI_API_OPENGL,
-				     config, shared, data);
-}
-
-static void
-driDestroyContext(__DRIcontext *pcp)
-{
-    if (pcp) {
-	driDriverAPI.DestroyContext(pcp);
-	free(pcp);
-    }
-}
-
-static int
-driCopyContext(__DRIcontext *dst, __DRIcontext *src, unsigned long mask)
-{
-    return GL_FALSE;
-}
-
-static void dri_get_drawable(__DRIdrawable *pdp);
-static void dri_put_drawable(__DRIdrawable *pdp);
-
-static int driBindContext(__DRIcontext *pcp,
-			  __DRIdrawable *pdp,
-			  __DRIdrawable *prp)
-{
-    /* Bind the drawable to the context */
-    if (pcp) {
-	pcp->driDrawablePriv = pdp;
-	pcp->driReadablePriv = prp;
-	if (pdp) {
-	    pdp->driContextPriv = pcp;
-	    dri_get_drawable(pdp);
-	}
-	if (prp && pdp != prp) {
-	    dri_get_drawable(prp);
-	}
-    }
-
-    return driDriverAPI.MakeCurrent(pcp, pdp, prp);
-}
-
-static int driUnbindContext(__DRIcontext *pcp)
-{
-    __DRIdrawable *pdp;
-    __DRIdrawable *prp;
-
-    if (pcp == NULL)
-	return GL_FALSE;
-
-    pdp = pcp->driDrawablePriv;
-    prp = pcp->driReadablePriv;
-
-    /* already unbound */
-    if (!pdp && !prp)
-	return GL_TRUE;
-
-    driDriverAPI.UnbindContext(pcp);
-
-    dri_put_drawable(pdp);
-
-    if (prp != pdp) {
-	dri_put_drawable(prp);
-    }
-
-    pcp->driDrawablePriv = NULL;
-    pcp->driReadablePriv = NULL;
-
-    return GL_TRUE;
-}
-
-
-/**
- * Drawable functions
- */
-
-static void dri_get_drawable(__DRIdrawable *pdp)
-{
-    pdp->refcount++;
-}
-
-static void dri_put_drawable(__DRIdrawable *pdp)
-{
-    if (pdp) {
-	pdp->refcount--;
-	if (pdp->refcount)
-	    return;
-
-	driDriverAPI.DestroyBuffer(pdp);
-	free(pdp);
-    }
-}
-
-static __DRIdrawable *
-driCreateNewDrawable(__DRIscreen *psp,
-		     const __DRIconfig *config, void *data)
-{
-    __DRIdrawable *pdp;
-
-    pdp = CALLOC_STRUCT(__DRIdrawableRec);
-    if (!pdp)
-	return NULL;
-
-    pdp->loaderPrivate = data;
-
-    pdp->driScreenPriv = psp;
-    pdp->driContextPriv = NULL;
-
-    dri_get_drawable(pdp);
-
-    if (!driDriverAPI.CreateBuffer(psp, pdp, &config->modes, GL_FALSE)) {
-	free(pdp);
-	return NULL;
-    }
-
-    pdp->lastStamp = 1; /* const */
-
-    return pdp;
-}
-
-static void
-driDestroyDrawable(__DRIdrawable *pdp)
-{
-    dri_put_drawable(pdp);
-}
-
-static void driSwapBuffers(__DRIdrawable *pdp)
-{
-    driDriverAPI.SwapBuffers(pdp);
-}
-
-const __DRIcoreExtension driCoreExtension = {
-    { __DRI_CORE, __DRI_CORE_VERSION },
-    NULL, /* driCreateNewScreen */
-    driDestroyScreen,
-    driGetExtensions,
-    driGetConfigAttrib,
-    driIndexConfigAttrib,
-    NULL, /* driCreateNewDrawable */
-    driDestroyDrawable,
-    driSwapBuffers,
-    driCreateNewContext,
-    driCopyContext,
-    driDestroyContext,
-    driBindContext,
-    driUnbindContext
-};
-
-const __DRIswrastExtension driSWRastExtension = {
-    { __DRI_SWRAST, __DRI_SWRAST_VERSION },
-    driCreateNewScreen,
-    driCreateNewDrawable,
-    driCreateNewContextForAPI,
-    driCreateContextAttribs
-};
diff --git a/src/mesa/drivers/dri/common/utils.c b/src/mesa/drivers/dri/common/utils.c
index c9fc218..f3780d9 100644
--- a/src/mesa/drivers/dri/common/utils.c
+++ b/src/mesa/drivers/dri/common/utils.c
@@ -189,6 +189,10 @@ driCreateConfigs(gl_format format,
       { 0x00FF0000, 0x0000FF00, 0x000000FF, 0x00000000 },
       /* MESA_FORMAT_ARGB8888 */
       { 0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000 },
+      /* MESA_FORMAT_XRGB2101010_UNORM */
+      { 0x3FF00000, 0x000FFC00, 0x000003FF, 0x00000000 },
+      /* MESA_FORMAT_ARGB2101010 */
+      { 0x3FF00000, 0x000FFC00, 0x000003FF, 0xC0000000 },
    };
 
    const uint32_t * masks;
@@ -214,6 +218,12 @@ driCreateConfigs(gl_format format,
    case MESA_FORMAT_SARGB8:
       masks = masks_table[2];
       break;
+   case MESA_FORMAT_XRGB2101010_UNORM:
+      masks = masks_table[3];
+      break;
+   case MESA_FORMAT_ARGB2101010:
+      masks = masks_table[4];
+      break;
    default:
       fprintf(stderr, "[%s:%u] Unknown framebuffer type %s (%d).\n",
               __FUNCTION__, __LINE__,
diff --git a/src/mesa/drivers/dri/i915/intel_context.c b/src/mesa/drivers/dri/i915/intel_context.c
index f27e3d0..d25358b 100644
--- a/src/mesa/drivers/dri/i915/intel_context.c
+++ b/src/mesa/drivers/dri/i915/intel_context.c
@@ -367,45 +367,6 @@ intelInitDriverFunctions(struct dd_function_table *functions)
    intel_init_syncobj_functions(functions);
 }
 
-static bool
-validate_context_version(struct intel_screen *screen,
-                         int mesa_api,
-                         unsigned major_version,
-                         unsigned minor_version,
-                         unsigned *dri_ctx_error)
-{
-   unsigned req_version = 10 * major_version + minor_version;
-   unsigned max_version = 0;
-
-   switch (mesa_api) {
-   case API_OPENGL_COMPAT:
-      max_version = screen->max_gl_compat_version;
-      break;
-   case API_OPENGL_CORE:
-      max_version = screen->max_gl_core_version;
-      break;
-   case API_OPENGLES:
-      max_version = screen->max_gl_es1_version;
-      break;
-   case API_OPENGLES2:
-      max_version = screen->max_gl_es2_version;
-      break;
-   default:
-      max_version = 0;
-      break;
-   }
-
-   if (max_version == 0) {
-      *dri_ctx_error = __DRI_CTX_ERROR_BAD_API;
-      return false;
-   } else if (req_version > max_version) {
-      *dri_ctx_error = __DRI_CTX_ERROR_BAD_VERSION;
-      return false;
-   }
-
-   return true;
-}
-
 bool
 intelInitContext(struct intel_context *intel,
                  int api,
@@ -424,17 +385,6 @@ intelInitContext(struct intel_context *intel,
    int bo_reuse_mode;
    struct gl_config visual;
 
-   /* we can't do anything without a connection to the device */
-   if (intelScreen->bufmgr == NULL) {
-      *dri_ctx_error = __DRI_CTX_ERROR_NO_MEMORY;
-      return false;
-   }
-
-   if (!validate_context_version(intelScreen,
-                                 api, major_version, minor_version,
-                                 dri_ctx_error))
-      return false;
-
    /* Can't rely on invalidate events, fall back to glViewport hack */
    if (!driContextPriv->driScreenPriv->dri2.useInvalidate) {
       intel->saved_viewport = functions->Viewport;
diff --git a/src/mesa/drivers/dri/i915/intel_context.h b/src/mesa/drivers/dri/i915/intel_context.h
index 6edb189..6fb73fc 100644
--- a/src/mesa/drivers/dri/i915/intel_context.h
+++ b/src/mesa/drivers/dri/i915/intel_context.h
@@ -293,32 +293,6 @@ extern char *__progname;
 #define SUBPIXEL_X 0.125
 #define SUBPIXEL_Y 0.125
 
-/**
- * Align a value down to an alignment value
- *
- * If \c value is not already aligned to the requested alignment value, it
- * will be rounded down.
- *
- * \param value  Value to be rounded
- * \param alignment  Alignment value to be used.  This must be a power of two.
- *
- * \sa ALIGN()
- */
-#define ROUND_DOWN_TO(value, alignment) ((value) & ~(alignment - 1))
-
-static INLINE uint32_t
-U_FIXED(float value, uint32_t frac_bits)
-{
-   value *= (1 << frac_bits);
-   return value < 0 ? 0 : value;
-}
-
-static INLINE uint32_t
-S_FIXED(float value, uint32_t frac_bits)
-{
-   return value * (1 << frac_bits);
-}
-
 #define INTEL_FIREVERTICES(intel)		\
 do {						\
    if ((intel)->prim.flush)			\
diff --git a/src/mesa/drivers/dri/i915/intel_screen.c b/src/mesa/drivers/dri/i915/intel_screen.c
index e3e6ac2..4f8c342 100644
--- a/src/mesa/drivers/dri/i915/intel_screen.c
+++ b/src/mesa/drivers/dri/i915/intel_screen.c
@@ -1062,33 +1062,25 @@ intel_screen_make_configs(__DRIscreen *dri_screen)
 static void
 set_max_gl_versions(struct intel_screen *screen)
 {
-   int gl_version_override = _mesa_get_gl_version_override();
+   __DRIscreen *psp = screen->driScrnPriv;
 
    switch (screen->gen) {
    case 3:
-      screen->max_gl_core_version = 0;
-      screen->max_gl_es1_version = 11;
-      screen->max_gl_compat_version = 21;
-      screen->max_gl_es2_version = 20;
+      psp->max_gl_core_version = 0;
+      psp->max_gl_es1_version = 11;
+      psp->max_gl_compat_version = 21;
+      psp->max_gl_es2_version = 20;
       break;
    case 2:
-      screen->max_gl_core_version = 0;
-      screen->max_gl_compat_version = 13;
-      screen->max_gl_es1_version = 11;
-      screen->max_gl_es2_version = 0;
+      psp->max_gl_core_version = 0;
+      psp->max_gl_compat_version = 13;
+      psp->max_gl_es1_version = 11;
+      psp->max_gl_es2_version = 0;
       break;
    default:
       assert(!"unrecognized intel_screen::gen");
       break;
    }
-
-   if (gl_version_override >= 31) {
-      screen->max_gl_core_version = MAX2(screen->max_gl_core_version,
-                                         gl_version_override);
-   } else {
-      screen->max_gl_compat_version = MAX2(screen->max_gl_compat_version,
-                                           gl_version_override);
-   }
 }
 
 /**
@@ -1137,16 +1129,6 @@ __DRIconfig **intelInitScreen2(__DRIscreen *psp)
 
    set_max_gl_versions(intelScreen);
 
-   psp->api_mask = (1 << __DRI_API_OPENGL);
-   if (intelScreen->max_gl_core_version > 0)
-      psp->api_mask |= (1 << __DRI_API_OPENGL_CORE);
-   if (intelScreen->max_gl_es1_version > 0)
-      psp->api_mask |= (1 << __DRI_API_GLES);
-   if (intelScreen->max_gl_es2_version > 0)
-      psp->api_mask |= (1 << __DRI_API_GLES2);
-   if (intelScreen->max_gl_es2_version >= 30)
-      psp->api_mask |= (1 << __DRI_API_GLES3);
-
    psp->extensions = intelScreenExtensions;
 
    return (const __DRIconfig**) intel_screen_make_configs(psp);
diff --git a/src/mesa/drivers/dri/i915/intel_screen.h b/src/mesa/drivers/dri/i915/intel_screen.h
index a0ff0e0..331ce90 100644
--- a/src/mesa/drivers/dri/i915/intel_screen.h
+++ b/src/mesa/drivers/dri/i915/intel_screen.h
@@ -40,11 +40,6 @@ struct intel_screen
    int deviceID;
    int gen;
 
-   int max_gl_core_version;
-   int max_gl_compat_version;
-   int max_gl_es1_version;
-   int max_gl_es2_version;
-
    __DRIscreen *driScrnPriv;
 
    bool no_hw;
diff --git a/src/mesa/drivers/dri/i965/Makefile.sources b/src/mesa/drivers/dri/i965/Makefile.sources
index e219316..c4d689e 100644
--- a/src/mesa/drivers/dri/i965/Makefile.sources
+++ b/src/mesa/drivers/dri/i965/Makefile.sources
@@ -7,7 +7,7 @@ i965_FILES = \
 	intel_blit.c \
 	intel_buffer_objects.c \
 	intel_buffers.c \
-	intel_context.c \
+	intel_debug.c \
 	intel_extensions.c \
 	intel_fbo.c \
 	intel_mipmap_tree.c \
@@ -44,6 +44,7 @@ i965_FILES = \
 	brw_context.c \
 	brw_cubemap_normalize.cpp \
 	brw_curbe.c \
+	brw_device_info.c \
 	brw_disasm.c \
 	brw_draw.c \
 	brw_draw_upload.c \
@@ -100,7 +101,6 @@ i965_FILES = \
 	brw_vs.c \
 	brw_vs_state.c \
 	brw_vs_surface_state.c \
-	brw_vtbl.c \
 	brw_wm.c \
 	brw_wm_iz.cpp \
 	brw_wm_sampler_state.c \
diff --git a/src/mesa/drivers/dri/i965/brw_binding_tables.c b/src/mesa/drivers/dri/i965/brw_binding_tables.c
index 9d15bac..bc39ae7 100644
--- a/src/mesa/drivers/dri/i965/brw_binding_tables.c
+++ b/src/mesa/drivers/dri/i965/brw_binding_tables.c
@@ -50,19 +50,16 @@
  * This copies brw_stage_state::surf_offset[] into the indirect state section
  * of the batchbuffer (allocated by brw_state_batch()).
  */
-void
+static void
 brw_upload_binding_table(struct brw_context *brw,
                          GLbitfield brw_new_binding_table,
-                         struct brw_stage_state *stage_state,
-                         unsigned binding_table_entries,
-                         int shader_time_surf_index)
+                         struct brw_stage_state *stage_state)
 {
-   if (INTEL_DEBUG & DEBUG_SHADER_TIME) {
-      gen7_create_shader_time_surface(brw, &stage_state->surf_offset[shader_time_surf_index]);
-   }
+   /* CACHE_NEW_*_PROG */
+   struct brw_stage_prog_data *prog_data = stage_state->prog_data;
 
    /* If there are no surfaces, skip making the binding table altogether. */
-   if (binding_table_entries == 0) {
+   if (prog_data->binding_table.size_bytes == 0) {
       if (stage_state->bind_bo_offset != 0) {
          brw->state.dirty.brw |= brw_new_binding_table;
          stage_state->bind_bo_offset = 0;
@@ -70,14 +67,16 @@ brw_upload_binding_table(struct brw_context *brw,
       return;
    }
 
-   size_t table_size_in_bytes = binding_table_entries * sizeof(uint32_t);
+   if (INTEL_DEBUG & DEBUG_SHADER_TIME) {
+      gen7_create_shader_time_surface(brw, &stage_state->surf_offset[prog_data->binding_table.shader_time_start]);
+   }
 
    uint32_t *bind = brw_state_batch(brw, AUB_TRACE_BINDING_TABLE,
-                                    table_size_in_bytes, 32,
+                                    prog_data->binding_table.size_bytes, 32,
                                     &stage_state->bind_bo_offset);
 
    /* BRW_NEW_SURFACES and BRW_NEW_*_CONSTBUF */
-   memcpy(bind, stage_state->surf_offset, table_size_in_bytes);
+   memcpy(bind, stage_state->surf_offset, prog_data->binding_table.size_bytes);
 
    brw->state.dirty.brw |= brw_new_binding_table;
 }
@@ -91,14 +90,7 @@ brw_upload_binding_table(struct brw_context *brw,
 static void
 brw_vs_upload_binding_table(struct brw_context *brw)
 {
-   struct brw_stage_state *stage_state = &brw->vs.base;
-   /* CACHE_NEW_VS_PROG */
-   const struct brw_vec4_prog_data *prog_data = &brw->vs.prog_data->base;
-
-   /* BRW_NEW_SURFACES and BRW_NEW_VS_CONSTBUF */
-   brw_upload_binding_table(brw, BRW_NEW_VS_BINDING_TABLE, stage_state,
-                            prog_data->binding_table_size,
-                            SURF_INDEX_VEC4_SHADER_TIME);
+   brw_upload_binding_table(brw, BRW_NEW_VS_BINDING_TABLE, &brw->vs.base);
 }
 
 const struct brw_tracked_state brw_vs_binding_table = {
@@ -117,12 +109,7 @@ const struct brw_tracked_state brw_vs_binding_table = {
 static void
 brw_upload_wm_binding_table(struct brw_context *brw)
 {
-   struct brw_stage_state *stage_state = &brw->wm.base;
-
-   /* BRW_NEW_SURFACES and CACHE_NEW_WM_PROG */
-   brw_upload_binding_table(brw, BRW_NEW_PS_BINDING_TABLE, stage_state,
-                            brw->wm.prog_data->binding_table_size,
-                            SURF_INDEX_WM_SHADER_TIME);
+   brw_upload_binding_table(brw, BRW_NEW_PS_BINDING_TABLE, &brw->wm.base);
 }
 
 const struct brw_tracked_state brw_wm_binding_table = {
@@ -138,19 +125,11 @@ const struct brw_tracked_state brw_wm_binding_table = {
 static void
 brw_gs_upload_binding_table(struct brw_context *brw)
 {
-   struct brw_stage_state *stage_state = &brw->gs.base;
-
    /* If there's no GS, skip changing anything. */
    if (!brw->gs.prog_data)
       return;
 
-   /* CACHE_NEW_GS_PROG */
-   const struct brw_vec4_prog_data *prog_data = &brw->gs.prog_data->base;
-
-   /* BRW_NEW_SURFACES and BRW_NEW_GS_CONSTBUF */
-   brw_upload_binding_table(brw, BRW_NEW_GS_BINDING_TABLE, stage_state,
-                            prog_data->binding_table_size,
-                            SURF_INDEX_VEC4_SHADER_TIME);
+   brw_upload_binding_table(brw, BRW_NEW_GS_BINDING_TABLE, &brw->gs.base);
 }
 
 const struct brw_tracked_state brw_gs_binding_table = {
diff --git a/src/mesa/drivers/dri/i965/brw_blorp.cpp b/src/mesa/drivers/dri/i965/brw_blorp.cpp
index 1576ff2..91df346 100644
--- a/src/mesa/drivers/dri/i965/brw_blorp.cpp
+++ b/src/mesa/drivers/dri/i965/brw_blorp.cpp
@@ -26,6 +26,7 @@
 
 #include "brw_blorp.h"
 #include "brw_defines.h"
+#include "brw_state.h"
 #include "gen6_blorp.h"
 #include "gen7_blorp.h"
 
@@ -66,7 +67,8 @@ brw_blorp_mip_info::set(struct intel_mipmap_tree *mt,
 void
 brw_blorp_surface_info::set(struct brw_context *brw,
                             struct intel_mipmap_tree *mt,
-                            unsigned int level, unsigned int layer)
+                            unsigned int level, unsigned int layer,
+                            bool is_render_target)
 {
    brw_blorp_mip_info::set(mt, level, layer);
    this->num_samples = mt->num_samples;
@@ -84,33 +86,35 @@ brw_blorp_surface_info::set(struct brw_context *brw,
       this->brw_surfaceformat = BRW_SURFACEFORMAT_R8_UNORM;
       break;
    case MESA_FORMAT_X8_Z24:
-   case MESA_FORMAT_Z32_FLOAT:
-      /* The miptree consists of 32 bits per pixel, arranged either as 24-bit
-       * depth values interleaved with 8 "don't care" bits, or as 32-bit
-       * floating point depth values.  Since depth values don't require any
-       * blending, it doesn't matter how we interpret the bit pattern as long
-       * as we copy the right amount of data, so just map it as 8-bit BGRA.
+      /* It would make sense to use BRW_SURFACEFORMAT_R24_UNORM_X8_TYPELESS
+       * here, but unfortunately it isn't supported as a render target, which
+       * would prevent us from blitting to 24-bit depth.
+       *
+       * The miptree consists of 32 bits per pixel, arranged as 24-bit depth
+       * values interleaved with 8 "don't care" bits.  Since depth values don't
+       * require any blending, it doesn't matter how we interpret the bit
+       * pattern as long as we copy the right amount of data, so just map it
+       * as 8-bit BGRA.
        */
       this->brw_surfaceformat = BRW_SURFACEFORMAT_B8G8R8A8_UNORM;
       break;
+   case MESA_FORMAT_Z32_FLOAT:
+      this->brw_surfaceformat = BRW_SURFACEFORMAT_R32_FLOAT;
+      break;
    case MESA_FORMAT_Z16:
-      /* The miptree consists of 16 bits per pixel of depth data.  Since depth
-       * values don't require any blending, it doesn't matter how we interpret
-       * the bit pattern as long as we copy the right amount of data, so just
-       * map is as 8-bit RG.
-       */
-      this->brw_surfaceformat = BRW_SURFACEFORMAT_R8G8_UNORM;
+      this->brw_surfaceformat = BRW_SURFACEFORMAT_R16_UNORM;
       break;
-   default:
-      /* Blorp blits don't support any sort of format conversion (except
-       * between sRGB and linear), so we can safely assume that the format is
-       * supported as a render target, even if this is the source image.  So
-       * we can convert to a surface format using brw->render_target_format.
-       */
-      assert(brw->format_supported_as_render_target[mt->format]);
-      this->brw_surfaceformat = brw->render_target_format[mt->format];
+   default: {
+      gl_format linear_format = _mesa_get_srgb_format_linear(mt->format);
+      if (is_render_target) {
+         assert(brw->format_supported_as_render_target[linear_format]);
+         this->brw_surfaceformat = brw->render_target_format[linear_format];
+      } else {
+         this->brw_surfaceformat = brw_format_for_mesa_format(linear_format);
+      }
       break;
    }
+   }
 }
 
 
diff --git a/src/mesa/drivers/dri/i965/brw_blorp.h b/src/mesa/drivers/dri/i965/brw_blorp.h
index dceb4fc..07ab805 100644
--- a/src/mesa/drivers/dri/i965/brw_blorp.h
+++ b/src/mesa/drivers/dri/i965/brw_blorp.h
@@ -122,7 +122,8 @@ public:
 
    void set(struct brw_context *brw,
             struct intel_mipmap_tree *mt,
-            unsigned int level, unsigned int layer);
+            unsigned int level, unsigned int layer,
+            bool is_render_target);
 
    uint32_t compute_tile_offsets(uint32_t *tile_x, uint32_t *tile_y) const;
 
diff --git a/src/mesa/drivers/dri/i965/brw_blorp_blit.cpp b/src/mesa/drivers/dri/i965/brw_blorp_blit.cpp
index 027c72e..2b94e2d 100644
--- a/src/mesa/drivers/dri/i965/brw_blorp_blit.cpp
+++ b/src/mesa/drivers/dri/i965/brw_blorp_blit.cpp
@@ -353,10 +353,23 @@ brw_blorp_copytexsubimage(struct brw_context *brw,
    if (brw->gen < 6)
       return false;
 
-   if (!color_formats_match(src_mt->format, dst_mt->format)) {
+   if (_mesa_get_format_base_format(src_mt->format) !=
+       _mesa_get_format_base_format(dst_mt->format)) {
       return false;
    }
 
+   /* We can't handle format conversions between Z24 and other formats since
+    * we have to lie about the surface format.  See the comments in
+    * brw_blorp_surface_info::set().
+    */
+   if ((src_mt->format == MESA_FORMAT_X8_Z24) !=
+       (dst_mt->format == MESA_FORMAT_X8_Z24)) {
+      return false;
+   }
+
+   if (!brw->format_supported_as_render_target[dst_mt->format])
+      return false;
+
    /* Source clipping shouldn't be necessary, since copytexsubimage (in
     * src/mesa/main/teximage.c) calls _mesa_clip_copytexsubimage() which
     * takes care of it.
@@ -899,22 +912,22 @@ void
 brw_blorp_blit_program::alloc_push_const_regs(int base_reg)
 {
 #define CONST_LOC(name) offsetof(brw_blorp_wm_push_constants, name)
-#define ALLOC_REG(name) \
-   this->name = \
-      brw_vec1_reg(BRW_GENERAL_REGISTER_FILE, \
-                   base_reg + CONST_LOC(name) / 32, \
-                   (CONST_LOC(name) % 32) / 4)
-
-   ALLOC_REG(dst_x0);
-   ALLOC_REG(dst_x1);
-   ALLOC_REG(dst_y0);
-   ALLOC_REG(dst_y1);
-   ALLOC_REG(rect_grid_x1);
-   ALLOC_REG(rect_grid_y1);
-   ALLOC_REG(x_transform.multiplier);
-   ALLOC_REG(x_transform.offset);
-   ALLOC_REG(y_transform.multiplier);
-   ALLOC_REG(y_transform.offset);
+#define ALLOC_REG(name, type)                                   \
+   this->name =                                                 \
+      retype(brw_vec1_reg(BRW_GENERAL_REGISTER_FILE,            \
+                          base_reg + CONST_LOC(name) / 32,      \
+                          (CONST_LOC(name) % 32) / 4), type)
+
+   ALLOC_REG(dst_x0, BRW_REGISTER_TYPE_UD);
+   ALLOC_REG(dst_x1, BRW_REGISTER_TYPE_UD);
+   ALLOC_REG(dst_y0, BRW_REGISTER_TYPE_UD);
+   ALLOC_REG(dst_y1, BRW_REGISTER_TYPE_UD);
+   ALLOC_REG(rect_grid_x1, BRW_REGISTER_TYPE_F);
+   ALLOC_REG(rect_grid_y1, BRW_REGISTER_TYPE_F);
+   ALLOC_REG(x_transform.multiplier, BRW_REGISTER_TYPE_F);
+   ALLOC_REG(x_transform.offset, BRW_REGISTER_TYPE_F);
+   ALLOC_REG(y_transform.multiplier, BRW_REGISTER_TYPE_F);
+   ALLOC_REG(y_transform.offset, BRW_REGISTER_TYPE_F);
 #undef CONST_LOC
 #undef ALLOC_REG
 }
@@ -2063,8 +2076,8 @@ brw_blorp_blit_params::brw_blorp_blit_params(struct brw_context *brw,
    struct gl_context *ctx = &brw->ctx;
    const struct gl_framebuffer *read_fb = ctx->ReadBuffer;
 
-   src.set(brw, src_mt, src_level, src_layer);
-   dst.set(brw, dst_mt, dst_level, dst_layer);
+   src.set(brw, src_mt, src_level, src_layer, false);
+   dst.set(brw, dst_mt, dst_level, dst_layer, true);
 
    /* Even though we do multisample resolves at the time of the blit, OpenGL
     * specification defines them as if they happen at the time of rendering,
@@ -2077,13 +2090,17 @@ brw_blorp_blit_params::brw_blorp_blit_params(struct brw_context *brw,
     * proprietary OpenGL driver also follow this approach. So, we choose to
     * follow it in our driver.
     *
-    * Following if-else block takes care of this exception made for
-    * multisampled resolves.
+    * When multisampling, if the source and destination formats are equal
+    * (aside from the color space), we choose to blit in sRGB space to get
+    * this higher quality image.
     */
-   if (src.num_samples > 1)
+   if (src.num_samples > 1 &&
+       _mesa_get_format_color_encoding(dst_mt->format) == GL_SRGB &&
+       _mesa_get_srgb_format_linear(src_mt->format) ==
+       _mesa_get_srgb_format_linear(dst_mt->format)) {
+      dst.brw_surfaceformat = brw_format_for_mesa_format(dst_mt->format);
       src.brw_surfaceformat = dst.brw_surfaceformat;
-   else
-      dst.brw_surfaceformat = src.brw_surfaceformat;
+   }
 
    use_wm_prog = true;
    memset(&wm_prog_key, 0, sizeof(wm_prog_key));
diff --git a/src/mesa/drivers/dri/i965/brw_blorp_clear.cpp b/src/mesa/drivers/dri/i965/brw_blorp_clear.cpp
index 4ff776f..d1933ce 100644
--- a/src/mesa/drivers/dri/i965/brw_blorp_clear.cpp
+++ b/src/mesa/drivers/dri/i965/brw_blorp_clear.cpp
@@ -127,6 +127,8 @@ brw_blorp_const_color_program::brw_blorp_const_color_program(
      clear_rgba(),
      base_mrf(0)
 {
+   prog_data.first_curbe_grf = 0;
+   prog_data.persample_msaa_dispatch = false;
    brw_init_compile(brw, &func, mem_ctx);
 }
 
@@ -186,7 +188,7 @@ brw_blorp_clear_params::brw_blorp_clear_params(struct brw_context *brw,
    struct gl_context *ctx = &brw->ctx;
    struct intel_renderbuffer *irb = intel_renderbuffer(rb);
 
-   dst.set(brw, irb->mt, irb->mt_level, irb->mt_layer);
+   dst.set(brw, irb->mt, irb->mt_level, irb->mt_layer, true);
 
    /* Override the surface format according to the context's sRGB rules. */
    gl_format format = _mesa_get_render_format(ctx, irb->mt->format);
@@ -305,7 +307,7 @@ brw_blorp_rt_resolve_params::brw_blorp_rt_resolve_params(
       struct brw_context *brw,
       struct intel_mipmap_tree *mt)
 {
-   dst.set(brw, mt, 0 /* level */, 0 /* layer */);
+   dst.set(brw, mt, 0 /* level */, 0 /* layer */, true);
 
    /* From the Ivy Bridge PRM, Vol2 Part1 11.9 "Render Target Resolve":
     *
diff --git a/src/mesa/drivers/dri/i965/brw_context.c b/src/mesa/drivers/dri/i965/brw_context.c
index 776d221..109f40b 100644
--- a/src/mesa/drivers/dri/i965/brw_context.c
+++ b/src/mesa/drivers/dri/i965/brw_context.c
@@ -1,4 +1,5 @@
 /*
+ Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
  Copyright (C) Intel Corp.  2006.  All Rights Reserved.
  Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
  develop this 3D driver.
@@ -31,6 +32,8 @@
 
 
 #include "main/api_exec.h"
+#include "main/context.h"
+#include "main/fbobject.h"
 #include "main/imports.h"
 #include "main/macros.h"
 #include "main/points.h"
@@ -40,17 +43,27 @@
 
 #include "vbo/vbo_context.h"
 
+#include "drivers/common/driverfuncs.h"
+#include "drivers/common/meta.h"
+#include "utils.h"
+
 #include "brw_context.h"
 #include "brw_defines.h"
 #include "brw_draw.h"
 #include "brw_state.h"
 
+#include "intel_batchbuffer.h"
+#include "intel_buffer_objects.h"
+#include "intel_buffers.h"
 #include "intel_fbo.h"
 #include "intel_mipmap_tree.h"
+#include "intel_pixel.h"
 #include "intel_regions.h"
 #include "intel_tex.h"
 #include "intel_tex_obj.h"
 
+#include "swrast_setup/swrast_setup.h"
+#include "tnl/tnl.h"
 #include "tnl/t_pipeline.h"
 #include "glsl/ralloc.h"
 
@@ -82,21 +95,163 @@ brw_query_samples_for_format(struct gl_context *ctx, GLenum target,
    }
 }
 
-static void brwInitDriverFunctions(struct intel_screen *screen,
-				   struct dd_function_table *functions)
+static const GLubyte *
+intelGetString(struct gl_context * ctx, GLenum name)
+{
+   const struct brw_context *const brw = brw_context(ctx);
+   const char *chipset;
+   static char buffer[128];
+
+   switch (name) {
+   case GL_VENDOR:
+      return (GLubyte *) "Intel Open Source Technology Center";
+      break;
+
+   case GL_RENDERER:
+      switch (brw->intelScreen->deviceID) {
+#undef CHIPSET
+#define CHIPSET(id, family, str) case id: chipset = str; break;
+#include "pci_ids/i965_pci_ids.h"
+      default:
+         chipset = "Unknown Intel Chipset";
+         break;
+      }
+
+      (void) driGetRendererString(buffer, chipset, 0);
+      return (GLubyte *) buffer;
+
+   default:
+      return NULL;
+   }
+}
+
+static void
+intel_viewport(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h)
+{
+   struct brw_context *brw = brw_context(ctx);
+   __DRIcontext *driContext = brw->driContext;
+
+   if (brw->saved_viewport)
+      brw->saved_viewport(ctx, x, y, w, h);
+
+   if (_mesa_is_winsys_fbo(ctx->DrawBuffer)) {
+      dri2InvalidateDrawable(driContext->driDrawablePriv);
+      dri2InvalidateDrawable(driContext->driReadablePriv);
+   }
+}
+
+static void
+intelInvalidateState(struct gl_context * ctx, GLuint new_state)
 {
-   intelInitDriverFunctions( functions );
+   struct brw_context *brw = brw_context(ctx);
+
+   if (ctx->swrast_context)
+      _swrast_InvalidateState(ctx, new_state);
+   _vbo_InvalidateState(ctx, new_state);
+
+   brw->NewGLState |= new_state;
+}
+
+static void
+intel_flush_front(struct gl_context *ctx)
+{
+   struct brw_context *brw = brw_context(ctx);
+   __DRIcontext *driContext = brw->driContext;
+   __DRIdrawable *driDrawable = driContext->driDrawablePriv;
+   __DRIscreen *const screen = brw->intelScreen->driScrnPriv;
+
+   if (brw->front_buffer_dirty && _mesa_is_winsys_fbo(ctx->DrawBuffer)) {
+      if (screen->dri2.loader->flushFrontBuffer != NULL &&
+          driDrawable &&
+          driDrawable->loaderPrivate) {
+
+         /* Resolve before flushing FAKE_FRONT_LEFT to FRONT_LEFT.
+          *
+          * This potentially resolves both front and back buffer. It
+          * is unnecessary to resolve the back, but harms nothing except
+          * performance. And no one cares about front-buffer render
+          * performance.
+          */
+         intel_resolve_for_dri2_flush(brw, driDrawable);
+         intel_batchbuffer_flush(brw);
+
+         screen->dri2.loader->flushFrontBuffer(driDrawable,
+                                               driDrawable->loaderPrivate);
+
+         /* We set the dirty bit in intel_prepare_render() if we're
+          * front buffer rendering once we get there.
+          */
+         brw->front_buffer_dirty = false;
+      }
+   }
+}
+
+static void
+intel_glFlush(struct gl_context *ctx)
+{
+   struct brw_context *brw = brw_context(ctx);
+
+   intel_batchbuffer_flush(brw);
+   intel_flush_front(ctx);
+   if (brw->is_front_buffer_rendering)
+      brw->need_throttle = true;
+}
+
+void
+intelFinish(struct gl_context * ctx)
+{
+   struct brw_context *brw = brw_context(ctx);
+
+   intel_glFlush(ctx);
+
+   if (brw->batch.last_bo)
+      drm_intel_bo_wait_rendering(brw->batch.last_bo);
+}
+
+static void
+brw_init_driver_functions(struct brw_context *brw,
+                          struct dd_function_table *functions)
+{
+   _mesa_init_driver_functions(functions);
+
+   /* GLX uses DRI2 invalidate events to handle window resizing.
+    * Unfortunately, EGL does not - libEGL is written in XCB (not Xlib),
+    * which doesn't provide a mechanism for snooping the event queues.
+    *
+    * So EGL still relies on viewport hacks to handle window resizing.
+    * This should go away with DRI3000.
+    */
+   if (!brw->driContext->driScreenPriv->dri2.useInvalidate) {
+      brw->saved_viewport = functions->Viewport;
+      functions->Viewport = intel_viewport;
+   }
+
+   functions->Flush = intel_glFlush;
+   functions->Finish = intelFinish;
+   functions->GetString = intelGetString;
+   functions->UpdateState = intelInvalidateState;
+
+   intelInitTextureFuncs(functions);
+   intelInitTextureImageFuncs(functions);
+   intelInitTextureSubImageFuncs(functions);
+   intelInitTextureCopyImageFuncs(functions);
+   intelInitClearFuncs(functions);
+   intelInitBufferFuncs(functions);
+   intelInitPixelFuncs(functions);
+   intelInitBufferObjectFuncs(functions);
+   intel_init_syncobj_functions(functions);
+   brw_init_object_purgeable_functions(functions);
 
    brwInitFragProgFuncs( functions );
    brw_init_common_queryobj_functions(functions);
-   if (screen->gen >= 6)
+   if (brw->gen >= 6)
       gen6_init_queryobj_functions(functions);
    else
       gen4_init_queryobj_functions(functions);
 
    functions->QuerySamplesForFormat = brw_query_samples_for_format;
 
-   if (screen->gen >= 7) {
+   if (brw->gen >= 7) {
       functions->BeginTransformFeedback = gen7_begin_transform_feedback;
       functions->EndTransformFeedback = gen7_end_transform_feedback;
    } else {
@@ -104,7 +259,7 @@ static void brwInitDriverFunctions(struct intel_screen *screen,
       functions->EndTransformFeedback = brw_end_transform_feedback;
    }
 
-   if (screen->gen >= 6)
+   if (brw->gen >= 6)
       functions->GetSamplePosition = gen6_get_sample_position;
 }
 
@@ -242,12 +397,6 @@ brw_initialize_context_constants(struct brw_context *brw)
    ctx->Const.UniformBooleanTrue = 1;
    ctx->Const.UniformBufferOffsetAlignment = 16;
 
-   ctx->Const.ForceGLSLExtensionsWarn =
-      driQueryOptionb(&brw->optionCache, "force_glsl_extensions_warn");
-
-   ctx->Const.DisableGLSLLineContinuations =
-      driQueryOptionb(&brw->optionCache, "disable_glsl_line_continuations");
-
    if (brw->gen >= 6) {
       ctx->Const.MaxVarying = 32;
       ctx->Const.VertexProgram.MaxOutputComponents = 128;
@@ -275,51 +424,174 @@ brw_initialize_context_constants(struct brw_context *brw)
    ctx->ShaderCompilerOptions[MESA_SHADER_VERTEX].PreferDP4 = true;
 }
 
+/**
+ * Process driconf (drirc) options, setting appropriate context flags.
+ *
+ * intelInitExtensions still pokes at optionCache directly, in order to
+ * avoid advertising various extensions.  No flags are set, so it makes
+ * sense to continue doing that there.
+ */
+static void
+brw_process_driconf_options(struct brw_context *brw)
+{
+   struct gl_context *ctx = &brw->ctx;
+
+   driOptionCache *options = &brw->optionCache;
+   driParseConfigFiles(options, &brw->intelScreen->optionCache,
+                       brw->driContext->driScreenPriv->myNum, "i965");
+
+   int bo_reuse_mode = driQueryOptioni(options, "bo_reuse");
+   switch (bo_reuse_mode) {
+   case DRI_CONF_BO_REUSE_DISABLED:
+      break;
+   case DRI_CONF_BO_REUSE_ALL:
+      intel_bufmgr_gem_enable_reuse(brw->bufmgr);
+      break;
+   }
+
+   if (!driQueryOptionb(options, "hiz")) {
+       brw->has_hiz = false;
+       /* On gen6, you can only do separate stencil with HIZ. */
+       if (brw->gen == 6)
+          brw->has_separate_stencil = false;
+   }
+
+   if (driQueryOptionb(options, "always_flush_batch")) {
+      fprintf(stderr, "flushing batchbuffer before/after each draw call\n");
+      brw->always_flush_batch = true;
+   }
+
+   if (driQueryOptionb(options, "always_flush_cache")) {
+      fprintf(stderr, "flushing GPU caches before/after each draw call\n");
+      brw->always_flush_cache = true;
+   }
+
+   if (driQueryOptionb(options, "disable_throttling")) {
+      fprintf(stderr, "disabling flush throttling\n");
+      brw->disable_throttling = true;
+   }
+
+   brw->disable_derivative_optimization =
+      driQueryOptionb(&brw->optionCache, "disable_derivative_optimization");
+
+   brw->precompile = driQueryOptionb(&brw->optionCache, "shader_precompile");
+
+   ctx->Const.ForceGLSLExtensionsWarn =
+      driQueryOptionb(options, "force_glsl_extensions_warn");
+
+   ctx->Const.DisableGLSLLineContinuations =
+      driQueryOptionb(options, "disable_glsl_line_continuations");
+}
+
 bool
-brwCreateContext(int api,
+brwCreateContext(gl_api api,
 	         const struct gl_config *mesaVis,
 		 __DRIcontext *driContextPriv,
                  unsigned major_version,
                  unsigned minor_version,
                  uint32_t flags,
-                 unsigned *error,
+                 unsigned *dri_ctx_error,
 	         void *sharedContextPrivate)
 {
    __DRIscreen *sPriv = driContextPriv->driScreenPriv;
+   struct gl_context *shareCtx = (struct gl_context *) sharedContextPrivate;
    struct intel_screen *screen = sPriv->driverPrivate;
+   const struct brw_device_info *devinfo = screen->devinfo;
    struct dd_function_table functions;
+   struct gl_config visual;
 
    struct brw_context *brw = rzalloc(NULL, struct brw_context);
    if (!brw) {
       printf("%s: failed to alloc context\n", __FUNCTION__);
-      *error = __DRI_CTX_ERROR_NO_MEMORY;
+      *dri_ctx_error = __DRI_CTX_ERROR_NO_MEMORY;
       return false;
    }
 
-   /* brwInitVtbl needs to know the chipset generation so that it can set the
-    * right pointers.
-    */
-   brw->gen = screen->gen;
-
-   brwInitVtbl( brw );
+   driContextPriv->driverPrivate = brw;
+   brw->driContext = driContextPriv;
+   brw->intelScreen = screen;
+   brw->bufmgr = screen->bufmgr;
+
+   brw->gen = devinfo->gen;
+   brw->gt = devinfo->gt;
+   brw->is_g4x = devinfo->is_g4x;
+   brw->is_baytrail = devinfo->is_baytrail;
+   brw->is_haswell = devinfo->is_haswell;
+   brw->has_llc = devinfo->has_llc;
+   brw->has_hiz = devinfo->has_hiz_and_separate_stencil;
+   brw->has_separate_stencil = devinfo->has_hiz_and_separate_stencil;
+   brw->has_pln = devinfo->has_pln;
+   brw->has_compr4 = devinfo->has_compr4;
+   brw->has_surface_tile_offset = devinfo->has_surface_tile_offset;
+   brw->has_negative_rhw_bug = devinfo->has_negative_rhw_bug;
+   brw->needs_unlit_centroid_workaround =
+      devinfo->needs_unlit_centroid_workaround;
+
+   brw->must_use_separate_stencil = screen->hw_must_use_separate_stencil;
+   brw->has_swizzling = screen->hw_has_swizzling;
+
+   if (brw->gen >= 7) {
+      gen7_init_vtable_surface_functions(brw);
+      gen7_init_vtable_sampler_functions(brw);
+      brw->vtbl.emit_depth_stencil_hiz = gen7_emit_depth_stencil_hiz;
+   } else {
+      gen4_init_vtable_surface_functions(brw);
+      gen4_init_vtable_sampler_functions(brw);
+      brw->vtbl.emit_depth_stencil_hiz = brw_emit_depth_stencil_hiz;
+   }
 
-   brwInitDriverFunctions(screen, &functions);
+   brw_init_driver_functions(brw, &functions);
 
    struct gl_context *ctx = &brw->ctx;
 
-   if (!intelInitContext( brw, api, major_version, minor_version,
-                          mesaVis, driContextPriv,
-			  sharedContextPrivate, &functions,
-			  error)) {
-      ralloc_free(brw);
+   if (mesaVis == NULL) {
+      memset(&visual, 0, sizeof visual);
+      mesaVis = &visual;
+   }
+
+   if (!_mesa_initialize_context(ctx, api, mesaVis, shareCtx, &functions)) {
+      *dri_ctx_error = __DRI_CTX_ERROR_NO_MEMORY;
+      printf("%s: failed to init mesa context\n", __FUNCTION__);
+      intelDestroyContext(driContextPriv);
       return false;
    }
 
+   /* Initialize the software rasterizer and helper modules.
+    *
+    * As of GL 3.1 core, the gen4+ driver doesn't need the swrast context for
+    * software fallbacks (which we have to support on legacy GL to do weird
+    * glDrawPixels(), glBitmap(), and other functions).
+    */
+   if (api != API_OPENGL_CORE && api != API_OPENGLES2) {
+      _swrast_CreateContext(ctx);
+   }
+
+   _vbo_CreateContext(ctx);
+   if (ctx->swrast_context) {
+      _tnl_CreateContext(ctx);
+      TNL_CONTEXT(ctx)->Driver.RunPipeline = _tnl_run_pipeline;
+      _swsetup_CreateContext(ctx);
+
+      /* Configure swrast to match hardware characteristics: */
+      _swrast_allow_pixel_fog(ctx, false);
+      _swrast_allow_vertex_fog(ctx, true);
+   }
+
+   _mesa_meta_init(ctx);
+
+   brw_process_driconf_options(brw);
+   brw_process_intel_debug_variable(brw);
    brw_initialize_context_constants(brw);
 
    /* Reinitialize the context point state.  It depends on ctx->Const values. */
    _mesa_init_point(ctx);
 
+   intelInitExtensions(ctx);
+
+   intel_batchbuffer_init(brw);
+
+   intel_fbo_init(brw);
+
    if (brw->gen >= 6) {
       /* Create a new hardware context.  Using a hardware context means that
        * our GPU state will be saved/restored on context switch, allowing us
@@ -332,124 +604,46 @@ brwCreateContext(int api,
 
       if (!brw->hw_ctx) {
          fprintf(stderr, "Gen6+ requires Kernel 3.6 or later.\n");
-         ralloc_free(brw);
+         intelDestroyContext(driContextPriv);
          return false;
       }
    }
 
    brw_init_surface_formats(brw);
 
-   /* Initialize swrast, tnl driver tables: */
-   TNLcontext *tnl = TNL_CONTEXT(ctx);
-   if (tnl)
-      tnl->Driver.RunPipeline = _tnl_run_pipeline;
-
-   ctx->DriverFlags.NewTransformFeedback = BRW_NEW_TRANSFORM_FEEDBACK;
-   ctx->DriverFlags.NewRasterizerDiscard = BRW_NEW_RASTERIZER_DISCARD;
-   ctx->DriverFlags.NewUniformBuffer = BRW_NEW_UNIFORM_BUFFER;
-
    if (brw->is_g4x || brw->gen >= 5) {
       brw->CMD_VF_STATISTICS = GM45_3DSTATE_VF_STATISTICS;
       brw->CMD_PIPELINE_SELECT = CMD_PIPELINE_SELECT_GM45;
-      brw->has_surface_tile_offset = true;
-      if (brw->gen < 6)
-	  brw->has_compr4 = true;
-      brw->has_aa_line_parameters = true;
-      brw->has_pln = true;
   } else {
       brw->CMD_VF_STATISTICS = GEN4_3DSTATE_VF_STATISTICS;
       brw->CMD_PIPELINE_SELECT = CMD_PIPELINE_SELECT_965;
    }
 
-   /* WM maximum threads is number of EUs times number of threads per EU. */
-   assert(brw->gen <= 7);
-
-   if (brw->is_haswell) {
-      if (brw->gt == 1) {
-	 brw->max_wm_threads = 102;
-	 brw->max_vs_threads = 70;
-	 brw->max_gs_threads = 70;
-	 brw->urb.size = 128;
-         brw->urb.min_vs_entries = 32;
-	 brw->urb.max_vs_entries = 640;
-	 brw->urb.max_gs_entries = 256;
-      } else if (brw->gt == 2) {
-	 brw->max_wm_threads = 204;
-	 brw->max_vs_threads = 280;
-	 brw->max_gs_threads = 256;
-	 brw->urb.size = 256;
-         brw->urb.min_vs_entries = 64;
-	 brw->urb.max_vs_entries = 1664;
-	 brw->urb.max_gs_entries = 640;
-      } else if (brw->gt == 3) {
-	 brw->max_wm_threads = 408;
-	 brw->max_vs_threads = 280;
-	 brw->max_gs_threads = 256;
-	 brw->urb.size = 512;
-         brw->urb.min_vs_entries = 64;
-	 brw->urb.max_vs_entries = 1664;
-	 brw->urb.max_gs_entries = 640;
-      }
-   } else if (brw->gen == 7) {
-      if (brw->gt == 1) {
-	 brw->max_wm_threads = 48;
-	 brw->max_vs_threads = 36;
-	 brw->max_gs_threads = 36;
-	 brw->urb.size = 128;
-         brw->urb.min_vs_entries = 32;
-	 brw->urb.max_vs_entries = 512;
-	 brw->urb.max_gs_entries = 192;
-      } else if (brw->gt == 2) {
-	 brw->max_wm_threads = 172;
-	 brw->max_vs_threads = 128;
-	 brw->max_gs_threads = 128;
-	 brw->urb.size = 256;
-         brw->urb.min_vs_entries = 32;
-	 brw->urb.max_vs_entries = 704;
-	 brw->urb.max_gs_entries = 320;
-      } else {
-	 assert(!"Unknown gen7 device.");
-      }
-   } else if (brw->gen == 6) {
-      if (brw->gt == 2) {
-	 brw->max_wm_threads = 80;
-	 brw->max_vs_threads = 60;
-	 brw->max_gs_threads = 60;
-	 brw->urb.size = 64;            /* volume 5c.5 section 5.1 */
-         brw->urb.min_vs_entries = 24;
-	 brw->urb.max_vs_entries = 256; /* volume 2a (see 3DSTATE_URB) */
-	 brw->urb.max_gs_entries = 256;
-      } else {
-	 brw->max_wm_threads = 40;
-	 brw->max_vs_threads = 24;
-	 brw->max_gs_threads = 21; /* conservative; 24 if rendering disabled */
-	 brw->urb.size = 32;            /* volume 5c.5 section 5.1 */
-         brw->urb.min_vs_entries = 24;
-	 brw->urb.max_vs_entries = 256; /* volume 2a (see 3DSTATE_URB) */
-	 brw->urb.max_gs_entries = 256;
-      }
+   brw->max_vs_threads = devinfo->max_vs_threads;
+   brw->max_gs_threads = devinfo->max_gs_threads;
+   brw->max_wm_threads = devinfo->max_wm_threads;
+   brw->urb.size = devinfo->urb.size;
+   brw->urb.min_vs_entries = devinfo->urb.min_vs_entries;
+   brw->urb.max_vs_entries = devinfo->urb.max_vs_entries;
+   brw->urb.max_gs_entries = devinfo->urb.max_gs_entries;
+
+   /* Estimate the size of the mappable aperture into the GTT.  There's an
+    * ioctl to get the whole GTT size, but not one to get the mappable subset.
+    * It turns out it's basically always 256MB, though some ancient hardware
+    * was smaller.
+    */
+   uint32_t gtt_size = 256 * 1024 * 1024;
+
+   /* We don't want to map two objects such that a memcpy between them would
+    * just fault one mapping in and then the other over and over forever.  So
+    * we would need to divide the GTT size by 2.  Additionally, some GTT is
+    * taken up by things like the framebuffer and the ringbuffer and such, so
+    * be more conservative.
+    */
+   brw->max_gtt_map_object_size = gtt_size / 4;
+
+   if (brw->gen == 6)
       brw->urb.gen6_gs_previously_active = false;
-   } else if (brw->gen == 5) {
-      brw->urb.size = 1024;
-      brw->max_vs_threads = 72;
-      brw->max_gs_threads = 32;
-      brw->max_wm_threads = 12 * 6;
-   } else if (brw->is_g4x) {
-      brw->urb.size = 384;
-      brw->max_vs_threads = 32;
-      brw->max_gs_threads = 2;
-      brw->max_wm_threads = 10 * 5;
-   } else if (brw->gen < 6) {
-      brw->urb.size = 256;
-      brw->max_vs_threads = 16;
-      brw->max_gs_threads = 2;
-      brw->max_wm_threads = 8 * 4;
-      brw->has_negative_rhw_bug = true;
-   }
-
-   if (brw->gen <= 7) {
-      brw->needs_unlit_centroid_workaround = true;
-   }
 
    brw->prim_restart.in_progress = false;
    brw->prim_restart.enable_cut_index = false;
@@ -461,36 +655,12 @@ brwCreateContext(int api,
       brw->curbe.next_buf = calloc(1, 4096);
    }
 
-   brw->state.dirty.mesa = ~0;
-   brw->state.dirty.brw = ~0;
-
-   /* Make sure that brw->state.dirty.brw has enough bits to hold all possible
-    * dirty flags.
-    */
-   STATIC_ASSERT(BRW_NUM_STATE_BITS <= 8 * sizeof(brw->state.dirty.brw));
-
-   brw->emit_state_always = 0;
-
-   brw->batch.need_workaround_flush = true;
-
    ctx->VertexProgram._MaintainTnlProgram = true;
    ctx->FragmentProgram._MaintainTexEnvProgram = true;
 
    brw_draw_init( brw );
 
-   brw->precompile = driQueryOptionb(&brw->optionCache, "shader_precompile");
-   brw->disable_derivative_optimization =
-      driQueryOptionb(&brw->optionCache, "disable_derivative_optimization");
-
-   ctx->Const.ContextFlags = 0;
-   if ((flags & __DRI_CTX_FLAG_FORWARD_COMPATIBLE) != 0)
-      ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_FORWARD_COMPATIBLE_BIT;
-
-   ctx->Debug.DebugOutput = GL_FALSE;
    if ((flags & __DRI_CTX_FLAG_DEBUG) != 0) {
-      ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_DEBUG_BIT;
-      ctx->Debug.DebugOutput = GL_TRUE;
-
       /* Turn on some extra GL_ARB_debug_output generation. */
       brw->perf_debug = true;
    }
@@ -513,3 +683,485 @@ brwCreateContext(int api,
    return true;
 }
 
+void
+intelDestroyContext(__DRIcontext * driContextPriv)
+{
+   struct brw_context *brw =
+      (struct brw_context *) driContextPriv->driverPrivate;
+   struct gl_context *ctx = &brw->ctx;
+
+   assert(brw); /* should never be null */
+   if (!brw)
+      return;
+
+   /* Dump a final BMP in case the application doesn't call SwapBuffers */
+   if (INTEL_DEBUG & DEBUG_AUB) {
+      intel_batchbuffer_flush(brw);
+      aub_dump_bmp(&brw->ctx);
+   }
+
+   _mesa_meta_free(&brw->ctx);
+
+   if (INTEL_DEBUG & DEBUG_SHADER_TIME) {
+      /* Force a report. */
+      brw->shader_time.report_time = 0;
+
+      brw_collect_and_report_shader_time(brw);
+      brw_destroy_shader_time(brw);
+   }
+
+   brw_destroy_state(brw);
+   brw_draw_destroy(brw);
+
+   drm_intel_bo_unreference(brw->curbe.curbe_bo);
+   drm_intel_bo_unreference(brw->vs.base.const_bo);
+   drm_intel_bo_unreference(brw->wm.base.const_bo);
+
+   free(brw->curbe.last_buf);
+   free(brw->curbe.next_buf);
+
+   drm_intel_gem_context_destroy(brw->hw_ctx);
+
+   if (ctx->swrast_context) {
+      _swsetup_DestroyContext(&brw->ctx);
+      _tnl_DestroyContext(&brw->ctx);
+   }
+   _vbo_DestroyContext(&brw->ctx);
+
+   if (ctx->swrast_context)
+      _swrast_DestroyContext(&brw->ctx);
+
+   intel_batchbuffer_free(brw);
+
+   drm_intel_bo_unreference(brw->first_post_swapbuffers_batch);
+   brw->first_post_swapbuffers_batch = NULL;
+
+   driDestroyOptionCache(&brw->optionCache);
+
+   /* free the Mesa context */
+   _mesa_free_context_data(&brw->ctx);
+
+   ralloc_free(brw);
+   driContextPriv->driverPrivate = NULL;
+}
+
+GLboolean
+intelUnbindContext(__DRIcontext * driContextPriv)
+{
+   /* Unset current context and dispath table */
+   _mesa_make_current(NULL, NULL, NULL);
+
+   return true;
+}
+
+/**
+ * Fixes up the context for GLES23 with our default-to-sRGB-capable behavior
+ * on window system framebuffers.
+ *
+ * Desktop GL is fairly reasonable in its handling of sRGB: You can ask if
+ * your renderbuffer can do sRGB encode, and you can flip a switch that does
+ * sRGB encode if the renderbuffer can handle it.  You can ask specifically
+ * for a visual where you're guaranteed to be capable, but it turns out that
+ * everyone just makes all their ARGB8888 visuals capable and doesn't offer
+ * incapable ones, becuase there's no difference between the two in resources
+ * used.  Applications thus get built that accidentally rely on the default
+ * visual choice being sRGB, so we make ours sRGB capable.  Everything sounds
+ * great...
+ *
+ * But for GLES2/3, they decided that it was silly to not turn on sRGB encode
+ * for sRGB renderbuffers you made with the GL_EXT_texture_sRGB equivalent.
+ * So they removed the enable knob and made it "if the renderbuffer is sRGB
+ * capable, do sRGB encode".  Then, for your window system renderbuffers, you
+ * can ask for sRGB visuals and get sRGB encode, or not ask for sRGB visuals
+ * and get no sRGB encode (assuming that both kinds of visual are available).
+ * Thus our choice to support sRGB by default on our visuals for desktop would
+ * result in broken rendering of GLES apps that aren't expecting sRGB encode.
+ *
+ * Unfortunately, renderbuffer setup happens before a context is created.  So
+ * in intel_screen.c we always set up sRGB, and here, if you're a GLES2/3
+ * context (without an sRGB visual, though we don't have sRGB visuals exposed
+ * yet), we go turn that back off before anyone finds out.
+ */
+static void
+intel_gles3_srgb_workaround(struct brw_context *brw,
+                            struct gl_framebuffer *fb)
+{
+   struct gl_context *ctx = &brw->ctx;
+
+   if (_mesa_is_desktop_gl(ctx) || !fb->Visual.sRGBCapable)
+      return;
+
+   /* Some day when we support the sRGB capable bit on visuals available for
+    * GLES, we'll need to respect that and not disable things here.
+    */
+   fb->Visual.sRGBCapable = false;
+   for (int i = 0; i < BUFFER_COUNT; i++) {
+      if (fb->Attachment[i].Renderbuffer &&
+          fb->Attachment[i].Renderbuffer->Format == MESA_FORMAT_SARGB8) {
+         fb->Attachment[i].Renderbuffer->Format = MESA_FORMAT_ARGB8888;
+      }
+   }
+}
+
+GLboolean
+intelMakeCurrent(__DRIcontext * driContextPriv,
+                 __DRIdrawable * driDrawPriv,
+                 __DRIdrawable * driReadPriv)
+{
+   struct brw_context *brw;
+   GET_CURRENT_CONTEXT(curCtx);
+
+   if (driContextPriv)
+      brw = (struct brw_context *) driContextPriv->driverPrivate;
+   else
+      brw = NULL;
+
+   /* According to the glXMakeCurrent() man page: "Pending commands to
+    * the previous context, if any, are flushed before it is released."
+    * But only flush if we're actually changing contexts.
+    */
+   if (brw_context(curCtx) && brw_context(curCtx) != brw) {
+      _mesa_flush(curCtx);
+   }
+
+   if (driContextPriv) {
+      struct gl_context *ctx = &brw->ctx;
+      struct gl_framebuffer *fb, *readFb;
+
+      if (driDrawPriv == NULL && driReadPriv == NULL) {
+         fb = _mesa_get_incomplete_framebuffer();
+         readFb = _mesa_get_incomplete_framebuffer();
+      } else {
+         fb = driDrawPriv->driverPrivate;
+         readFb = driReadPriv->driverPrivate;
+         driContextPriv->dri2.draw_stamp = driDrawPriv->dri2.stamp - 1;
+         driContextPriv->dri2.read_stamp = driReadPriv->dri2.stamp - 1;
+      }
+
+      /* The sRGB workaround changes the renderbuffer's format. We must change
+       * the format before the renderbuffer's miptree get's allocated, otherwise
+       * the formats of the renderbuffer and its miptree will differ.
+       */
+      intel_gles3_srgb_workaround(brw, fb);
+      intel_gles3_srgb_workaround(brw, readFb);
+
+      intel_prepare_render(brw);
+      _mesa_make_current(ctx, fb, readFb);
+   } else {
+      _mesa_make_current(NULL, NULL, NULL);
+   }
+
+   return true;
+}
+
+void
+intel_resolve_for_dri2_flush(struct brw_context *brw,
+                             __DRIdrawable *drawable)
+{
+   if (brw->gen < 6) {
+      /* MSAA and fast color clear are not supported, so don't waste time
+       * checking whether a resolve is needed.
+       */
+      return;
+   }
+
+   struct gl_framebuffer *fb = drawable->driverPrivate;
+   struct intel_renderbuffer *rb;
+
+   /* Usually, only the back buffer will need to be downsampled. However,
+    * the front buffer will also need it if the user has rendered into it.
+    */
+   static const gl_buffer_index buffers[2] = {
+         BUFFER_BACK_LEFT,
+         BUFFER_FRONT_LEFT,
+   };
+
+   for (int i = 0; i < 2; ++i) {
+      rb = intel_get_renderbuffer(fb, buffers[i]);
+      if (rb == NULL || rb->mt == NULL)
+         continue;
+      if (rb->mt->num_samples <= 1)
+         intel_miptree_resolve_color(brw, rb->mt);
+      else
+         intel_miptree_downsample(brw, rb->mt);
+   }
+}
+
+static unsigned
+intel_bits_per_pixel(const struct intel_renderbuffer *rb)
+{
+   return _mesa_get_format_bytes(intel_rb_format(rb)) * 8;
+}
+
+static void
+intel_query_dri2_buffers(struct brw_context *brw,
+                         __DRIdrawable *drawable,
+                         __DRIbuffer **buffers,
+                         int *count);
+
+static void
+intel_process_dri2_buffer(struct brw_context *brw,
+                          __DRIdrawable *drawable,
+                          __DRIbuffer *buffer,
+                          struct intel_renderbuffer *rb,
+                          const char *buffer_name);
+
+void
+intel_update_renderbuffers(__DRIcontext *context, __DRIdrawable *drawable)
+{
+   struct gl_framebuffer *fb = drawable->driverPrivate;
+   struct intel_renderbuffer *rb;
+   struct brw_context *brw = context->driverPrivate;
+   __DRIbuffer *buffers = NULL;
+   int i, count;
+   const char *region_name;
+
+   /* Set this up front, so that in case our buffers get invalidated
+    * while we're getting new buffers, we don't clobber the stamp and
+    * thus ignore the invalidate. */
+   drawable->lastStamp = drawable->dri2.stamp;
+
+   if (unlikely(INTEL_DEBUG & DEBUG_DRI))
+      fprintf(stderr, "enter %s, drawable %p\n", __func__, drawable);
+
+   intel_query_dri2_buffers(brw, drawable, &buffers, &count);
+
+   if (buffers == NULL)
+      return;
+
+   for (i = 0; i < count; i++) {
+       switch (buffers[i].attachment) {
+       case __DRI_BUFFER_FRONT_LEFT:
+           rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
+           region_name = "dri2 front buffer";
+           break;
+
+       case __DRI_BUFFER_FAKE_FRONT_LEFT:
+           rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
+           region_name = "dri2 fake front buffer";
+           break;
+
+       case __DRI_BUFFER_BACK_LEFT:
+           rb = intel_get_renderbuffer(fb, BUFFER_BACK_LEFT);
+           region_name = "dri2 back buffer";
+           break;
+
+       case __DRI_BUFFER_DEPTH:
+       case __DRI_BUFFER_HIZ:
+       case __DRI_BUFFER_DEPTH_STENCIL:
+       case __DRI_BUFFER_STENCIL:
+       case __DRI_BUFFER_ACCUM:
+       default:
+           fprintf(stderr,
+                   "unhandled buffer attach event, attachment type %d\n",
+                   buffers[i].attachment);
+           return;
+       }
+
+       intel_process_dri2_buffer(brw, drawable, &buffers[i], rb, region_name);
+   }
+
+   driUpdateFramebufferSize(&brw->ctx, drawable);
+}
+
+/**
+ * intel_prepare_render should be called anywhere that curent read/drawbuffer
+ * state is required.
+ */
+void
+intel_prepare_render(struct brw_context *brw)
+{
+   __DRIcontext *driContext = brw->driContext;
+   __DRIdrawable *drawable;
+
+   drawable = driContext->driDrawablePriv;
+   if (drawable && drawable->dri2.stamp != driContext->dri2.draw_stamp) {
+      if (drawable->lastStamp != drawable->dri2.stamp)
+         intel_update_renderbuffers(driContext, drawable);
+      driContext->dri2.draw_stamp = drawable->dri2.stamp;
+   }
+
+   drawable = driContext->driReadablePriv;
+   if (drawable && drawable->dri2.stamp != driContext->dri2.read_stamp) {
+      if (drawable->lastStamp != drawable->dri2.stamp)
+         intel_update_renderbuffers(driContext, drawable);
+      driContext->dri2.read_stamp = drawable->dri2.stamp;
+   }
+
+   /* If we're currently rendering to the front buffer, the rendering
+    * that will happen next will probably dirty the front buffer.  So
+    * mark it as dirty here.
+    */
+   if (brw->is_front_buffer_rendering)
+      brw->front_buffer_dirty = true;
+
+   /* Wait for the swapbuffers before the one we just emitted, so we
+    * don't get too many swaps outstanding for apps that are GPU-heavy
+    * but not CPU-heavy.
+    *
+    * We're using intelDRI2Flush (called from the loader before
+    * swapbuffer) and glFlush (for front buffer rendering) as the
+    * indicator that a frame is done and then throttle when we get
+    * here as we prepare to render the next frame.  At this point for
+    * round trips for swap/copy and getting new buffers are done and
+    * we'll spend less time waiting on the GPU.
+    *
+    * Unfortunately, we don't have a handle to the batch containing
+    * the swap, and getting our hands on that doesn't seem worth it,
+    * so we just us the first batch we emitted after the last swap.
+    */
+   if (brw->need_throttle && brw->first_post_swapbuffers_batch) {
+      if (!brw->disable_throttling)
+         drm_intel_bo_wait_rendering(brw->first_post_swapbuffers_batch);
+      drm_intel_bo_unreference(brw->first_post_swapbuffers_batch);
+      brw->first_post_swapbuffers_batch = NULL;
+      brw->need_throttle = false;
+   }
+}
+
+/**
+ * \brief Query DRI2 to obtain a DRIdrawable's buffers.
+ *
+ * To determine which DRI buffers to request, examine the renderbuffers
+ * attached to the drawable's framebuffer. Then request the buffers with
+ * DRI2GetBuffers() or DRI2GetBuffersWithFormat().
+ *
+ * This is called from intel_update_renderbuffers().
+ *
+ * \param drawable      Drawable whose buffers are queried.
+ * \param buffers       [out] List of buffers returned by DRI2 query.
+ * \param buffer_count  [out] Number of buffers returned.
+ *
+ * \see intel_update_renderbuffers()
+ * \see DRI2GetBuffers()
+ * \see DRI2GetBuffersWithFormat()
+ */
+static void
+intel_query_dri2_buffers(struct brw_context *brw,
+                         __DRIdrawable *drawable,
+                         __DRIbuffer **buffers,
+                         int *buffer_count)
+{
+   __DRIscreen *screen = brw->intelScreen->driScrnPriv;
+   struct gl_framebuffer *fb = drawable->driverPrivate;
+   int i = 0;
+   unsigned attachments[8];
+
+   struct intel_renderbuffer *front_rb;
+   struct intel_renderbuffer *back_rb;
+
+   front_rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
+   back_rb = intel_get_renderbuffer(fb, BUFFER_BACK_LEFT);
+
+   memset(attachments, 0, sizeof(attachments));
+   if ((brw->is_front_buffer_rendering ||
+        brw->is_front_buffer_reading ||
+        !back_rb) && front_rb) {
+      /* If a fake front buffer is in use, then querying for
+       * __DRI_BUFFER_FRONT_LEFT will cause the server to copy the image from
+       * the real front buffer to the fake front buffer.  So before doing the
+       * query, we need to make sure all the pending drawing has landed in the
+       * real front buffer.
+       */
+      intel_batchbuffer_flush(brw);
+      intel_flush_front(&brw->ctx);
+
+      attachments[i++] = __DRI_BUFFER_FRONT_LEFT;
+      attachments[i++] = intel_bits_per_pixel(front_rb);
+   } else if (front_rb && brw->front_buffer_dirty) {
+      /* We have pending front buffer rendering, but we aren't querying for a
+       * front buffer.  If the front buffer we have is a fake front buffer,
+       * the X server is going to throw it away when it processes the query.
+       * So before doing the query, make sure all the pending drawing has
+       * landed in the real front buffer.
+       */
+      intel_batchbuffer_flush(brw);
+      intel_flush_front(&brw->ctx);
+   }
+
+   if (back_rb) {
+      attachments[i++] = __DRI_BUFFER_BACK_LEFT;
+      attachments[i++] = intel_bits_per_pixel(back_rb);
+   }
+
+   assert(i <= ARRAY_SIZE(attachments));
+
+   *buffers = screen->dri2.loader->getBuffersWithFormat(drawable,
+                                                        &drawable->w,
+                                                        &drawable->h,
+                                                        attachments, i / 2,
+                                                        buffer_count,
+                                                        drawable->loaderPrivate);
+}
+
+/**
+ * \brief Assign a DRI buffer's DRM region to a renderbuffer.
+ *
+ * This is called from intel_update_renderbuffers().
+ *
+ * \par Note:
+ *    DRI buffers whose attachment point is DRI2BufferStencil or
+ *    DRI2BufferDepthStencil are handled as special cases.
+ *
+ * \param buffer_name is a human readable name, such as "dri2 front buffer",
+ *        that is passed to intel_region_alloc_for_handle().
+ *
+ * \see intel_update_renderbuffers()
+ * \see intel_region_alloc_for_handle()
+ */
+static void
+intel_process_dri2_buffer(struct brw_context *brw,
+                          __DRIdrawable *drawable,
+                          __DRIbuffer *buffer,
+                          struct intel_renderbuffer *rb,
+                          const char *buffer_name)
+{
+   struct intel_region *region = NULL;
+
+   if (!rb)
+      return;
+
+   unsigned num_samples = rb->Base.Base.NumSamples;
+
+   /* We try to avoid closing and reopening the same BO name, because the first
+    * use of a mapping of the buffer involves a bunch of page faulting which is
+    * moderately expensive.
+    */
+   if (num_samples == 0) {
+       if (rb->mt &&
+           rb->mt->region &&
+           rb->mt->region->name == buffer->name)
+          return;
+   } else {
+       if (rb->mt &&
+           rb->mt->singlesample_mt &&
+           rb->mt->singlesample_mt->region &&
+           rb->mt->singlesample_mt->region->name == buffer->name)
+          return;
+   }
+
+   if (unlikely(INTEL_DEBUG & DEBUG_DRI)) {
+      fprintf(stderr,
+              "attaching buffer %d, at %d, cpp %d, pitch %d\n",
+              buffer->name, buffer->attachment,
+              buffer->cpp, buffer->pitch);
+   }
+
+   intel_miptree_release(&rb->mt);
+   region = intel_region_alloc_for_handle(brw->intelScreen,
+                                          buffer->cpp,
+                                          drawable->w,
+                                          drawable->h,
+                                          buffer->pitch,
+                                          buffer->name,
+                                          buffer_name);
+   if (!region)
+      return;
+
+   rb->mt = intel_miptree_create_for_dri2_buffer(brw,
+                                                 buffer->attachment,
+                                                 intel_rb_format(rb),
+                                                 num_samples,
+                                                 region);
+   intel_region_release(&region);
+}
diff --git a/src/mesa/drivers/dri/i965/brw_context.h b/src/mesa/drivers/dri/i965/brw_context.h
index c6e6655..3b95922 100644
--- a/src/mesa/drivers/dri/i965/brw_context.h
+++ b/src/mesa/drivers/dri/i965/brw_context.h
@@ -33,14 +33,34 @@
 #ifndef BRWCONTEXT_INC
 #define BRWCONTEXT_INC
 
-#include "intel_context.h"
-#include "brw_structs.h"
+#include <stdbool.h>
+#include <string.h>
 #include "main/imports.h"
 #include "main/macros.h"
+#include "main/mm.h"
+#include "main/mtypes.h"
+#include "brw_structs.h"
+
+#ifdef __cplusplus
+extern "C" {
+	/* Evil hack for using libdrm in a c++ compiler. */
+        #define virtual virt
+#endif
+
+#include <drm.h>
+#include <intel_bufmgr.h>
+#include <i915_drm.h>
+#ifdef __cplusplus
+	#undef virtual
+}
+#endif
 
 #ifdef __cplusplus
 extern "C" {
 #endif
+#include "intel_debug.h"
+#include "intel_screen.h"
+#include "intel_tex_obj.h"
 
 /* Glossary:
  *
@@ -119,6 +139,9 @@ extern "C" {
  * Handles blending and (presumably) depth and stencil testing.
  */
 
+#define INTEL_WRITE_PART  0x1
+#define INTEL_WRITE_FULL  0x2
+#define INTEL_READ        0x4
 
 #define BRW_MAX_CURBE                    (32*16)
 
@@ -305,6 +328,27 @@ struct brw_shader {
    struct exec_list *ir;
 };
 
+/* Note: If adding fields that need anything besides a normal memcmp() for
+ * comparing them, be sure to go fix the the stage-specific
+ * prog_data_compare().
+ */
+struct brw_stage_prog_data {
+   struct {
+      /** size of our binding table. */
+      uint32_t size_bytes;
+
+      /** @{
+       * surface indices for the various groups of surfaces
+       */
+      uint32_t pull_constants_start;
+      uint32_t texture_start;
+      uint32_t gather_texture_start;
+      uint32_t ubo_start;
+      uint32_t shader_time_start;
+      /** @} */
+   } binding_table;
+};
+
 /* Data about a particular attempt to compile a program.  Note that
  * there can be many of these, each in a different GL state
  * corresponding to a different brw_wm_prog_key struct, with different
@@ -314,6 +358,8 @@ struct brw_shader {
  * struct!
  */
 struct brw_wm_prog_data {
+   struct brw_stage_prog_data base;
+
    GLuint curb_read_length;
    GLuint num_varying_inputs;
 
@@ -323,12 +369,17 @@ struct brw_wm_prog_data {
    GLuint reg_blocks_16;
    GLuint total_scratch;
 
-   unsigned binding_table_size;
+   struct {
+      /** @{
+       * surface indices the WM-specific surfaces
+       */
+      uint32_t render_target_start;
+      /** @} */
+   } binding_table;
 
    GLuint nr_params;       /**< number of float params/constants */
    GLuint nr_pull_params;
    bool dual_src_blend;
-   int dispatch_width;
    uint32_t prog_offset_16;
 
    /**
@@ -521,6 +572,7 @@ struct brw_ff_gs_prog_data {
  * this struct!
  */
 struct brw_vec4_prog_data {
+   struct brw_stage_prog_data base;
    struct brw_vue_map vue_map;
 
    /**
@@ -542,8 +594,6 @@ struct brw_vec4_prog_data {
     */
    GLuint urb_entry_size;
 
-   unsigned binding_table_size;
-
    /* These pointers must appear last.  See brw_vec4_prog_data_compare(). */
    const float **param;
    const float **pull_param;
@@ -627,95 +677,10 @@ struct brw_gs_prog_data
 /** Maximum number of actual buffers used for stream output */
 #define BRW_MAX_SOL_BUFFERS 4
 
-#define BRW_MAX_WM_UBOS              12
-#define BRW_MAX_VS_UBOS              12
-
-/**
- * Helpers to create Surface Binding Table indexes for draw buffers,
- * textures, and constant buffers.
- *
- * Shader threads access surfaces via numeric handles, rather than directly
- * using pointers.  The binding table maps these numeric handles to the
- * address of the actual buffer.
- *
- * For example, a shader might ask to sample from "surface 7."  In this case,
- * bind[7] would contain a pointer to a texture.
- *
- * Currently, our WM binding tables are (arbitrarily) programmed as follows:
- *
- *    +-------------------------------+
- *    |   0 | Draw buffer 0           |
- *    |   . |     .                   |
- *    |   : |     :                   |
- *    |   7 | Draw buffer 7           |
- *    |-----|-------------------------|
- *    |   8 | WM Pull Constant Buffer |
- *    |-----|-------------------------|
- *    |   9 | Texture 0               |
- *    |   . |     .                   |
- *    |   : |     :                   |
- *    |  24 | Texture 15              |
- *    |-----|-------------------------|
- *    |  25 | UBO 0                   |
- *    |   . |     .                   |
- *    |   : |     :                   |
- *    |  36 | UBO 11                  |
- *    |-----|-------------------------|
- *    |  37 | Shader time buffer      |
- *    |-----|-------------------------|
- *    |  38 | Gather texture 0        |
- *    |   . |     .                   |
- *    |   : |     :                   |
- *    |  53 | Gather texture 15       |
- *    +-------------------------------+
- *
- * Our VS (and Gen7 GS) binding tables are programmed as follows:
- *
- *    +-----+-------------------------+
- *    |   0 | Pull Constant Buffer    |
- *    +-----+-------------------------+
- *    |   1 | Texture 0               |
- *    |   . |     .                   |
- *    |   : |     :                   |
- *    |  16 | Texture 15              |
- *    +-----+-------------------------+
- *    |  17 | UBO 0                   |
- *    |   . |     .                   |
- *    |   : |     :                   |
- *    |  28 | UBO 11                  |
- *    |-----|-------------------------|
- *    |  29 | Shader time buffer      |
- *    |-----|-------------------------|
- *    |  30 | Gather texture 0        |
- *    |   . |     .                   |
- *    |   : |     :                   |
- *    |  45 | Gather texture 15       |
- *    +-------------------------------+
- *
- * Our (gen6) GS binding tables are programmed as follows:
- *
- *    +-----+-------------------------+
- *    |   0 | SOL Binding 0           |
- *    |   . |     .                   |
- *    |   : |     :                   |
- *    |  63 | SOL Binding 63          |
- *    +-----+-------------------------+
- */
-#define SURF_INDEX_DRAW(d)           (d)
-#define SURF_INDEX_FRAG_CONST_BUFFER (BRW_MAX_DRAW_BUFFERS + 1)
-#define SURF_INDEX_TEXTURE(t)        (BRW_MAX_DRAW_BUFFERS + 2 + (t))
-#define SURF_INDEX_WM_UBO(u)         (SURF_INDEX_TEXTURE(BRW_MAX_TEX_UNIT) + u)
-#define SURF_INDEX_WM_SHADER_TIME    (SURF_INDEX_WM_UBO(12))
-#define SURF_INDEX_GATHER_TEXTURE(t) (SURF_INDEX_WM_SHADER_TIME + 1 + (t))
-/** Maximum size of the binding table. */
-#define BRW_MAX_WM_SURFACES          (SURF_INDEX_GATHER_TEXTURE(BRW_MAX_TEX_UNIT))
-
-#define SURF_INDEX_VEC4_CONST_BUFFER (0)
-#define SURF_INDEX_VEC4_TEXTURE(t)   (SURF_INDEX_VEC4_CONST_BUFFER + 1 + (t))
-#define SURF_INDEX_VEC4_UBO(u)       (SURF_INDEX_VEC4_TEXTURE(BRW_MAX_TEX_UNIT) + u)
-#define SURF_INDEX_VEC4_SHADER_TIME  (SURF_INDEX_VEC4_UBO(12))
-#define SURF_INDEX_VEC4_GATHER_TEXTURE(t)   (SURF_INDEX_VEC4_SHADER_TIME + 1 + (t))
-#define BRW_MAX_VEC4_SURFACES        (SURF_INDEX_VEC4_GATHER_TEXTURE(BRW_MAX_TEX_UNIT))
+#define BRW_MAX_SURFACES   (BRW_MAX_DRAW_BUFFERS +                      \
+                            BRW_MAX_TEX_UNIT * 2 + /* normal, gather */ \
+                            12 + /* ubo */                              \
+                            2 /* shader time, pull constants */)
 
 #define SURF_INDEX_GEN6_SOL_BINDING(t) (t)
 #define BRW_MAX_GEN6_GS_SURFACES       SURF_INDEX_GEN6_SOL_BINDING(BRW_MAX_SOL_BINDINGS)
@@ -771,8 +736,7 @@ struct brw_cache_item {
 };   
 
 
-typedef bool (*cache_aux_compare_func)(const void *a, const void *b,
-                                       int aux_size, const void *key);
+typedef bool (*cache_aux_compare_func)(const void *a, const void *b);
 typedef void (*cache_aux_free_func)(const void *aux);
 
 struct brw_cache {
@@ -876,12 +840,48 @@ struct brw_query_object {
    int last_index;
 };
 
+struct intel_sync_object {
+   struct gl_sync_object Base;
+
+   /** Batch associated with this sync object */
+   drm_intel_bo *bo;
+};
+
+struct intel_batchbuffer {
+   /** Current batchbuffer being queued up. */
+   drm_intel_bo *bo;
+   /** Last BO submitted to the hardware.  Used for glFinish(). */
+   drm_intel_bo *last_bo;
+   /** BO for post-sync nonzero writes for gen6 workaround. */
+   drm_intel_bo *workaround_bo;
+   bool need_workaround_flush;
+
+   struct cached_batch_item *cached_items;
+
+   uint16_t emit, total;
+   uint16_t used, reserved_space;
+   uint32_t *map;
+   uint32_t *cpu_map;
+#define BATCH_SZ (8192*sizeof(uint32_t))
+
+   uint32_t state_batch_offset;
+   bool is_blit;
+   bool needs_sol_reset;
+
+   struct {
+      uint16_t used;
+      int reloc_count;
+   } saved;
+};
 
 /**
- * Data shared between brw_context::vs and brw_context::gs
+ * Data shared between each programmable stage in the pipeline (vs, gs, and
+ * wm).
  */
 struct brw_stage_state
 {
+   struct brw_stage_prog_data *prog_data;
+
    /**
     * Optional scratch buffer used to store spilled register values and
     * variably-indexed GRF arrays.
@@ -902,7 +902,7 @@ struct brw_stage_state
 
    /* Binding table: pointers to SURFACE_STATE entries. */
    uint32_t bind_bo_offset;
-   uint32_t surf_offset[BRW_MAX_WM_SURFACES];
+   uint32_t surf_offset[BRW_MAX_SURFACES];
 
    /** SAMPLER_STATE count and table offset */
    uint32_t sampler_count;
@@ -922,10 +922,6 @@ struct brw_context
 
    struct
    {
-      void (*destroy) (struct brw_context * brw);
-      void (*finish_batch) (struct brw_context * brw);
-      void (*new_batch) (struct brw_context * brw);
-
       void (*update_texture_surface)(struct gl_context *ctx,
                                      unsigned unit,
                                      uint32_t *surf_offset,
@@ -1040,8 +1036,6 @@ struct brw_context
 
    uint32_t max_gtt_map_object_size;
 
-   bool emit_state_always;
-
    int gen;
    int gt;
 
@@ -1057,7 +1051,6 @@ struct brw_context
    bool has_surface_tile_offset;
    bool has_compr4;
    bool has_negative_rhw_bug;
-   bool has_aa_line_parameters;
    bool has_pln;
 
    /**
@@ -1300,10 +1293,11 @@ struct brw_context
       struct {
          struct ra_regs *regs;
 
-         /** Array of the ra classes for the unaligned contiguous
-          * register block sizes used.
+         /**
+          * Array of the ra classes for the unaligned contiguous register
+          * block sizes used, indexed by register size.
           */
-         int *classes;
+         int classes[16];
 
          /**
           * Mapping for register-allocated objects in *regs to the first
@@ -1401,15 +1395,38 @@ struct brw_context
                           GLint x, GLint y, GLsizei width, GLsizei height);
 };
 
+static INLINE bool
+is_power_of_two(uint32_t value)
+{
+   return (value & (value - 1)) == 0;
+}
+
 /*======================================================================
  * brw_vtbl.c
  */
 void brwInitVtbl( struct brw_context *brw );
 
+/* brw_clear.c */
+extern void intelInitClearFuncs(struct dd_function_table *functions);
+
 /*======================================================================
  * brw_context.c
  */
-bool brwCreateContext(int api,
+extern void intelFinish(struct gl_context * ctx);
+
+enum {
+   DRI_CONF_BO_REUSE_DISABLED,
+   DRI_CONF_BO_REUSE_ALL
+};
+
+void intel_update_renderbuffers(__DRIcontext *context,
+                                __DRIdrawable *drawable);
+void intel_prepare_render(struct brw_context *brw);
+
+void intel_resolve_for_dri2_flush(struct brw_context *brw,
+                                  __DRIdrawable *drawable);
+
+bool brwCreateContext(gl_api api,
 		      const struct gl_config *mesaVis,
 		      __DRIcontext *driContextPriv,
                       unsigned major_version,
@@ -1507,7 +1524,8 @@ brw_update_sol_surface(struct brw_context *brw,
                        unsigned stride_dwords, unsigned offset_dwords);
 void brw_upload_ubo_surfaces(struct brw_context *brw,
 			     struct gl_shader *shader,
-			     uint32_t *surf_offsets);
+                             struct brw_stage_state *stage_state,
+                             struct brw_stage_prog_data *prog_data);
 
 /* brw_surface_formats.c */
 bool brw_is_hiz_depth_format(struct brw_context *ctx, gl_format format);
@@ -1517,6 +1535,18 @@ bool brw_render_target_supported(struct brw_context *brw,
 /* brw_performance_monitor.c */
 void brw_init_performance_monitors(struct brw_context *brw);
 
+/* intel_extensions.c */
+extern void intelInitExtensions(struct gl_context *ctx);
+
+/* intel_state.c */
+extern int intel_translate_shadow_compare_func(GLenum func);
+extern int intel_translate_compare_func(GLenum func);
+extern int intel_translate_stencil_op(GLenum op);
+extern int intel_translate_logic_op(GLenum opcode);
+
+/* intel_syncobj.c */
+void intel_init_syncobj_functions(struct dd_function_table *functions);
+
 /* gen6_sol.c */
 void
 brw_begin_transform_feedback(struct gl_context *ctx, GLenum mode,
@@ -1688,6 +1718,33 @@ gen6_upload_vec4_push_constants(struct brw_context *brw,
                                 struct brw_stage_state *stage_state,
                                 enum state_struct_type type);
 
+/* ================================================================
+ * From linux kernel i386 header files, copes with odd sizes better
+ * than COPY_DWORDS would:
+ * XXX Put this in src/mesa/main/imports.h ???
+ */
+#if defined(i386) || defined(__i386__)
+static INLINE void * __memcpy(void * to, const void * from, size_t n)
+{
+   int d0, d1, d2;
+   __asm__ __volatile__(
+      "rep ; movsl\n\t"
+      "testb $2,%b4\n\t"
+      "je 1f\n\t"
+      "movsw\n"
+      "1:\ttestb $1,%b4\n\t"
+      "je 2f\n\t"
+      "movsb\n"
+      "2:"
+      : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+      :"0" (n/4), "q" (n),"1" ((long) to),"2" ((long) from)
+      : "memory");
+   return (to);
+}
+#else
+#define __memcpy(a,b,c) memcpy(a,b,c)
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/mesa/drivers/dri/i965/brw_cubemap_normalize.cpp b/src/mesa/drivers/dri/i965/brw_cubemap_normalize.cpp
index 949414c..3357129 100644
--- a/src/mesa/drivers/dri/i965/brw_cubemap_normalize.cpp
+++ b/src/mesa/drivers/dri/i965/brw_cubemap_normalize.cpp
@@ -52,7 +52,7 @@ brw_cubemap_normalize_visitor::visit_leave(ir_texture *ir)
    if (ir->sampler->type->sampler_dimensionality != GLSL_SAMPLER_DIM_CUBE)
       return visit_continue;
 
-   if (ir->op == ir_txs)
+   if (!ir->coordinate)
       return visit_continue;
 
    void *mem_ctx = ralloc_parent(ir);
diff --git a/src/mesa/drivers/dri/i965/brw_defines.h b/src/mesa/drivers/dri/i965/brw_defines.h
index 7dfb2b9..5ba9d45 100644
--- a/src/mesa/drivers/dri/i965/brw_defines.h
+++ b/src/mesa/drivers/dri/i965/brw_defines.h
@@ -733,6 +733,8 @@ enum opcode {
    BRW_OPCODE_FBH =	75,
    BRW_OPCODE_FBL =	76,
    BRW_OPCODE_CBIT =	77,
+   BRW_OPCODE_ADDC =	78,
+   BRW_OPCODE_SUBB =	79,
    BRW_OPCODE_SAD2 =	80,
    BRW_OPCODE_SADA2 =	81,
    BRW_OPCODE_DP4 =	84,
@@ -1379,6 +1381,7 @@ enum brw_message_target {
 # define GEN6_GS_SO_STATISTICS_ENABLE			(1 << 9)
 # define GEN6_GS_RENDERING_ENABLE			(1 << 8)
 # define GEN7_GS_INCLUDE_PRIMITIVE_ID			(1 << 4)
+# define GEN7_GS_REORDER_TRAILING			(1 << 2)
 # define GEN7_GS_ENABLE					(1 << 0)
 /* DW6 */
 # define HSW_GS_CONTROL_DATA_FORMAT_SHIFT		31
diff --git a/src/mesa/drivers/dri/i965/brw_device_info.c b/src/mesa/drivers/dri/i965/brw_device_info.c
new file mode 100644
index 0000000..b472356
--- /dev/null
+++ b/src/mesa/drivers/dri/i965/brw_device_info.c
@@ -0,0 +1,205 @@
+/*
+ * Copyright © 2013 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "brw_device_info.h"
+
+static const struct brw_device_info brw_device_info_i965 = {
+   .gen = 4,
+   .has_negative_rhw_bug = true,
+   .needs_unlit_centroid_workaround = true,
+   .max_vs_threads = 16,
+   .max_gs_threads = 2,
+   .max_wm_threads = 8 * 4,
+   .urb = {
+      .size = 256,
+   },
+};
+
+static const struct brw_device_info brw_device_info_g4x = {
+   .gen = 4,
+   .has_pln = true,
+   .has_compr4 = true,
+   .needs_unlit_centroid_workaround = true,
+   .is_g4x = true,
+   .max_vs_threads = 32,
+   .max_gs_threads = 2,
+   .max_wm_threads = 10 * 5,
+   .urb = {
+      .size = 384,
+   },
+};
+
+static const struct brw_device_info brw_device_info_ilk = {
+   .gen = 5,
+   .has_pln = true,
+   .has_compr4 = true,
+   .has_surface_tile_offset = true,
+   .needs_unlit_centroid_workaround = true,
+   .max_vs_threads = 72,
+   .max_gs_threads = 32,
+   .max_wm_threads = 12 * 6,
+   .urb = {
+      .size = 1024,
+   },
+};
+
+static const struct brw_device_info brw_device_info_snb_gt1 = {
+   .gen = 6,
+   .gt = 2,
+   .has_hiz_and_separate_stencil = true,
+   .has_llc = true,
+   .has_pln = true,
+   .has_surface_tile_offset = true,
+   .needs_unlit_centroid_workaround = true,
+   .max_vs_threads = 24,
+   .max_gs_threads = 21, /* conservative; 24 if rendering disabled. */
+   .max_wm_threads = 40,
+   .urb = {
+      .size = 32,
+      .min_vs_entries = 24,
+      .max_vs_entries = 256,
+      .max_gs_entries = 256,
+   },
+};
+
+static const struct brw_device_info brw_device_info_snb_gt2 = {
+   .gen = 6,
+   .gt = 2,
+   .has_hiz_and_separate_stencil = true,
+   .has_llc = true,
+   .has_pln = true,
+   .has_surface_tile_offset = true,
+   .needs_unlit_centroid_workaround = true,
+   .max_vs_threads = 60,
+   .max_gs_threads = 60,
+   .max_wm_threads = 80,
+   .urb = {
+      .size = 64,
+      .min_vs_entries = 24,
+      .max_vs_entries = 256,
+      .max_gs_entries = 256,
+   },
+};
+
+#define GEN7_FEATURES                               \
+   .gen = 7,                                        \
+   .has_hiz_and_separate_stencil = true,            \
+   .must_use_separate_stencil = true,               \
+   .has_llc = true,                                 \
+   .has_pln = true,                                 \
+   .has_surface_tile_offset = true,                 \
+   .needs_unlit_centroid_workaround = true
+
+static const struct brw_device_info brw_device_info_ivb_gt1 = {
+   GEN7_FEATURES, .is_ivybridge = true, .gt = 1,
+   .max_vs_threads = 36,
+   .max_gs_threads = 36,
+   .max_wm_threads = 48,
+   .urb = {
+      .size = 128,
+      .min_vs_entries = 32,
+      .max_vs_entries = 512,
+      .max_gs_entries = 192,
+   },
+};
+
+static const struct brw_device_info brw_device_info_ivb_gt2 = {
+   GEN7_FEATURES, .is_ivybridge = true, .gt = 2,
+   .max_vs_threads = 128,
+   .max_gs_threads = 128,
+   .max_wm_threads = 172,
+   .urb = {
+      .size = 256,
+      .min_vs_entries = 32,
+      .max_vs_entries = 704,
+      .max_gs_entries = 320,
+   },
+};
+
+static const struct brw_device_info brw_device_info_byt = {
+   GEN7_FEATURES, .is_baytrail = true, .gt = 1,
+   .has_llc = false,
+   .max_vs_threads = 36,
+   .max_gs_threads = 36,
+   .max_wm_threads = 48,
+   .urb = {
+      .size = 128,
+      .min_vs_entries = 32,
+      .max_vs_entries = 512,
+      .max_gs_entries = 192,
+   },
+};
+
+static const struct brw_device_info brw_device_info_hsw_gt1 = {
+   GEN7_FEATURES, .is_haswell = true, .gt = 1,
+   .max_vs_threads = 70,
+   .max_gs_threads = 70,
+   .max_wm_threads = 102,
+   .urb = {
+      .size = 128,
+      .min_vs_entries = 32,
+      .max_vs_entries = 640,
+      .max_gs_entries = 256,
+   },
+};
+
+static const struct brw_device_info brw_device_info_hsw_gt2 = {
+   GEN7_FEATURES, .is_haswell = true, .gt = 2,
+   .max_vs_threads = 280,
+   .max_gs_threads = 256,
+   .max_wm_threads = 204,
+   .urb = {
+      .size = 256,
+      .min_vs_entries = 64,
+      .max_vs_entries = 1664,
+      .max_gs_entries = 640,
+   },
+};
+
+static const struct brw_device_info brw_device_info_hsw_gt3 = {
+   GEN7_FEATURES, .is_haswell = true, .gt = 3,
+   .max_vs_threads = 280,
+   .max_gs_threads = 256,
+   .max_wm_threads = 408,
+   .urb = {
+      .size = 512,
+      .min_vs_entries = 64,
+      .max_vs_entries = 1664,
+      .max_gs_entries = 640,
+   },
+};
+
+const struct brw_device_info *
+brw_get_device_info(int devid)
+{
+   switch (devid) {
+#undef CHIPSET
+#define CHIPSET(id, family, name) case id: return &brw_device_info_##family;
+#include "pci_ids/i965_pci_ids.h"
+   default:
+      fprintf(stderr, "Unknown Intel device.");
+      abort();
+   }
+}
diff --git a/src/mesa/drivers/dri/i965/brw_device_info.h b/src/mesa/drivers/dri/i965/brw_device_info.h
new file mode 100644
index 0000000..66ec935
--- /dev/null
+++ b/src/mesa/drivers/dri/i965/brw_device_info.h
@@ -0,0 +1,80 @@
+ /*
+  * Copyright © 2013 Intel Corporation
+  *
+  * Permission is hereby granted, free of charge, to any person obtaining a
+  * copy of this software and associated documentation files (the "Software"),
+  * to deal in the Software without restriction, including without limitation
+  * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+  * and/or sell copies of the Software, and to permit persons to whom the
+  * Software is furnished to do so, subject to the following conditions:
+  *
+  * The above copyright notice and this permission notice (including the next
+  * paragraph) shall be included in all copies or substantial portions of the
+  * Software.
+  *
+  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+  * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+  * IN THE SOFTWARE.
+  *
+  */
+
+#pragma once
+#include <stdbool.h>
+
+struct brw_device_info
+{
+   int gen; /**< Generation number: 4, 5, 6, 7, ... */
+   int gt;
+
+   bool is_g4x;
+   bool is_ivybridge;
+   bool is_baytrail;
+   bool is_haswell;
+
+   bool has_hiz_and_separate_stencil;
+   bool must_use_separate_stencil;
+
+   bool has_llc;
+
+   bool has_pln;
+   bool has_compr4;
+   bool has_surface_tile_offset;
+
+   /**
+    * Quirks:
+    *  @{
+    */
+   bool has_negative_rhw_bug;
+
+   /**
+    * Some versions of Gen hardware don't do centroid interpolation correctly
+    * on unlit pixels, causing incorrect values for derivatives near triangle
+    * edges.  Enabling this flag causes the fragment shader to use
+    * non-centroid interpolation for unlit pixels, at the expense of two extra
+    * fragment shader instructions.
+    */
+   bool needs_unlit_centroid_workaround;
+   /** @} */
+
+   /**
+    * GPU Limits:
+    *  @{
+    */
+   unsigned max_vs_threads;
+   unsigned max_gs_threads;
+   unsigned max_wm_threads;
+
+   struct {
+      unsigned size;
+      unsigned min_vs_entries;
+      unsigned max_vs_entries;
+      unsigned max_gs_entries;
+   } urb;
+   /** @} */
+};
+
+const struct brw_device_info *brw_get_device_info(int devid);
diff --git a/src/mesa/drivers/dri/i965/brw_disasm.c b/src/mesa/drivers/dri/i965/brw_disasm.c
index 18e6c9d..22b37d7 100644
--- a/src/mesa/drivers/dri/i965/brw_disasm.c
+++ b/src/mesa/drivers/dri/i965/brw_disasm.c
@@ -77,6 +77,8 @@ const struct opcode_desc opcode_descs[128] = {
     [BRW_OPCODE_BFE] = { .name = "bfe", .nsrc = 3, .ndst = 1},
     [BRW_OPCODE_BFI1] = { .name = "bfe1", .nsrc = 2, .ndst = 1},
     [BRW_OPCODE_BFI2] = { .name = "bfe2", .nsrc = 3, .ndst = 1},
+    [BRW_OPCODE_ADDC] = { .name = "addc", .nsrc = 2, .ndst = 1},
+    [BRW_OPCODE_SUBB] = { .name = "subb", .nsrc = 2, .ndst = 1},
 
     [BRW_OPCODE_SEND] = { .name = "send", .nsrc = 1, .ndst = 1 },
     [BRW_OPCODE_SENDC] = { .name = "sendc", .nsrc = 1, .ndst = 1 },
diff --git a/src/mesa/drivers/dri/i965/brw_eu.h b/src/mesa/drivers/dri/i965/brw_eu.h
index 720bc74..072310d 100644
--- a/src/mesa/drivers/dri/i965/brw_eu.h
+++ b/src/mesa/drivers/dri/i965/brw_eu.h
@@ -181,6 +181,8 @@ ALU3(BFI2)
 ALU1(FBH)
 ALU1(FBL)
 ALU1(CBIT)
+ALU2(ADDC)
+ALU2(SUBB)
 
 ROUND(RNDZ)
 ROUND(RNDE)
diff --git a/src/mesa/drivers/dri/i965/brw_eu_emit.c b/src/mesa/drivers/dri/i965/brw_eu_emit.c
index 7ed3df0..8efd679 100644
--- a/src/mesa/drivers/dri/i965/brw_eu_emit.c
+++ b/src/mesa/drivers/dri/i965/brw_eu_emit.c
@@ -968,6 +968,8 @@ ALU3(BFI2)
 ALU1(FBH)
 ALU1(FBL)
 ALU1(CBIT)
+ALU2(ADDC)
+ALU2(SUBB)
 
 ROUND(RNDZ)
 ROUND(RNDE)
@@ -2191,11 +2193,27 @@ void brw_SAMPLE(struct brw_compile *p,
    struct brw_context *brw = p->brw;
    struct brw_instruction *insn;
 
-   gen6_resolve_implied_move(p, &src0, msg_reg_nr);
+   if (msg_reg_nr != -1)
+      gen6_resolve_implied_move(p, &src0, msg_reg_nr);
 
    insn = next_insn(p, BRW_OPCODE_SEND);
    insn->header.predicate_control = 0; /* XXX */
-   insn->header.compression_control = BRW_COMPRESSION_NONE;
+
+   /* From the 965 PRM (volume 4, part 1, section 14.2.41):
+    *
+    *    "Instruction compression is not allowed for this instruction (that
+    *     is, send). The hardware behavior is undefined if this instruction is
+    *     set as compressed. However, compress control can be set to "SecHalf"
+    *     to affect the EMask generation."
+    *
+    * No similar wording is found in later PRMs, but there are examples
+    * utilizing send with SecHalf.  More importantly, SIMD8 sampler messages
+    * are allowed in SIMD16 mode and they could not work without SecHalf.  For
+    * these reasons, we allow BRW_COMPRESSION_2NDHALF here.
+    */
+   if (insn->header.compression_control != BRW_COMPRESSION_2NDHALF)
+      insn->header.compression_control = BRW_COMPRESSION_NONE;
+
    if (brw->gen < 6)
       insn->header.destreg__conditionalmod = msg_reg_nr;
 
diff --git a/src/mesa/drivers/dri/i965/brw_fs.cpp b/src/mesa/drivers/dri/i965/brw_fs.cpp
index 89eb33e..65a4b66 100644
--- a/src/mesa/drivers/dri/i965/brw_fs.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs.cpp
@@ -47,6 +47,7 @@ extern "C" {
 }
 #include "brw_fs.h"
 #include "main/uniforms.h"
+#include "brw_fs_live_variables.h"
 #include "glsl/glsl_types.h"
 
 void
@@ -180,6 +181,8 @@ ALU1(FBH)
 ALU1(FBL)
 ALU1(CBIT)
 ALU3(MAD)
+ALU2(ADDC)
+ALU2(SUBB)
 
 /** Gen4 predicated IF. */
 fs_inst *
@@ -352,7 +355,8 @@ fs_inst::is_send_from_grf()
    return (opcode == FS_OPCODE_VARYING_PULL_CONSTANT_LOAD_GEN7 ||
            opcode == SHADER_OPCODE_SHADER_TIME_ADD ||
            (opcode == FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD &&
-            src[1].file == GRF));
+            src[1].file == GRF) ||
+           (is_tex() && src[0].file == GRF));
 }
 
 bool
@@ -364,6 +368,9 @@ fs_visitor::can_do_source_mods(fs_inst *inst)
    if (inst->is_send_from_grf())
       return false;
 
+   if (!inst->can_do_source_mods())
+      return false;
+
    return true;
 }
 
@@ -433,6 +440,14 @@ fs_reg::equals(const fs_reg &r) const
            imm.u == r.imm.u);
 }
 
+fs_reg
+fs_reg::retype(uint32_t type)
+{
+   fs_reg result = *this;
+   result.type = type;
+   return result;
+}
+
 bool
 fs_reg::is_zero() const
 {
@@ -695,6 +710,18 @@ fs_inst::is_partial_write()
            this->force_sechalf);
 }
 
+int
+fs_inst::regs_read(fs_visitor *v, int arg)
+{
+   if (is_tex() && arg == 0 && src[0].file == GRF) {
+      if (v->dispatch_width == 16)
+	 return (mlen + 1) / 2;
+      else
+	 return mlen;
+   }
+   return 1;
+}
+
 /**
  * Returns how many MRFs an FS opcode will write over.
  *
@@ -707,6 +734,9 @@ fs_visitor::implied_mrf_writes(fs_inst *inst)
    if (inst->mlen == 0)
       return 0;
 
+   if (inst->base_mrf == -1)
+      return 0;
+
    switch (inst->opcode) {
    case SHADER_OPCODE_RCP:
    case SHADER_OPCODE_RSQ:
@@ -1441,7 +1471,7 @@ fs_visitor::split_virtual_grfs()
 	 }
       }
    }
-   this->live_intervals_valid = false;
+   invalidate_live_intervals();
 }
 
 /**
@@ -1499,10 +1529,7 @@ fs_visitor::compact_virtual_grfs()
       if (remap_table[i] != -1) {
          remap_table[i] = new_index;
          virtual_grf_sizes[new_index] = virtual_grf_sizes[i];
-         if (live_intervals_valid) {
-            virtual_grf_start[new_index] = virtual_grf_start[i];
-            virtual_grf_end[new_index] = virtual_grf_end[i];
-         }
+         invalidate_live_intervals();
          ++new_index;
       }
    }
@@ -1673,7 +1700,7 @@ fs_visitor::move_uniform_array_access_to_pull_constants()
          base_ir = inst->ir;
          current_annotation = inst->annotation;
 
-         fs_reg surf_index = fs_reg((unsigned)SURF_INDEX_FRAG_CONST_BUFFER);
+         fs_reg surf_index = fs_reg(c->prog_data.base.binding_table.pull_constants_start);
          fs_reg temp = fs_reg(this, glsl_type::float_type);
          exec_list list = VARYING_PULL_CONSTANT_LOAD(temp,
                                                      surf_index,
@@ -1757,7 +1784,7 @@ fs_visitor::setup_pull_constants()
          assert(!inst->src[i].reladdr);
 
 	 fs_reg dst = fs_reg(this, glsl_type::float_type);
-	 fs_reg index = fs_reg((unsigned)SURF_INDEX_FRAG_CONST_BUFFER);
+	 fs_reg index = fs_reg(c->prog_data.base.binding_table.pull_constants_start);
 	 fs_reg offset = fs_reg((unsigned)(pull_index * 4) & ~15);
 	 fs_inst *pull =
             new(mem_ctx) fs_inst(FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD,
@@ -1842,10 +1869,33 @@ fs_visitor::dead_code_eliminate()
       fs_inst *inst = (fs_inst *)node;
 
       if (inst->dst.file == GRF) {
-         assert(this->virtual_grf_end[inst->dst.reg] >= pc);
-         if (this->virtual_grf_end[inst->dst.reg] == pc) {
-            inst->remove();
-            progress = true;
+         bool dead = true;
+
+         for (int i = 0; i < inst->regs_written; i++) {
+            int var = live_intervals->var_from_vgrf[inst->dst.reg];
+            assert(live_intervals->end[var + inst->dst.reg_offset + i] >= pc);
+            if (live_intervals->end[var + inst->dst.reg_offset + i] != pc) {
+               dead = false;
+               break;
+            }
+         }
+
+         if (dead) {
+            /* Don't dead code eliminate instructions that write to the
+             * accumulator as a side-effect. Instead just set the destination
+             * to the null register to free it.
+             */
+            switch (inst->opcode) {
+            case BRW_OPCODE_ADDC:
+            case BRW_OPCODE_SUBB:
+            case BRW_OPCODE_MACH:
+               inst->dst = fs_reg(retype(brw_null_reg(), inst->dst.type));
+               break;
+            default:
+               inst->remove();
+               progress = true;
+               break;
+            }
          }
       }
 
@@ -1853,7 +1903,7 @@ fs_visitor::dead_code_eliminate()
    }
 
    if (progress)
-      live_intervals_valid = false;
+      invalidate_live_intervals();
 
    return progress;
 }
@@ -2011,7 +2061,7 @@ fs_visitor::dead_code_eliminate_local()
    _mesa_hash_table_destroy(ht, NULL);
 
    if (progress)
-      live_intervals_valid = false;
+      invalidate_live_intervals();
 
    return progress;
 }
@@ -2040,11 +2090,16 @@ fs_visitor::register_coalesce_2()
 	  inst->src[0].smear != -1 ||
 	  inst->dst.file != GRF ||
 	  inst->dst.type != inst->src[0].type ||
-	  virtual_grf_sizes[inst->src[0].reg] != 1 ||
-	  virtual_grf_interferes(inst->dst.reg, inst->src[0].reg)) {
+	  virtual_grf_sizes[inst->src[0].reg] != 1) {
 	 continue;
       }
 
+      int var_from = live_intervals->var_from_reg(&inst->src[0]);
+      int var_to = live_intervals->var_from_reg(&inst->dst);
+
+      if (live_intervals->vars_interfere(var_from, var_to))
+         continue;
+
       int reg_from = inst->src[0].reg;
       assert(inst->src[0].reg_offset == 0);
       int reg_to = inst->dst.reg;
@@ -2068,32 +2123,13 @@ fs_visitor::register_coalesce_2()
       }
 
       inst->remove();
-
-      /* We don't need to recalculate live intervals inside the loop despite
-       * flagging live_intervals_valid because we only use live intervals for
-       * the interferes test, and we must have had a situation where the
-       * intervals were:
-       *
-       *  from  to
-       *  ^
-       *  |
-       *  v
-       *        ^
-       *        |
-       *        v
-       *
-       * Some register R that might get coalesced with one of these two could
-       * only be referencing "to", otherwise "from"'s range would have been
-       * longer.  R's range could also only start at the end of "to" or later,
-       * otherwise it will conflict with "to" when we try to coalesce "to"
-       * into Rw anyway.
-       */
-      live_intervals_valid = false;
-
       progress = true;
       continue;
    }
 
+   if (progress)
+      invalidate_live_intervals();
+
    return progress;
 }
 
@@ -2185,6 +2221,13 @@ fs_visitor::register_coalesce()
 	    break;
 	 }
 
+	 if (scan_inst->mlen > 0 && scan_inst->base_mrf == -1 &&
+	     scan_inst->src[0].file == GRF &&
+	     scan_inst->src[0].reg == inst->dst.reg) {
+	    interfered = true;
+	    break;
+	 }
+
 	 /* The accumulator result appears to get used for the
 	  * conditional modifier generation.  When negating a UD
 	  * value, there is a 33rd bit generated for the sign in the
@@ -2218,6 +2261,7 @@ fs_visitor::register_coalesce()
                   new_src.abs = 1;
                }
 	       new_src.negate ^= scan_inst->src[i].negate;
+	       new_src.sechalf = scan_inst->src[i].sechalf;
 	       scan_inst->src[i] = new_src;
 	    }
 	 }
@@ -2228,7 +2272,7 @@ fs_visitor::register_coalesce()
    }
 
    if (progress)
-      live_intervals_valid = false;
+      invalidate_live_intervals();
 
    return progress;
 }
@@ -2372,7 +2416,7 @@ fs_visitor::compute_to_mrf()
 	    }
 	 }
 
-	 if (scan_inst->mlen > 0) {
+	 if (scan_inst->mlen > 0 && scan_inst->base_mrf != -1) {
 	    /* Found a SEND instruction, which means that there are
 	     * live values in MRFs from base_mrf to base_mrf +
 	     * scan_inst->mlen - 1.  Don't go pushing our MRF write up
@@ -2391,7 +2435,7 @@ fs_visitor::compute_to_mrf()
    }
 
    if (progress)
-      live_intervals_valid = false;
+      invalidate_live_intervals();
 
    return progress;
 }
@@ -2434,7 +2478,7 @@ fs_visitor::remove_duplicate_mrf_writes()
 	 last_mrf_move[inst->dst.reg] = NULL;
       }
 
-      if (inst->mlen > 0) {
+      if (inst->mlen > 0 && inst->base_mrf != -1) {
 	 /* Found a SEND instruction, which will include two or fewer
 	  * implied MRF writes.  We could do better here.
 	  */
@@ -2462,7 +2506,7 @@ fs_visitor::remove_duplicate_mrf_writes()
    }
 
    if (progress)
-      live_intervals_valid = false;
+      invalidate_live_intervals();
 
    return progress;
 }
@@ -2729,7 +2773,7 @@ fs_visitor::lower_uniform_pull_constant_loads()
          inst->opcode = FS_OPCODE_UNIFORM_PULL_CONSTANT_LOAD_GEN7;
          inst->src[1] = payload;
 
-         this->live_intervals_valid = false;
+         invalidate_live_intervals();
       } else {
          /* Before register allocation, we didn't tell the scheduler about the
           * MRF we use.  We know it's safe to use this MRF because nothing
@@ -2783,11 +2827,10 @@ fs_visitor::dump_instruction(backend_instruction *be_inst)
    case UNIFORM:
       printf("***u%d***", inst->dst.reg);
       break;
-   case ARF:
-      if (inst->dst.reg == BRW_ARF_NULL)
-         printf("(null)");
-      else
-         printf("arf%d", inst->dst.reg);
+   case HW_REG:
+      printf("hw_reg%d", inst->dst.fixed_hw_reg.nr);
+      if (inst->dst.fixed_hw_reg.subnr)
+         printf("+%d", inst->dst.fixed_hw_reg.subnr);
       break;
    default:
       printf("???");
@@ -2833,6 +2876,17 @@ fs_visitor::dump_instruction(backend_instruction *be_inst)
             break;
          }
          break;
+      case HW_REG:
+         if (inst->src[i].fixed_hw_reg.negate)
+            printf("-");
+         if (inst->src[i].fixed_hw_reg.abs)
+            printf("|");
+         printf("hw_reg%d", inst->src[i].fixed_hw_reg.nr);
+         if (inst->src[i].fixed_hw_reg.subnr)
+            printf("+%d", inst->src[i].fixed_hw_reg.subnr);
+         if (inst->src[i].fixed_hw_reg.abs)
+            printf("|");
+         break;
       default:
          printf("???");
          break;
@@ -2940,12 +2994,25 @@ fs_visitor::setup_payload_gen6()
    }
 }
 
+void
+fs_visitor::assign_binding_table_offsets()
+{
+   uint32_t next_binding_table_offset = 0;
+
+   c->prog_data.binding_table.render_target_start = next_binding_table_offset;
+   next_binding_table_offset += c->key.nr_color_regions;
+
+   assign_common_binding_table_offsets(next_binding_table_offset);
+}
+
 bool
 fs_visitor::run()
 {
    sanity_param_count = fp->Base.Parameters->NumParameters;
    uint32_t orig_nr_params = c->prog_data.nr_params;
 
+   assign_binding_table_offsets();
+
    if (brw->gen >= 6)
       setup_payload_gen6();
    else
@@ -3137,8 +3204,6 @@ brw_wm_fs_emit(struct brw_context *brw, struct brw_wm_compile *c,
       }
    }
 
-   c->prog_data.dispatch_width = 8;
-
    fs_generator g(brw, c, prog, fp, v.dual_src_output.file != BAD_FILE);
    const unsigned *generated = g.generate_assembly(&v.instructions,
                                                    simd16_instructions,
diff --git a/src/mesa/drivers/dri/i965/brw_fs.h b/src/mesa/drivers/dri/i965/brw_fs.h
index cf6379c..b5aed23 100644
--- a/src/mesa/drivers/dri/i965/brw_fs.h
+++ b/src/mesa/drivers/dri/i965/brw_fs.h
@@ -55,6 +55,10 @@ namespace {
    struct acp_entry;
 }
 
+namespace brw {
+   class fs_live_variables;
+}
+
 class fs_reg {
 public:
    DECLARE_RALLOC_CXX_OPERATORS(fs_reg)
@@ -74,11 +78,12 @@ public:
    bool is_zero() const;
    bool is_one() const;
    bool is_valid_3src() const;
+   fs_reg retype(uint32_t type);
 
-   /** Register file: ARF, GRF, MRF, IMM. */
+   /** Register file: GRF, MRF, IMM. */
    enum register_file file;
    /**
-    * Register number.  For ARF/MRF, it's the hardware register.  For
+    * Register number.  For MRF, it's the hardware register.  For
     * GRF, it's a virtual register number until register allocation
     */
    int reg;
@@ -107,8 +112,9 @@ public:
 };
 
 static const fs_reg reg_undef;
-static const fs_reg reg_null_f(ARF, BRW_ARF_NULL, BRW_REGISTER_TYPE_F);
-static const fs_reg reg_null_d(ARF, BRW_ARF_NULL, BRW_REGISTER_TYPE_D);
+static const fs_reg reg_null_f(retype(brw_null_reg(), BRW_REGISTER_TYPE_F));
+static const fs_reg reg_null_d(retype(brw_null_reg(), BRW_REGISTER_TYPE_D));
+static const fs_reg reg_null_ud(retype(brw_null_reg(), BRW_REGISTER_TYPE_UD));
 
 class ip_record : public exec_node {
 public:
@@ -140,6 +146,7 @@ public:
    bool overwrites_reg(const fs_reg &reg);
    bool is_send_from_grf();
    bool is_partial_write();
+   int regs_read(fs_visitor *v, int arg);
 
    fs_reg dst;
    fs_reg src[3];
@@ -259,6 +266,8 @@ public:
    fs_inst *FBL(fs_reg dst, fs_reg value);
    fs_inst *CBIT(fs_reg dst, fs_reg value);
    fs_inst *MAD(fs_reg dst, fs_reg c, fs_reg b, fs_reg a);
+   fs_inst *ADDC(fs_reg dst, fs_reg src0, fs_reg src1);
+   fs_inst *SUBB(fs_reg dst, fs_reg src0, fs_reg src1);
 
    int type_size(const struct glsl_type *type);
    fs_inst *get_instruction_generating_reg(fs_inst *start,
@@ -270,6 +279,7 @@ public:
                                         uint32_t const_offset);
 
    bool run();
+   void assign_binding_table_offsets();
    void setup_payload_gen4();
    void setup_payload_gen6();
    void assign_curb_setup();
@@ -287,6 +297,7 @@ public:
    void compact_virtual_grfs();
    void move_uniform_array_access_to_pull_constants();
    void setup_pull_constants();
+   void invalidate_live_intervals();
    void calculate_live_intervals();
    bool opt_algebraic();
    bool opt_cse();
@@ -346,7 +357,8 @@ public:
    void try_replace_with_sel();
    void emit_bool_to_cond_code(ir_rvalue *condition);
    void emit_if_gen6(ir_if *ir);
-   void emit_unspill(fs_inst *inst, fs_reg reg, uint32_t spill_offset);
+   void emit_unspill(fs_inst *inst, fs_reg reg, uint32_t spill_offset,
+                     int count);
 
    void emit_fragment_program_code();
    void setup_fp_regs();
@@ -409,7 +421,7 @@ public:
    int virtual_grf_array_size;
    int *virtual_grf_start;
    int *virtual_grf_end;
-   bool live_intervals_valid;
+   brw::fs_live_variables *live_intervals;
 
    /* This is the map from UNIFORM hw_reg + reg_offset as generated by
     * the visitor to the packed uniform number after
diff --git a/src/mesa/drivers/dri/i965/brw_fs_channel_expressions.cpp b/src/mesa/drivers/dri/i965/brw_fs_channel_expressions.cpp
index fb932d8..5024bed 100644
--- a/src/mesa/drivers/dri/i965/brw_fs_channel_expressions.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs_channel_expressions.cpp
@@ -233,7 +233,10 @@ ir_channel_expressions_visitor::visit_leave(ir_assignment *ir)
    case ir_binop_add:
    case ir_binop_sub:
    case ir_binop_mul:
+   case ir_binop_imul_high:
    case ir_binop_div:
+   case ir_binop_carry:
+   case ir_binop_borrow:
    case ir_binop_mod:
    case ir_binop_min:
    case ir_binop_max:
diff --git a/src/mesa/drivers/dri/i965/brw_fs_copy_propagation.cpp b/src/mesa/drivers/dri/i965/brw_fs_copy_propagation.cpp
index 034ebef..7b90982 100644
--- a/src/mesa/drivers/dri/i965/brw_fs_copy_propagation.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs_copy_propagation.cpp
@@ -279,6 +279,9 @@ fs_visitor::try_copy_propagate(fs_inst *inst, int arg, acp_entry *entry)
    if (entry->src.file == IMM)
       return false;
 
+   if (inst->regs_read(this, arg) > 1)
+      return false;
+
    if (inst->src[arg].file != entry->dst.file ||
        inst->src[arg].reg != entry->dst.reg ||
        inst->src[arg].reg_offset != entry->dst.reg_offset) {
@@ -343,6 +346,8 @@ fs_visitor::try_constant_propagate(fs_inst *inst, acp_entry *entry)
 
       case BRW_OPCODE_SHL:
       case BRW_OPCODE_SHR:
+      case BRW_OPCODE_ADDC:
+      case BRW_OPCODE_SUBB:
          if (i == 1) {
             inst->src[i] = entry->src;
             progress = true;
@@ -560,7 +565,7 @@ fs_visitor::opt_copy_propagate()
    ralloc_free(mem_ctx);
 
    if (progress)
-      live_intervals_valid = false;
+      invalidate_live_intervals();
 
    return progress;
 }
diff --git a/src/mesa/drivers/dri/i965/brw_fs_cse.cpp b/src/mesa/drivers/dri/i965/brw_fs_cse.cpp
index ccd4e5e..d8ed4be 100644
--- a/src/mesa/drivers/dri/i965/brw_fs_cse.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs_cse.cpp
@@ -98,7 +98,8 @@ fs_visitor::opt_cse_local(bblock_t *block, exec_list *aeb)
       if (is_expression(inst) &&
           !inst->predicate &&
           !inst->is_partial_write() &&
-          !inst->conditional_mod)
+          !inst->conditional_mod &&
+          inst->dst.file != HW_REG)
       {
 	 bool found = false;
 
@@ -208,7 +209,7 @@ fs_visitor::opt_cse_local(bblock_t *block, exec_list *aeb)
    ralloc_free(mem_ctx);
 
    if (progress)
-      this->live_intervals_valid = false;
+      invalidate_live_intervals();
 
    return progress;
 }
diff --git a/src/mesa/drivers/dri/i965/brw_fs_fp.cpp b/src/mesa/drivers/dri/i965/brw_fs_fp.cpp
index 0594948..1ebaa4f 100644
--- a/src/mesa/drivers/dri/i965/brw_fs_fp.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs_fp.cpp
@@ -137,8 +137,8 @@ fs_visitor::emit_fragment_program_code()
    fs_reg one = fs_reg(this, glsl_type::float_type);
    emit(MOV(one, fs_reg(1.0f)));
 
-   for (unsigned int insn = 0; insn < fp->Base.NumInstructions; insn++) {
-      const struct prog_instruction *fpi = &fp->Base.Instructions[insn];
+   for (unsigned int insn = 0; insn < prog->NumInstructions; insn++) {
+      const struct prog_instruction *fpi = &prog->Instructions[insn];
       base_ir = fpi;
 
       //_mesa_print_instruction(fpi);
@@ -583,7 +583,7 @@ void
 fs_visitor::setup_fp_regs()
 {
    /* PROGRAM_TEMPORARY */
-   int num_temp = fp->Base.NumTemporaries;
+   int num_temp = prog->NumTemporaries;
    fp_temp_regs = rzalloc_array(mem_ctx, fs_reg, num_temp);
    for (int i = 0; i < num_temp; i++)
       fp_temp_regs[i] = fs_reg(this, glsl_type::vec4_type);
@@ -591,17 +591,17 @@ fs_visitor::setup_fp_regs()
    /* PROGRAM_STATE_VAR etc. */
    if (dispatch_width == 8) {
       for (unsigned p = 0;
-           p < fp->Base.Parameters->NumParameters; p++) {
+           p < prog->Parameters->NumParameters; p++) {
          for (unsigned int i = 0; i < 4; i++) {
             c->prog_data.param[c->prog_data.nr_params++] =
-               &fp->Base.Parameters->ParameterValues[p][i].f;
+               &prog->Parameters->ParameterValues[p][i].f;
          }
       }
    }
 
    fp_input_regs = rzalloc_array(mem_ctx, fs_reg, VARYING_SLOT_MAX);
    for (int i = 0; i < VARYING_SLOT_MAX; i++) {
-      if (fp->Base.InputsRead & BITFIELD64_BIT(i)) {
+      if (prog->InputsRead & BITFIELD64_BIT(i)) {
          /* Make up a dummy instruction to reuse code for emitting
           * interpolation.
           */
@@ -687,7 +687,7 @@ fs_visitor::get_fp_dst_reg(const prog_dst_register *dst)
 fs_reg
 fs_visitor::get_fp_src_reg(const prog_src_register *src)
 {
-   struct gl_program_parameter_list *plist = fp->Base.Parameters;
+   struct gl_program_parameter_list *plist = prog->Parameters;
 
    fs_reg result;
 
diff --git a/src/mesa/drivers/dri/i965/brw_fs_generator.cpp b/src/mesa/drivers/dri/i965/brw_fs_generator.cpp
index 5b1ecc8..fa15f7b 100644
--- a/src/mesa/drivers/dri/i965/brw_fs_generator.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs_generator.cpp
@@ -61,10 +61,10 @@ fs_generator::~fs_generator()
 void
 fs_generator::mark_surface_used(unsigned surf_index)
 {
-   assert(surf_index < BRW_MAX_WM_SURFACES);
+   assert(surf_index < BRW_MAX_SURFACES);
 
-   c->prog_data.binding_table_size =
-      MAX2(c->prog_data.binding_table_size, surf_index + 1);
+   c->prog_data.base.binding_table.size_bytes =
+      MAX2(c->prog_data.base.binding_table.size_bytes, (surf_index + 1) * 4);
 }
 
 void
@@ -174,18 +174,20 @@ fs_generator::generate_fb_write(fs_inst *inst)
 
    brw_pop_insn_state(p);
 
+   uint32_t surf_index =
+      c->prog_data.binding_table.render_target_start + inst->target;
    brw_fb_WRITE(p,
 		dispatch_width,
 		inst->base_mrf,
 		implied_header,
 		msg_control,
-		SURF_INDEX_DRAW(inst->target),
+		surf_index,
 		inst->mlen,
 		0,
 		eot,
 		inst->header_present);
 
-   mark_surface_used(SURF_INDEX_DRAW(inst->target));
+   mark_surface_used(surf_index);
 }
 
 /* Computes the integer pixel x,y values from the origin.
@@ -381,7 +383,8 @@ fs_generator::generate_tex(fs_inst *inst, struct brw_reg dst, struct brw_reg src
       break;
    }
 
-   if (dispatch_width == 16)
+   if (dispatch_width == 16 &&
+      !inst->force_uncompressed && !inst->force_sechalf)
       simd_mode = BRW_SAMPLER_SIMD_MODE_SIMD16;
 
    if (brw->gen >= 5) {
@@ -500,31 +503,50 @@ fs_generator::generate_tex(fs_inst *inst, struct brw_reg dst, struct brw_reg src
       dst = vec16(dst);
    }
 
+   if (brw->gen >= 7 && inst->header_present && dispatch_width == 16) {
+      /* The send-from-GRF for 16-wide texturing with a header has an extra
+       * hardware register allocated to it, which we need to skip over (since
+       * our coordinates in the payload are in the even-numbered registers,
+       * and the header comes right before the first one).
+       */
+      assert(src.file == BRW_GENERAL_REGISTER_FILE);
+      src.nr++;
+   }
+
    /* Load the message header if present.  If there's a texture offset,
     * we need to set it up explicitly and load the offset bitfield.
     * Otherwise, we can use an implied move from g0 to the first message reg.
     */
    if (inst->texture_offset) {
+      struct brw_reg header_reg;
+
+      if (brw->gen >= 7) {
+         header_reg = src;
+      } else {
+         assert(inst->base_mrf != -1);
+         header_reg = retype(brw_message_reg(inst->base_mrf),
+                             BRW_REGISTER_TYPE_UD);
+      }
       brw_push_insn_state(p);
       brw_set_mask_control(p, BRW_MASK_DISABLE);
       brw_set_compression_control(p, BRW_COMPRESSION_NONE);
       /* Explicitly set up the message header by copying g0 to the MRF. */
-      brw_MOV(p, retype(brw_message_reg(inst->base_mrf), BRW_REGISTER_TYPE_UD),
-                 retype(brw_vec8_grf(0, 0), BRW_REGISTER_TYPE_UD));
+      brw_MOV(p, header_reg, retype(brw_vec8_grf(0, 0), BRW_REGISTER_TYPE_UD));
 
       /* Then set the offset bits in DWord 2. */
-      brw_MOV(p, retype(brw_vec1_reg(BRW_MESSAGE_REGISTER_FILE,
-                                     inst->base_mrf, 2), BRW_REGISTER_TYPE_UD),
+      brw_MOV(p, retype(brw_vec1_reg(header_reg.file,
+                                     header_reg.nr, 2), BRW_REGISTER_TYPE_UD),
                  brw_imm_ud(inst->texture_offset));
       brw_pop_insn_state(p);
    } else if (inst->header_present) {
+      assert(brw->gen < 7);
       /* Set up an implied move from g0 to the MRF. */
       src = retype(brw_vec8_grf(0, 0), BRW_REGISTER_TYPE_UW);
    }
 
-   uint32_t surface_index = inst->opcode == SHADER_OPCODE_TG4
-      ? SURF_INDEX_GATHER_TEXTURE(inst->sampler)
-      : SURF_INDEX_TEXTURE(inst->sampler);
+   uint32_t surface_index = (inst->opcode == SHADER_OPCODE_TG4
+      ? c->prog_data.base.binding_table.gather_texture_start
+      : c->prog_data.base.binding_table.texture_start) + inst->sampler;
 
    brw_SAMPLE(p,
 	      retype(dst, BRW_REGISTER_TYPE_UW),
@@ -568,10 +590,8 @@ fs_generator::generate_tex(fs_inst *inst, struct brw_reg dst, struct brw_reg src
  * sample_d.  On at least Haswell, sample_d instruction does some
  * optimizations if the same LOD is used for all pixels in the subspan.
  *
- * For DDY, it's harder, as we want to produce the pairs swizzled between each
- * other.  We could probably do it like ddx and swizzle the right order later,
- * but bail for now and just produce
- * ((ss0.tl - ss0.bl)x4 (ss1.tl - ss1.bl)x4)
+ * For DDY, we need to use ALIGN16 mode since it's capable of doing the
+ * appropriate swizzling.
  */
 void
 fs_generator::generate_ddx(fs_inst *inst, struct brw_reg dst, struct brw_reg src)
@@ -612,22 +632,65 @@ void
 fs_generator::generate_ddy(fs_inst *inst, struct brw_reg dst, struct brw_reg src,
                          bool negate_value)
 {
-   struct brw_reg src0 = brw_reg(src.file, src.nr, 0,
-				 BRW_REGISTER_TYPE_F,
-				 BRW_VERTICAL_STRIDE_4,
-				 BRW_WIDTH_4,
-				 BRW_HORIZONTAL_STRIDE_0,
-				 BRW_SWIZZLE_XYZW, WRITEMASK_XYZW);
-   struct brw_reg src1 = brw_reg(src.file, src.nr, 2,
-				 BRW_REGISTER_TYPE_F,
-				 BRW_VERTICAL_STRIDE_4,
-				 BRW_WIDTH_4,
-				 BRW_HORIZONTAL_STRIDE_0,
-				 BRW_SWIZZLE_XYZW, WRITEMASK_XYZW);
-   if (negate_value)
-      brw_ADD(p, dst, src1, negate(src0));
-   else
-      brw_ADD(p, dst, src0, negate(src1));
+   if (c->key.high_quality_derivatives) {
+      /* produce accurate derivatives */
+      struct brw_reg src0 = brw_reg(src.file, src.nr, 0,
+                                    BRW_REGISTER_TYPE_F,
+                                    BRW_VERTICAL_STRIDE_4,
+                                    BRW_WIDTH_4,
+                                    BRW_HORIZONTAL_STRIDE_1,
+                                    BRW_SWIZZLE_XYXY, WRITEMASK_XYZW);
+      struct brw_reg src1 = brw_reg(src.file, src.nr, 0,
+                                    BRW_REGISTER_TYPE_F,
+                                    BRW_VERTICAL_STRIDE_4,
+                                    BRW_WIDTH_4,
+                                    BRW_HORIZONTAL_STRIDE_1,
+                                    BRW_SWIZZLE_ZWZW, WRITEMASK_XYZW);
+      brw_push_insn_state(p);
+      brw_set_access_mode(p, BRW_ALIGN_16);
+      brw_set_compression_control(p, BRW_COMPRESSION_NONE);
+      if (negate_value)
+         brw_ADD(p, dst, src1, negate(src0));
+      else
+         brw_ADD(p, dst, src0, negate(src1));
+      if (dispatch_width == 16) {
+         /* From page 340 of the i965 PRM:
+          *
+          *     "A compressed instruction must be in Align1 access
+          *     mode. Align16 mode instructions cannot be compressed."
+          *
+          * Therefore, when doing a 16-wide dispatch, we need to manually
+          * unroll to two instructions.
+          */
+         brw_set_compression_control(p, BRW_COMPRESSION_2NDHALF);
+         src0 = sechalf(src0);
+         src1 = sechalf(src1);
+         dst = sechalf(dst);
+         if (negate_value)
+            brw_ADD(p, dst, src1, negate(src0));
+         else
+            brw_ADD(p, dst, src0, negate(src1));
+      }
+      brw_pop_insn_state(p);
+   } else {
+      /* replicate the derivative at the top-left pixel to other pixels */
+      struct brw_reg src0 = brw_reg(src.file, src.nr, 0,
+                                    BRW_REGISTER_TYPE_F,
+                                    BRW_VERTICAL_STRIDE_4,
+                                    BRW_WIDTH_4,
+                                    BRW_HORIZONTAL_STRIDE_0,
+                                    BRW_SWIZZLE_XYZW, WRITEMASK_XYZW);
+      struct brw_reg src1 = brw_reg(src.file, src.nr, 2,
+                                    BRW_REGISTER_TYPE_F,
+                                    BRW_VERTICAL_STRIDE_4,
+                                    BRW_WIDTH_4,
+                                    BRW_HORIZONTAL_STRIDE_0,
+                                    BRW_SWIZZLE_XYZW, WRITEMASK_XYZW);
+      if (negate_value)
+         brw_ADD(p, dst, src1, negate(src0));
+      else
+         brw_ADD(p, dst, src0, negate(src1));
+   }
 }
 
 void
@@ -870,8 +933,6 @@ fs_generator::generate_mov_dispatch_to_flags(fs_inst *inst)
 static uint32_t brw_file_from_reg(fs_reg *reg)
 {
    switch (reg->file) {
-   case ARF:
-      return BRW_ARCHITECTURE_REGISTER_FILE;
    case GRF:
       return BRW_GENERAL_REGISTER_FILE;
    case MRF:
@@ -891,7 +952,6 @@ brw_reg_from_fs_reg(fs_reg *reg)
 
    switch (reg->file) {
    case GRF:
-   case ARF:
    case MRF:
       if (reg->smear == -1) {
 	 brw_reg = brw_vec8_reg(brw_file_from_reg(reg), reg->reg, 0);
@@ -1084,10 +1144,11 @@ fs_generator::generate_shader_time_add(fs_inst *inst,
     */
    brw_MOV(p, payload_offset, offset);
    brw_MOV(p, payload_value, value);
-   brw_shader_time_add(p, payload, SURF_INDEX_WM_SHADER_TIME);
+   brw_shader_time_add(p, payload,
+                       c->prog_data.base.binding_table.shader_time_start);
    brw_pop_insn_state(p);
 
-   mark_surface_used(SURF_INDEX_WM_SHADER_TIME);
+   mark_surface_used(c->prog_data.base.binding_table.shader_time_start);
 }
 
 void
@@ -1203,6 +1264,7 @@ fs_generator::generate_code(exec_list *instructions)
 	 break;
 
       case BRW_OPCODE_MAD:
+         assert(brw->gen >= 6);
 	 brw_set_access_mode(p, BRW_ALIGN_16);
 	 if (dispatch_width == 16) {
 	    brw_set_compression_control(p, BRW_COMPRESSION_NONE);
@@ -1217,6 +1279,7 @@ fs_generator::generate_code(exec_list *instructions)
 	 break;
 
       case BRW_OPCODE_LRP:
+         assert(brw->gen >= 6);
 	 brw_set_access_mode(p, BRW_ALIGN_16);
 	 if (dispatch_width == 16) {
 	    brw_set_compression_control(p, BRW_COMPRESSION_NONE);
@@ -1265,9 +1328,11 @@ fs_generator::generate_code(exec_list *instructions)
 	 brw_SHL(p, dst, src[0], src[1]);
 	 break;
       case BRW_OPCODE_F32TO16:
+         assert(brw->gen >= 7);
          brw_F32TO16(p, dst, src[0]);
          break;
       case BRW_OPCODE_F16TO32:
+         assert(brw->gen >= 7);
          brw_F16TO32(p, dst, src[0]);
          break;
       case BRW_OPCODE_CMP:
@@ -1277,24 +1342,41 @@ fs_generator::generate_code(exec_list *instructions)
 	 brw_SEL(p, dst, src[0], src[1]);
 	 break;
       case BRW_OPCODE_BFREV:
+         assert(brw->gen >= 7);
          /* BFREV only supports UD type for src and dst. */
          brw_BFREV(p, retype(dst, BRW_REGISTER_TYPE_UD),
                       retype(src[0], BRW_REGISTER_TYPE_UD));
          break;
       case BRW_OPCODE_FBH:
+         assert(brw->gen >= 7);
          /* FBH only supports UD type for dst. */
          brw_FBH(p, retype(dst, BRW_REGISTER_TYPE_UD), src[0]);
          break;
       case BRW_OPCODE_FBL:
+         assert(brw->gen >= 7);
          /* FBL only supports UD type for dst. */
          brw_FBL(p, retype(dst, BRW_REGISTER_TYPE_UD), src[0]);
          break;
       case BRW_OPCODE_CBIT:
+         assert(brw->gen >= 7);
          /* CBIT only supports UD type for dst. */
          brw_CBIT(p, retype(dst, BRW_REGISTER_TYPE_UD), src[0]);
          break;
+      case BRW_OPCODE_ADDC:
+         assert(brw->gen >= 7);
+         brw_set_acc_write_control(p, 1);
+         brw_ADDC(p, dst, src[0], src[1]);
+         brw_set_acc_write_control(p, 0);
+         break;
+      case BRW_OPCODE_SUBB:
+         assert(brw->gen >= 7);
+         brw_set_acc_write_control(p, 1);
+         brw_SUBB(p, dst, src[0], src[1]);
+         brw_set_acc_write_control(p, 0);
+         break;
 
       case BRW_OPCODE_BFE:
+         assert(brw->gen >= 7);
          brw_set_access_mode(p, BRW_ALIGN_16);
          if (dispatch_width == 16) {
             brw_set_compression_control(p, BRW_COMPRESSION_NONE);
@@ -1309,9 +1391,11 @@ fs_generator::generate_code(exec_list *instructions)
          break;
 
       case BRW_OPCODE_BFI1:
+         assert(brw->gen >= 7);
          brw_BFI1(p, dst, src[0], src[1]);
          break;
       case BRW_OPCODE_BFI2:
+         assert(brw->gen >= 7);
          brw_set_access_mode(p, BRW_ALIGN_16);
          if (dispatch_width == 16) {
             brw_set_compression_control(p, BRW_COMPRESSION_NONE);
diff --git a/src/mesa/drivers/dri/i965/brw_fs_live_variables.cpp b/src/mesa/drivers/dri/i965/brw_fs_live_variables.cpp
index f5daab2..b3026c2 100644
--- a/src/mesa/drivers/dri/i965/brw_fs_live_variables.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs_live_variables.cpp
@@ -30,21 +30,103 @@
 
 using namespace brw;
 
+#define MAX_INSTRUCTION (1 << 30)
+
 /** @file brw_fs_live_variables.cpp
  *
- * Support for computing at the basic block level which variables
- * (virtual GRFs in our case) are live at entry and exit.
+ * Support for calculating liveness information about virtual GRFs.
+ *
+ * This produces a live interval for each whole virtual GRF.  We could
+ * choose to expose per-component live intervals for VGRFs of size > 1,
+ * but we currently do not.  It is easier for the consumers of this
+ * information to work with whole VGRFs.
+ *
+ * However, we internally track use/def information at the per-component
+ * (reg_offset) level for greater accuracy.  Large VGRFs may be accessed
+ * piecemeal over many (possibly non-adjacent) instructions.  In this case,
+ * examining a single instruction is insufficient to decide whether a whole
+ * VGRF is ultimately used or defined.  Tracking individual components
+ * allows us to easily assemble this information.
  *
  * See Muchnik's Advanced Compiler Design and Implementation, section
  * 14.1 (p444).
  */
 
+void
+fs_live_variables::setup_one_read(bblock_t *block, fs_inst *inst,
+                                  int ip, fs_reg reg)
+{
+   int var = var_from_vgrf[reg.reg] + reg.reg_offset;
+
+   /* In most cases, a register can be written over safely by the
+    * same instruction that is its last use.  For a single
+    * instruction, the sources are dereferenced before writing of the
+    * destination starts (naturally).  This gets more complicated for
+    * simd16, because the instruction:
+    *
+    * mov(16)      g4<1>F      g4<8,8,1>F   g6<8,8,1>F
+    *
+    * is actually decoded in hardware as:
+    *
+    * mov(8)       g4<1>F      g4<8,8,1>F   g6<8,8,1>F
+    * mov(8)       g5<1>F      g5<8,8,1>F   g7<8,8,1>F
+    *
+    * Which is safe.  However, if we have uniform accesses
+    * happening, we get into trouble:
+    *
+    * mov(8)       g4<1>F      g4<0,1,0>F   g6<8,8,1>F
+    * mov(8)       g5<1>F      g4<0,1,0>F   g7<8,8,1>F
+    *
+    * Now our destination for the first instruction overwrote the
+    * second instruction's src0, and we get garbage for those 8
+    * pixels.  There's a similar issue for the pre-gen6
+    * pixel_x/pixel_y, which are registers of 16-bit values and thus
+    * would get stomped by the first decode as well.
+    */
+   int end_ip = ip;
+   if (v->dispatch_width == 16 && (reg.smear != -1 ||
+                                   (v->pixel_x.reg == reg.reg ||
+                                    v->pixel_y.reg == reg.reg))) {
+      end_ip++;
+   }
+
+   start[var] = MIN2(start[var], ip);
+   end[var] = MAX2(end[var], end_ip);
+
+   /* The use[] bitset marks when the block makes use of a variable (VGRF
+    * channel) without having completely defined that variable within the
+    * block.
+    */
+   if (!BITSET_TEST(bd[block->block_num].def, var))
+      BITSET_SET(bd[block->block_num].use, var);
+}
+
+void
+fs_live_variables::setup_one_write(bblock_t *block, fs_inst *inst,
+                                   int ip, fs_reg reg)
+{
+   int var = var_from_vgrf[reg.reg] + reg.reg_offset;
+
+   start[var] = MIN2(start[var], ip);
+   end[var] = MAX2(end[var], ip);
+
+   /* The def[] bitset marks when an initialization in a block completely
+    * screens off previous updates of that variable (VGRF channel).
+    */
+   if (inst->dst.file == GRF && !inst->is_partial_write()) {
+      if (!BITSET_TEST(bd[block->block_num].use, var))
+         BITSET_SET(bd[block->block_num].def, var);
+   }
+}
+
 /**
  * Sets up the use[] and def[] bitsets.
  *
  * The basic-block-level live variable analysis needs to know which
  * variables get used before they're completely defined, and which
  * variables are completely defined before they're used.
+ *
+ * These are tracked at the per-component level, rather than whole VGRFs.
  */
 void
 fs_live_variables::setup_def_use()
@@ -64,24 +146,24 @@ fs_live_variables::setup_def_use()
 
 	 /* Set use[] for this instruction */
 	 for (unsigned int i = 0; i < 3; i++) {
-	    if (inst->src[i].file == GRF) {
-	       int reg = inst->src[i].reg;
+            fs_reg reg = inst->src[i];
 
-	       if (!BITSET_TEST(bd[b].def, reg))
-		  BITSET_SET(bd[b].use, reg);
-	    }
+            if (reg.file != GRF)
+               continue;
+
+            for (int j = 0; j < inst->regs_read(v, i); j++) {
+               setup_one_read(block, inst, ip, reg);
+               reg.reg_offset++;
+            }
 	 }
 
-	 /* Check for unconditional writes to whole registers. These
-	  * are the things that screen off preceding definitions of a
-	  * variable, and thus qualify for being in def[].
-	  */
-	 if (inst->dst.file == GRF &&
-	     inst->regs_written == v->virtual_grf_sizes[inst->dst.reg] &&
-	     !inst->is_partial_write()) {
-	    int reg = inst->dst.reg;
-            if (!BITSET_TEST(bd[b].use, reg))
-               BITSET_SET(bd[b].def, reg);
+         /* Set def[] for this instruction */
+         if (inst->dst.file == GRF) {
+            fs_reg reg = inst->dst;
+            for (int j = 0; j < inst->regs_written; j++) {
+               setup_one_write(block, inst, ip, reg);
+               reg.reg_offset++;
+            }
 	 }
 
 	 ip++;
@@ -132,15 +214,65 @@ fs_live_variables::compute_live_variables()
    }
 }
 
+/**
+ * Extend the start/end ranges for each variable to account for the
+ * new information calculated from control flow.
+ */
+void
+fs_live_variables::compute_start_end()
+{
+   for (int b = 0; b < cfg->num_blocks; b++) {
+      for (int i = 0; i < num_vars; i++) {
+	 if (BITSET_TEST(bd[b].livein, i)) {
+	    start[i] = MIN2(start[i], cfg->blocks[b]->start_ip);
+	    end[i] = MAX2(end[i], cfg->blocks[b]->start_ip);
+	 }
+
+	 if (BITSET_TEST(bd[b].liveout, i)) {
+	    start[i] = MIN2(start[i], cfg->blocks[b]->end_ip);
+	    end[i] = MAX2(end[i], cfg->blocks[b]->end_ip);
+	 }
+
+      }
+   }
+}
+
+int
+fs_live_variables::var_from_reg(fs_reg *reg)
+{
+   return var_from_vgrf[reg->reg] + reg->reg_offset;
+}
+
 fs_live_variables::fs_live_variables(fs_visitor *v, cfg_t *cfg)
    : v(v), cfg(cfg)
 {
-   mem_ctx = ralloc_context(cfg->mem_ctx);
+   mem_ctx = this;
+
+   num_vgrfs = v->virtual_grf_count;
+   num_vars = 0;
+   var_from_vgrf = rzalloc_array(mem_ctx, int, num_vgrfs);
+   for (int i = 0; i < num_vgrfs; i++) {
+      var_from_vgrf[i] = num_vars;
+      num_vars += v->virtual_grf_sizes[i];
+   }
+
+   vgrf_from_var = rzalloc_array(mem_ctx, int, num_vars);
+   for (int i = 0; i < num_vgrfs; i++) {
+      for (int j = 0; j < v->virtual_grf_sizes[i]; j++) {
+         vgrf_from_var[var_from_vgrf[i] + j] = i;
+      }
+   }
+
+   start = ralloc_array(mem_ctx, int, num_vars);
+   end = rzalloc_array(mem_ctx, int, num_vars);
+   for (int i = 0; i < num_vars; i++) {
+      start[i] = MAX_INSTRUCTION;
+      end[i] = -1;
+   }
 
-   num_vars = v->virtual_grf_count;
    bd = rzalloc_array(mem_ctx, struct block_data, cfg->num_blocks);
 
-   bitset_words = BITSET_WORDS(v->virtual_grf_count);
+   bitset_words = BITSET_WORDS(num_vars);
    for (int i = 0; i < cfg->num_blocks; i++) {
       bd[i].def = rzalloc_array(mem_ctx, BITSET_WORD, bitset_words);
       bd[i].use = rzalloc_array(mem_ctx, BITSET_WORD, bitset_words);
@@ -150,6 +282,7 @@ fs_live_variables::fs_live_variables(fs_visitor *v, cfg_t *cfg)
 
    setup_def_use();
    compute_live_variables();
+   compute_start_end();
 }
 
 fs_live_variables::~fs_live_variables()
@@ -157,105 +290,54 @@ fs_live_variables::~fs_live_variables()
    ralloc_free(mem_ctx);
 }
 
-#define MAX_INSTRUCTION (1 << 30)
+void
+fs_visitor::invalidate_live_intervals()
+{
+   ralloc_free(live_intervals);
+   live_intervals = NULL;
+}
 
+/**
+ * Compute the live intervals for each virtual GRF.
+ *
+ * This uses the per-component use/def data, but combines it to produce
+ * information about whole VGRFs.
+ */
 void
 fs_visitor::calculate_live_intervals()
 {
-   int num_vars = this->virtual_grf_count;
-
-   if (this->live_intervals_valid)
+   if (this->live_intervals)
       return;
 
-   int *start = ralloc_array(mem_ctx, int, num_vars);
-   int *end = ralloc_array(mem_ctx, int, num_vars);
+   int num_vgrfs = this->virtual_grf_count;
    ralloc_free(this->virtual_grf_start);
    ralloc_free(this->virtual_grf_end);
-   this->virtual_grf_start = start;
-   this->virtual_grf_end = end;
-
-   for (int i = 0; i < num_vars; i++) {
-      start[i] = MAX_INSTRUCTION;
-      end[i] = -1;
-   }
-
-   /* Start by setting up the intervals with no knowledge of control
-    * flow.
-    */
-   int ip = 0;
-   foreach_list(node, &this->instructions) {
-      fs_inst *inst = (fs_inst *)node;
-
-      for (unsigned int i = 0; i < 3; i++) {
-	 if (inst->src[i].file == GRF) {
-	    int reg = inst->src[i].reg;
-            int end_ip = ip;
-
-            /* In most cases, a register can be written over safely by the
-             * same instruction that is its last use.  For a single
-             * instruction, the sources are dereferenced before writing of the
-             * destination starts (naturally).  This gets more complicated for
-             * simd16, because the instruction:
-             *
-             * mov(16)      g4<1>F      g4<8,8,1>F   g6<8,8,1>F
-             *
-             * is actually decoded in hardware as:
-             *
-             * mov(8)       g4<1>F      g4<8,8,1>F   g6<8,8,1>F
-             * mov(8)       g5<1>F      g5<8,8,1>F   g7<8,8,1>F
-             *
-             * Which is safe.  However, if we have uniform accesses
-             * happening, we get into trouble:
-             *
-             * mov(8)       g4<1>F      g4<0,1,0>F   g6<8,8,1>F
-             * mov(8)       g5<1>F      g4<0,1,0>F   g7<8,8,1>F
-             *
-             * Now our destination for the first instruction overwrote the
-             * second instruction's src0, and we get garbage for those 8
-             * pixels.  There's a similar issue for the pre-gen6
-             * pixel_x/pixel_y, which are registers of 16-bit values and thus
-             * would get stomped by the first decode as well.
-             */
-            if (dispatch_width == 16 && (inst->src[i].smear >= 0 ||
-                                         (this->pixel_x.reg == reg ||
-                                          this->pixel_y.reg == reg))) {
-               end_ip++;
-            }
+   virtual_grf_start = ralloc_array(mem_ctx, int, num_vgrfs);
+   virtual_grf_end = ralloc_array(mem_ctx, int, num_vgrfs);
 
-            start[reg] = MIN2(start[reg], ip);
-            end[reg] = MAX2(end[reg], end_ip);
-	 }
-      }
-
-      if (inst->dst.file == GRF) {
-         int reg = inst->dst.reg;
-
-         start[reg] = MIN2(start[reg], ip);
-         end[reg] = MAX2(end[reg], ip);
-      }
-
-      ip++;
+   for (int i = 0; i < num_vgrfs; i++) {
+      virtual_grf_start[i] = MAX_INSTRUCTION;
+      virtual_grf_end[i] = -1;
    }
 
-   /* Now, extend those intervals using our analysis of control flow. */
    cfg_t cfg(this);
-   fs_live_variables livevars(this, &cfg);
-
-   for (int b = 0; b < cfg.num_blocks; b++) {
-      for (int i = 0; i < num_vars; i++) {
-	 if (BITSET_TEST(livevars.bd[b].livein, i)) {
-	    start[i] = MIN2(start[i], cfg.blocks[b]->start_ip);
-	    end[i] = MAX2(end[i], cfg.blocks[b]->start_ip);
-	 }
-
-	 if (BITSET_TEST(livevars.bd[b].liveout, i)) {
-	    start[i] = MIN2(start[i], cfg.blocks[b]->end_ip);
-	    end[i] = MAX2(end[i], cfg.blocks[b]->end_ip);
-	 }
-      }
+   this->live_intervals = new(mem_ctx) fs_live_variables(this, &cfg);
+
+   /* Merge the per-component live ranges to whole VGRF live ranges. */
+   for (int i = 0; i < live_intervals->num_vars; i++) {
+      int vgrf = live_intervals->vgrf_from_var[i];
+      virtual_grf_start[vgrf] = MIN2(virtual_grf_start[vgrf],
+                                     live_intervals->start[i]);
+      virtual_grf_end[vgrf] = MAX2(virtual_grf_end[vgrf],
+                                   live_intervals->end[i]);
    }
+}
 
-   this->live_intervals_valid = true;
+bool
+fs_live_variables::vars_interfere(int a, int b)
+{
+   return !(end[b] <= start[a] ||
+            end[a] <= start[b]);
 }
 
 bool
diff --git a/src/mesa/drivers/dri/i965/brw_fs_live_variables.h b/src/mesa/drivers/dri/i965/brw_fs_live_variables.h
index e227439..82575d8 100644
--- a/src/mesa/drivers/dri/i965/brw_fs_live_variables.h
+++ b/src/mesa/drivers/dri/i965/brw_fs_live_variables.h
@@ -28,6 +28,8 @@
 #include "brw_fs.h"
 #include "main/bitset.h"
 
+class cfg_t;
+
 namespace brw {
 
 struct block_data {
@@ -59,15 +61,41 @@ public:
    ~fs_live_variables();
 
    void setup_def_use();
+   void setup_one_read(bblock_t *block, fs_inst *inst, int ip, fs_reg reg);
+   void setup_one_write(bblock_t *block, fs_inst *inst, int ip, fs_reg reg);
    void compute_live_variables();
+   void compute_start_end();
+
+   bool vars_interfere(int a, int b);
+   int var_from_reg(fs_reg *reg);
 
    fs_visitor *v;
    cfg_t *cfg;
    void *mem_ctx;
 
+   /** Map from virtual GRF number to index in block_data arrays. */
+   int *var_from_vgrf;
+
+   /**
+    * Map from any index in block_data to the virtual GRF containing it.
+    *
+    * For virtual_grf_sizes of [1, 2, 3], vgrf_from_var would contain
+    * [0, 1, 1, 2, 2, 2].
+    */
+   int *vgrf_from_var;
+
    int num_vars;
+   int num_vgrfs;
    int bitset_words;
 
+   /** @{
+    * Final computed live ranges for each var (each component of each virtual
+    * GRF).
+    */
+   int *start;
+   int *end;
+   /** @} */
+
    /** Per-basic-block information on live variables */
    struct block_data *bd;
 };
diff --git a/src/mesa/drivers/dri/i965/brw_fs_reg_allocate.cpp b/src/mesa/drivers/dri/i965/brw_fs_reg_allocate.cpp
index b9102d9..157c9ae 100644
--- a/src/mesa/drivers/dri/i965/brw_fs_reg_allocate.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs_reg_allocate.cpp
@@ -83,9 +83,9 @@ brw_alloc_reg_set(struct brw_context *brw, int reg_width)
     * aggregates of scalar values at the GLSL level were split to scalar
     * values by split_virtual_grfs().
     *
-    * However, texture SEND messages return a series of contiguous registers.
-    * We currently always ask for 4 registers, but we may convert that to use
-    * less some day.
+    * However, texture SEND messages return a series of contiguous registers
+    * to write into.  We currently always ask for 4 registers, but we may
+    * convert that to use less some day.
     *
     * Additionally, on gen5 we need aligned pairs of registers for the PLN
     * instruction, and on gen4 we need 8 contiguous regs for workaround simd16
@@ -94,9 +94,22 @@ brw_alloc_reg_set(struct brw_context *brw, int reg_width)
     * So we have a need for classes for 1, 2, 4, and 8 registers currently,
     * and we add in '3' to make indexing the array easier for the common case
     * (since we'll probably want it for texturing later).
+    *
+    * And, on gen7 and newer, we do texturing SEND messages from GRFs, which
+    * means that we may need any size up to the sampler message size limit (11
+    * regs).
     */
-   const int class_count = 5;
-   const int class_sizes[class_count] = {1, 2, 3, 4, 8};
+   int class_count;
+   int class_sizes[BRW_MAX_MRF];
+
+   if (brw->gen >= 7) {
+      for (class_count = 0; class_count < 11; class_count++)
+         class_sizes[class_count] = class_count + 1;
+   } else {
+      for (class_count = 0; class_count < 4; class_count++)
+         class_sizes[class_count] = class_count + 1;
+      class_sizes[class_count++] = 8;
+   }
 
    /* Compute the total number of registers across all classes. */
    int ra_reg_count = 0;
@@ -159,7 +172,10 @@ brw_alloc_reg_set(struct brw_context *brw, int reg_width)
    ra_set_finalize(regs, NULL);
 
    brw->wm.reg_sets[index].regs = regs;
-   brw->wm.reg_sets[index].classes = classes;
+   for (unsigned i = 0; i < ARRAY_SIZE(brw->wm.reg_sets[index].classes); i++)
+      brw->wm.reg_sets[index].classes[i] = -1;
+   for (int i = 0; i < class_count; i++)
+      brw->wm.reg_sets[index].classes[class_sizes[i] - 1] = classes[i];
    brw->wm.reg_sets[index].ra_reg_to_grf = ra_reg_to_grf;
    brw->wm.reg_sets[index].aligned_pairs_class = aligned_pairs_class;
 }
@@ -411,17 +427,12 @@ fs_visitor::assign_regs()
                                                     node_count);
 
    for (int i = 0; i < this->virtual_grf_count; i++) {
-      int size = this->virtual_grf_sizes[i];
+      unsigned size = this->virtual_grf_sizes[i];
       int c;
 
-      if (size == 8) {
-         c = 4;
-      } else {
-         assert(size >= 1 &&
-                size <= 4 &&
-                "Register allocation relies on split_virtual_grfs()");
-         c = brw->wm.reg_sets[rsi].classes[size - 1];
-      }
+      assert(size <= ARRAY_SIZE(brw->wm.reg_sets[rsi].classes) &&
+             "Register allocation relies on split_virtual_grfs()");
+      c = brw->wm.reg_sets[rsi].classes[size - 1];
 
       /* Special case: on pre-GEN6 hardware that supports PLN, the
        * second operand of a PLN instruction needs to be an
@@ -501,19 +512,25 @@ fs_visitor::assign_regs()
 }
 
 void
-fs_visitor::emit_unspill(fs_inst *inst, fs_reg dst, uint32_t spill_offset)
+fs_visitor::emit_unspill(fs_inst *inst, fs_reg dst, uint32_t spill_offset,
+                         int count)
 {
-   fs_inst *unspill_inst = new(mem_ctx) fs_inst(FS_OPCODE_UNSPILL, dst);
-   unspill_inst->offset = spill_offset;
-   unspill_inst->ir = inst->ir;
-   unspill_inst->annotation = inst->annotation;
+   for (int i = 0; i < count; i++) {
+      fs_inst *unspill_inst = new(mem_ctx) fs_inst(FS_OPCODE_UNSPILL, dst);
+      unspill_inst->offset = spill_offset;
+      unspill_inst->ir = inst->ir;
+      unspill_inst->annotation = inst->annotation;
+
+      /* Choose a MRF that won't conflict with an MRF that's live across the
+       * spill.  Nothing else will make it up to MRF 14/15.
+       */
+      unspill_inst->base_mrf = 14;
+      unspill_inst->mlen = 1; /* header contains offset */
+      inst->insert_before(unspill_inst);
 
-   /* Choose a MRF that won't conflict with an MRF that's live across the
-    * spill.  Nothing else will make it up to MRF 14/15.
-    */
-   unspill_inst->base_mrf = 14;
-   unspill_inst->mlen = 1; /* header contains offset */
-   inst->insert_before(unspill_inst);
+      dst.reg_offset++;
+      spill_offset += REG_SIZE;
+   }
 }
 
 int
@@ -612,9 +629,14 @@ fs_visitor::spill_reg(int spill_reg)
       for (unsigned int i = 0; i < 3; i++) {
 	 if (inst->src[i].file == GRF &&
 	     inst->src[i].reg == spill_reg) {
-	    inst->src[i].reg = virtual_grf_alloc(1);
-	    emit_unspill(inst, inst->src[i],
-                         spill_offset + REG_SIZE * inst->src[i].reg_offset);
+            int regs_read = inst->regs_read(this, i);
+
+            inst->src[i].reg = virtual_grf_alloc(regs_read);
+            inst->src[i].reg_offset = 0;
+
+            emit_unspill(inst, inst->src[i],
+                         spill_offset + REG_SIZE * inst->src[i].reg_offset,
+                         regs_read);
 	 }
       }
 
@@ -630,12 +652,8 @@ fs_visitor::spill_reg(int spill_reg)
           * since we write back out all of the regs_written().
 	  */
 	 if (inst->predicate || inst->force_uncompressed || inst->force_sechalf) {
-            fs_reg unspill_reg = inst->dst;
-            for (int chan = 0; chan < inst->regs_written; chan++) {
-               emit_unspill(inst, unspill_reg,
-                            subset_spill_offset + REG_SIZE * chan);
-               unspill_reg.reg_offset++;
-            }
+            emit_unspill(inst, inst->dst, subset_spill_offset,
+                         inst->regs_written);
 	 }
 
 	 fs_reg spill_src = inst->dst;
@@ -658,5 +676,5 @@ fs_visitor::spill_reg(int spill_reg)
       }
    }
 
-   this->live_intervals_valid = false;
+   invalidate_live_intervals();
 }
diff --git a/src/mesa/drivers/dri/i965/brw_fs_visitor.cpp b/src/mesa/drivers/dri/i965/brw_fs_visitor.cpp
index a8ad659..9f37013 100644
--- a/src/mesa/drivers/dri/i965/brw_fs_visitor.cpp
+++ b/src/mesa/drivers/dri/i965/brw_fs_visitor.cpp
@@ -433,7 +433,7 @@ fs_visitor::visit(ir_expression *ir)
 	 if (brw->gen >= 7 && dispatch_width == 16)
 	    fail("16-wide explicit accumulator operands unsupported\n");
 
-	 struct brw_reg acc = retype(brw_acc_reg(), BRW_REGISTER_TYPE_D);
+	 struct brw_reg acc = retype(brw_acc_reg(), this->result.type);
 
 	 emit(MUL(acc, op[0], op[1]));
 	 emit(MACH(reg_null_d, op[0], op[1]));
@@ -442,11 +442,41 @@ fs_visitor::visit(ir_expression *ir)
 	 emit(MUL(this->result, op[0], op[1]));
       }
       break;
+   case ir_binop_imul_high: {
+      if (brw->gen >= 7 && dispatch_width == 16)
+         fail("16-wide explicit accumulator operands unsupported\n");
+
+      struct brw_reg acc = retype(brw_acc_reg(), this->result.type);
+
+      emit(MUL(acc, op[0], op[1]));
+      emit(MACH(this->result, op[0], op[1]));
+      break;
+   }
    case ir_binop_div:
       /* Floating point should be lowered by DIV_TO_MUL_RCP in the compiler. */
       assert(ir->type->is_integer());
       emit_math(SHADER_OPCODE_INT_QUOTIENT, this->result, op[0], op[1]);
       break;
+   case ir_binop_carry: {
+      if (brw->gen >= 7 && dispatch_width == 16)
+         fail("16-wide explicit accumulator operands unsupported\n");
+
+      struct brw_reg acc = retype(brw_acc_reg(), BRW_REGISTER_TYPE_UD);
+
+      emit(ADDC(reg_null_ud, op[0], op[1]));
+      emit(MOV(this->result, fs_reg(acc)));
+      break;
+   }
+   case ir_binop_borrow: {
+      if (brw->gen >= 7 && dispatch_width == 16)
+         fail("16-wide explicit accumulator operands unsupported\n");
+
+      struct brw_reg acc = retype(brw_acc_reg(), BRW_REGISTER_TYPE_UD);
+
+      emit(SUBB(reg_null_ud, op[0], op[1]));
+      emit(MOV(this->result, fs_reg(acc)));
+      break;
+   }
    case ir_binop_mod:
       /* Floating point should be lowered by MOD_TO_FRACT in the compiler. */
       assert(ir->type->is_integer());
@@ -674,7 +704,8 @@ fs_visitor::visit(ir_expression *ir)
        */
       ir_constant *uniform_block = ir->operands[0]->as_constant();
       ir_constant *const_offset = ir->operands[1]->as_constant();
-      fs_reg surf_index = fs_reg((unsigned)SURF_INDEX_WM_UBO(uniform_block->value.u[0]));
+      fs_reg surf_index = fs_reg(c->prog_data.base.binding_table.ubo_start +
+                                 uniform_block->value.u[0]);
       if (const_offset) {
          fs_reg packed_consts = fs_reg(this, glsl_type::float_type);
          packed_consts.type = result.type;
@@ -1149,6 +1180,11 @@ fs_visitor::emit_texture_gen5(ir_texture *ir, fs_reg dst, fs_reg coordinate,
       mlen += reg_width;
       inst = emit(SHADER_OPCODE_TXS, dst);
       break;
+   case ir_query_levels:
+      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), fs_reg(0u)));
+      mlen += reg_width;
+      inst = emit(SHADER_OPCODE_TXS, dst);
+      break;
    case ir_txf:
       mlen = header_present + 4 * reg_width;
       emit(MOV(fs_reg(MRF, base_mrf + mlen - reg_width, BRW_REGISTER_TYPE_UD), lod));
@@ -1191,27 +1227,28 @@ fs_visitor::emit_texture_gen7(ir_texture *ir, fs_reg dst, fs_reg coordinate,
                               fs_reg shadow_c, fs_reg lod, fs_reg lod2,
                               fs_reg sample_index)
 {
-   int mlen = 0;
-   int base_mrf = 2;
    int reg_width = dispatch_width / 8;
    bool header_present = false;
    int offsets[3];
 
+   fs_reg payload = fs_reg(this, glsl_type::float_type);
+   fs_reg next = payload;
+
    if (ir->op == ir_tg4 || (ir->offset && ir->op != ir_txf)) {
-      /* * The offsets set up by the ir_texture visitor are in the
-       * m1 header, so we can't go headerless.
+      /* For general texture offsets (no txf workaround), we need a header to
+       * put them in.  Note that for 16-wide we're making space for two actual
+       * hardware registers here, so the emit will have to fix up for this.
        *
        * * ir4_tg4 needs to place its channel select in the header,
        * for interaction with ARB_texture_swizzle
        */
       header_present = true;
-      mlen++;
-      base_mrf--;
+      next.reg_offset++;
    }
 
    if (ir->shadow_comparitor) {
-      emit(MOV(fs_reg(MRF, base_mrf + mlen), shadow_c));
-      mlen += reg_width;
+      emit(MOV(next, shadow_c));
+      next.reg_offset++;
    }
 
    /* Set up the LOD info */
@@ -1221,12 +1258,12 @@ fs_visitor::emit_texture_gen7(ir_texture *ir, fs_reg dst, fs_reg coordinate,
    case ir_tg4:
       break;
    case ir_txb:
-      emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
-      mlen += reg_width;
+      emit(MOV(next, lod));
+      next.reg_offset++;
       break;
    case ir_txl:
-      emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
-      mlen += reg_width;
+      emit(MOV(next, lod));
+      next.reg_offset++;
       break;
    case ir_txd: {
       if (dispatch_width == 16)
@@ -1236,28 +1273,32 @@ fs_visitor::emit_texture_gen7(ir_texture *ir, fs_reg dst, fs_reg coordinate,
        * [hdr], [ref], x, dPdx.x, dPdy.x, y, dPdx.y, dPdy.y, z, dPdx.z, dPdy.z
        */
       for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
-	 emit(MOV(fs_reg(MRF, base_mrf + mlen), coordinate));
+	 emit(MOV(next, coordinate));
 	 coordinate.reg_offset++;
-	 mlen += reg_width;
+	 next.reg_offset++;
 
          /* For cube map array, the coordinate is (u,v,r,ai) but there are
           * only derivatives for (u, v, r).
           */
          if (i < ir->lod_info.grad.dPdx->type->vector_elements) {
-            emit(MOV(fs_reg(MRF, base_mrf + mlen), lod));
+            emit(MOV(next, lod));
             lod.reg_offset++;
-            mlen += reg_width;
+            next.reg_offset++;
 
-            emit(MOV(fs_reg(MRF, base_mrf + mlen), lod2));
+            emit(MOV(next, lod2));
             lod2.reg_offset++;
-            mlen += reg_width;
+            next.reg_offset++;
          }
       }
       break;
    }
    case ir_txs:
-      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), lod));
-      mlen += reg_width;
+      emit(MOV(next.retype(BRW_REGISTER_TYPE_UD), lod));
+      next.reg_offset++;
+      break;
+   case ir_query_levels:
+      emit(MOV(next.retype(BRW_REGISTER_TYPE_UD), fs_reg(0u)));
+      next.reg_offset++;
       break;
    case ir_txf:
       /* It appears that the ld instruction used for txf does its
@@ -1275,72 +1316,75 @@ fs_visitor::emit_texture_gen7(ir_texture *ir, fs_reg dst, fs_reg coordinate,
       }
 
       /* Unfortunately, the parameters for LD are intermixed: u, lod, v, r. */
-      emit(ADD(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_D),
-               coordinate, offsets[0]));
+      emit(ADD(next.retype(BRW_REGISTER_TYPE_D), coordinate, offsets[0]));
       coordinate.reg_offset++;
-      mlen += reg_width;
+      next.reg_offset++;
 
-      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_D), lod));
-      mlen += reg_width;
+      emit(MOV(next.retype(BRW_REGISTER_TYPE_D), lod));
+      next.reg_offset++;
 
       for (int i = 1; i < ir->coordinate->type->vector_elements; i++) {
-	 emit(ADD(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_D),
-                  coordinate, offsets[i]));
+	 emit(ADD(next.retype(BRW_REGISTER_TYPE_D), coordinate, offsets[i]));
 	 coordinate.reg_offset++;
-	 mlen += reg_width;
+	 next.reg_offset++;
       }
       break;
    case ir_txf_ms:
-      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), sample_index));
-      mlen += reg_width;
+      emit(MOV(next.retype(BRW_REGISTER_TYPE_UD), sample_index));
+      next.reg_offset++;
 
       /* constant zero MCS; we arrange to never actually have a compressed
        * multisample surface here for now. TODO: issue ld_mcs to get this first,
        * if we ever support texturing from compressed multisample surfaces
        */
-      emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_UD), fs_reg(0u)));
-      mlen += reg_width;
+      emit(MOV(next.retype(BRW_REGISTER_TYPE_UD), fs_reg(0u)));
+      next.reg_offset++;
 
       /* there is no offsetting for this message; just copy in the integer
        * texture coordinates
        */
       for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
-         emit(MOV(fs_reg(MRF, base_mrf + mlen, BRW_REGISTER_TYPE_D),
-                  coordinate));
+         emit(MOV(next.retype(BRW_REGISTER_TYPE_D), coordinate));
          coordinate.reg_offset++;
-         mlen += reg_width;
+         next.reg_offset++;
       }
       break;
    }
 
    /* Set up the coordinate (except for cases where it was done above) */
-   if (ir->op != ir_txd && ir->op != ir_txs && ir->op != ir_txf && ir->op != ir_txf_ms) {
+   if (ir->op != ir_txd && ir->op != ir_txs && ir->op != ir_txf && ir->op != ir_txf_ms && ir->op != ir_query_levels) {
       for (int i = 0; i < ir->coordinate->type->vector_elements; i++) {
-	 emit(MOV(fs_reg(MRF, base_mrf + mlen), coordinate));
+	 emit(MOV(next, coordinate));
 	 coordinate.reg_offset++;
-	 mlen += reg_width;
+	 next.reg_offset++;
       }
    }
 
    /* Generate the SEND */
    fs_inst *inst = NULL;
    switch (ir->op) {
-   case ir_tex: inst = emit(SHADER_OPCODE_TEX, dst); break;
-   case ir_txb: inst = emit(FS_OPCODE_TXB, dst); break;
-   case ir_txl: inst = emit(SHADER_OPCODE_TXL, dst); break;
-   case ir_txd: inst = emit(SHADER_OPCODE_TXD, dst); break;
-   case ir_txf: inst = emit(SHADER_OPCODE_TXF, dst); break;
-   case ir_txf_ms: inst = emit(SHADER_OPCODE_TXF_MS, dst); break;
-   case ir_txs: inst = emit(SHADER_OPCODE_TXS, dst); break;
-   case ir_lod: inst = emit(SHADER_OPCODE_LOD, dst); break;
-   case ir_tg4: inst = emit(SHADER_OPCODE_TG4, dst); break;
-   }
-   inst->base_mrf = base_mrf;
-   inst->mlen = mlen;
+   case ir_tex: inst = emit(SHADER_OPCODE_TEX, dst, payload); break;
+   case ir_txb: inst = emit(FS_OPCODE_TXB, dst, payload); break;
+   case ir_txl: inst = emit(SHADER_OPCODE_TXL, dst, payload); break;
+   case ir_txd: inst = emit(SHADER_OPCODE_TXD, dst, payload); break;
+   case ir_txf: inst = emit(SHADER_OPCODE_TXF, dst, payload); break;
+   case ir_txf_ms: inst = emit(SHADER_OPCODE_TXF_MS, dst, payload); break;
+   case ir_txs: inst = emit(SHADER_OPCODE_TXS, dst, payload); break;
+   case ir_query_levels: inst = emit(SHADER_OPCODE_TXS, dst, payload); break;
+   case ir_lod: inst = emit(SHADER_OPCODE_LOD, dst, payload); break;
+   case ir_tg4: inst = emit(SHADER_OPCODE_TG4, dst, payload); break;
+   }
+   inst->base_mrf = -1;
+   if (reg_width == 2)
+      inst->mlen = next.reg_offset * reg_width - header_present;
+   else
+      inst->mlen = next.reg_offset * reg_width;
+
    inst->header_present = header_present;
    inst->regs_written = 4;
 
-   if (mlen > 11) {
+   virtual_grf_sizes[payload.reg] = next.reg_offset;
+   if (inst->mlen > 11) {
       fail("Message length >11 disallowed by hardware\n");
    }
 
@@ -1363,7 +1407,7 @@ fs_visitor::rescale_texcoord(ir_texture *ir, fs_reg coordinate,
        (brw->gen < 6 ||
 	(brw->gen >= 6 && (c->key.tex.gl_clamp_mask[0] & (1 << sampler) ||
 			     c->key.tex.gl_clamp_mask[1] & (1 << sampler))))) {
-      struct gl_program_parameter_list *params = fp->Base.Parameters;
+      struct gl_program_parameter_list *params = prog->Parameters;
       int tokens[STATE_LENGTH] = {
 	 STATE_INTERNAL,
 	 STATE_TEXRECT_SCALE,
@@ -1383,9 +1427,9 @@ fs_visitor::rescale_texcoord(ir_texture *ir, fs_reg coordinate,
       GLuint index = _mesa_add_state_reference(params,
 					       (gl_state_index *)tokens);
       c->prog_data.param[c->prog_data.nr_params++] =
-         &fp->Base.Parameters->ParameterValues[index][0].f;
+         &prog->Parameters->ParameterValues[index][0].f;
       c->prog_data.param[c->prog_data.nr_params++] =
-         &fp->Base.Parameters->ParameterValues[index][1].f;
+         &prog->Parameters->ParameterValues[index][1].f;
    }
 
    /* The 965 requires the EU to do the normalization of GL rectangle
@@ -1454,18 +1498,19 @@ fs_visitor::visit(ir_texture *ir)
    fs_inst *inst = NULL;
 
    int sampler =
-      _mesa_get_sampler_uniform_value(ir->sampler, shader_prog, &fp->Base);
+      _mesa_get_sampler_uniform_value(ir->sampler, shader_prog, prog);
    /* FINISHME: We're failing to recompile our programs when the sampler is
     * updated.  This only matters for the texture rectangle scale parameters
     * (pre-gen6, or gen6+ with GL_CLAMP).
     */
-   int texunit = fp->Base.SamplerUnits[sampler];
+   int texunit = prog->SamplerUnits[sampler];
 
    if (ir->op == ir_tg4) {
       /* When tg4 is used with the degenerate ZERO/ONE swizzles, don't bother
        * emitting anything other than setting up the constant result.
        */
-      int swiz = GET_SWZ(c->key.tex.swizzles[sampler], 0);
+      ir_constant *chan = ir->lod_info.component->as_constant();
+      int swiz = GET_SWZ(c->key.tex.swizzles[sampler], chan->value.i[0]);
       if (swiz == SWIZZLE_ZERO || swiz == SWIZZLE_ONE) {
 
          fs_reg res = fs_reg(this, glsl_type::vec4_type);
@@ -1507,6 +1552,7 @@ fs_visitor::visit(ir_texture *ir)
    case ir_tex:
    case ir_lod:
    case ir_tg4:
+   case ir_query_levels:
       break;
    case ir_txb:
       ir->lod_info.bias->accept(this);
@@ -1549,9 +1595,6 @@ fs_visitor::visit(ir_texture *ir)
                                lod, lod2);
    }
 
-   /* The header is set up by generate_tex() when necessary. */
-   inst->src[0] = reg_undef;
-
    if (ir->offset != NULL && ir->op != ir_txf)
       inst->texture_offset = brw_texture_offset(ir->offset->as_constant());
 
@@ -1583,14 +1626,17 @@ fs_visitor::visit(ir_texture *ir)
 uint32_t
 fs_visitor::gather_channel(ir_texture *ir, int sampler)
 {
-   int swiz = GET_SWZ(c->key.tex.swizzles[sampler], 0 /* red */);
-   if (c->key.tex.gather_channel_quirk_mask & (1<<sampler))
-      return 2;   /* gather4 sampler is broken for green channel on RG32F --
-                   * we must ask for blue instead.
-                   */
+   ir_constant *chan = ir->lod_info.component->as_constant();
+   int swiz = GET_SWZ(c->key.tex.swizzles[sampler], chan->value.i[0]);
    switch (swiz) {
       case SWIZZLE_X: return 0;
-      case SWIZZLE_Y: return 1;
+      case SWIZZLE_Y:
+         /* gather4 sampler is broken for green channel on RG32F --
+          * we must ask for blue instead.
+          */
+         if (c->key.tex.gather_channel_quirk_mask & (1<<sampler))
+            return 2;
+         return 1;
       case SWIZZLE_Z: return 2;
       case SWIZZLE_W: return 3;
       default:
@@ -1606,6 +1652,13 @@ fs_visitor::gather_channel(ir_texture *ir, int sampler)
 void
 fs_visitor::swizzle_result(ir_texture *ir, fs_reg orig_val, int sampler)
 {
+   if (ir->op == ir_query_levels) {
+      /* # levels is in .w */
+      orig_val.reg_offset += 3;
+      this->result = orig_val;
+      return;
+   }
+
    this->result = orig_val;
 
    /* txs,lod don't actually sample the texture, so swizzling the result
@@ -2468,7 +2521,7 @@ fs_visitor::emit_fb_writes()
 	 fail("Missing support for simd16 depth writes on gen6\n");
       }
 
-      if (fp->Base.OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_DEPTH)) {
+      if (prog->OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_DEPTH)) {
 	 /* Hand over gl_FragDepth. */
 	 assert(this->frag_depth.file != BAD_FILE);
 	 emit(MOV(fs_reg(MRF, nr), this->frag_depth));
@@ -2616,7 +2669,10 @@ fs_visitor::fs_visitor(struct brw_context *brw,
    this->c = c;
    this->brw = brw;
    this->fp = fp;
+   this->prog = &fp->Base;
    this->shader_prog = shader_prog;
+   this->prog = &fp->Base;
+   this->stage_prog_data = &c->prog_data.base;
    this->ctx = &brw->ctx;
    this->mem_ctx = ralloc_context(NULL);
    if (shader_prog)
@@ -2642,7 +2698,7 @@ fs_visitor::fs_visitor(struct brw_context *brw,
    this->virtual_grf_array_size = 0;
    this->virtual_grf_start = NULL;
    this->virtual_grf_end = NULL;
-   this->live_intervals_valid = false;
+   this->live_intervals = NULL;
 
    this->params_remap = NULL;
    this->nr_params_remap = 0;
diff --git a/src/mesa/drivers/dri/i965/brw_gs_surface_state.c b/src/mesa/drivers/dri/i965/brw_gs_surface_state.c
index d0ce412..55152c2 100644
--- a/src/mesa/drivers/dri/i965/brw_gs_surface_state.c
+++ b/src/mesa/drivers/dri/i965/brw_gs_surface_state.c
@@ -67,7 +67,6 @@ static void
 brw_upload_gs_ubo_surfaces(struct brw_context *brw)
 {
    struct gl_context *ctx = &brw->ctx;
-   struct brw_stage_state *stage_state = &brw->gs.base;
 
    /* _NEW_PROGRAM */
    struct gl_shader_program *prog = ctx->Shader.CurrentGeometryProgram;
@@ -75,15 +74,16 @@ brw_upload_gs_ubo_surfaces(struct brw_context *brw)
    if (!prog)
       return;
 
+   /* CACHE_NEW_GS_PROG */
    brw_upload_ubo_surfaces(brw, prog->_LinkedShaders[MESA_SHADER_GEOMETRY],
-			   &stage_state->surf_offset[SURF_INDEX_VEC4_UBO(0)]);
+			   &brw->gs.base, &brw->gs.prog_data->base.base);
 }
 
 const struct brw_tracked_state brw_gs_ubo_surfaces = {
    .dirty = {
       .mesa = _NEW_PROGRAM,
       .brw = BRW_NEW_BATCH | BRW_NEW_UNIFORM_BUFFER,
-      .cache = 0,
+      .cache = CACHE_NEW_GS_PROG,
    },
    .emit = brw_upload_gs_ubo_surfaces,
 };
diff --git a/src/mesa/drivers/dri/i965/brw_misc_state.c b/src/mesa/drivers/dri/i965/brw_misc_state.c
index 7f4cd6f..5d1c27d 100644
--- a/src/mesa/drivers/dri/i965/brw_misc_state.c
+++ b/src/mesa/drivers/dri/i965/brw_misc_state.c
@@ -838,7 +838,11 @@ static void upload_aa_line_parameters(struct brw_context *brw)
 {
    struct gl_context *ctx = &brw->ctx;
 
-   if (!ctx->Line.SmoothFlag || !brw->has_aa_line_parameters)
+   if (!ctx->Line.SmoothFlag)
+      return;
+
+   /* Original Gen4 doesn't have 3DSTATE_AA_LINE_PARAMETERS. */
+   if (brw->gen == 4 && !brw->is_g4x)
       return;
 
    if (brw->gen == 6)
diff --git a/src/mesa/drivers/dri/i965/brw_reg.h b/src/mesa/drivers/dri/i965/brw_reg.h
index 6df3366..3ee3543 100644
--- a/src/mesa/drivers/dri/i965/brw_reg.h
+++ b/src/mesa/drivers/dri/i965/brw_reg.h
@@ -77,6 +77,7 @@ extern "C" {
 #define BRW_SWIZZLE_ZZZZ      BRW_SWIZZLE4(2,2,2,2)
 #define BRW_SWIZZLE_WWWW      BRW_SWIZZLE4(3,3,3,3)
 #define BRW_SWIZZLE_XYXY      BRW_SWIZZLE4(0,1,0,1)
+#define BRW_SWIZZLE_ZWZW      BRW_SWIZZLE4(2,3,2,3)
 
 static inline bool
 brw_is_single_value_swizzle(int swiz)
diff --git a/src/mesa/drivers/dri/i965/brw_schedule_instructions.cpp b/src/mesa/drivers/dri/i965/brw_schedule_instructions.cpp
index 5530683..84b74ff 100644
--- a/src/mesa/drivers/dri/i965/brw_schedule_instructions.cpp
+++ b/src/mesa/drivers/dri/i965/brw_schedule_instructions.cpp
@@ -569,7 +569,7 @@ fs_instruction_scheduler::calculate_deps()
       for (int i = 0; i < 3; i++) {
 	 if (inst->src[i].file == GRF) {
             if (post_reg_alloc) {
-               for (int r = 0; r < reg_width; r++)
+               for (int r = 0; r < reg_width * inst->regs_read(v, i); r++)
                   add_dep(last_grf_write[inst->src[i].reg + r], n);
             } else {
                add_dep(last_grf_write[inst->src[i].reg], n);
@@ -594,12 +594,14 @@ fs_instruction_scheduler::calculate_deps()
 	 }
       }
 
-      for (int i = 0; i < inst->mlen; i++) {
-	 /* It looks like the MRF regs are released in the send
-	  * instruction once it's sent, not when the result comes
-	  * back.
-	  */
-	 add_dep(last_mrf_write[inst->base_mrf + i], n);
+      if (inst->base_mrf != -1) {
+	 for (int i = 0; i < inst->mlen; i++) {
+	    /* It looks like the MRF regs are released in the send
+	     * instruction once it's sent, not when the result comes
+	     * back.
+	     */
+	    add_dep(last_mrf_write[inst->base_mrf + i], n);
+	 }
       }
 
       if (inst->predicate) {
@@ -642,7 +644,7 @@ fs_instruction_scheduler::calculate_deps()
 	 add_barrier_deps(n);
       }
 
-      if (inst->mlen > 0) {
+      if (inst->mlen > 0 && inst->base_mrf != -1) {
 	 for (int i = 0; i < v->implied_mrf_writes(inst); i++) {
 	    add_dep(last_mrf_write[inst->base_mrf + i], n);
 	    last_mrf_write[inst->base_mrf + i] = n;
@@ -677,7 +679,7 @@ fs_instruction_scheduler::calculate_deps()
       for (int i = 0; i < 3; i++) {
 	 if (inst->src[i].file == GRF) {
             if (post_reg_alloc) {
-               for (int r = 0; r < reg_width; r++)
+               for (int r = 0; r < reg_width * inst->regs_read(v, i); r++)
                   add_dep(n, last_grf_write[inst->src[i].reg + r]);
             } else {
                add_dep(n, last_grf_write[inst->src[i].reg]);
@@ -702,12 +704,14 @@ fs_instruction_scheduler::calculate_deps()
 	 }
       }
 
-      for (int i = 0; i < inst->mlen; i++) {
-	 /* It looks like the MRF regs are released in the send
-	  * instruction once it's sent, not when the result comes
-	  * back.
-	  */
-	 add_dep(n, last_mrf_write[inst->base_mrf + i], 2);
+      if (inst->base_mrf != -1) {
+	 for (int i = 0; i < inst->mlen; i++) {
+	    /* It looks like the MRF regs are released in the send
+	     * instruction once it's sent, not when the result comes
+	     * back.
+	     */
+	    add_dep(n, last_mrf_write[inst->base_mrf + i], 2);
+	 }
       }
 
       if (inst->predicate) {
@@ -749,7 +753,7 @@ fs_instruction_scheduler::calculate_deps()
 	 add_barrier_deps(n);
       }
 
-      if (inst->mlen > 0) {
+      if (inst->mlen > 0 && inst->base_mrf != -1) {
 	 for (int i = 0; i < v->implied_mrf_writes(inst); i++) {
 	    last_mrf_write[inst->base_mrf + i] = n;
 	 }
@@ -1061,11 +1065,15 @@ instruction_scheduler::schedule_instructions(backend_instruction *next_block_hea
 	 child->unblocked_time = MAX2(child->unblocked_time,
 				      time + chosen->child_latency[i]);
 
+         if (debug) {
+            printf("\tchild %d, %d parents: ", i, child->parent_count);
+            bv->dump_instruction(child->inst);
+         }
+
 	 child->parent_count--;
 	 if (child->parent_count == 0) {
             if (debug) {
-               printf("now available: ");
-               bv->dump_instruction(child->inst);
+               printf("\t\tnow available\n");
             }
 	    instructions.push_tail(child);
 	 }
@@ -1138,7 +1146,7 @@ fs_visitor::schedule_instructions(bool post_reg_alloc)
              dispatch_width, sched.time);
    }
 
-   this->live_intervals_valid = false;
+   invalidate_live_intervals();
 }
 
 void
diff --git a/src/mesa/drivers/dri/i965/brw_shader.cpp b/src/mesa/drivers/dri/i965/brw_shader.cpp
index 61c4bf5..5992a1c 100644
--- a/src/mesa/drivers/dri/i965/brw_shader.cpp
+++ b/src/mesa/drivers/dri/i965/brw_shader.cpp
@@ -568,6 +568,25 @@ backend_instruction::is_control_flow()
    }
 }
 
+bool
+backend_instruction::can_do_source_mods()
+{
+   switch (opcode) {
+   case BRW_OPCODE_ADDC:
+   case BRW_OPCODE_BFE:
+   case BRW_OPCODE_BFI1:
+   case BRW_OPCODE_BFI2:
+   case BRW_OPCODE_BFREV:
+   case BRW_OPCODE_CBIT:
+   case BRW_OPCODE_FBH:
+   case BRW_OPCODE_FBL:
+   case BRW_OPCODE_SUBB:
+      return false;
+   default:
+      return true;
+   }
+}
+
 void
 backend_visitor::dump_instructions()
 {
@@ -578,3 +597,50 @@ backend_visitor::dump_instructions()
       dump_instruction(inst);
    }
 }
+
+
+/**
+ * Sets up the starting offsets for the groups of binding table entries
+ * commong to all pipeline stages.
+ *
+ * Unused groups are initialized to 0xd0d0d0d0 to make it obvious that they're
+ * unused but also make sure that addition of small offsets to them will
+ * trigger some of our asserts that surface indices are < BRW_MAX_SURFACES.
+ */
+void
+backend_visitor::assign_common_binding_table_offsets(uint32_t next_binding_table_offset)
+{
+   int num_textures = _mesa_fls(prog->SamplersUsed);
+
+   stage_prog_data->binding_table.texture_start = next_binding_table_offset;
+   next_binding_table_offset += num_textures;
+
+   if (shader) {
+      stage_prog_data->binding_table.ubo_start = next_binding_table_offset;
+      next_binding_table_offset += shader->base.NumUniformBlocks;
+   } else {
+      stage_prog_data->binding_table.ubo_start = 0xd0d0d0d0;
+   }
+
+   if (INTEL_DEBUG & DEBUG_SHADER_TIME) {
+      stage_prog_data->binding_table.shader_time_start = next_binding_table_offset;
+      next_binding_table_offset++;
+   } else {
+      stage_prog_data->binding_table.shader_time_start = 0xd0d0d0d0;
+   }
+
+   if (prog->UsesGather) {
+      stage_prog_data->binding_table.gather_texture_start = next_binding_table_offset;
+      next_binding_table_offset += num_textures;
+   } else {
+      stage_prog_data->binding_table.gather_texture_start = 0xd0d0d0d0;
+   }
+
+   /* This may or may not be used depending on how the compile goes. */
+   stage_prog_data->binding_table.pull_constants_start = next_binding_table_offset;
+   next_binding_table_offset++;
+
+   assert(next_binding_table_offset <= BRW_MAX_SURFACES);
+
+   /* prog_data->base.binding_table.size will be set by mark_surface_used. */
+}
diff --git a/src/mesa/drivers/dri/i965/brw_shader.h b/src/mesa/drivers/dri/i965/brw_shader.h
index 55769ff..7cebf1f 100644
--- a/src/mesa/drivers/dri/i965/brw_shader.h
+++ b/src/mesa/drivers/dri/i965/brw_shader.h
@@ -29,7 +29,6 @@
 
 enum register_file {
    BAD_FILE,
-   ARF,
    GRF,
    MRF,
    IMM,
@@ -45,6 +44,7 @@ public:
    bool is_tex();
    bool is_math();
    bool is_control_flow();
+   bool can_do_source_mods();
 
    enum opcode opcode; /* BRW_OPCODE_* or FS_OPCODE_* */
 
@@ -59,6 +59,8 @@ public:
    struct gl_context *ctx;
    struct brw_shader *shader;
    struct gl_shader_program *shader_prog;
+   struct gl_program *prog;
+   struct brw_stage_prog_data *stage_prog_data;
 
    /** ralloc context for temporary data used during compile */
    void *mem_ctx;
@@ -71,6 +73,8 @@ public:
 
    virtual void dump_instruction(backend_instruction *inst) = 0;
    void dump_instructions();
+
+   void assign_common_binding_table_offsets(uint32_t next_binding_table_offset);
 };
 
 uint32_t brw_texture_offset(ir_constant *offset);
diff --git a/src/mesa/drivers/dri/i965/brw_state.h b/src/mesa/drivers/dri/i965/brw_state.h
index ec64328..0d8503a 100644
--- a/src/mesa/drivers/dri/i965/brw_state.h
+++ b/src/mesa/drivers/dri/i965/brw_state.h
@@ -239,12 +239,6 @@ brw_upload_vec4_pull_constants(struct brw_context *brw,
                                const struct gl_program *prog,
                                struct brw_stage_state *stage_state,
                                const struct brw_vec4_prog_data *prog_data);
-void
-brw_upload_binding_table(struct brw_context *brw,
-                         GLbitfield brw_new_binding_table,
-                         struct brw_stage_state *stage_state,
-                         unsigned binding_table_entries,
-                         int shader_time_surf_index);
 
 /* gen7_vs_state.c */
 void
diff --git a/src/mesa/drivers/dri/i965/brw_state_cache.c b/src/mesa/drivers/dri/i965/brw_state_cache.c
index ef32840..9ccd2bc 100644
--- a/src/mesa/drivers/dri/i965/brw_state_cache.c
+++ b/src/mesa/drivers/dri/i965/brw_state_cache.c
@@ -215,9 +215,7 @@ brw_try_upload_using_copy(struct brw_cache *cache,
 	 }
 
          if (cache->aux_compare[result_item->cache_id]) {
-            if (!cache->aux_compare[result_item->cache_id](item_aux, aux,
-                                                           item->aux_size,
-                                                           item->key))
+            if (!cache->aux_compare[result_item->cache_id](item_aux, aux))
                continue;
          } else if (memcmp(item_aux, aux, item->aux_size) != 0) {
 	    continue;
diff --git a/src/mesa/drivers/dri/i965/brw_state_upload.c b/src/mesa/drivers/dri/i965/brw_state_upload.c
index d7fe319..ec9bfb0 100644
--- a/src/mesa/drivers/dri/i965/brw_state_upload.c
+++ b/src/mesa/drivers/dri/i965/brw_state_upload.c
@@ -263,6 +263,7 @@ brw_upload_initial_gpu_state(struct brw_context *brw)
 
 void brw_init_state( struct brw_context *brw )
 {
+   struct gl_context *ctx = &brw->ctx;
    const struct brw_tracked_state **atoms;
    int num_atoms;
 
@@ -291,6 +292,18 @@ void brw_init_state( struct brw_context *brw )
    }
 
    brw_upload_initial_gpu_state(brw);
+
+   brw->state.dirty.mesa = ~0;
+   brw->state.dirty.brw = ~0;
+
+   /* Make sure that brw->state.dirty.brw has enough bits to hold all possible
+    * dirty flags.
+    */
+   STATIC_ASSERT(BRW_NUM_STATE_BITS <= 8 * sizeof(brw->state.dirty.brw));
+
+   ctx->DriverFlags.NewTransformFeedback = BRW_NEW_TRANSFORM_FEEDBACK;
+   ctx->DriverFlags.NewRasterizerDiscard = BRW_NEW_RASTERIZER_DISCARD;
+   ctx->DriverFlags.NewUniformBuffer = BRW_NEW_UNIFORM_BUFFER;
 }
 
 
@@ -471,7 +484,8 @@ void brw_upload_state(struct brw_context *brw)
    state->brw |= ctx->NewDriverState;
    ctx->NewDriverState = 0;
 
-   if (brw->emit_state_always) {
+   if (0) {
+      /* Always re-emit all state. */
       state->mesa |= ~0;
       state->brw |= ~0;
       state->cache |= ~0;
diff --git a/src/mesa/drivers/dri/i965/brw_surface_formats.c b/src/mesa/drivers/dri/i965/brw_surface_formats.c
index 8666336..7afca79 100644
--- a/src/mesa/drivers/dri/i965/brw_surface_formats.c
+++ b/src/mesa/drivers/dri/i965/brw_surface_formats.c
@@ -532,6 +532,8 @@ brw_init_surface_formats(struct brw_context *brw)
    int gen;
    gl_format format;
 
+   memset(&ctx->TextureFormatSupported, 0, sizeof(ctx->TextureFormatSupported));
+
    gen = brw->gen * 10;
    if (brw->is_g4x)
       gen += 5;
diff --git a/src/mesa/drivers/dri/i965/brw_tex_layout.c b/src/mesa/drivers/dri/i965/brw_tex_layout.c
index e4e66b4..d912862 100644
--- a/src/mesa/drivers/dri/i965/brw_tex_layout.c
+++ b/src/mesa/drivers/dri/i965/brw_tex_layout.c
@@ -197,6 +197,18 @@ brw_miptree_layout_2d(struct intel_mipmap_tree *mt)
 }
 
 static void
+align_cube(struct intel_mipmap_tree *mt)
+{
+   /* The 965's sampler lays cachelines out according to how accesses
+    * in the texture surfaces run, so they may be "vertical" through
+    * memory.  As a result, the docs say in Surface Padding Requirements:
+    * Sampling Engine Surfaces that two extra rows of padding are required.
+    */
+   if (mt->target == GL_TEXTURE_CUBE_MAP)
+      mt->total_height += 2;
+}
+
+static void
 brw_miptree_layout_texture_array(struct brw_context *brw,
 				 struct intel_mipmap_tree *mt)
 {
@@ -220,84 +232,45 @@ brw_miptree_layout_texture_array(struct brw_context *brw,
       }
    }
    mt->total_height = qpitch * mt->physical_depth0;
+
+   align_cube(mt);
 }
 
 static void
 brw_miptree_layout_texture_3d(struct brw_context *brw,
                               struct intel_mipmap_tree *mt)
 {
-   unsigned width  = mt->physical_width0;
-   unsigned height = mt->physical_height0;
-   unsigned depth = mt->physical_depth0;
-   unsigned pack_x_pitch, pack_x_nr;
-   unsigned pack_y_pitch;
+   unsigned yscale = mt->compressed ? 4 : 1;
 
+   mt->total_width = 0;
    mt->total_height = 0;
 
-   if (mt->compressed) {
-       mt->total_width = ALIGN(width, mt->align_w);
-       pack_y_pitch = (height + 3) / 4;
-   } else {
-      mt->total_width = mt->physical_width0;
-      pack_y_pitch = ALIGN(mt->physical_height0, mt->align_h);
-   }
-
-   pack_x_pitch = width;
-   pack_x_nr = 1;
-
+   unsigned ysum = 0;
    for (unsigned level = mt->first_level; level <= mt->last_level; level++) {
-      int x = 0;
-      int y = 0;
-
-      intel_miptree_set_level_info(mt, level,
-                                   0, mt->total_height,
-                                   width, height, depth);
-
-      for (int q = 0; q < depth; /* empty */) {
-         for (int j = 0; j < pack_x_nr && q < depth; j++, q++) {
-            intel_miptree_set_image_offset(mt, level, q, x, y);
-            x += pack_x_pitch;
-         }
-         if (x > mt->total_width)
-            mt->total_width = x;
-
-         x = 0;
-         y += pack_y_pitch;
-      }
+      unsigned WL = MAX2(mt->physical_width0 >> level, 1);
+      unsigned HL = MAX2(mt->physical_height0 >> level, 1);
+      unsigned DL = MAX2(mt->physical_depth0 >> level, 1);
+      unsigned wL = ALIGN(WL, mt->align_w);
+      unsigned hL = ALIGN(HL, mt->align_h);
 
-      mt->total_height += y;
-      width  = minify(width, 1);
-      height = minify(height, 1);
-      if (mt->target == GL_TEXTURE_3D)
-         depth = minify(depth, 1);
+      if (mt->target == GL_TEXTURE_CUBE_MAP)
+         DL = 6;
 
-      if (mt->compressed) {
-         pack_y_pitch = (height + 3) / 4;
+      intel_miptree_set_level_info(mt, level, 0, 0, WL, HL, DL);
 
-         if (pack_x_pitch > ALIGN(width, mt->align_w)) {
-            pack_x_pitch = ALIGN(width, mt->align_w);
-            pack_x_nr <<= 1;
-         }
-      } else {
-         pack_x_nr <<= 1;
-         if (pack_x_pitch > 4) {
-            pack_x_pitch >>= 1;
-         }
-
-         if (pack_y_pitch > 2) {
-            pack_y_pitch >>= 1;
-            pack_y_pitch = ALIGN(pack_y_pitch, mt->align_h);
-         }
+      for (unsigned q = 0; q < DL; q++) {
+         unsigned x = (q % (1 << level)) * wL;
+         unsigned y = ysum + (q >> level) * hL;
+
+         intel_miptree_set_image_offset(mt, level, q, x, y / yscale);
+         mt->total_width = MAX2(mt->total_width, x + wL);
+         mt->total_height = MAX2(mt->total_height, (y + hL) / yscale);
       }
+
+      ysum += ALIGN(DL, 1 << level) / (1 << level) * hL;
    }
 
-   /* The 965's sampler lays cachelines out according to how accesses
-    * in the texture surfaces run, so they may be "vertical" through
-    * memory.  As a result, the docs say in Surface Padding Requirements:
-    * Sampling Engine Surfaces that two extra rows of padding are required.
-    */
-   if (mt->target == GL_TEXTURE_CUBE_MAP)
-      mt->total_height += 2;
+   align_cube(mt);
 }
 
 void
diff --git a/src/mesa/drivers/dri/i965/brw_vec4.cpp b/src/mesa/drivers/dri/i965/brw_vec4.cpp
index 75c3d34..d3ee9a1 100644
--- a/src/mesa/drivers/dri/i965/brw_vec4.cpp
+++ b/src/mesa/drivers/dri/i965/brw_vec4.cpp
@@ -222,6 +222,9 @@ vec4_visitor::can_do_source_mods(vec4_instruction *inst)
    if (inst->is_send_from_grf())
       return false;
 
+   if (!inst->can_do_source_mods())
+      return false;
+
    return true;
 }
 
@@ -314,7 +317,20 @@ vec4_visitor::dead_code_eliminate()
       if (inst->dst.file == GRF) {
          assert(this->virtual_grf_end[inst->dst.reg] >= pc);
          if (this->virtual_grf_end[inst->dst.reg] == pc) {
-            inst->remove();
+            /* Don't dead code eliminate instructions that write to the
+             * accumulator as a side-effect. Instead just set the destination
+             * to the null register to free it.
+             */
+            switch (inst->opcode) {
+            case BRW_OPCODE_ADDC:
+            case BRW_OPCODE_SUBB:
+            case BRW_OPCODE_MACH:
+               inst->dst = dst_reg(retype(brw_null_reg(), inst->dst.type));
+               break;
+            default:
+               inst->remove();
+               break;
+            }
             progress = true;
          }
       }
@@ -1413,6 +1429,8 @@ vec4_visitor::run()
    if (INTEL_DEBUG & DEBUG_SHADER_TIME)
       emit_shader_time_begin();
 
+   assign_common_binding_table_offsets(0);
+
    emit_prolog();
 
    /* Generate VS IR for main().  (the visitor only descends into
@@ -1578,7 +1596,7 @@ bool
 brw_vec4_prog_data_compare(const struct brw_vec4_prog_data *a,
                            const struct brw_vec4_prog_data *b)
 {
-   /* Compare all the struct up to the pointers. */
+   /* Compare all the struct (including the base) up to the pointers. */
    if (memcmp(a, b, offsetof(struct brw_vec4_prog_data, param)))
       return false;
 
diff --git a/src/mesa/drivers/dri/i965/brw_vec4.h b/src/mesa/drivers/dri/i965/brw_vec4.h
index 5b8075a..41d91e5 100644
--- a/src/mesa/drivers/dri/i965/brw_vec4.h
+++ b/src/mesa/drivers/dri/i965/brw_vec4.h
@@ -97,7 +97,7 @@ swizzle_for_size(int size);
 class reg
 {
 public:
-   /** Register file: ARF, GRF, MRF, IMM. */
+   /** Register file: GRF, MRF, IMM. */
    enum register_file file;
    /** virtual register number.  0 = fixed hw reg */
    int reg;
@@ -245,7 +245,11 @@ public:
       return dst_reg(retype(brw_null_reg(), BRW_REGISTER_TYPE_D));
    }
 
-   struct gl_program *prog;
+   dst_reg dst_null_ud()
+   {
+      return dst_reg(retype(brw_null_reg(), BRW_REGISTER_TYPE_UD));
+   }
+
    struct brw_vec4_compile *c;
    const struct brw_vec4_prog_key *key;
    struct brw_vec4_prog_data *prog_data;
@@ -414,6 +418,8 @@ public:
    vec4_instruction *FBL(dst_reg dst, src_reg value);
    vec4_instruction *CBIT(dst_reg dst, src_reg value);
    vec4_instruction *MAD(dst_reg dst, src_reg c, src_reg b, src_reg a);
+   vec4_instruction *ADDC(dst_reg dst, src_reg src0, src_reg src1);
+   vec4_instruction *SUBB(dst_reg dst, src_reg src0, src_reg src1);
 
    int implied_mrf_writes(vec4_instruction *inst);
 
diff --git a/src/mesa/drivers/dri/i965/brw_vec4_copy_propagation.cpp b/src/mesa/drivers/dri/i965/brw_vec4_copy_propagation.cpp
index cd2b118..d009a08 100644
--- a/src/mesa/drivers/dri/i965/brw_vec4_copy_propagation.cpp
+++ b/src/mesa/drivers/dri/i965/brw_vec4_copy_propagation.cpp
@@ -97,6 +97,8 @@ try_constant_propagation(vec4_instruction *inst, int arg, src_reg *values[4])
 
    case BRW_OPCODE_SHL:
    case BRW_OPCODE_SHR:
+   case BRW_OPCODE_ADDC:
+   case BRW_OPCODE_SUBB:
       if (arg == 1) {
          inst->src[arg] = value;
          return true;
diff --git a/src/mesa/drivers/dri/i965/brw_vec4_generator.cpp b/src/mesa/drivers/dri/i965/brw_vec4_generator.cpp
index 00efb10..1b597b5 100644
--- a/src/mesa/drivers/dri/i965/brw_vec4_generator.cpp
+++ b/src/mesa/drivers/dri/i965/brw_vec4_generator.cpp
@@ -155,10 +155,10 @@ vec4_generator::~vec4_generator()
 void
 vec4_generator::mark_surface_used(unsigned surf_index)
 {
-   assert(surf_index < BRW_MAX_VEC4_SURFACES);
+   assert(surf_index < BRW_MAX_SURFACES);
 
-   prog_data->binding_table_size = MAX2(prog_data->binding_table_size,
-                                        surf_index + 1);
+   prog_data->base.binding_table.size_bytes =
+      MAX2(prog_data->base.binding_table.size_bytes, (surf_index + 1) * 4);
 }
 
 void
@@ -385,9 +385,9 @@ vec4_generator::generate_tex(vec4_instruction *inst,
       break;
    }
 
-   uint32_t surface_index = inst->opcode == SHADER_OPCODE_TG4
-      ? SURF_INDEX_VEC4_GATHER_TEXTURE(inst->sampler)
-      : SURF_INDEX_VEC4_TEXTURE(inst->sampler);
+   uint32_t surface_index = (inst->opcode == SHADER_OPCODE_TG4
+      ? prog_data->base.binding_table.gather_texture_start
+      : prog_data->base.binding_table.texture_start) + inst->sampler;
 
    brw_SAMPLE(p,
 	      dst,
@@ -873,6 +873,7 @@ vec4_generator::generate_vec4_instruction(vec4_instruction *instruction,
       break;
 
    case BRW_OPCODE_MAD:
+      assert(brw->gen >= 6);
       brw_MAD(p, dst, src[0], src[1], src[2]);
       break;
 
@@ -935,43 +936,65 @@ vec4_generator::generate_vec4_instruction(vec4_instruction *instruction,
       break;
 
    case BRW_OPCODE_F32TO16:
+      assert(brw->gen >= 7);
       brw_F32TO16(p, dst, src[0]);
       break;
 
    case BRW_OPCODE_F16TO32:
+      assert(brw->gen >= 7);
       brw_F16TO32(p, dst, src[0]);
       break;
 
    case BRW_OPCODE_LRP:
+      assert(brw->gen >= 6);
       brw_LRP(p, dst, src[0], src[1], src[2]);
       break;
 
    case BRW_OPCODE_BFREV:
+      assert(brw->gen >= 7);
       /* BFREV only supports UD type for src and dst. */
       brw_BFREV(p, retype(dst, BRW_REGISTER_TYPE_UD),
                    retype(src[0], BRW_REGISTER_TYPE_UD));
       break;
    case BRW_OPCODE_FBH:
+      assert(brw->gen >= 7);
       /* FBH only supports UD type for dst. */
       brw_FBH(p, retype(dst, BRW_REGISTER_TYPE_UD), src[0]);
       break;
    case BRW_OPCODE_FBL:
+      assert(brw->gen >= 7);
       /* FBL only supports UD type for dst. */
       brw_FBL(p, retype(dst, BRW_REGISTER_TYPE_UD), src[0]);
       break;
    case BRW_OPCODE_CBIT:
+      assert(brw->gen >= 7);
       /* CBIT only supports UD type for dst. */
       brw_CBIT(p, retype(dst, BRW_REGISTER_TYPE_UD), src[0]);
       break;
+   case BRW_OPCODE_ADDC:
+      assert(brw->gen >= 7);
+      brw_set_acc_write_control(p, 1);
+      brw_ADDC(p, dst, src[0], src[1]);
+      brw_set_acc_write_control(p, 0);
+      break;
+   case BRW_OPCODE_SUBB:
+      assert(brw->gen >= 7);
+      brw_set_acc_write_control(p, 1);
+      brw_SUBB(p, dst, src[0], src[1]);
+      brw_set_acc_write_control(p, 0);
+      break;
 
    case BRW_OPCODE_BFE:
+      assert(brw->gen >= 7);
       brw_BFE(p, dst, src[0], src[1], src[2]);
       break;
 
    case BRW_OPCODE_BFI1:
+      assert(brw->gen >= 7);
       brw_BFI1(p, dst, src[0], src[1]);
       break;
    case BRW_OPCODE_BFI2:
+      assert(brw->gen >= 7);
       brw_BFI2(p, dst, src[0], src[1], src[2]);
       break;
 
@@ -1100,8 +1123,9 @@ vec4_generator::generate_vec4_instruction(vec4_instruction *instruction,
       break;
 
    case SHADER_OPCODE_SHADER_TIME_ADD:
-      brw_shader_time_add(p, src[0], SURF_INDEX_VEC4_SHADER_TIME);
-      mark_surface_used(SURF_INDEX_VEC4_SHADER_TIME);
+      brw_shader_time_add(p, src[0],
+                          prog_data->base.binding_table.shader_time_start);
+      mark_surface_used(prog_data->base.binding_table.shader_time_start);
       break;
 
    case VS_OPCODE_UNPACK_FLAGS_SIMD4X2:
diff --git a/src/mesa/drivers/dri/i965/brw_vec4_gs.c b/src/mesa/drivers/dri/i965/brw_vec4_gs.c
index 064e541..b48422c 100644
--- a/src/mesa/drivers/dri/i965/brw_vec4_gs.c
+++ b/src/mesa/drivers/dri/i965/brw_vec4_gs.c
@@ -286,6 +286,8 @@ brw_upload_gs_prog(struct brw_context *brw)
                                 gp, &key);
       assert(success);
    }
+   brw->gs.base.prog_data = &brw->gs.prog_data->base.base;
+
    if (memcmp(&brw->vs.prog_data->base.vue_map, &brw->vue_map_geom_out,
               sizeof(brw->vue_map_geom_out)) != 0) {
       brw->vue_map_geom_out = brw->gs.prog_data->base.vue_map;
@@ -304,8 +306,7 @@ const struct brw_tracked_state brw_gs_prog = {
 
 
 bool
-brw_gs_prog_data_compare(const void *in_a, const void *in_b,
-                         int aux_size, const void *in_key)
+brw_gs_prog_data_compare(const void *in_a, const void *in_b)
 {
    const struct brw_gs_prog_data *a = in_a;
    const struct brw_gs_prog_data *b = in_b;
diff --git a/src/mesa/drivers/dri/i965/brw_vec4_gs.h b/src/mesa/drivers/dri/i965/brw_vec4_gs.h
index 82caadc..8b979ac 100644
--- a/src/mesa/drivers/dri/i965/brw_vec4_gs.h
+++ b/src/mesa/drivers/dri/i965/brw_vec4_gs.h
@@ -30,8 +30,7 @@
 extern "C" {
 #endif
 
-bool brw_gs_prog_data_compare(const void *a, const void *b,
-                              int aux_size, const void *key);
+bool brw_gs_prog_data_compare(const void *a, const void *b);
 void brw_gs_prog_data_free(const void *in_prog_data);
 
 #ifdef __cplusplus
diff --git a/src/mesa/drivers/dri/i965/brw_vec4_gs_visitor.cpp b/src/mesa/drivers/dri/i965/brw_vec4_gs_visitor.cpp
index 2d3a058..96636e8 100644
--- a/src/mesa/drivers/dri/i965/brw_vec4_gs_visitor.cpp
+++ b/src/mesa/drivers/dri/i965/brw_vec4_gs_visitor.cpp
@@ -156,6 +156,23 @@ vec4_gs_visitor::emit_prolog()
       }
    }
 
+   /* If the geometry shader uses the gl_PointSize input, we need to fix it up
+    * to account for the fact that the vertex shader stored it in the w
+    * component of VARYING_SLOT_PSIZ.
+    */
+   if (c->gp->program.Base.InputsRead & VARYING_BIT_PSIZ) {
+      this->current_annotation = "swizzle gl_PointSize input";
+      for (int vertex = 0; vertex < c->gp->program.VerticesIn; vertex++) {
+         dst_reg dst(ATTR,
+                     BRW_VARYING_SLOT_COUNT * vertex + VARYING_SLOT_PSIZ);
+         dst.type = BRW_REGISTER_TYPE_F;
+         src_reg src(dst);
+         dst.writemask = WRITEMASK_X;
+         src.swizzle = BRW_SWIZZLE_WWWW;
+         emit(MOV(dst, src));
+      }
+   }
+
    this->current_annotation = NULL;
 }
 
diff --git a/src/mesa/drivers/dri/i965/brw_vec4_visitor.cpp b/src/mesa/drivers/dri/i965/brw_vec4_visitor.cpp
index 9e6cc78..231815f 100644
--- a/src/mesa/drivers/dri/i965/brw_vec4_visitor.cpp
+++ b/src/mesa/drivers/dri/i965/brw_vec4_visitor.cpp
@@ -162,6 +162,8 @@ ALU1(FBH)
 ALU1(FBL)
 ALU1(CBIT)
 ALU3(MAD)
+ALU2(ADDC)
+ALU2(SUBB)
 
 /** Gen4 predicated IF. */
 vec4_instruction *
@@ -1356,7 +1358,7 @@ vec4_visitor::visit(ir_expression *ir)
             else
                emit(MUL(result_dst, op[0], op[1]));
          } else {
-            struct brw_reg acc = retype(brw_acc_reg(), BRW_REGISTER_TYPE_D);
+            struct brw_reg acc = retype(brw_acc_reg(), result_dst.type);
 
             emit(MUL(acc, op[0], op[1]));
             emit(MACH(dst_null_d(), op[0], op[1]));
@@ -1366,11 +1368,32 @@ vec4_visitor::visit(ir_expression *ir)
 	 emit(MUL(result_dst, op[0], op[1]));
       }
       break;
+   case ir_binop_imul_high: {
+      struct brw_reg acc = retype(brw_acc_reg(), result_dst.type);
+
+      emit(MUL(acc, op[0], op[1]));
+      emit(MACH(result_dst, op[0], op[1]));
+      break;
+   }
    case ir_binop_div:
       /* Floating point should be lowered by DIV_TO_MUL_RCP in the compiler. */
       assert(ir->type->is_integer());
       emit_math(SHADER_OPCODE_INT_QUOTIENT, result_dst, op[0], op[1]);
       break;
+   case ir_binop_carry: {
+      struct brw_reg acc = retype(brw_acc_reg(), BRW_REGISTER_TYPE_UD);
+
+      emit(ADDC(dst_null_ud(), op[0], op[1]));
+      emit(MOV(result_dst, src_reg(acc)));
+      break;
+   }
+   case ir_binop_borrow: {
+      struct brw_reg acc = retype(brw_acc_reg(), BRW_REGISTER_TYPE_UD);
+
+      emit(SUBB(dst_null_ud(), op[0], op[1]));
+      emit(MOV(result_dst, src_reg(acc)));
+      break;
+   }
    case ir_binop_mod:
       /* Floating point should be lowered by MOD_TO_FRACT in the compiler. */
       assert(ir->type->is_integer());
@@ -1552,7 +1575,7 @@ vec4_visitor::visit(ir_expression *ir)
       src_reg packed_consts = src_reg(this, glsl_type::vec4_type);
       packed_consts.type = result.type;
       src_reg surf_index =
-         src_reg(SURF_INDEX_VEC4_UBO(uniform_block->value.u[0]));
+         src_reg(prog_data->base.binding_table.ubo_start + uniform_block->value.u[0]);
       if (const_offset_ir) {
          offset = src_reg(const_offset / 16);
       } else {
@@ -2150,7 +2173,8 @@ vec4_visitor::visit(ir_texture *ir)
     * emitting anything other than setting up the constant result.
     */
    if (ir->op == ir_tg4) {
-      int swiz = GET_SWZ(key->tex.swizzles[sampler], 0);
+      ir_constant *chan = ir->lod_info.component->as_constant();
+      int swiz = GET_SWZ(key->tex.swizzles[sampler], chan->value.i[0]);
       if (swiz == SWIZZLE_ZERO || swiz == SWIZZLE_ONE) {
          dst_reg result(this, ir->type);
          this->result = src_reg(result);
@@ -2192,6 +2216,10 @@ vec4_visitor::visit(ir_texture *ir)
       lod = this->result;
       lod_type = ir->lod_info.lod->type;
       break;
+   case ir_query_levels:
+      lod = src_reg(0);
+      lod_type = glsl_type::int_type;
+      break;
    case ir_txf_ms:
       ir->lod_info.sample_index->accept(this);
       sample_index = this->result;
@@ -2233,6 +2261,9 @@ vec4_visitor::visit(ir_texture *ir)
    case ir_tg4:
       inst = new(mem_ctx) vec4_instruction(this, SHADER_OPCODE_TG4);
       break;
+   case ir_query_levels:
+      inst = new(mem_ctx) vec4_instruction(this, SHADER_OPCODE_TXS);
+      break;
    case ir_txb:
       assert(!"TXB is not valid for vertex shaders.");
       break;
@@ -2264,7 +2295,7 @@ vec4_visitor::visit(ir_texture *ir)
    /* MRF for the first parameter */
    int param_base = inst->base_mrf + inst->header_present;
 
-   if (ir->op == ir_txs) {
+   if (ir->op == ir_txs || ir->op == ir_query_levels) {
       int writemask = brw->gen == 4 ? WRITEMASK_W : WRITEMASK_X;
       emit(MOV(dst_reg(MRF, param_base, lod_type, writemask), lod));
    } else {
@@ -2391,14 +2422,17 @@ vec4_visitor::visit(ir_texture *ir)
 uint32_t
 vec4_visitor::gather_channel(ir_texture *ir, int sampler)
 {
-   int swiz = GET_SWZ(key->tex.swizzles[sampler], 0 /* red */);
-   if (key->tex.gather_channel_quirk_mask & (1<<sampler))
-      return 2;   /* gather4 sampler is broken for green channel on RG32F --
-                   * we must ask for blue instead.
-                   */
+   ir_constant *chan = ir->lod_info.component->as_constant();
+   int swiz = GET_SWZ(key->tex.swizzles[sampler], chan->value.i[0]);
    switch (swiz) {
       case SWIZZLE_X: return 0;
-      case SWIZZLE_Y: return 1;
+      case SWIZZLE_Y:
+         /* gather4 sampler is broken for green channel on RG32F --
+          * we must ask for blue instead.
+          */
+         if (key->tex.gather_channel_quirk_mask & (1<<sampler))
+            return 2;
+         return 1;
       case SWIZZLE_Z: return 2;
       case SWIZZLE_W: return 3;
       default:
@@ -2415,6 +2449,13 @@ vec4_visitor::swizzle_result(ir_texture *ir, src_reg orig_val, int sampler)
    this->result = src_reg(this, ir->type);
    dst_reg swizzled_result(this->result);
 
+   if (ir->op == ir_query_levels) {
+      /* # levels is in .w */
+      orig_val.swizzle = BRW_SWIZZLE4(SWIZZLE_W, SWIZZLE_W, SWIZZLE_W, SWIZZLE_W);
+      emit(MOV(swizzled_result, orig_val));
+      return;
+   }
+
    if (ir->op == ir_txs || ir->type == glsl_type::float_type
 			|| s == SWIZZLE_NOOP || ir->op == ir_tg4) {
       emit(MOV(swizzled_result, orig_val));
@@ -2987,7 +3028,7 @@ vec4_visitor::emit_pull_constant_load(vec4_instruction *inst,
 				      int base_offset)
 {
    int reg_offset = base_offset + orig_src.reg_offset;
-   src_reg index = src_reg((unsigned)SURF_INDEX_VEC4_CONST_BUFFER);
+   src_reg index = src_reg(prog_data->base.binding_table.pull_constants_start);
    src_reg offset = get_pull_constant_offset(inst, orig_src.reladdr, reg_offset);
    vec4_instruction *load;
 
@@ -3121,6 +3162,7 @@ vec4_visitor::vec4_visitor(struct brw_context *brw,
    this->prog = prog;
    this->key = key;
    this->prog_data = prog_data;
+   this->stage_prog_data = &prog_data->base;
 
    this->variable_ht = hash_table_ctor(0,
 				       hash_table_pointer_hash,
diff --git a/src/mesa/drivers/dri/i965/brw_vec4_vp.cpp b/src/mesa/drivers/dri/i965/brw_vec4_vp.cpp
index d2dc253..1f3d75c 100644
--- a/src/mesa/drivers/dri/i965/brw_vec4_vp.cpp
+++ b/src/mesa/drivers/dri/i965/brw_vec4_vp.cpp
@@ -560,7 +560,7 @@ vec4_vs_visitor::get_vp_src_reg(const prog_src_register &src)
       #endif
 
          result = src_reg(this, glsl_type::vec4_type);
-         src_reg surf_index = src_reg(unsigned(SURF_INDEX_VEC4_CONST_BUFFER));
+         src_reg surf_index = src_reg(unsigned(prog_data->base.binding_table.pull_constants_start));
          vec4_instruction *load =
             new(mem_ctx) vec4_instruction(this, VS_OPCODE_PULL_CONSTANT_LOAD,
                                           dst_reg(result), surf_index, reladdr);
diff --git a/src/mesa/drivers/dri/i965/brw_vs.c b/src/mesa/drivers/dri/i965/brw_vs.c
index f5bf590..c0ae3ed 100644
--- a/src/mesa/drivers/dri/i965/brw_vs.c
+++ b/src/mesa/drivers/dri/i965/brw_vs.c
@@ -176,8 +176,7 @@ gl_clip_plane *brw_select_clip_planes(struct gl_context *ctx)
 
 
 bool
-brw_vs_prog_data_compare(const void *in_a, const void *in_b,
-                         int aux_size, const void *in_key)
+brw_vs_prog_data_compare(const void *in_a, const void *in_b)
 {
    const struct brw_vs_prog_data *a = in_a;
    const struct brw_vs_prog_data *b = in_b;
@@ -489,6 +488,8 @@ static void brw_upload_vs_prog(struct brw_context *brw)
       (void) success;
       assert(success);
    }
+   brw->vs.base.prog_data = &brw->vs.prog_data->base.base;
+
    if (memcmp(&brw->vs.prog_data->base.vue_map, &brw->vue_map_geom_out,
               sizeof(brw->vue_map_geom_out)) != 0) {
       brw->vue_map_vs = brw->vs.prog_data->base.vue_map;
diff --git a/src/mesa/drivers/dri/i965/brw_vs.h b/src/mesa/drivers/dri/i965/brw_vs.h
index 747ba6c..5d62e47 100644
--- a/src/mesa/drivers/dri/i965/brw_vs.h
+++ b/src/mesa/drivers/dri/i965/brw_vs.h
@@ -93,8 +93,7 @@ bool brw_vs_precompile(struct gl_context *ctx, struct gl_shader_program *prog);
 void brw_vs_debug_recompile(struct brw_context *brw,
                             struct gl_shader_program *prog,
                             const struct brw_vs_prog_key *key);
-bool brw_vs_prog_data_compare(const void *a, const void *b,
-                              int aux_size, const void *key);
+bool brw_vs_prog_data_compare(const void *a, const void *b);
 void brw_vs_prog_data_free(const void *in_prog_data);
 
 #ifdef __cplusplus
diff --git a/src/mesa/drivers/dri/i965/brw_vs_surface_state.c b/src/mesa/drivers/dri/i965/brw_vs_surface_state.c
index 2c5d06f..7e4bcc0 100644
--- a/src/mesa/drivers/dri/i965/brw_vs_surface_state.c
+++ b/src/mesa/drivers/dri/i965/brw_vs_surface_state.c
@@ -44,6 +44,7 @@ brw_upload_vec4_pull_constants(struct brw_context *brw,
                                const struct brw_vec4_prog_data *prog_data)
 {
    int i;
+   uint32_t surf_index = prog_data->base.binding_table.pull_constants_start;
 
    /* Updates the ParamaterValues[i] pointers for all parameters of the
     * basic type of PROGRAM_STATE_VAR.
@@ -54,7 +55,7 @@ brw_upload_vec4_pull_constants(struct brw_context *brw,
       if (stage_state->const_bo) {
 	 drm_intel_bo_unreference(stage_state->const_bo);
 	 stage_state->const_bo = NULL;
-	 stage_state->surf_offset[SURF_INDEX_VEC4_CONST_BUFFER] = 0;
+	 stage_state->surf_offset[surf_index] = 0;
 	 brw->state.dirty.brw |= brw_new_constbuf;
       }
       return;
@@ -84,9 +85,9 @@ brw_upload_vec4_pull_constants(struct brw_context *brw,
 
    drm_intel_gem_bo_unmap_gtt(stage_state->const_bo);
 
-   const int surf = SURF_INDEX_VEC4_CONST_BUFFER;
    brw->vtbl.create_constant_surface(brw, stage_state->const_bo, 0, size,
-                                     &stage_state->surf_offset[surf], false);
+                                     &stage_state->surf_offset[surf_index],
+                                     false);
 
    brw->state.dirty.brw |= brw_new_constbuf;
 }
@@ -127,8 +128,6 @@ const struct brw_tracked_state brw_vs_pull_constants = {
 static void
 brw_upload_vs_ubo_surfaces(struct brw_context *brw)
 {
-   struct brw_stage_state *stage_state = &brw->vs.base;
-
    struct gl_context *ctx = &brw->ctx;
    /* _NEW_PROGRAM */
    struct gl_shader_program *prog = ctx->Shader.CurrentVertexProgram;
@@ -136,15 +135,16 @@ brw_upload_vs_ubo_surfaces(struct brw_context *brw)
    if (!prog)
       return;
 
+   /* CACHE_NEW_VS_PROG */
    brw_upload_ubo_surfaces(brw, prog->_LinkedShaders[MESA_SHADER_VERTEX],
-			   &stage_state->surf_offset[SURF_INDEX_VEC4_UBO(0)]);
+			   &brw->vs.base, &brw->vs.prog_data->base.base);
 }
 
 const struct brw_tracked_state brw_vs_ubo_surfaces = {
    .dirty = {
       .mesa = _NEW_PROGRAM,
       .brw = BRW_NEW_BATCH | BRW_NEW_UNIFORM_BUFFER,
-      .cache = 0,
+      .cache = CACHE_NEW_VS_PROG,
    },
    .emit = brw_upload_vs_ubo_surfaces,
 };
diff --git a/src/mesa/drivers/dri/i965/brw_vtbl.c b/src/mesa/drivers/dri/i965/brw_vtbl.c
deleted file mode 100644
index ea156a8..0000000
--- a/src/mesa/drivers/dri/i965/brw_vtbl.c
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- Copyright (C) Intel Corp.  2006.  All Rights Reserved.
- Intel funded Tungsten Graphics (http://www.tungstengraphics.com) to
- develop this 3D driver.
- 
- Permission is hereby granted, free of charge, to any person obtaining
- a copy of this software and associated documentation files (the
- "Software"), to deal in the Software without restriction, including
- without limitation the rights to use, copy, modify, merge, publish,
- distribute, sublicense, and/or sell copies of the Software, and to
- permit persons to whom the Software is furnished to do so, subject to
- the following conditions:
- 
- The above copyright notice and this permission notice (including the
- next paragraph) shall be included in all copies or substantial
- portions of the Software.
- 
- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
- LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
- OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
- WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- 
-**********************************************************************/
-
-/*
- * Authors:
- *   Keith Whitwell <keith@tungstengraphics.com>
- */
-
-#include "main/glheader.h"
-#include "main/mtypes.h"
-#include "main/imports.h"
-#include "main/macros.h"
-#include "main/colormac.h"
-#include "main/renderbuffer.h"
-#include "main/framebuffer.h"
-
-#include "intel_batchbuffer.h" 
-#include "intel_regions.h" 
-#include "intel_fbo.h"
-
-#include "brw_context.h"
-#include "brw_program.h"
-#include "brw_defines.h"
-#include "brw_state.h"
-#include "brw_draw.h"
-#include "brw_vs.h"
-#include "brw_wm.h"
-
-#include "gen6_blorp.h"
-#include "gen7_blorp.h"
-
-#include "glsl/ralloc.h"
-
-static void
-dri_bo_release(drm_intel_bo **bo)
-{
-   drm_intel_bo_unreference(*bo);
-   *bo = NULL;
-}
-
-
-/**
- * called from intelDestroyContext()
- */
-static void
-brw_destroy_context(struct brw_context *brw)
-{
-   if (INTEL_DEBUG & DEBUG_SHADER_TIME) {
-      /* Force a report. */
-      brw->shader_time.report_time = 0;
-
-      brw_collect_and_report_shader_time(brw);
-      brw_destroy_shader_time(brw);
-   }
-
-   brw_destroy_state(brw);
-   brw_draw_destroy( brw );
-
-   dri_bo_release(&brw->curbe.curbe_bo);
-   dri_bo_release(&brw->vs.base.const_bo);
-   dri_bo_release(&brw->wm.base.const_bo);
-
-   free(brw->curbe.last_buf);
-   free(brw->curbe.next_buf);
-
-   drm_intel_gem_context_destroy(brw->hw_ctx);
-}
-
-/**
- * called from intel_batchbuffer_flush and children before sending a
- * batchbuffer off.
- *
- * Note that ALL state emitted here must fit in the reserved space
- * at the end of a batchbuffer.  If you add more GPU state, increase
- * the BATCH_RESERVED macro.
- */
-static void
-brw_finish_batch(struct brw_context *brw)
-{
-   brw_emit_query_end(brw);
-
-   if (brw->curbe.curbe_bo) {
-      drm_intel_gem_bo_unmap_gtt(brw->curbe.curbe_bo);
-      drm_intel_bo_unreference(brw->curbe.curbe_bo);
-      brw->curbe.curbe_bo = NULL;
-   }
-}
-
-
-/**
- * called from intelFlushBatchLocked
- */
-static void
-brw_new_batch(struct brw_context *brw)
-{
-   /* If the kernel supports hardware contexts, then most hardware state is
-    * preserved between batches; we only need to re-emit state that is required
-    * to be in every batch.  Otherwise we need to re-emit all the state that
-    * would otherwise be stored in the context (which for all intents and
-    * purposes means everything).
-    */
-   if (brw->hw_ctx == NULL)
-      brw->state.dirty.brw |= BRW_NEW_CONTEXT;
-
-   brw->state.dirty.brw |= BRW_NEW_BATCH;
-
-   /* Assume that the last command before the start of our batch was a
-    * primitive, for safety.
-    */
-   brw->batch.need_workaround_flush = true;
-
-   brw->state_batch_count = 0;
-
-   brw->ib.type = -1;
-
-   /* Mark that the current program cache BO has been used by the GPU.
-    * It will be reallocated if we need to put new programs in for the
-    * next batch.
-    */
-   brw->cache.bo_used_by_gpu = true;
-
-   /* We need to periodically reap the shader time results, because rollover
-    * happens every few seconds.  We also want to see results every once in a
-    * while, because many programs won't cleanly destroy our context, so the
-    * end-of-run printout may not happen.
-    */
-   if (INTEL_DEBUG & DEBUG_SHADER_TIME)
-      brw_collect_and_report_shader_time(brw);
-}
-
-void brwInitVtbl( struct brw_context *brw )
-{
-   brw->vtbl.new_batch = brw_new_batch;
-   brw->vtbl.finish_batch = brw_finish_batch;
-   brw->vtbl.destroy = brw_destroy_context;
-
-   assert(brw->gen >= 4);
-   if (brw->gen >= 7) {
-      gen7_init_vtable_surface_functions(brw);
-      gen7_init_vtable_sampler_functions(brw);
-      brw->vtbl.emit_depth_stencil_hiz = gen7_emit_depth_stencil_hiz;
-   } else if (brw->gen >= 4) {
-      gen4_init_vtable_surface_functions(brw);
-      gen4_init_vtable_sampler_functions(brw);
-      brw->vtbl.emit_depth_stencil_hiz = brw_emit_depth_stencil_hiz;
-   }
-}
diff --git a/src/mesa/drivers/dri/i965/brw_wm.c b/src/mesa/drivers/dri/i965/brw_wm.c
index 6ce58dd..0fda490 100644
--- a/src/mesa/drivers/dri/i965/brw_wm.c
+++ b/src/mesa/drivers/dri/i965/brw_wm.c
@@ -103,13 +103,12 @@ brw_compute_barycentric_interp_modes(struct brw_context *brw,
 }
 
 bool
-brw_wm_prog_data_compare(const void *in_a, const void *in_b,
-                         int aux_size, const void *in_key)
+brw_wm_prog_data_compare(const void *in_a, const void *in_b)
 {
    const struct brw_wm_prog_data *a = in_a;
    const struct brw_wm_prog_data *b = in_b;
 
-   /* Compare all the struct up to the pointers. */
+   /* Compare all the struct (including the base) up to the pointers. */
    if (memcmp(a, b, offsetof(struct brw_wm_prog_data, param)))
       return false;
 
@@ -349,7 +348,7 @@ brw_populate_sampler_prog_key_data(struct gl_context *ctx,
          /* gather4's channel select for green from RG32F is broken;
           * requires a shader w/a on IVB; fixable with just SCS on HSW. */
          if (brw->gen >= 7 && !brw->is_haswell && prog->UsesGather) {
-            if (img->InternalFormat == GL_RG32F && GET_SWZ(t->_Swizzle, 0) == 1)
+            if (img->InternalFormat == GL_RG32F)
                key->gather_channel_quirk_mask |= 1 << s;
          }
       }
@@ -512,6 +511,7 @@ brw_upload_wm_prog(struct brw_context *brw)
       (void) success;
       assert(success);
    }
+   brw->wm.base.prog_data = &brw->wm.prog_data->base;
 }
 
 
diff --git a/src/mesa/drivers/dri/i965/brw_wm.h b/src/mesa/drivers/dri/i965/brw_wm.h
index aa786de..259a4b6 100644
--- a/src/mesa/drivers/dri/i965/brw_wm.h
+++ b/src/mesa/drivers/dri/i965/brw_wm.h
@@ -114,8 +114,7 @@ bool do_wm_prog(struct brw_context *brw,
 void brw_wm_debug_recompile(struct brw_context *brw,
                             struct gl_shader_program *prog,
                             const struct brw_wm_prog_key *key);
-bool brw_wm_prog_data_compare(const void *a, const void *b,
-                              int aux_size, const void *key);
+bool brw_wm_prog_data_compare(const void *a, const void *b);
 void brw_wm_prog_data_free(const void *in_prog_data);
 
 #endif
diff --git a/src/mesa/drivers/dri/i965/brw_wm_surface_state.c b/src/mesa/drivers/dri/i965/brw_wm_surface_state.c
index 6e91857..e1b5cfc 100644
--- a/src/mesa/drivers/dri/i965/brw_wm_surface_state.c
+++ b/src/mesa/drivers/dri/i965/brw_wm_surface_state.c
@@ -424,7 +424,8 @@ brw_upload_wm_pull_constants(struct brw_context *brw)
       (struct brw_fragment_program *) brw->fragment_program;
    struct gl_program_parameter_list *params = fp->program.Base.Parameters;
    const int size = brw->wm.prog_data->nr_pull_params * sizeof(float);
-   const int surf_index = SURF_INDEX_FRAG_CONST_BUFFER;
+   const int surf_index =
+      brw->wm.prog_data->base.binding_table.pull_constants_start;
    float *constants;
    unsigned int i;
 
@@ -496,12 +497,14 @@ brw_update_null_renderbuffer_surface(struct brw_context *brw, unsigned int unit)
    drm_intel_bo *bo = NULL;
    unsigned pitch_minus_1 = 0;
    uint32_t multisampling_state = 0;
+   uint32_t surf_index =
+      brw->wm.prog_data->binding_table.render_target_start + unit;
 
    /* _NEW_BUFFERS */
    const struct gl_framebuffer *fb = ctx->DrawBuffer;
 
    surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE, 6 * 4, 32,
-                          &brw->wm.base.surf_offset[SURF_INDEX_DRAW(unit)]);
+                          &brw->wm.base.surf_offset[surf_index]);
 
    if (fb->Visual.samples > 1) {
       /* On Gen6, null render targets seem to cause GPU hangs when
@@ -554,7 +557,7 @@ brw_update_null_renderbuffer_surface(struct brw_context *brw, unsigned int unit)
 
    if (bo) {
       drm_intel_bo_emit_reloc(brw->batch.bo,
-                              brw->wm.base.surf_offset[SURF_INDEX_DRAW(unit)] + 4,
+                              brw->wm.base.surf_offset[surf_index] + 4,
                               bo, 0,
                               I915_GEM_DOMAIN_RENDER, I915_GEM_DOMAIN_RENDER);
    }
@@ -580,6 +583,8 @@ brw_update_renderbuffer_surface(struct brw_context *brw,
    uint32_t format = 0;
    /* _NEW_BUFFERS */
    gl_format rb_format = _mesa_get_render_format(ctx, intel_rb_format(irb));
+   uint32_t surf_index =
+      brw->wm.prog_data->binding_table.render_target_start + unit;
 
    assert(!layered);
 
@@ -603,7 +608,7 @@ brw_update_renderbuffer_surface(struct brw_context *brw,
    region = irb->mt->region;
 
    surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE, 6 * 4, 32,
-                          &brw->wm.base.surf_offset[SURF_INDEX_DRAW(unit)]);
+                          &brw->wm.base.surf_offset[surf_index]);
 
    format = brw->render_target_format[rb_format];
    if (unlikely(!brw->format_supported_as_render_target[rb_format])) {
@@ -659,7 +664,7 @@ brw_update_renderbuffer_surface(struct brw_context *brw,
    }
 
    drm_intel_bo_emit_reloc(brw->batch.bo,
-			   brw->wm.base.surf_offset[SURF_INDEX_DRAW(unit)] + 4,
+			   brw->wm.base.surf_offset[surf_index] + 4,
 			   region->bo,
 			   surf[1] - region->bo->offset,
 			   I915_GEM_DOMAIN_RENDER,
@@ -715,7 +720,7 @@ const struct brw_tracked_state gen6_renderbuffer_surfaces = {
 static void
 update_stage_texture_surfaces(struct brw_context *brw,
                               const struct gl_program *prog,
-                              uint32_t *surf_offset,
+                              struct brw_stage_state *stage_state,
                               bool for_gather)
 {
    if (!prog)
@@ -723,8 +728,13 @@ update_stage_texture_surfaces(struct brw_context *brw,
 
    struct gl_context *ctx = &brw->ctx;
 
-   unsigned num_samplers = _mesa_fls(prog->SamplersUsed);
+   uint32_t *surf_offset = stage_state->surf_offset;
+   if (for_gather)
+      surf_offset += stage_state->prog_data->binding_table.gather_texture_start;
+   else
+      surf_offset += stage_state->prog_data->binding_table.texture_start;
 
+   unsigned num_samplers = _mesa_fls(prog->SamplersUsed);
    for (unsigned s = 0; s < num_samplers; s++) {
       surf_offset[s] = 0;
 
@@ -756,37 +766,19 @@ brw_update_texture_surfaces(struct brw_context *brw)
    struct gl_program *fs = (struct gl_program *) brw->fragment_program;
 
    /* _NEW_TEXTURE */
-   update_stage_texture_surfaces(brw, vs,
-                                 brw->vs.base.surf_offset +
-                                 SURF_INDEX_VEC4_TEXTURE(0),
-                                 false);
-   update_stage_texture_surfaces(brw, gs,
-                                 brw->gs.base.surf_offset +
-                                 SURF_INDEX_VEC4_TEXTURE(0),
-                                 false);
-   update_stage_texture_surfaces(brw, fs,
-                                 brw->wm.base.surf_offset +
-                                 SURF_INDEX_TEXTURE(0),
-                                 false);
+   update_stage_texture_surfaces(brw, vs, &brw->vs.base, false);
+   update_stage_texture_surfaces(brw, gs, &brw->gs.base, false);
+   update_stage_texture_surfaces(brw, fs, &brw->wm.base, false);
 
    /* emit alternate set of surface state for gather. this
     * allows the surface format to be overriden for only the
     * gather4 messages. */
    if (vs && vs->UsesGather)
-      update_stage_texture_surfaces(brw, vs,
-                                    brw->vs.base.surf_offset +
-                                    SURF_INDEX_VEC4_GATHER_TEXTURE(0),
-                                    true);
+      update_stage_texture_surfaces(brw, vs, &brw->vs.base, true);
    if (gs && gs->UsesGather)
-      update_stage_texture_surfaces(brw, gs,
-                                    brw->gs.base.surf_offset +
-                                    SURF_INDEX_VEC4_GATHER_TEXTURE(0),
-                                    true);
+      update_stage_texture_surfaces(brw, gs, &brw->gs.base, true);
    if (fs && fs->UsesGather)
-      update_stage_texture_surfaces(brw, fs,
-                                    brw->wm.base.surf_offset +
-                                    SURF_INDEX_GATHER_TEXTURE(0),
-                                    true);
+      update_stage_texture_surfaces(brw, fs, &brw->wm.base, true);
 
    brw->state.dirty.brw |= BRW_NEW_SURFACES;
 }
@@ -806,13 +798,17 @@ const struct brw_tracked_state brw_texture_surfaces = {
 void
 brw_upload_ubo_surfaces(struct brw_context *brw,
 			struct gl_shader *shader,
-			uint32_t *surf_offsets)
+                        struct brw_stage_state *stage_state,
+                        struct brw_stage_prog_data *prog_data)
 {
    struct gl_context *ctx = &brw->ctx;
 
    if (!shader)
       return;
 
+   uint32_t *surf_offsets =
+      &stage_state->surf_offset[prog_data->binding_table.ubo_start];
+
    for (int i = 0; i < shader->NumUniformBlocks; i++) {
       struct gl_uniform_buffer_binding *binding;
       struct intel_buffer_object *intel_bo;
@@ -845,15 +841,16 @@ brw_upload_wm_ubo_surfaces(struct brw_context *brw)
    if (!prog)
       return;
 
+   /* CACHE_NEW_WM_PROG */
    brw_upload_ubo_surfaces(brw, prog->_LinkedShaders[MESA_SHADER_FRAGMENT],
-			   &brw->wm.base.surf_offset[SURF_INDEX_WM_UBO(0)]);
+                           &brw->wm.base, &brw->wm.prog_data->base);
 }
 
 const struct brw_tracked_state brw_wm_ubo_surfaces = {
    .dirty = {
       .mesa = _NEW_PROGRAM,
       .brw = BRW_NEW_BATCH | BRW_NEW_UNIFORM_BUFFER,
-      .cache = 0,
+      .cache = CACHE_NEW_WM_PROG,
    },
    .emit = brw_upload_wm_ubo_surfaces,
 };
diff --git a/src/mesa/drivers/dri/i965/gen6_wm_state.c b/src/mesa/drivers/dri/i965/gen6_wm_state.c
index c96a107..e3395ce 100644
--- a/src/mesa/drivers/dri/i965/gen6_wm_state.c
+++ b/src/mesa/drivers/dri/i965/gen6_wm_state.c
@@ -78,8 +78,7 @@ gen6_upload_wm_push_constants(struct brw_context *brw)
 	 printf("\n");
       }
 
-      brw->wm.base.push_const_size =
-         ALIGN(prog_data->nr_params, prog_data->dispatch_width) / 8;
+      brw->wm.base.push_const_size = ALIGN(prog_data->nr_params, 8) / 8;
    }
 }
 
@@ -123,8 +122,7 @@ upload_wm_state(struct brw_context *brw)
        * state flags from gen6_upload_wm_push_constants.
        */
       OUT_BATCH(brw->wm.base.push_const_offset +
-		ALIGN(brw->wm.prog_data->nr_params,
-		      brw->wm.prog_data->dispatch_width) / 8 - 1);
+		brw->wm.base.push_const_size - 1);
       OUT_BATCH(0);
       OUT_BATCH(0);
       OUT_BATCH(0);
diff --git a/src/mesa/drivers/dri/i965/gen7_blorp.cpp b/src/mesa/drivers/dri/i965/gen7_blorp.cpp
index 9df3d92..f64e536 100644
--- a/src/mesa/drivers/dri/i965/gen7_blorp.cpp
+++ b/src/mesa/drivers/dri/i965/gen7_blorp.cpp
@@ -706,8 +706,8 @@ gen7_blorp_emit_depth_stencil_config(struct brw_context *brw,
       surfwidth = params->depth.width;
       surfheight = params->depth.height;
    } else {
-      surfwidth = params->depth.mt->physical_width0;
-      surfheight = params->depth.mt->physical_height0;
+      surfwidth = params->depth.mt->logical_width0;
+      surfheight = params->depth.mt->logical_height0;
    }
 
    /* 3DSTATE_DEPTH_BUFFER */
diff --git a/src/mesa/drivers/dri/i965/gen7_gs_state.c b/src/mesa/drivers/dri/i965/gen7_gs_state.c
index 3dd5896..c272b7d 100644
--- a/src/mesa/drivers/dri/i965/gen7_gs_state.c
+++ b/src/mesa/drivers/dri/i965/gen7_gs_state.c
@@ -105,6 +105,33 @@ upload_gs_state(struct brw_context *brw)
          (0 << GEN6_GS_URB_ENTRY_READ_OFFSET_SHIFT) |
          (prog_data->dispatch_grf_start_reg <<
           GEN6_GS_DISPATCH_START_GRF_SHIFT);
+
+      /* Note: the meaning of the GEN7_GS_REORDER_TRAILING bit changes between
+       * Ivy Bridge and Haswell.
+       *
+       * On Ivy Bridge, setting this bit causes the vertices of a triangle
+       * strip to be delivered to the geometry shader in an order that does
+       * not strictly follow the OpenGL spec, but preserves triangle
+       * orientation.  For example, if the vertices are (1, 2, 3, 4, 5), then
+       * the geometry shader sees triangles:
+       *
+       * (1, 2, 3), (2, 4, 3), (3, 4, 5)
+       *
+       * (Clearing the bit is even worse, because it fails to preserve
+       * orientation).
+       *
+       * Triangle strips with adjacency always ordered in a way that preserves
+       * triangle orientation but does not strictly follow the OpenGL spec,
+       * regardless of the setting of this bit.
+       *
+       * On Haswell, both triangle strips and triangle strips with adjacency
+       * are always ordered in a way that preserves triangle orientation.
+       * Setting this bit causes the ordering to strictly follow the OpenGL
+       * spec.
+       *
+       * So in either case we want to set the bit.  Unfortunately on Ivy
+       * Bridge this will get the order close to correct but not perfect.
+       */
       uint32_t dw5 =
          ((brw->max_gs_threads - 1) << max_threads_shift) |
          (brw->gs.prog_data->control_data_header_size_hwords <<
@@ -113,6 +140,7 @@ upload_gs_state(struct brw_context *brw)
          GEN6_GS_STATISTICS_ENABLE |
          (brw->gs.prog_data->include_primitive_id ?
           GEN7_GS_INCLUDE_PRIMITIVE_ID : 0) |
+         GEN7_GS_REORDER_TRAILING |
          GEN7_GS_ENABLE;
       uint32_t dw6 = 0;
 
diff --git a/src/mesa/drivers/dri/i965/gen7_misc_state.c b/src/mesa/drivers/dri/i965/gen7_misc_state.c
index eb942cf..3f3833e 100644
--- a/src/mesa/drivers/dri/i965/gen7_misc_state.c
+++ b/src/mesa/drivers/dri/i965/gen7_misc_state.c
@@ -93,8 +93,8 @@ gen7_emit_depth_stencil_hiz(struct brw_context *brw,
    lod = irb ? irb->mt_level - irb->mt->first_level : 0;
 
    if (mt) {
-      width = mt->physical_width0;
-      height = mt->physical_height0;
+      width = mt->logical_width0;
+      height = mt->logical_height0;
    }
 
    /* _NEW_DEPTH, _NEW_STENCIL, _NEW_BUFFERS */
diff --git a/src/mesa/drivers/dri/i965/gen7_wm_state.c b/src/mesa/drivers/dri/i965/gen7_wm_state.c
index 80073cd..a2046c3 100644
--- a/src/mesa/drivers/dri/i965/gen7_wm_state.c
+++ b/src/mesa/drivers/dri/i965/gen7_wm_state.c
@@ -60,8 +60,22 @@ upload_wm_state(struct brw_context *brw)
    if (fp->program.Base.InputsRead & VARYING_BIT_POS)
       dw1 |= GEN7_WM_USES_SOURCE_DEPTH | GEN7_WM_USES_SOURCE_W;
    if (fp->program.Base.OutputsWritten & BITFIELD64_BIT(FRAG_RESULT_DEPTH)) {
-      writes_depth = true;
-      dw1 |= GEN7_WM_PSCDEPTH_ON;
+      writes_depth = fp->program.FragDepthLayout != FRAG_DEPTH_LAYOUT_UNCHANGED;
+
+      switch (fp->program.FragDepthLayout) {
+         case FRAG_DEPTH_LAYOUT_NONE:
+         case FRAG_DEPTH_LAYOUT_ANY:
+            dw1 |= GEN7_WM_PSCDEPTH_ON;
+            break;
+         case FRAG_DEPTH_LAYOUT_GREATER:
+            dw1 |= GEN7_WM_PSCDEPTH_ON_GE;
+            break;
+         case FRAG_DEPTH_LAYOUT_LESS:
+            dw1 |= GEN7_WM_PSCDEPTH_ON_LE;
+            break;
+         case FRAG_DEPTH_LAYOUT_UNCHANGED:
+            break;
+      }
    }
    /* CACHE_NEW_WM_PROG */
    dw1 |= brw->wm.prog_data->barycentric_interp_modes <<
diff --git a/src/mesa/drivers/dri/i965/gen7_wm_surface_state.c b/src/mesa/drivers/dri/i965/gen7_wm_surface_state.c
index 564ac76..4488d48 100644
--- a/src/mesa/drivers/dri/i965/gen7_wm_surface_state.c
+++ b/src/mesa/drivers/dri/i965/gen7_wm_surface_state.c
@@ -451,9 +451,11 @@ gen7_update_null_renderbuffer_surface(struct brw_context *brw, unsigned unit)
 
    /* _NEW_BUFFERS */
    const struct gl_framebuffer *fb = ctx->DrawBuffer;
+   uint32_t surf_index =
+      brw->wm.prog_data->binding_table.render_target_start + unit;
 
    uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE, 8 * 4, 32,
-                                    &brw->wm.base.surf_offset[SURF_INDEX_DRAW(unit)]);
+                                    &brw->wm.base.surf_offset[surf_index]);
    memset(surf, 0, 8 * 4);
 
    /* From the Ivybridge PRM, Volume 4, Part 1, page 65,
@@ -495,7 +497,8 @@ gen7_update_renderbuffer_surface(struct brw_context *brw,
    GLenum gl_target = rb->TexImage ?
                          rb->TexImage->TexObject->Target : GL_TEXTURE_2D;
 
-   uint32_t surf_index = SURF_INDEX_DRAW(unit);
+   uint32_t surf_index =
+      brw->wm.prog_data->binding_table.render_target_start + unit;
 
    uint32_t *surf = brw_state_batch(brw, AUB_TRACE_SURFACE_STATE, 8 * 4, 32,
                                     &brw->wm.base.surf_offset[surf_index]);
diff --git a/src/mesa/drivers/dri/i965/intel_batchbuffer.c b/src/mesa/drivers/dri/i965/intel_batchbuffer.c
index 0aa2551..6d1ae79 100644
--- a/src/mesa/drivers/dri/i965/intel_batchbuffer.c
+++ b/src/mesa/drivers/dri/i965/intel_batchbuffer.c
@@ -70,6 +70,8 @@ intel_batchbuffer_init(struct brw_context *brw)
 						      4096, 4096);
    }
 
+   brw->batch.need_workaround_flush = true;
+
    if (!brw->has_llc) {
       brw->batch.cpu_map = malloc(BATCH_SZ);
       brw->batch.map = brw->batch.cpu_map;
@@ -170,6 +172,68 @@ do_batch_dump(struct brw_context *brw)
    }
 }
 
+/**
+ * Called when starting a new batch buffer.
+ */
+static void
+brw_new_batch(struct brw_context *brw)
+{
+   /* If the kernel supports hardware contexts, then most hardware state is
+    * preserved between batches; we only need to re-emit state that is required
+    * to be in every batch.  Otherwise we need to re-emit all the state that
+    * would otherwise be stored in the context (which for all intents and
+    * purposes means everything).
+    */
+   if (brw->hw_ctx == NULL)
+      brw->state.dirty.brw |= BRW_NEW_CONTEXT;
+
+   brw->state.dirty.brw |= BRW_NEW_BATCH;
+
+   /* Assume that the last command before the start of our batch was a
+    * primitive, for safety.
+    */
+   brw->batch.need_workaround_flush = true;
+
+   brw->state_batch_count = 0;
+
+   brw->ib.type = -1;
+
+   /* Mark that the current program cache BO has been used by the GPU.
+    * It will be reallocated if we need to put new programs in for the
+    * next batch.
+    */
+   brw->cache.bo_used_by_gpu = true;
+
+   /* We need to periodically reap the shader time results, because rollover
+    * happens every few seconds.  We also want to see results every once in a
+    * while, because many programs won't cleanly destroy our context, so the
+    * end-of-run printout may not happen.
+    */
+   if (INTEL_DEBUG & DEBUG_SHADER_TIME)
+      brw_collect_and_report_shader_time(brw);
+}
+
+/**
+ * Called from intel_batchbuffer_flush before emitting MI_BATCHBUFFER_END and
+ * sending it off.
+ *
+ * This function can emit state (say, to preserve registers that aren't saved
+ * between batches).  All of this state MUST fit in the reserved space at the
+ * end of the batchbuffer.  If you add more GPU state, increase the reserved
+ * space by updating the BATCH_RESERVED macro.
+ */
+static void
+brw_finish_batch(struct brw_context *brw)
+{
+   brw_emit_query_end(brw);
+
+   if (brw->curbe.curbe_bo) {
+      drm_intel_gem_bo_unmap_gtt(brw->curbe.curbe_bo);
+      drm_intel_bo_unreference(brw->curbe.curbe_bo);
+      brw->curbe.curbe_bo = NULL;
+   }
+}
+
 /* TODO: Push this whole function into bufmgr.
  */
 static int
@@ -222,7 +286,7 @@ do_flush_locked(struct brw_context *brw)
       fprintf(stderr, "intel_do_flush_locked failed: %s\n", strerror(-ret));
       exit(1);
    }
-   brw->vtbl.new_batch(brw);
+   brw_new_batch(brw);
 
    return ret;
 }
@@ -254,8 +318,7 @@ _intel_batchbuffer_flush(struct brw_context *brw,
 
    brw->batch.reserved_space = 0;
 
-   if (brw->vtbl.finish_batch)
-      brw->vtbl.finish_batch(brw);
+   brw_finish_batch(brw);
 
    /* Mark the end of the buffer. */
    intel_batchbuffer_emit_dword(brw, MI_BATCH_BUFFER_END);
diff --git a/src/mesa/drivers/dri/i965/intel_chipset.h b/src/mesa/drivers/dri/i965/intel_chipset.h
index 65cb50e..a760dee 100644
--- a/src/mesa/drivers/dri/i965/intel_chipset.h
+++ b/src/mesa/drivers/dri/i965/intel_chipset.h
@@ -25,6 +25,9 @@
  *
  */
 
+#pragma once
+#include <stdbool.h>
+
 #define PCI_CHIP_IGD_GM			0xA011
 #define PCI_CHIP_IGD_G			0xA001
 
diff --git a/src/mesa/drivers/dri/i965/intel_context.c b/src/mesa/drivers/dri/i965/intel_context.c
deleted file mode 100644
index 4f96989..0000000
--- a/src/mesa/drivers/dri/i965/intel_context.c
+++ /dev/null
@@ -1,911 +0,0 @@
-/**************************************************************************
- * 
- * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- * 
- **************************************************************************/
-
-
-#include "main/glheader.h"
-#include "main/context.h"
-#include "main/extensions.h"
-#include "main/fbobject.h"
-#include "main/framebuffer.h"
-#include "main/imports.h"
-#include "main/renderbuffer.h"
-
-#include "swrast/swrast.h"
-#include "swrast_setup/swrast_setup.h"
-#include "tnl/tnl.h"
-#include "drivers/common/driverfuncs.h"
-#include "drivers/common/meta.h"
-
-#include "intel_chipset.h"
-#include "intel_buffers.h"
-#include "intel_tex.h"
-#include "intel_batchbuffer.h"
-#include "intel_pixel.h"
-#include "intel_regions.h"
-#include "intel_buffer_objects.h"
-#include "intel_fbo.h"
-#include "intel_bufmgr.h"
-#include "intel_screen.h"
-#include "intel_mipmap_tree.h"
-
-#include "utils.h"
-#include "../glsl/ralloc.h"
-
-#ifndef INTEL_DEBUG
-int INTEL_DEBUG = (0);
-#endif
-
-
-static const GLubyte *
-intelGetString(struct gl_context * ctx, GLenum name)
-{
-   const struct brw_context *const brw = brw_context(ctx);
-   const char *chipset;
-   static char buffer[128];
-
-   switch (name) {
-   case GL_VENDOR:
-      return (GLubyte *) "Intel Open Source Technology Center";
-      break;
-
-   case GL_RENDERER:
-      switch (brw->intelScreen->deviceID) {
-#undef CHIPSET
-#define CHIPSET(id, symbol, str) case id: chipset = str; break;
-#include "pci_ids/i965_pci_ids.h"
-      default:
-         chipset = "Unknown Intel Chipset";
-         break;
-      }
-
-      (void) driGetRendererString(buffer, chipset, 0);
-      return (GLubyte *) buffer;
-
-   default:
-      return NULL;
-   }
-}
-
-void
-intel_resolve_for_dri2_flush(struct brw_context *brw,
-                             __DRIdrawable *drawable)
-{
-   if (brw->gen < 6) {
-      /* MSAA and fast color clear are not supported, so don't waste time
-       * checking whether a resolve is needed.
-       */
-      return;
-   }
-
-   struct gl_framebuffer *fb = drawable->driverPrivate;
-   struct intel_renderbuffer *rb;
-
-   /* Usually, only the back buffer will need to be downsampled. However,
-    * the front buffer will also need it if the user has rendered into it.
-    */
-   static const gl_buffer_index buffers[2] = {
-         BUFFER_BACK_LEFT,
-         BUFFER_FRONT_LEFT,
-   };
-
-   for (int i = 0; i < 2; ++i) {
-      rb = intel_get_renderbuffer(fb, buffers[i]);
-      if (rb == NULL || rb->mt == NULL)
-         continue;
-      if (rb->mt->num_samples <= 1)
-         intel_miptree_resolve_color(brw, rb->mt);
-      else
-         intel_miptree_downsample(brw, rb->mt);
-   }
-}
-
-static void
-intel_flush_front(struct gl_context *ctx)
-{
-   struct brw_context *brw = brw_context(ctx);
-    __DRIcontext *driContext = brw->driContext;
-    __DRIdrawable *driDrawable = driContext->driDrawablePriv;
-    __DRIscreen *const screen = brw->intelScreen->driScrnPriv;
-
-    if (brw->front_buffer_dirty && _mesa_is_winsys_fbo(ctx->DrawBuffer)) {
-      if (screen->dri2.loader->flushFrontBuffer != NULL &&
-          driDrawable &&
-          driDrawable->loaderPrivate) {
-
-         /* Resolve before flushing FAKE_FRONT_LEFT to FRONT_LEFT.
-          *
-          * This potentially resolves both front and back buffer. It
-          * is unnecessary to resolve the back, but harms nothing except
-          * performance. And no one cares about front-buffer render
-          * performance.
-          */
-         intel_resolve_for_dri2_flush(brw, driDrawable);
-         intel_batchbuffer_flush(brw);
-
-         screen->dri2.loader->flushFrontBuffer(driDrawable,
-                                               driDrawable->loaderPrivate);
-
-	 /* We set the dirty bit in intel_prepare_render() if we're
-	  * front buffer rendering once we get there.
-	  */
-	 brw->front_buffer_dirty = false;
-      }
-   }
-}
-
-static unsigned
-intel_bits_per_pixel(const struct intel_renderbuffer *rb)
-{
-   return _mesa_get_format_bytes(intel_rb_format(rb)) * 8;
-}
-
-static void
-intel_query_dri2_buffers(struct brw_context *brw,
-			 __DRIdrawable *drawable,
-			 __DRIbuffer **buffers,
-			 int *count);
-
-static void
-intel_process_dri2_buffer(struct brw_context *brw,
-			  __DRIdrawable *drawable,
-			  __DRIbuffer *buffer,
-			  struct intel_renderbuffer *rb,
-			  const char *buffer_name);
-
-void
-intel_update_renderbuffers(__DRIcontext *context, __DRIdrawable *drawable)
-{
-   struct gl_framebuffer *fb = drawable->driverPrivate;
-   struct intel_renderbuffer *rb;
-   struct brw_context *brw = context->driverPrivate;
-   __DRIbuffer *buffers = NULL;
-   int i, count;
-   const char *region_name;
-
-   /* Set this up front, so that in case our buffers get invalidated
-    * while we're getting new buffers, we don't clobber the stamp and
-    * thus ignore the invalidate. */
-   drawable->lastStamp = drawable->dri2.stamp;
-
-   if (unlikely(INTEL_DEBUG & DEBUG_DRI))
-      fprintf(stderr, "enter %s, drawable %p\n", __func__, drawable);
-
-   intel_query_dri2_buffers(brw, drawable, &buffers, &count);
-
-   if (buffers == NULL)
-      return;
-
-   for (i = 0; i < count; i++) {
-       switch (buffers[i].attachment) {
-       case __DRI_BUFFER_FRONT_LEFT:
-	   rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
-	   region_name = "dri2 front buffer";
-	   break;
-
-       case __DRI_BUFFER_FAKE_FRONT_LEFT:
-	   rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
-	   region_name = "dri2 fake front buffer";
-	   break;
-
-       case __DRI_BUFFER_BACK_LEFT:
-	   rb = intel_get_renderbuffer(fb, BUFFER_BACK_LEFT);
-	   region_name = "dri2 back buffer";
-	   break;
-
-       case __DRI_BUFFER_DEPTH:
-       case __DRI_BUFFER_HIZ:
-       case __DRI_BUFFER_DEPTH_STENCIL:
-       case __DRI_BUFFER_STENCIL:
-       case __DRI_BUFFER_ACCUM:
-       default:
-	   fprintf(stderr,
-		   "unhandled buffer attach event, attachment type %d\n",
-		   buffers[i].attachment);
-	   return;
-       }
-
-       intel_process_dri2_buffer(brw, drawable, &buffers[i], rb, region_name);
-   }
-
-   driUpdateFramebufferSize(&brw->ctx, drawable);
-}
-
-/**
- * intel_prepare_render should be called anywhere that curent read/drawbuffer
- * state is required.
- */
-void
-intel_prepare_render(struct brw_context *brw)
-{
-   __DRIcontext *driContext = brw->driContext;
-   __DRIdrawable *drawable;
-
-   drawable = driContext->driDrawablePriv;
-   if (drawable && drawable->dri2.stamp != driContext->dri2.draw_stamp) {
-      if (drawable->lastStamp != drawable->dri2.stamp)
-	 intel_update_renderbuffers(driContext, drawable);
-      driContext->dri2.draw_stamp = drawable->dri2.stamp;
-   }
-
-   drawable = driContext->driReadablePriv;
-   if (drawable && drawable->dri2.stamp != driContext->dri2.read_stamp) {
-      if (drawable->lastStamp != drawable->dri2.stamp)
-	 intel_update_renderbuffers(driContext, drawable);
-      driContext->dri2.read_stamp = drawable->dri2.stamp;
-   }
-
-   /* If we're currently rendering to the front buffer, the rendering
-    * that will happen next will probably dirty the front buffer.  So
-    * mark it as dirty here.
-    */
-   if (brw->is_front_buffer_rendering)
-      brw->front_buffer_dirty = true;
-
-   /* Wait for the swapbuffers before the one we just emitted, so we
-    * don't get too many swaps outstanding for apps that are GPU-heavy
-    * but not CPU-heavy.
-    *
-    * We're using intelDRI2Flush (called from the loader before
-    * swapbuffer) and glFlush (for front buffer rendering) as the
-    * indicator that a frame is done and then throttle when we get
-    * here as we prepare to render the next frame.  At this point for
-    * round trips for swap/copy and getting new buffers are done and
-    * we'll spend less time waiting on the GPU.
-    *
-    * Unfortunately, we don't have a handle to the batch containing
-    * the swap, and getting our hands on that doesn't seem worth it,
-    * so we just us the first batch we emitted after the last swap.
-    */
-   if (brw->need_throttle && brw->first_post_swapbuffers_batch) {
-      if (!brw->disable_throttling)
-         drm_intel_bo_wait_rendering(brw->first_post_swapbuffers_batch);
-      drm_intel_bo_unreference(brw->first_post_swapbuffers_batch);
-      brw->first_post_swapbuffers_batch = NULL;
-      brw->need_throttle = false;
-   }
-}
-
-static void
-intel_viewport(struct gl_context *ctx, GLint x, GLint y, GLsizei w, GLsizei h)
-{
-    struct brw_context *brw = brw_context(ctx);
-    __DRIcontext *driContext = brw->driContext;
-
-    if (brw->saved_viewport)
-	brw->saved_viewport(ctx, x, y, w, h);
-
-    if (_mesa_is_winsys_fbo(ctx->DrawBuffer)) {
-       dri2InvalidateDrawable(driContext->driDrawablePriv);
-       dri2InvalidateDrawable(driContext->driReadablePriv);
-    }
-}
-
-static const struct dri_debug_control debug_control[] = {
-   { "tex",   DEBUG_TEXTURE},
-   { "state", DEBUG_STATE},
-   { "ioctl", DEBUG_IOCTL},
-   { "blit",  DEBUG_BLIT},
-   { "mip",   DEBUG_MIPTREE},
-   { "fall",  DEBUG_PERF},
-   { "perf",  DEBUG_PERF},
-   { "bat",   DEBUG_BATCH},
-   { "pix",   DEBUG_PIXEL},
-   { "buf",   DEBUG_BUFMGR},
-   { "reg",   DEBUG_REGION},
-   { "fbo",   DEBUG_FBO},
-   { "fs",    DEBUG_WM },
-   { "gs",    DEBUG_GS},
-   { "sync",  DEBUG_SYNC},
-   { "prim",  DEBUG_PRIMS },
-   { "vert",  DEBUG_VERTS },
-   { "dri",   DEBUG_DRI },
-   { "sf",    DEBUG_SF },
-   { "stats", DEBUG_STATS },
-   { "wm",    DEBUG_WM },
-   { "urb",   DEBUG_URB },
-   { "vs",    DEBUG_VS },
-   { "clip",  DEBUG_CLIP },
-   { "aub",   DEBUG_AUB },
-   { "shader_time", DEBUG_SHADER_TIME },
-   { "no16",  DEBUG_NO16 },
-   { "blorp", DEBUG_BLORP },
-   { "vue",   DEBUG_VUE },
-   { NULL,    0 }
-};
-
-
-static void
-intelInvalidateState(struct gl_context * ctx, GLuint new_state)
-{
-   struct brw_context *brw = brw_context(ctx);
-
-    if (ctx->swrast_context)
-       _swrast_InvalidateState(ctx, new_state);
-   _vbo_InvalidateState(ctx, new_state);
-
-   brw->NewGLState |= new_state;
-}
-
-static void
-intel_glFlush(struct gl_context *ctx)
-{
-   struct brw_context *brw = brw_context(ctx);
-
-   intel_batchbuffer_flush(brw);
-   intel_flush_front(ctx);
-   if (brw->is_front_buffer_rendering)
-      brw->need_throttle = true;
-}
-
-void
-intelFinish(struct gl_context * ctx)
-{
-   struct brw_context *brw = brw_context(ctx);
-
-   intel_glFlush(ctx);
-
-   if (brw->batch.last_bo)
-      drm_intel_bo_wait_rendering(brw->batch.last_bo);
-}
-
-void
-intelInitDriverFunctions(struct dd_function_table *functions)
-{
-   _mesa_init_driver_functions(functions);
-
-   functions->Flush = intel_glFlush;
-   functions->Finish = intelFinish;
-   functions->GetString = intelGetString;
-   functions->UpdateState = intelInvalidateState;
-
-   intelInitTextureFuncs(functions);
-   intelInitTextureImageFuncs(functions);
-   intelInitTextureSubImageFuncs(functions);
-   intelInitTextureCopyImageFuncs(functions);
-   intelInitClearFuncs(functions);
-   intelInitBufferFuncs(functions);
-   intelInitPixelFuncs(functions);
-   intelInitBufferObjectFuncs(functions);
-   intel_init_syncobj_functions(functions);
-   brw_init_object_purgeable_functions(functions);
-}
-
-static bool
-validate_context_version(struct intel_screen *screen,
-                         int mesa_api,
-                         unsigned major_version,
-                         unsigned minor_version,
-                         unsigned *dri_ctx_error)
-{
-   unsigned req_version = 10 * major_version + minor_version;
-   unsigned max_version = 0;
-
-   switch (mesa_api) {
-   case API_OPENGL_COMPAT:
-      max_version = screen->max_gl_compat_version;
-      break;
-   case API_OPENGL_CORE:
-      max_version = screen->max_gl_core_version;
-      break;
-   case API_OPENGLES:
-      max_version = screen->max_gl_es1_version;
-      break;
-   case API_OPENGLES2:
-      max_version = screen->max_gl_es2_version;
-      break;
-   default:
-      max_version = 0;
-      break;
-   }
-
-   if (max_version == 0) {
-      *dri_ctx_error = __DRI_CTX_ERROR_BAD_API;
-      return false;
-   } else if (req_version > max_version) {
-      *dri_ctx_error = __DRI_CTX_ERROR_BAD_VERSION;
-      return false;
-   }
-
-   return true;
-}
-
-bool
-intelInitContext(struct brw_context *brw,
-                 int api,
-                 unsigned major_version,
-                 unsigned minor_version,
-                 const struct gl_config * mesaVis,
-                 __DRIcontext * driContextPriv,
-                 void *sharedContextPrivate,
-                 struct dd_function_table *functions,
-                 unsigned *dri_ctx_error)
-{
-   struct gl_context *ctx = &brw->ctx;
-   struct gl_context *shareCtx = (struct gl_context *) sharedContextPrivate;
-   __DRIscreen *sPriv = driContextPriv->driScreenPriv;
-   struct intel_screen *intelScreen = sPriv->driverPrivate;
-   int bo_reuse_mode;
-   struct gl_config visual;
-
-   /* we can't do anything without a connection to the device */
-   if (intelScreen->bufmgr == NULL) {
-      *dri_ctx_error = __DRI_CTX_ERROR_NO_MEMORY;
-      return false;
-   }
-
-   if (!validate_context_version(intelScreen,
-                                 api, major_version, minor_version,
-                                 dri_ctx_error))
-      return false;
-
-   /* Can't rely on invalidate events, fall back to glViewport hack */
-   if (!driContextPriv->driScreenPriv->dri2.useInvalidate) {
-      brw->saved_viewport = functions->Viewport;
-      functions->Viewport = intel_viewport;
-   }
-
-   if (mesaVis == NULL) {
-      memset(&visual, 0, sizeof visual);
-      mesaVis = &visual;
-   }
-
-   brw->intelScreen = intelScreen;
-   brw->bufmgr = intelScreen->bufmgr;
-
-   if (!_mesa_initialize_context(&brw->ctx, api, mesaVis, shareCtx,
-                                 functions)) {
-      *dri_ctx_error = __DRI_CTX_ERROR_NO_MEMORY;
-      printf("%s: failed to init mesa context\n", __FUNCTION__);
-      return false;
-   }
-
-   driContextPriv->driverPrivate = brw;
-   brw->driContext = driContextPriv;
-
-   brw->gen = intelScreen->gen;
-
-   const int devID = intelScreen->deviceID;
-   if (IS_SNB_GT1(devID) || IS_IVB_GT1(devID) || IS_HSW_GT1(devID))
-      brw->gt = 1;
-   else if (IS_SNB_GT2(devID) || IS_IVB_GT2(devID) || IS_HSW_GT2(devID))
-      brw->gt = 2;
-   else if (IS_HSW_GT3(devID))
-      brw->gt = 3;
-   else
-      brw->gt = 0;
-
-   if (IS_HASWELL(devID)) {
-      brw->is_haswell = true;
-   } else if (IS_BAYTRAIL(devID)) {
-      brw->is_baytrail = true;
-      brw->gt = 1;
-   } else if (IS_G4X(devID)) {
-      brw->is_g4x = true;
-   }
-
-   brw->has_separate_stencil = brw->intelScreen->hw_has_separate_stencil;
-   brw->must_use_separate_stencil = brw->intelScreen->hw_must_use_separate_stencil;
-   brw->has_hiz = brw->gen >= 6;
-   brw->has_llc = brw->intelScreen->hw_has_llc;
-   brw->has_swizzling = brw->intelScreen->hw_has_swizzling;
-
-   memset(&ctx->TextureFormatSupported,
-	  0, sizeof(ctx->TextureFormatSupported));
-
-   driParseConfigFiles(&brw->optionCache, &intelScreen->optionCache,
-                       sPriv->myNum, "i965");
-
-   /* Estimate the size of the mappable aperture into the GTT.  There's an
-    * ioctl to get the whole GTT size, but not one to get the mappable subset.
-    * It turns out it's basically always 256MB, though some ancient hardware
-    * was smaller.
-    */
-   uint32_t gtt_size = 256 * 1024 * 1024;
-
-   /* We don't want to map two objects such that a memcpy between them would
-    * just fault one mapping in and then the other over and over forever.  So
-    * we would need to divide the GTT size by 2.  Additionally, some GTT is
-    * taken up by things like the framebuffer and the ringbuffer and such, so
-    * be more conservative.
-    */
-   brw->max_gtt_map_object_size = gtt_size / 4;
-
-   bo_reuse_mode = driQueryOptioni(&brw->optionCache, "bo_reuse");
-   switch (bo_reuse_mode) {
-   case DRI_CONF_BO_REUSE_DISABLED:
-      break;
-   case DRI_CONF_BO_REUSE_ALL:
-      intel_bufmgr_gem_enable_reuse(brw->bufmgr);
-      break;
-   }
-
-   /* Initialize the software rasterizer and helper modules.
-    *
-    * As of GL 3.1 core, the gen4+ driver doesn't need the swrast context for
-    * software fallbacks (which we have to support on legacy GL to do weird
-    * glDrawPixels(), glBitmap(), and other functions).
-    */
-   if (api != API_OPENGL_CORE && api != API_OPENGLES2) {
-      _swrast_CreateContext(ctx);
-   }
-
-   _vbo_CreateContext(ctx);
-   if (ctx->swrast_context) {
-      _tnl_CreateContext(ctx);
-      _swsetup_CreateContext(ctx);
-
-      /* Configure swrast to match hardware characteristics: */
-      _swrast_allow_pixel_fog(ctx, false);
-      _swrast_allow_vertex_fog(ctx, true);
-   }
-
-   _mesa_meta_init(ctx);
-
-   intelInitExtensions(ctx);
-
-   INTEL_DEBUG = driParseDebugString(getenv("INTEL_DEBUG"), debug_control);
-   if (INTEL_DEBUG & DEBUG_BUFMGR)
-      dri_bufmgr_set_debug(brw->bufmgr, true);
-   if ((INTEL_DEBUG & DEBUG_SHADER_TIME) && brw->gen < 7) {
-      fprintf(stderr,
-              "shader_time debugging requires gen7 (Ivybridge) or better.\n");
-      INTEL_DEBUG &= ~DEBUG_SHADER_TIME;
-   }
-   if (INTEL_DEBUG & DEBUG_PERF)
-      brw->perf_debug = true;
-
-   if (INTEL_DEBUG & DEBUG_AUB)
-      drm_intel_bufmgr_gem_set_aub_dump(brw->bufmgr, true);
-
-   intel_batchbuffer_init(brw);
-
-   intel_fbo_init(brw);
-
-   if (!driQueryOptionb(&brw->optionCache, "hiz")) {
-       brw->has_hiz = false;
-       /* On gen6, you can only do separate stencil with HIZ. */
-       if (brw->gen == 6)
-	  brw->has_separate_stencil = false;
-   }
-
-   if (driQueryOptionb(&brw->optionCache, "always_flush_batch")) {
-      fprintf(stderr, "flushing batchbuffer before/after each draw call\n");
-      brw->always_flush_batch = 1;
-   }
-
-   if (driQueryOptionb(&brw->optionCache, "always_flush_cache")) {
-      fprintf(stderr, "flushing GPU caches before/after each draw call\n");
-      brw->always_flush_cache = 1;
-   }
-
-   if (driQueryOptionb(&brw->optionCache, "disable_throttling")) {
-      fprintf(stderr, "disabling flush throttling\n");
-      brw->disable_throttling = 1;
-   }
-
-   return true;
-}
-
-void
-intelDestroyContext(__DRIcontext * driContextPriv)
-{
-   struct brw_context *brw =
-      (struct brw_context *) driContextPriv->driverPrivate;
-   struct gl_context *ctx = &brw->ctx;
-
-   assert(brw); /* should never be null */
-   if (brw) {
-      /* Dump a final BMP in case the application doesn't call SwapBuffers */
-      if (INTEL_DEBUG & DEBUG_AUB) {
-         intel_batchbuffer_flush(brw);
-	 aub_dump_bmp(&brw->ctx);
-      }
-
-      _mesa_meta_free(&brw->ctx);
-
-      brw->vtbl.destroy(brw);
-
-      if (ctx->swrast_context) {
-         _swsetup_DestroyContext(&brw->ctx);
-         _tnl_DestroyContext(&brw->ctx);
-      }
-      _vbo_DestroyContext(&brw->ctx);
-
-      if (ctx->swrast_context)
-         _swrast_DestroyContext(&brw->ctx);
-
-      intel_batchbuffer_free(brw);
-
-      drm_intel_bo_unreference(brw->first_post_swapbuffers_batch);
-      brw->first_post_swapbuffers_batch = NULL;
-
-      driDestroyOptionCache(&brw->optionCache);
-
-      /* free the Mesa context */
-      _mesa_free_context_data(&brw->ctx);
-
-      ralloc_free(brw);
-      driContextPriv->driverPrivate = NULL;
-   }
-}
-
-GLboolean
-intelUnbindContext(__DRIcontext * driContextPriv)
-{
-   /* Unset current context and dispath table */
-   _mesa_make_current(NULL, NULL, NULL);
-
-   return true;
-}
-
-/**
- * Fixes up the context for GLES23 with our default-to-sRGB-capable behavior
- * on window system framebuffers.
- *
- * Desktop GL is fairly reasonable in its handling of sRGB: You can ask if
- * your renderbuffer can do sRGB encode, and you can flip a switch that does
- * sRGB encode if the renderbuffer can handle it.  You can ask specifically
- * for a visual where you're guaranteed to be capable, but it turns out that
- * everyone just makes all their ARGB8888 visuals capable and doesn't offer
- * incapable ones, becuase there's no difference between the two in resources
- * used.  Applications thus get built that accidentally rely on the default
- * visual choice being sRGB, so we make ours sRGB capable.  Everything sounds
- * great...
- *
- * But for GLES2/3, they decided that it was silly to not turn on sRGB encode
- * for sRGB renderbuffers you made with the GL_EXT_texture_sRGB equivalent.
- * So they removed the enable knob and made it "if the renderbuffer is sRGB
- * capable, do sRGB encode".  Then, for your window system renderbuffers, you
- * can ask for sRGB visuals and get sRGB encode, or not ask for sRGB visuals
- * and get no sRGB encode (assuming that both kinds of visual are available).
- * Thus our choice to support sRGB by default on our visuals for desktop would
- * result in broken rendering of GLES apps that aren't expecting sRGB encode.
- *
- * Unfortunately, renderbuffer setup happens before a context is created.  So
- * in intel_screen.c we always set up sRGB, and here, if you're a GLES2/3
- * context (without an sRGB visual, though we don't have sRGB visuals exposed
- * yet), we go turn that back off before anyone finds out.
- */
-static void
-intel_gles3_srgb_workaround(struct brw_context *brw,
-                            struct gl_framebuffer *fb)
-{
-   struct gl_context *ctx = &brw->ctx;
-
-   if (_mesa_is_desktop_gl(ctx) || !fb->Visual.sRGBCapable)
-      return;
-
-   /* Some day when we support the sRGB capable bit on visuals available for
-    * GLES, we'll need to respect that and not disable things here.
-    */
-   fb->Visual.sRGBCapable = false;
-   for (int i = 0; i < BUFFER_COUNT; i++) {
-      if (fb->Attachment[i].Renderbuffer &&
-          fb->Attachment[i].Renderbuffer->Format == MESA_FORMAT_SARGB8) {
-         fb->Attachment[i].Renderbuffer->Format = MESA_FORMAT_ARGB8888;
-      }
-   }
-}
-
-GLboolean
-intelMakeCurrent(__DRIcontext * driContextPriv,
-                 __DRIdrawable * driDrawPriv,
-                 __DRIdrawable * driReadPriv)
-{
-   struct brw_context *brw;
-   GET_CURRENT_CONTEXT(curCtx);
-
-   if (driContextPriv)
-      brw = (struct brw_context *) driContextPriv->driverPrivate;
-   else
-      brw = NULL;
-
-   /* According to the glXMakeCurrent() man page: "Pending commands to
-    * the previous context, if any, are flushed before it is released."
-    * But only flush if we're actually changing contexts.
-    */
-   if (brw_context(curCtx) && brw_context(curCtx) != brw) {
-      _mesa_flush(curCtx);
-   }
-
-   if (driContextPriv) {
-      struct gl_context *ctx = &brw->ctx;
-      struct gl_framebuffer *fb, *readFb;
-      
-      if (driDrawPriv == NULL && driReadPriv == NULL) {
-	 fb = _mesa_get_incomplete_framebuffer();
-	 readFb = _mesa_get_incomplete_framebuffer();
-      } else {
-	 fb = driDrawPriv->driverPrivate;
-	 readFb = driReadPriv->driverPrivate;
-	 driContextPriv->dri2.draw_stamp = driDrawPriv->dri2.stamp - 1;
-	 driContextPriv->dri2.read_stamp = driReadPriv->dri2.stamp - 1;
-      }
-
-      /* The sRGB workaround changes the renderbuffer's format. We must change
-       * the format before the renderbuffer's miptree get's allocated, otherwise
-       * the formats of the renderbuffer and its miptree will differ.
-       */
-      intel_gles3_srgb_workaround(brw, fb);
-      intel_gles3_srgb_workaround(brw, readFb);
-
-      intel_prepare_render(brw);
-      _mesa_make_current(ctx, fb, readFb);
-   }
-   else {
-      _mesa_make_current(NULL, NULL, NULL);
-   }
-
-   return true;
-}
-
-/**
- * \brief Query DRI2 to obtain a DRIdrawable's buffers.
- *
- * To determine which DRI buffers to request, examine the renderbuffers
- * attached to the drawable's framebuffer. Then request the buffers with
- * DRI2GetBuffers() or DRI2GetBuffersWithFormat().
- *
- * This is called from intel_update_renderbuffers().
- *
- * \param drawable      Drawable whose buffers are queried.
- * \param buffers       [out] List of buffers returned by DRI2 query.
- * \param buffer_count  [out] Number of buffers returned.
- *
- * \see intel_update_renderbuffers()
- * \see DRI2GetBuffers()
- * \see DRI2GetBuffersWithFormat()
- */
-static void
-intel_query_dri2_buffers(struct brw_context *brw,
-			 __DRIdrawable *drawable,
-			 __DRIbuffer **buffers,
-			 int *buffer_count)
-{
-   __DRIscreen *screen = brw->intelScreen->driScrnPriv;
-   struct gl_framebuffer *fb = drawable->driverPrivate;
-   int i = 0;
-   unsigned attachments[8];
-
-   struct intel_renderbuffer *front_rb;
-   struct intel_renderbuffer *back_rb;
-
-   front_rb = intel_get_renderbuffer(fb, BUFFER_FRONT_LEFT);
-   back_rb = intel_get_renderbuffer(fb, BUFFER_BACK_LEFT);
-
-   memset(attachments, 0, sizeof(attachments));
-   if ((brw->is_front_buffer_rendering ||
-	brw->is_front_buffer_reading ||
-	!back_rb) && front_rb) {
-      /* If a fake front buffer is in use, then querying for
-       * __DRI_BUFFER_FRONT_LEFT will cause the server to copy the image from
-       * the real front buffer to the fake front buffer.  So before doing the
-       * query, we need to make sure all the pending drawing has landed in the
-       * real front buffer.
-       */
-      intel_batchbuffer_flush(brw);
-      intel_flush_front(&brw->ctx);
-
-      attachments[i++] = __DRI_BUFFER_FRONT_LEFT;
-      attachments[i++] = intel_bits_per_pixel(front_rb);
-   } else if (front_rb && brw->front_buffer_dirty) {
-      /* We have pending front buffer rendering, but we aren't querying for a
-       * front buffer.  If the front buffer we have is a fake front buffer,
-       * the X server is going to throw it away when it processes the query.
-       * So before doing the query, make sure all the pending drawing has
-       * landed in the real front buffer.
-       */
-      intel_batchbuffer_flush(brw);
-      intel_flush_front(&brw->ctx);
-   }
-
-   if (back_rb) {
-      attachments[i++] = __DRI_BUFFER_BACK_LEFT;
-      attachments[i++] = intel_bits_per_pixel(back_rb);
-   }
-
-   assert(i <= ARRAY_SIZE(attachments));
-
-   *buffers = screen->dri2.loader->getBuffersWithFormat(drawable,
-							&drawable->w,
-							&drawable->h,
-							attachments, i / 2,
-							buffer_count,
-							drawable->loaderPrivate);
-}
-
-/**
- * \brief Assign a DRI buffer's DRM region to a renderbuffer.
- *
- * This is called from intel_update_renderbuffers().
- *
- * \par Note:
- *    DRI buffers whose attachment point is DRI2BufferStencil or
- *    DRI2BufferDepthStencil are handled as special cases.
- *
- * \param buffer_name is a human readable name, such as "dri2 front buffer",
- *        that is passed to intel_region_alloc_for_handle().
- *
- * \see intel_update_renderbuffers()
- * \see intel_region_alloc_for_handle()
- */
-static void
-intel_process_dri2_buffer(struct brw_context *brw,
-			  __DRIdrawable *drawable,
-			  __DRIbuffer *buffer,
-			  struct intel_renderbuffer *rb,
-			  const char *buffer_name)
-{
-   struct intel_region *region = NULL;
-
-   if (!rb)
-      return;
-
-   unsigned num_samples = rb->Base.Base.NumSamples;
-
-   /* We try to avoid closing and reopening the same BO name, because the first
-    * use of a mapping of the buffer involves a bunch of page faulting which is
-    * moderately expensive.
-    */
-   if (num_samples == 0) {
-       if (rb->mt &&
-           rb->mt->region &&
-           rb->mt->region->name == buffer->name)
-          return;
-   } else {
-       if (rb->mt &&
-           rb->mt->singlesample_mt &&
-           rb->mt->singlesample_mt->region &&
-           rb->mt->singlesample_mt->region->name == buffer->name)
-          return;
-   }
-
-   if (unlikely(INTEL_DEBUG & DEBUG_DRI)) {
-      fprintf(stderr,
-	      "attaching buffer %d, at %d, cpp %d, pitch %d\n",
-	      buffer->name, buffer->attachment,
-	      buffer->cpp, buffer->pitch);
-   }
-
-   intel_miptree_release(&rb->mt);
-   region = intel_region_alloc_for_handle(brw->intelScreen,
-                                          buffer->cpp,
-                                          drawable->w,
-                                          drawable->h,
-                                          buffer->pitch,
-                                          buffer->name,
-                                          buffer_name);
-   if (!region)
-      return;
-
-   rb->mt = intel_miptree_create_for_dri2_buffer(brw,
-                                                 buffer->attachment,
-                                                 intel_rb_format(rb),
-                                                 num_samples,
-                                                 region);
-   intel_region_release(&region);
-}
diff --git a/src/mesa/drivers/dri/i965/intel_context.h b/src/mesa/drivers/dri/i965/intel_context.h
deleted file mode 100644
index f35dafa..0000000
--- a/src/mesa/drivers/dri/i965/intel_context.h
+++ /dev/null
@@ -1,291 +0,0 @@
-/**************************************************************************
- * 
- * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
- * All Rights Reserved.
- * 
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the
- * "Software"), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sub license, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice (including the
- * next paragraph) shall be included in all copies or substantial portions
- * of the Software.
- * 
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
- * IN NO EVENT SHALL TUNGSTEN GRAPHICS AND/OR ITS SUPPLIERS BE LIABLE FOR
- * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
- * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- * 
- **************************************************************************/
-
-#ifndef INTELCONTEXT_INC
-#define INTELCONTEXT_INC
-
-
-#include <stdbool.h>
-#include <string.h>
-#include "main/mtypes.h"
-#include "main/mm.h"
-
-#ifdef __cplusplus
-extern "C" {
-	/* Evil hack for using libdrm in a c++ compiler. */
-	#define virtual virt
-#endif
-
-#include "drm.h"
-#include "intel_bufmgr.h"
-
-#include "intel_screen.h"
-#include "intel_tex_obj.h"
-#include "i915_drm.h"
-
-#ifdef __cplusplus
-	#undef virtual
-#endif
-
-#include "tnl/t_vertex.h"
-
-struct intel_region;
-
-#define INTEL_WRITE_PART  0x1
-#define INTEL_WRITE_FULL  0x2
-#define INTEL_READ        0x4
-
-#ifndef likely
-#ifdef __GNUC__
-#define likely(expr) (__builtin_expect(expr, 1))
-#define unlikely(expr) (__builtin_expect(expr, 0))
-#else
-#define likely(expr) (expr)
-#define unlikely(expr) (expr)
-#endif
-#endif
-
-struct intel_sync_object {
-   struct gl_sync_object Base;
-
-   /** Batch associated with this sync object */
-   drm_intel_bo *bo;
-};
-
-struct brw_context;
-
-struct intel_batchbuffer {
-   /** Current batchbuffer being queued up. */
-   drm_intel_bo *bo;
-   /** Last BO submitted to the hardware.  Used for glFinish(). */
-   drm_intel_bo *last_bo;
-   /** BO for post-sync nonzero writes for gen6 workaround. */
-   drm_intel_bo *workaround_bo;
-   bool need_workaround_flush;
-
-   struct cached_batch_item *cached_items;
-
-   uint16_t emit, total;
-   uint16_t used, reserved_space;
-   uint32_t *map;
-   uint32_t *cpu_map;
-#define BATCH_SZ (8192*sizeof(uint32_t))
-
-   uint32_t state_batch_offset;
-   bool is_blit;
-   bool needs_sol_reset;
-
-   struct {
-      uint16_t used;
-      int reloc_count;
-   } saved;
-};
-
-/**
- * Align a value down to an alignment value
- *
- * If \c value is not already aligned to the requested alignment value, it
- * will be rounded down.
- *
- * \param value  Value to be rounded
- * \param alignment  Alignment value to be used.  This must be a power of two.
- *
- * \sa ALIGN()
- */
-#define ROUND_DOWN_TO(value, alignment) ((value) & ~(alignment - 1))
-
-static INLINE uint32_t
-U_FIXED(float value, uint32_t frac_bits)
-{
-   value *= (1 << frac_bits);
-   return value < 0 ? 0 : value;
-}
-
-static INLINE uint32_t
-S_FIXED(float value, uint32_t frac_bits)
-{
-   return value * (1 << frac_bits);
-}
-
-/* ================================================================
- * From linux kernel i386 header files, copes with odd sizes better
- * than COPY_DWORDS would:
- * XXX Put this in src/mesa/main/imports.h ???
- */
-#if defined(i386) || defined(__i386__)
-static INLINE void * __memcpy(void * to, const void * from, size_t n)
-{
-   int d0, d1, d2;
-   __asm__ __volatile__(
-      "rep ; movsl\n\t"
-      "testb $2,%b4\n\t"
-      "je 1f\n\t"
-      "movsw\n"
-      "1:\ttestb $1,%b4\n\t"
-      "je 2f\n\t"
-      "movsb\n"
-      "2:"
-      : "=&c" (d0), "=&D" (d1), "=&S" (d2)
-      :"0" (n/4), "q" (n),"1" ((long) to),"2" ((long) from)
-      : "memory");
-   return (to);
-}
-#else
-#define __memcpy(a,b,c) memcpy(a,b,c)
-#endif
-
-
-/* ================================================================
- * Debugging:
- */
-extern int INTEL_DEBUG;
-
-#define DEBUG_TEXTURE	0x1
-#define DEBUG_STATE	0x2
-#define DEBUG_IOCTL	0x4
-#define DEBUG_BLIT	0x8
-#define DEBUG_MIPTREE   0x10
-#define DEBUG_PERF	0x20
-#define DEBUG_BATCH     0x80
-#define DEBUG_PIXEL     0x100
-#define DEBUG_BUFMGR    0x200
-#define DEBUG_REGION    0x400
-#define DEBUG_FBO       0x800
-#define DEBUG_GS        0x1000
-#define DEBUG_SYNC	0x2000
-#define DEBUG_PRIMS	0x4000
-#define DEBUG_VERTS	0x8000
-#define DEBUG_DRI       0x10000
-#define DEBUG_SF        0x20000
-#define DEBUG_STATS     0x100000
-#define DEBUG_WM        0x400000
-#define DEBUG_URB       0x800000
-#define DEBUG_VS        0x1000000
-#define DEBUG_CLIP      0x2000000
-#define DEBUG_AUB       0x4000000
-#define DEBUG_SHADER_TIME 0x8000000
-#define DEBUG_BLORP     0x10000000
-#define DEBUG_NO16      0x20000000
-#define DEBUG_VUE       0x40000000
-
-#ifdef HAVE_ANDROID_PLATFORM
-#define LOG_TAG "INTEL-MESA"
-#include <cutils/log.h>
-#ifndef ALOGW
-#define ALOGW LOGW
-#endif
-#define dbg_printf(...)	ALOGW(__VA_ARGS__)
-#else
-#define dbg_printf(...)	printf(__VA_ARGS__)
-#endif /* HAVE_ANDROID_PLATFORM */
-
-#define DBG(...) do {						\
-	if (unlikely(INTEL_DEBUG & FILE_DEBUG_FLAG))		\
-		dbg_printf(__VA_ARGS__);			\
-} while(0)
-
-#define perf_debug(...) do {					\
-   static GLuint msg_id = 0;                                    \
-   if (unlikely(INTEL_DEBUG & DEBUG_PERF))                      \
-      dbg_printf(__VA_ARGS__);                                  \
-   if (brw->perf_debug)                                         \
-      _mesa_gl_debug(&brw->ctx, &msg_id,                        \
-                     MESA_DEBUG_TYPE_PERFORMANCE,               \
-                     MESA_DEBUG_SEVERITY_MEDIUM,                \
-                     __VA_ARGS__);                              \
-} while(0)
-
-#define WARN_ONCE(cond, fmt...) do {                            \
-   if (unlikely(cond)) {                                        \
-      static bool _warned = false;                              \
-      static GLuint msg_id = 0;                                 \
-      if (!_warned) {                                           \
-         fprintf(stderr, "WARNING: ");                          \
-         fprintf(stderr, fmt);                                  \
-         _warned = true;                                        \
-                                                                \
-         _mesa_gl_debug(ctx, &msg_id,                           \
-                        MESA_DEBUG_TYPE_OTHER,                  \
-                        MESA_DEBUG_SEVERITY_HIGH, fmt);         \
-      }                                                         \
-   }                                                            \
-} while (0)
-
-/* ================================================================
- * intel_context.c:
- */
-
-extern bool intelInitContext(struct brw_context *brw,
-                             int api,
-                             unsigned major_version,
-                             unsigned minor_version,
-                             const struct gl_config * mesaVis,
-                             __DRIcontext * driContextPriv,
-                             void *sharedContextPrivate,
-                             struct dd_function_table *functions,
-                             unsigned *dri_ctx_error);
-
-extern void intelFinish(struct gl_context * ctx);
-
-extern void intelInitDriverFunctions(struct dd_function_table *functions);
-
-void intel_init_syncobj_functions(struct dd_function_table *functions);
-
-enum {
-   DRI_CONF_BO_REUSE_DISABLED,
-   DRI_CONF_BO_REUSE_ALL
-};
-
-extern int intel_translate_shadow_compare_func(GLenum func);
-extern int intel_translate_compare_func(GLenum func);
-extern int intel_translate_stencil_op(GLenum op);
-extern int intel_translate_logic_op(GLenum opcode);
-
-void intel_update_renderbuffers(__DRIcontext *context,
-				__DRIdrawable *drawable);
-void intel_prepare_render(struct brw_context *brw);
-
-void
-intel_resolve_for_dri2_flush(struct brw_context *brw,
-                             __DRIdrawable *drawable);
-
-extern void
-intelInitExtensions(struct gl_context *ctx);
-extern void
-intelInitClearFuncs(struct dd_function_table *functions);
-
-static INLINE bool
-is_power_of_two(uint32_t value)
-{
-   return (value & (value - 1)) == 0;
-}
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/src/mesa/drivers/dri/i965/intel_debug.c b/src/mesa/drivers/dri/i965/intel_debug.c
new file mode 100644
index 0000000..03abdfa
--- /dev/null
+++ b/src/mesa/drivers/dri/i965/intel_debug.c
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * Copyright © 2006 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ */
+
+/**
+ * \file intel_debug.c
+ *
+ * Support for the INTEL_DEBUG environment variable, along with other
+ * miscellaneous debugging code.
+ */
+
+#include "brw_context.h"
+#include "intel_debug.h"
+#include "utils.h"
+
+int INTEL_DEBUG = 0;
+
+static const struct dri_debug_control debug_control[] = {
+   { "tex",   DEBUG_TEXTURE},
+   { "state", DEBUG_STATE},
+   { "ioctl", DEBUG_IOCTL},
+   { "blit",  DEBUG_BLIT},
+   { "mip",   DEBUG_MIPTREE},
+   { "fall",  DEBUG_PERF},
+   { "perf",  DEBUG_PERF},
+   { "bat",   DEBUG_BATCH},
+   { "pix",   DEBUG_PIXEL},
+   { "buf",   DEBUG_BUFMGR},
+   { "reg",   DEBUG_REGION},
+   { "fbo",   DEBUG_FBO},
+   { "fs",    DEBUG_WM },
+   { "gs",    DEBUG_GS},
+   { "sync",  DEBUG_SYNC},
+   { "prim",  DEBUG_PRIMS },
+   { "vert",  DEBUG_VERTS },
+   { "dri",   DEBUG_DRI },
+   { "sf",    DEBUG_SF },
+   { "stats", DEBUG_STATS },
+   { "wm",    DEBUG_WM },
+   { "urb",   DEBUG_URB },
+   { "vs",    DEBUG_VS },
+   { "clip",  DEBUG_CLIP },
+   { "aub",   DEBUG_AUB },
+   { "shader_time", DEBUG_SHADER_TIME },
+   { "no16",  DEBUG_NO16 },
+   { "blorp", DEBUG_BLORP },
+   { NULL,    0 }
+};
+
+void
+brw_process_intel_debug_variable(struct brw_context *brw)
+{
+   INTEL_DEBUG = driParseDebugString(getenv("INTEL_DEBUG"), debug_control);
+   if (INTEL_DEBUG & DEBUG_BUFMGR)
+      dri_bufmgr_set_debug(brw->bufmgr, true);
+
+   if ((INTEL_DEBUG & DEBUG_SHADER_TIME) && brw->gen < 7) {
+      fprintf(stderr,
+              "shader_time debugging requires gen7 (Ivybridge) or better.\n");
+      INTEL_DEBUG &= ~DEBUG_SHADER_TIME;
+   }
+
+   if (INTEL_DEBUG & DEBUG_PERF)
+      brw->perf_debug = true;
+
+   if (INTEL_DEBUG & DEBUG_AUB)
+      drm_intel_bufmgr_gem_set_aub_dump(brw->bufmgr, true);
+}
diff --git a/src/mesa/drivers/dri/i965/intel_debug.h b/src/mesa/drivers/dri/i965/intel_debug.h
new file mode 100644
index 0000000..486a8d6
--- /dev/null
+++ b/src/mesa/drivers/dri/i965/intel_debug.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright 2003 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * Copyright © 2007 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER(S) AND/OR ITS SUPPLIERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+#pragma once
+
+/**
+ * \file intel_debug.h
+ *
+ * Basic INTEL_DEBUG environment variable handling.  This file defines the
+ * list of debugging flags, as well as some macros for handling them.
+ */
+
+extern int INTEL_DEBUG;
+
+#define DEBUG_TEXTURE	  0x1
+#define DEBUG_STATE	  0x2
+#define DEBUG_IOCTL	  0x4
+#define DEBUG_BLIT	  0x8
+#define DEBUG_MIPTREE     0x10
+#define DEBUG_PERF	  0x20
+#define DEBUG_BATCH       0x80
+#define DEBUG_PIXEL       0x100
+#define DEBUG_BUFMGR      0x200
+#define DEBUG_REGION      0x400
+#define DEBUG_FBO         0x800
+#define DEBUG_GS          0x1000
+#define DEBUG_SYNC	  0x2000
+#define DEBUG_PRIMS	  0x4000
+#define DEBUG_VERTS	  0x8000
+#define DEBUG_DRI         0x10000
+#define DEBUG_SF          0x20000
+#define DEBUG_STATS       0x100000
+#define DEBUG_WM          0x400000
+#define DEBUG_URB         0x800000
+#define DEBUG_VS          0x1000000
+#define DEBUG_CLIP        0x2000000
+#define DEBUG_AUB         0x4000000
+#define DEBUG_SHADER_TIME 0x8000000
+#define DEBUG_BLORP       0x10000000
+#define DEBUG_NO16        0x20000000
+#define DEBUG_VUE         0x40000000
+
+#ifdef HAVE_ANDROID_PLATFORM
+#define LOG_TAG "INTEL-MESA"
+#include <cutils/log.h>
+#ifndef ALOGW
+#define ALOGW LOGW
+#endif
+#define dbg_printf(...)	ALOGW(__VA_ARGS__)
+#else
+#define dbg_printf(...)	printf(__VA_ARGS__)
+#endif /* HAVE_ANDROID_PLATFORM */
+
+#define DBG(...) do {						\
+	if (unlikely(INTEL_DEBUG & FILE_DEBUG_FLAG))		\
+		dbg_printf(__VA_ARGS__);			\
+} while(0)
+
+#define perf_debug(...) do {					\
+   static GLuint msg_id = 0;                                    \
+   if (unlikely(INTEL_DEBUG & DEBUG_PERF))                      \
+      dbg_printf(__VA_ARGS__);                                  \
+   if (brw->perf_debug)                                         \
+      _mesa_gl_debug(&brw->ctx, &msg_id,                        \
+                     MESA_DEBUG_TYPE_PERFORMANCE,               \
+                     MESA_DEBUG_SEVERITY_MEDIUM,                \
+                     __VA_ARGS__);                              \
+} while(0)
+
+#define WARN_ONCE(cond, fmt...) do {                            \
+   if (unlikely(cond)) {                                        \
+      static bool _warned = false;                              \
+      static GLuint msg_id = 0;                                 \
+      if (!_warned) {                                           \
+         fprintf(stderr, "WARNING: ");                          \
+         fprintf(stderr, fmt);                                  \
+         _warned = true;                                        \
+                                                                \
+         _mesa_gl_debug(ctx, &msg_id,                           \
+                        MESA_DEBUG_TYPE_OTHER,                  \
+                        MESA_DEBUG_SEVERITY_HIGH, fmt);         \
+      }                                                         \
+   }                                                            \
+} while (0)
+
+struct brw_context;
+
+extern void brw_process_intel_debug_variable(struct brw_context *brw);
diff --git a/src/mesa/drivers/dri/i965/intel_extensions.c b/src/mesa/drivers/dri/i965/intel_extensions.c
index 0502a48..803d090 100644
--- a/src/mesa/drivers/dri/i965/intel_extensions.c
+++ b/src/mesa/drivers/dri/i965/intel_extensions.c
@@ -125,7 +125,9 @@ intelInitExtensions(struct gl_context *ctx)
    ctx->Extensions.OES_standard_derivatives = true;
    ctx->Extensions.OES_EGL_image_external = true;
 
-   if (brw->gen >= 6)
+   if (brw->gen >= 7)
+      ctx->Const.GLSLVersion = 330;
+   else if (brw->gen >= 6)
       ctx->Const.GLSLVersion = 140;
    else
       ctx->Const.GLSLVersion = 120;
@@ -158,6 +160,7 @@ intelInitExtensions(struct gl_context *ctx)
       ctx->Extensions.ARB_texture_query_lod = true;
       ctx->Extensions.EXT_timer_query = true;
       ctx->Extensions.EXT_shader_integer_mix = ctx->Const.GLSLVersion >= 130;
+      ctx->Extensions.ARB_texture_query_levels = ctx->Const.GLSLVersion >= 130;
    }
 
    if (brw->gen == 5)
@@ -165,6 +168,7 @@ intelInitExtensions(struct gl_context *ctx)
 
    if (brw->gen >= 7) {
       ctx->Extensions.ARB_texture_gather = true;
+      ctx->Extensions.ARB_conservative_depth = true;
    }
 
    if (ctx->API == API_OPENGL_CORE)
diff --git a/src/mesa/drivers/dri/i965/intel_fbo.c b/src/mesa/drivers/dri/i965/intel_fbo.c
index 1692325..ddecb2b 100644
--- a/src/mesa/drivers/dri/i965/intel_fbo.c
+++ b/src/mesa/drivers/dri/i965/intel_fbo.c
@@ -159,7 +159,7 @@ intel_unmap_renderbuffer(struct gl_context *ctx,
 unsigned
 intel_quantize_num_samples(struct intel_screen *intel, unsigned num_samples)
 {
-   switch (intel->gen) {
+   switch (intel->devinfo->gen) {
    case 6:
       /* Gen6 supports only 4x multisampling. */
       if (num_samples > 0)
diff --git a/src/mesa/drivers/dri/i965/intel_screen.c b/src/mesa/drivers/dri/i965/intel_screen.c
index cddc8e8..b3d6055 100644
--- a/src/mesa/drivers/dri/i965/intel_screen.c
+++ b/src/mesa/drivers/dri/i965/intel_screen.c
@@ -213,6 +213,9 @@ static struct intel_image_format intel_image_formats[] = {
    { __DRI_IMAGE_FOURCC_XRGB8888, __DRI_IMAGE_COMPONENTS_RGB, 1,
      { { 0, 0, 0, __DRI_IMAGE_FORMAT_XRGB8888, 4 }, } },
 
+   { __DRI_IMAGE_FOURCC_RGB565, __DRI_IMAGE_COMPONENTS_RGB, 1,
+     { { 0, 0, 0, __DRI_IMAGE_FORMAT_RGB565, 2 } } },
+
    { __DRI_IMAGE_FOURCC_YUV410, __DRI_IMAGE_COMPONENTS_Y_U_V, 3,
      { { 0, 0, 0, __DRI_IMAGE_FORMAT_R8, 1 },
        { 1, 2, 2, __DRI_IMAGE_FORMAT_R8, 1 },
@@ -293,6 +296,12 @@ intel_allocate_image(int dri_format, void *loaderPrivate)
     case __DRI_IMAGE_FORMAT_XRGB8888:
        image->format = MESA_FORMAT_XRGB8888;
        break;
+    case __DRI_IMAGE_FORMAT_ARGB2101010:
+       image->format = MESA_FORMAT_ARGB2101010;
+       break;
+    case __DRI_IMAGE_FORMAT_XRGB2101010:
+       image->format = MESA_FORMAT_XRGB2101010_UNORM;
+       break;
     case __DRI_IMAGE_FORMAT_ARGB8888:
        image->format = MESA_FORMAT_ARGB8888;
        break;
@@ -379,6 +388,10 @@ intel_dri_format(GLuint format)
       return __DRI_IMAGE_FORMAT_R8;
    case MESA_FORMAT_RG88:
       return __DRI_IMAGE_FORMAT_GR88;
+   case MESA_FORMAT_XRGB2101010_UNORM:
+      return __DRI_IMAGE_FORMAT_XRGB2101010;
+   case MESA_FORMAT_ARGB2101010:
+      return __DRI_IMAGE_FORMAT_ARGB2101010;
    }
 
    return MESA_FORMAT_NONE;
@@ -934,7 +947,7 @@ intelCreateBuffer(__DRIscreen * driScrnPriv,
    if (mesaVis->depthBits == 24) {
       assert(mesaVis->stencilBits == 8);
 
-      if (screen->hw_has_separate_stencil) {
+      if (screen->devinfo->has_hiz_and_separate_stencil) {
          rb = intel_create_private_renderbuffer(MESA_FORMAT_X8_Z24,
                                                 num_samples);
          _mesa_add_renderbuffer(fb, BUFFER_DEPTH, &rb->Base.Base);
@@ -984,32 +997,6 @@ intelDestroyBuffer(__DRIdrawable * driDrawPriv)
     _mesa_reference_framebuffer(&fb, NULL);
 }
 
-static GLboolean
-intelCreateContext(gl_api api,
-		   const struct gl_config * mesaVis,
-                   __DRIcontext * driContextPriv,
-		   unsigned major_version,
-		   unsigned minor_version,
-		   uint32_t flags,
-		   unsigned *error,
-                   void *sharedContextPrivate)
-{
-   bool success = false;
-
-   success = brwCreateContext(api, mesaVis,
-                              driContextPriv,
-                              major_version, minor_version, flags,
-                              error, sharedContextPrivate);
-
-   if (success)
-      return true;
-
-   if (driContextPriv->driverPrivate != NULL)
-      intelDestroyContext(driContextPriv);
-
-   return false;
-}
-
 static bool
 intel_init_bufmgr(struct intel_screen *intelScreen)
 {
@@ -1034,31 +1021,6 @@ intel_init_bufmgr(struct intel_screen *intelScreen)
    return true;
 }
 
-/**
- * Override intel_screen.hw_has_separate_stencil with environment variable
- * INTEL_SEPARATE_STENCIL.
- *
- * Valid values for INTEL_SEPARATE_STENCIL are "0" and "1". If an invalid
- * valid value is encountered, a warning is emitted and INTEL_SEPARATE_STENCIL
- * is ignored.
- */
-static void
-intel_override_separate_stencil(struct intel_screen *screen)
-{
-   const char *s = getenv("INTEL_SEPARATE_STENCIL");
-   if (!s) {
-      return;
-   } else if (!strncmp("0", s, 2)) {
-      screen->hw_has_separate_stencil = false;
-   } else if (!strncmp("1", s, 2)) {
-      screen->hw_has_separate_stencil = true;
-   } else {
-      fprintf(stderr,
-	      "warning: env variable INTEL_SEPARATE_STENCIL=\"%s\" has "
-	      "invalid value and is ignored", s);
-   }
-}
-
 static bool
 intel_detect_swizzling(struct intel_screen *screen)
 {
@@ -1100,6 +1062,7 @@ intel_screen_make_configs(__DRIscreen *dri_screen)
    static const uint8_t multisample_samples[2]  = {4, 8};
 
    struct intel_screen *screen = dri_screen->driverPrivate;
+   const struct brw_device_info *devinfo = screen->devinfo;
    uint8_t depth_bits[4], stencil_bits[4];
    __DRIconfig **configs = NULL;
 
@@ -1118,7 +1081,7 @@ intel_screen_make_configs(__DRIscreen *dri_screen)
       if (formats[i] == MESA_FORMAT_RGB565) {
          depth_bits[1] = 16;
          stencil_bits[1] = 0;
-         if (screen->gen >= 6) {
+         if (devinfo->gen >= 6) {
              depth_bits[2] = 24;
              stencil_bits[2] = 8;
              num_depth_stencil_bits = 3;
@@ -1174,7 +1137,7 @@ intel_screen_make_configs(__DRIscreen *dri_screen)
     * them.
     */
    for (int i = 0; i < ARRAY_SIZE(formats); i++) {
-      if (screen->gen < 6)
+      if (devinfo->gen < 6)
          break;
 
       __DRIconfig **new_configs;
@@ -1192,9 +1155,9 @@ intel_screen_make_configs(__DRIscreen *dri_screen)
          stencil_bits[1] = 8;
       }
 
-      if (screen->gen >= 7)
+      if (devinfo->gen >= 7)
          num_msaa_modes = 2;
-      else if (screen->gen == 6)
+      else if (devinfo->gen == 6)
          num_msaa_modes = 1;
 
       new_configs = driCreateConfigs(formats[i],
@@ -1220,40 +1183,32 @@ intel_screen_make_configs(__DRIscreen *dri_screen)
 static void
 set_max_gl_versions(struct intel_screen *screen)
 {
-   int gl_version_override = _mesa_get_gl_version_override();
+   __DRIscreen *psp = screen->driScrnPriv;
 
-   switch (screen->gen) {
+   switch (screen->devinfo->gen) {
    case 7:
-      screen->max_gl_core_version = 31;
-      screen->max_gl_compat_version = 30;
-      screen->max_gl_es1_version = 11;
-      screen->max_gl_es2_version = 30;
+      psp->max_gl_core_version = 33;
+      psp->max_gl_compat_version = 30;
+      psp->max_gl_es1_version = 11;
+      psp->max_gl_es2_version = 30;
       break;
    case 6:
-      screen->max_gl_core_version = 31;
-      screen->max_gl_compat_version = 30;
-      screen->max_gl_es1_version = 11;
-      screen->max_gl_es2_version = 30;
+      psp->max_gl_core_version = 31;
+      psp->max_gl_compat_version = 30;
+      psp->max_gl_es1_version = 11;
+      psp->max_gl_es2_version = 30;
       break;
    case 5:
    case 4:
-      screen->max_gl_core_version = 0;
-      screen->max_gl_compat_version = 21;
-      screen->max_gl_es1_version = 11;
-      screen->max_gl_es2_version = 20;
+      psp->max_gl_core_version = 0;
+      psp->max_gl_compat_version = 21;
+      psp->max_gl_es1_version = 11;
+      psp->max_gl_es2_version = 20;
       break;
    default:
       assert(!"unrecognized intel_screen::gen");
       break;
    }
-
-   if (gl_version_override >= 31) {
-      screen->max_gl_core_version = MAX2(screen->max_gl_core_version,
-                                         gl_version_override);
-   } else {
-      screen->max_gl_compat_version = MAX2(screen->max_gl_compat_version,
-                                           gl_version_override);
-   }
 }
 
 /**
@@ -1291,44 +1246,14 @@ __DRIconfig **intelInitScreen2(__DRIscreen *psp)
        return false;
 
    intelScreen->deviceID = drm_intel_bufmgr_gem_get_devid(intelScreen->bufmgr);
+   intelScreen->devinfo = brw_get_device_info(intelScreen->deviceID);
 
-   if (IS_GEN7(intelScreen->deviceID)) {
-      intelScreen->gen = 7;
-   } else if (IS_GEN6(intelScreen->deviceID)) {
-      intelScreen->gen = 6;
-   } else if (IS_GEN5(intelScreen->deviceID)) {
-      intelScreen->gen = 5;
-   } else {
-      intelScreen->gen = 4;
-   }
-
-   intelScreen->hw_has_separate_stencil = intelScreen->gen >= 6;
-   intelScreen->hw_must_use_separate_stencil = intelScreen->gen >= 7;
-
-   int has_llc = 0;
-   bool success = intel_get_param(intelScreen->driScrnPriv, I915_PARAM_HAS_LLC,
-				  &has_llc);
-   if (success && has_llc)
-      intelScreen->hw_has_llc = true;
-   else if (!success && intelScreen->gen >= 6)
-      intelScreen->hw_has_llc = true;
-
-   intel_override_separate_stencil(intelScreen);
+   intelScreen->hw_must_use_separate_stencil = intelScreen->devinfo->gen >= 7;
 
    intelScreen->hw_has_swizzling = intel_detect_swizzling(intelScreen);
 
    set_max_gl_versions(intelScreen);
 
-   psp->api_mask = (1 << __DRI_API_OPENGL);
-   if (intelScreen->max_gl_core_version > 0)
-      psp->api_mask |= (1 << __DRI_API_OPENGL_CORE);
-   if (intelScreen->max_gl_es1_version > 0)
-      psp->api_mask |= (1 << __DRI_API_GLES);
-   if (intelScreen->max_gl_es2_version > 0)
-      psp->api_mask |= (1 << __DRI_API_GLES2);
-   if (intelScreen->max_gl_es2_version >= 30)
-      psp->api_mask |= (1 << __DRI_API_GLES3);
-
    psp->extensions = intelScreenExtensions;
 
    return (const __DRIconfig**) intel_screen_make_configs(psp);
@@ -1389,7 +1314,7 @@ intelReleaseBuffer(__DRIscreen *screen, __DRIbuffer *buffer)
 const struct __DriverAPIRec driDriverAPI = {
    .InitScreen		 = intelInitScreen2,
    .DestroyScreen	 = intelDestroyScreen,
-   .CreateContext	 = intelCreateContext,
+   .CreateContext	 = brwCreateContext,
    .DestroyContext	 = intelDestroyContext,
    .CreateBuffer	 = intelCreateBuffer,
    .DestroyBuffer	 = intelDestroyBuffer,
diff --git a/src/mesa/drivers/dri/i965/intel_screen.h b/src/mesa/drivers/dri/i965/intel_screen.h
index 9af4220..0b75c6e 100644
--- a/src/mesa/drivers/dri/i965/intel_screen.h
+++ b/src/mesa/drivers/dri/i965/intel_screen.h
@@ -32,32 +32,22 @@
 #include <sys/time.h>
 #include "dri_util.h"
 #include "intel_bufmgr.h"
+#include "intel_chipset.h"
+#include "brw_device_info.h"
 #include "i915_drm.h"
 #include "xmlconfig.h"
 
 struct intel_screen
 {
    int deviceID;
-   int gen;
-
-   int max_gl_core_version;
-   int max_gl_compat_version;
-   int max_gl_es1_version;
-   int max_gl_es2_version;
+   const struct brw_device_info *devinfo;
 
    __DRIscreen *driScrnPriv;
 
    bool no_hw;
 
-   /*
-    * The hardware hiz and separate stencil fields are needed in intel_screen,
-    * rather than solely in brw_context, because glXCreatePbuffer and
-    * glXCreatePixmap are not passed a GLXContext.
-    */
-   bool hw_has_separate_stencil;
    bool hw_must_use_separate_stencil;
 
-   bool hw_has_llc;
    bool hw_has_swizzling;
 
    dri_bufmgr *bufmgr;
diff --git a/src/mesa/drivers/dri/i965/intel_tex_subimage.c b/src/mesa/drivers/dri/i965/intel_tex_subimage.c
index 05e684c..5cfdbd9 100644
--- a/src/mesa/drivers/dri/i965/intel_tex_subimage.c
+++ b/src/mesa/drivers/dri/i965/intel_tex_subimage.c
@@ -43,6 +43,43 @@
 
 #define FILE_DEBUG_FLAG DEBUG_TEXTURE
 
+#define ALIGN_DOWN(a, b) ROUND_DOWN_TO(a, b)
+#define ALIGN_UP(a, b) ALIGN(a, b)
+
+/* Tile dimensions.
+ * Width and span are in bytes, height is in pixels (i.e. unitless).
+ * A "span" is the most number of bytes we can copy from linear to tiled
+ * without needing to calculate a new destination address.
+ */
+static const uint32_t xtile_width = 512;
+static const uint32_t xtile_height = 8;
+static const uint32_t xtile_span = 64;
+static const uint32_t ytile_width = 128;
+static const uint32_t ytile_height = 32;
+static const uint32_t ytile_span = 16;
+
+typedef void *(*mem_copy_fn)(void *dest, const void *src, size_t n);
+
+/**
+ * Each row from y0 to y1 is copied in three parts: [x0,x1), [x1,x2), [x2,x3).
+ * These ranges are in bytes, i.e. pixels * bytes-per-pixel.
+ * The first and last ranges must be shorter than a "span" (the longest linear
+ * stretch within a tile) and the middle must equal a whole number of spans.
+ * Ranges may be empty.  The region copied must land entirely within one tile.
+ * 'dst' is the start of the tile and 'src' is the corresponding
+ * address to copy from, though copying begins at (x0, y0).
+ * To enable swizzling 'swizzle_bit' must be 1<<6, otherwise zero.
+ * Swizzling flips bit 6 in the copy destination offset, when certain other
+ * bits are set in it.
+ */
+typedef void (*tile_copy_fn)(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
+                             uint32_t y0, uint32_t y1,
+                             char *dst, const char *src,
+                             uint32_t src_pitch,
+                             uint32_t swizzle_bit,
+                             mem_copy_fn mem_copy);
+
+
 static bool
 intel_blit_texsubimage(struct gl_context * ctx,
 		       struct gl_texture_image *texImage,
@@ -132,26 +169,351 @@ err:
    return false;
 }
 
+#ifdef __SSSE3__
+static const uint8_t rgba8_permutation[16] =
+   { 2,1,0,3, 6,5,4,7, 10,9,8,11, 14,13,12,15 };
+
+typedef char v16 __attribute__((vector_size(16)));
+
+/* NOTE: dst must be 16 byte aligned */
+#define rgba8_copy_16(dst, src)                     \
+   *(v16*)(dst) = __builtin_ia32_pshufb128(         \
+       (v16) __builtin_ia32_loadups((float*)(src)), \
+      *(v16*) rgba8_permutation                     \
+   )
+#endif
+
+/**
+ * Copy RGBA to BGRA - swap R and B.
+ */
+static inline void *
+rgba8_copy(void *dst, const void *src, size_t bytes)
+{
+   uint8_t *d = dst;
+   uint8_t const *s = src;
+
+#ifdef __SSSE3__
+   /* Fast copying for tile spans.
+    *
+    * As long as the destination texture is 16 aligned,
+    * any 16 or 64 spans we get here should also be 16 aligned.
+    */
+
+   if (bytes == 16) {
+      assert(!(((uintptr_t)dst) & 0xf));
+      rgba8_copy_16(d+ 0, s+ 0);
+      return dst;
+   }
+
+   if (bytes == 64) {
+      assert(!(((uintptr_t)dst) & 0xf));
+      rgba8_copy_16(d+ 0, s+ 0);
+      rgba8_copy_16(d+16, s+16);
+      rgba8_copy_16(d+32, s+32);
+      rgba8_copy_16(d+48, s+48);
+      return dst;
+   }
+#endif
+
+   while (bytes >= 4) {
+      d[0] = s[2];
+      d[1] = s[1];
+      d[2] = s[0];
+      d[3] = s[3];
+      d += 4;
+      s += 4;
+      bytes -= 4;
+   }
+   return dst;
+}
+
+/**
+ * Copy texture data from linear to X tile layout.
+ *
+ * \copydoc tile_copy_fn
+ */
+static inline void
+xtile_copy(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
+           uint32_t y0, uint32_t y1,
+           char *dst, const char *src,
+           uint32_t src_pitch,
+           uint32_t swizzle_bit,
+           mem_copy_fn mem_copy)
+{
+   /* The copy destination offset for each range copied is the sum of
+    * an X offset 'x0' or 'xo' and a Y offset 'yo.'
+    */
+   uint32_t xo, yo;
+
+   src += y0 * src_pitch;
+
+   for (yo = y0 * xtile_width; yo < y1 * xtile_width; yo += xtile_width) {
+      /* Bits 9 and 10 of the copy destination offset control swizzling.
+       * Only 'yo' contributes to those bits in the total offset,
+       * so calculate 'swizzle' just once per row.
+       * Move bits 9 and 10 three and four places respectively down
+       * to bit 6 and xor them.
+       */
+      uint32_t swizzle = ((yo >> 3) ^ (yo >> 4)) & swizzle_bit;
+
+      mem_copy(dst + ((x0 + yo) ^ swizzle), src + x0, x1 - x0);
+
+      for (xo = x1; xo < x2; xo += xtile_span) {
+         mem_copy(dst + ((xo + yo) ^ swizzle), src + xo, xtile_span);
+      }
+
+      mem_copy(dst + ((xo + yo) ^ swizzle), src + x2, x3 - x2);
+
+      src += src_pitch;
+   }
+}
+
+/**
+ * Copy texture data from linear to Y tile layout.
+ *
+ * \copydoc tile_copy_fn
+ */
+static inline void
+ytile_copy(
+   uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
+   uint32_t y0, uint32_t y1,
+   char *dst, const char *src,
+   uint32_t src_pitch,
+   uint32_t swizzle_bit,
+   mem_copy_fn mem_copy)
+{
+   /* Y tiles consist of columns that are 'ytile_span' wide (and the same height
+    * as the tile).  Thus the destination offset for (x,y) is the sum of:
+    *   (x % column_width)                    // position within column
+    *   (x / column_width) * bytes_per_column // column number * bytes per column
+    *   y * column_width
+    *
+    * The copy destination offset for each range copied is the sum of
+    * an X offset 'xo0' or 'xo' and a Y offset 'yo.'
+    */
+   const uint32_t column_width = ytile_span;
+   const uint32_t bytes_per_column = column_width * ytile_height;
+
+   uint32_t xo0 = (x0 % ytile_span) + (x0 / ytile_span) * bytes_per_column;
+   uint32_t xo1 = (x1 % ytile_span) + (x1 / ytile_span) * bytes_per_column;
+
+   /* Bit 9 of the destination offset control swizzling.
+    * Only the X offset contributes to bit 9 of the total offset,
+    * so swizzle can be calculated in advance for these X positions.
+    * Move bit 9 three places down to bit 6.
+    */
+   uint32_t swizzle0 = (xo0 >> 3) & swizzle_bit;
+   uint32_t swizzle1 = (xo1 >> 3) & swizzle_bit;
+
+   uint32_t x, yo;
+
+   src += y0 * src_pitch;
+
+   for (yo = y0 * column_width; yo < y1 * column_width; yo += column_width) {
+      uint32_t xo = xo1;
+      uint32_t swizzle = swizzle1;
+
+      mem_copy(dst + ((xo0 + yo) ^ swizzle0), src + x0, x1 - x0);
+
+      /* Step by spans/columns.  As it happens, the swizzle bit flips
+       * at each step so we don't need to calculate it explicitly.
+       */
+      for (x = x1; x < x2; x += ytile_span) {
+         mem_copy(dst + ((xo + yo) ^ swizzle), src + x, ytile_span);
+         xo += bytes_per_column;
+         swizzle ^= swizzle_bit;
+      }
+
+      mem_copy(dst + ((xo + yo) ^ swizzle), src + x2, x3 - x2);
+
+      src += src_pitch;
+   }
+}
+
+/**
+ * Copy texture data from linear to X tile layout, faster.
+ *
+ * Same as \ref xtile_copy but faster, because it passes constant parameters
+ * for common cases, allowing the compiler to inline code optimized for those
+ * cases.
+ *
+ * \copydoc tile_copy_fn
+ */
+static void
+xtile_copy_faster(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
+                  uint32_t y0, uint32_t y1,
+                  char *dst, const char *src,
+                  uint32_t src_pitch,
+                  uint32_t swizzle_bit,
+                  mem_copy_fn mem_copy)
+{
+   if (x0 == 0 && x3 == xtile_width && y0 == 0 && y1 == xtile_height) {
+      if (mem_copy == memcpy)
+         return xtile_copy(0, 0, xtile_width, xtile_width, 0, xtile_height,
+                           dst, src, src_pitch, swizzle_bit, memcpy);
+      else if (mem_copy == rgba8_copy)
+         return xtile_copy(0, 0, xtile_width, xtile_width, 0, xtile_height,
+                           dst, src, src_pitch, swizzle_bit, rgba8_copy);
+   } else {
+      if (mem_copy == memcpy)
+         return xtile_copy(x0, x1, x2, x3, y0, y1,
+                           dst, src, src_pitch, swizzle_bit, memcpy);
+      else if (mem_copy == rgba8_copy)
+         return xtile_copy(x0, x1, x2, x3, y0, y1,
+                           dst, src, src_pitch, swizzle_bit, rgba8_copy);
+   }
+   xtile_copy(x0, x1, x2, x3, y0, y1,
+              dst, src, src_pitch, swizzle_bit, mem_copy);
+}
+
+/**
+ * Copy texture data from linear to Y tile layout, faster.
+ *
+ * Same as \ref ytile_copy but faster, because it passes constant parameters
+ * for common cases, allowing the compiler to inline code optimized for those
+ * cases.
+ *
+ * \copydoc tile_copy_fn
+ */
+static void
+ytile_copy_faster(uint32_t x0, uint32_t x1, uint32_t x2, uint32_t x3,
+                  uint32_t y0, uint32_t y1,
+                  char *dst, const char *src,
+                  uint32_t src_pitch,
+                  uint32_t swizzle_bit,
+                  mem_copy_fn mem_copy)
+{
+   if (x0 == 0 && x3 == ytile_width && y0 == 0 && y1 == ytile_height) {
+      if (mem_copy == memcpy)
+         return ytile_copy(0, 0, ytile_width, ytile_width, 0, ytile_height,
+                           dst, src, src_pitch, swizzle_bit, memcpy);
+      else if (mem_copy == rgba8_copy)
+         return ytile_copy(0, 0, ytile_width, ytile_width, 0, ytile_height,
+                           dst, src, src_pitch, swizzle_bit, rgba8_copy);
+   } else {
+      if (mem_copy == memcpy)
+         return ytile_copy(x0, x1, x2, x3, y0, y1,
+                           dst, src, src_pitch, swizzle_bit, memcpy);
+      else if (mem_copy == rgba8_copy)
+         return ytile_copy(x0, x1, x2, x3, y0, y1,
+                           dst, src, src_pitch, swizzle_bit, rgba8_copy);
+   }
+   ytile_copy(x0, x1, x2, x3, y0, y1,
+              dst, src, src_pitch, swizzle_bit, mem_copy);
+}
+
+/**
+ * Copy from linear to tiled texture.
+ *
+ * Divide the region given by X range [xt1, xt2) and Y range [yt1, yt2) into
+ * pieces that do not cross tile boundaries and copy each piece with a tile
+ * copy function (\ref tile_copy_fn).
+ * The X range is in bytes, i.e. pixels * bytes-per-pixel.
+ * The Y range is in pixels (i.e. unitless).
+ * 'dst' is the start of the texture and 'src' is the corresponding
+ * address to copy from, though copying begins at (xt1, yt1).
+ */
+static void
+linear_to_tiled(uint32_t xt1, uint32_t xt2,
+                uint32_t yt1, uint32_t yt2,
+                char *dst, const char *src,
+                uint32_t dst_pitch, uint32_t src_pitch,
+                bool has_swizzling,
+                uint32_t tiling,
+                mem_copy_fn mem_copy)
+{
+   tile_copy_fn tile_copy;
+   uint32_t xt0, xt3;
+   uint32_t yt0, yt3;
+   uint32_t xt, yt;
+   uint32_t tw, th, span;
+   uint32_t swizzle_bit = has_swizzling ? 1<<6 : 0;
+
+   if (tiling == I915_TILING_X) {
+      tw = xtile_width;
+      th = xtile_height;
+      span = xtile_span;
+      tile_copy = xtile_copy_faster;
+   } else if (tiling == I915_TILING_Y) {
+      tw = ytile_width;
+      th = ytile_height;
+      span = ytile_span;
+      tile_copy = ytile_copy_faster;
+   } else {
+      assert(!"unsupported tiling");
+      return;
+   }
+
+   /* Round out to tile boundaries. */
+   xt0 = ALIGN_DOWN(xt1, tw);
+   xt3 = ALIGN_UP  (xt2, tw);
+   yt0 = ALIGN_DOWN(yt1, th);
+   yt3 = ALIGN_UP  (yt2, th);
+
+   /* Loop over all tiles to which we have something to copy.
+    * 'xt' and 'yt' are the origin of the destination tile, whether copying
+    * copying a full or partial tile.
+    * tile_copy() copies one tile or partial tile.
+    * Looping x inside y is the faster memory access pattern.
+    */
+   for (yt = yt0; yt < yt3; yt += th) {
+      for (xt = xt0; xt < xt3; xt += tw) {
+         /* The area to update is [x0,x3) x [y0,y1).
+          * May not want the whole tile, hence the min and max.
+          */
+         uint32_t x0 = MAX2(xt1, xt);
+         uint32_t y0 = MAX2(yt1, yt);
+         uint32_t x3 = MIN2(xt2, xt + tw);
+         uint32_t y1 = MIN2(yt2, yt + th);
+
+         /* [x0,x3) is split into [x0,x1), [x1,x2), [x2,x3) such that
+          * the middle interval is the longest span-aligned part.
+          * The sub-ranges could be empty.
+          */
+         uint32_t x1, x2;
+         x1 = ALIGN_UP(x0, span);
+         if (x1 > x3)
+            x1 = x2 = x3;
+         else
+            x2 = ALIGN_DOWN(x3, span);
+
+         assert(x0 <= x1 && x1 <= x2 && x2 <= x3);
+         assert(x1 - x0 < span && x3 - x2 < span);
+         assert(x3 - x0 <= tw);
+         assert((x2 - x1) % span == 0);
+
+         /* Translate by (xt,yt) for single-tile copier. */
+         tile_copy(x0-xt, x1-xt, x2-xt, x3-xt,
+                   y0-yt, y1-yt,
+                   dst + xt * th + yt * dst_pitch,
+                   src + xt      + yt * src_pitch,
+                   src_pitch,
+                   swizzle_bit,
+                   mem_copy);
+      }
+   }
+}
+
 /**
  * \brief A fast path for glTexImage and glTexSubImage.
  *
  * \param for_glTexImage Was this called from glTexImage or glTexSubImage?
  *
- * This fast path is taken when the hardware natively supports the texture
- * format (such as GL_BGRA) and when the texture memory is X-tiled. It uploads
+ * This fast path is taken when the texture format is BGRA, RGBA,
+ * A or L and when the texture memory is X- or Y-tiled.  It uploads
  * the texture data by mapping the texture memory without a GTT fence, thus
- * acquiring a tiled view of the memory, and then memcpy'ing sucessive
- * subspans within each tile.
+ * acquiring a tiled view of the memory, and then copying sucessive
+ * spans within each tile.
  *
  * This is a performance win over the conventional texture upload path because
  * it avoids the performance penalty of writing through the write-combine
  * buffer. In the conventional texture upload path,
  * texstore.c:store_texsubimage(), the texture memory is mapped through a GTT
  * fence, thus acquiring a linear view of the memory, then each row in the
- * image is memcpy'd. In this fast path, we replace each row's memcpy with
- * a sequence of memcpy's over each bit6 swizzle span in the row.
+ * image is memcpy'd. In this fast path, we replace each row's copy with
+ * a sequence of copies over each linear span in tile.
  *
- * This fast path's use case is Google Chrome's paint rectangles.  Chrome (as
+ * One use case is Google Chrome's paint rectangles.  Chrome (as
  * of version 21) renders each page as a tiling of 256x256 GL_BGRA textures.
  * Each page's content is initially uploaded with glTexImage2D and damaged
  * regions are updated with glTexSubImage2D. On some workloads, the
@@ -176,14 +538,15 @@ intel_texsubimage_tiled_memcpy(struct gl_context * ctx,
 
    int error = 0;
 
-   /* This fastpath is restricted to a specific texture type: level 0 of
-    * a 2D BGRA texture. It could be generalized to support more types by
-    * varying the arithmetic loop below.
+   uint32_t cpp;
+   mem_copy_fn mem_copy = NULL;
+
+   /* This fastpath is restricted to specific texture types: level 0 of
+    * a 2D BGRA, RGBA, L8 or A8 texture. It could be generalized to support
+    * more types.
     */
    if (!brw->has_llc ||
-       format != GL_BGRA ||
        type != GL_UNSIGNED_BYTE ||
-       texImage->TexFormat != MESA_FORMAT_ARGB8888 ||
        texImage->TexObject->Target != GL_TEXTURE_2D ||
        texImage->Level != 0 ||
        pixels == NULL ||
@@ -197,12 +560,28 @@ intel_texsubimage_tiled_memcpy(struct gl_context * ctx,
        packing->Invert)
       return false;
 
+   if ((texImage->TexFormat == MESA_FORMAT_L8 && format == GL_LUMINANCE) ||
+       (texImage->TexFormat == MESA_FORMAT_A8 && format == GL_ALPHA)) {
+      cpp = 1;
+      mem_copy = memcpy;
+   } else if (texImage->TexFormat == MESA_FORMAT_ARGB8888) {
+      cpp = 4;
+      if (format == GL_BGRA) {
+         mem_copy = memcpy;
+      } else if (format == GL_RGBA) {
+         mem_copy = rgba8_copy;
+      }
+   }
+   if (!mem_copy)
+      return false;
+
    if (for_glTexImage)
       ctx->Driver.AllocTextureImageBuffer(ctx, texImage);
 
    if (!image->mt ||
-       image->mt->region->tiling != I915_TILING_X) {
-      /* The algorithm below is written only for X-tiled memory. */
+       (image->mt->region->tiling != I915_TILING_X &&
+       image->mt->region->tiling != I915_TILING_Y)) {
+      /* The algorithm is written only for X- or Y-tiled memory. */
       return false;
    }
 
@@ -236,61 +615,15 @@ intel_texsubimage_tiled_memcpy(struct gl_context * ctx,
    DBG("%s: level=%d offset=(%d,%d) (w,h)=(%d,%d)\n",
        __FUNCTION__, texImage->Level, xoffset, yoffset, width, height);
 
-   /* In the tiling algorithm below, some variables are in units of pixels,
-    * others are in units of bytes, and others (such as height) are unitless.
-    * Each variable name is suffixed with its units.
-    */
-
-   const uint32_t x_max_pixels = xoffset + width;
-   const uint32_t y_max_pixels = yoffset + height;
-
-   const uint32_t tile_size_bytes = 4096;
-
-   const uint32_t tile_width_bytes = 512;
-   const uint32_t tile_width_pixels = 128;
-
-   const uint32_t tile_height = 8;
-
-   const uint32_t cpp = 4; /* chars per pixel of GL_BGRA */
-   const uint32_t swizzle_width_pixels = 16;
-
-   const uint32_t stride_bytes = image->mt->region->pitch;
-   const uint32_t width_tiles = stride_bytes / tile_width_bytes;
-
-   for (uint32_t y_pixels = yoffset; y_pixels < y_max_pixels; ++y_pixels) {
-      const uint32_t y_offset_bytes = (y_pixels / tile_height) * width_tiles * tile_size_bytes
-                                    + (y_pixels % tile_height) * tile_width_bytes;
-
-      for (uint32_t x_pixels = xoffset; x_pixels < x_max_pixels; x_pixels += swizzle_width_pixels) {
-         const uint32_t x_offset_bytes = (x_pixels / tile_width_pixels) * tile_size_bytes
-                                       + (x_pixels % tile_width_pixels) * cpp;
-
-         intptr_t offset_bytes = y_offset_bytes + x_offset_bytes;
-         if (brw->has_swizzling) {
-#if 0
-            /* Clear, unoptimized version. */
-            bool bit6 = (offset_bytes >> 6) & 1;
-            bool bit9 = (offset_bytes >> 9) & 1;
-            bool bit10 = (offset_bytes >> 10) & 1;
-
-            if (bit9 ^ bit10)
-               offset_bytes ^= (1 << 6);
-#else
-            /* Optimized, obfuscated version. */
-            offset_bytes ^= ((offset_bytes >> 3) ^ (offset_bytes >> 4))
-                          & (1 << 6);
-#endif
-         }
-
-         const uint32_t swizzle_bound_pixels = ALIGN(x_pixels + 1, swizzle_width_pixels);
-         const uint32_t memcpy_bound_pixels = MIN2(x_max_pixels, swizzle_bound_pixels);
-         const uint32_t copy_size = cpp * (memcpy_bound_pixels - x_pixels);
-
-         memcpy(bo->virtual + offset_bytes, pixels, copy_size);
-         pixels += copy_size;
-         x_pixels -= (x_pixels % swizzle_width_pixels);
-      }
-   }
+   linear_to_tiled(
+      xoffset * cpp, (xoffset + width) * cpp,
+      yoffset, yoffset + height,
+      bo->virtual, pixels - (xoffset + yoffset * width) * cpp,
+      image->mt->region->pitch, width * cpp,
+      brw->has_swizzling,
+      image->mt->region->tiling,
+      mem_copy
+   );
 
    drm_intel_bo_unmap(bo);
    return true;
diff --git a/src/mesa/drivers/dri/nouveau/nouveau_context.c b/src/mesa/drivers/dri/nouveau/nouveau_context.c
index eab1aa2..0b648ac 100644
--- a/src/mesa/drivers/dri/nouveau/nouveau_context.c
+++ b/src/mesa/drivers/dri/nouveau/nouveau_context.c
@@ -61,29 +61,6 @@ nouveau_context_create(gl_api api,
 	struct nouveau_context *nctx;
 	struct gl_context *ctx;
 
-	switch (api) {
-	case API_OPENGL_COMPAT:
-		/* Do after-the-fact version checking (below).
-		 */
-		break;
-	case API_OPENGLES:
-		/* NV10 and NV20 can support OpenGL ES 1.0 only.  Older chips
-		 * cannot do even that.
-		 */
-		if ((screen->device->chipset & 0xf0) == 0x00) {
-			*error = __DRI_CTX_ERROR_BAD_API;
-			return GL_FALSE;
-		} else if (minor_version != 0) {
-			*error = __DRI_CTX_ERROR_BAD_VERSION;
-			return GL_FALSE;
-		}
-		break;
-	case API_OPENGLES2:
-	case API_OPENGL_CORE:
-		*error = __DRI_CTX_ERROR_BAD_API;
-		return GL_FALSE;
-	}
-
 	/* API and flag filtering is handled in dri2CreateContextAttribs.
 	 */
 	(void) flags;
diff --git a/src/mesa/drivers/dri/nouveau/nouveau_screen.c b/src/mesa/drivers/dri/nouveau/nouveau_screen.c
index ca39fff..6816406 100644
--- a/src/mesa/drivers/dri/nouveau/nouveau_screen.c
+++ b/src/mesa/drivers/dri/nouveau/nouveau_screen.c
@@ -93,6 +93,18 @@ nouveau_init_screen2(__DRIscreen *dri_screen)
 	if (!screen)
 		return NULL;
 
+
+        /* Compat version validation will occur at context init after
+         * _mesa_compute_version().
+         */
+        dri_screen->max_gl_compat_version = 15;
+
+        /* NV10 and NV20 can support OpenGL ES 1.0 only.  Older chips
+         * cannot do even that.
+         */
+        if ((screen->device->chipset & 0xf0) != 0x00)
+                dri_screen->max_gl_es1_version = 10;
+
 	dri_screen->driverPrivate = screen;
 	dri_screen->extensions = nouveau_screen_extensions;
 	screen->dri_screen = dri_screen;
diff --git a/src/mesa/drivers/dri/nouveau/nouveau_texture.c b/src/mesa/drivers/dri/nouveau/nouveau_texture.c
index da74e8f..8904389 100644
--- a/src/mesa/drivers/dri/nouveau/nouveau_texture.c
+++ b/src/mesa/drivers/dri/nouveau/nouveau_texture.c
@@ -494,6 +494,14 @@ nouveau_compressed_teximage(struct gl_context *ctx, GLuint dims,
 			 &ctx->Unpack, GL_TRUE);
 }
 
+static GLboolean
+nouveau_teximage_alloc(struct gl_context *ctx, struct gl_texture_image *ti)
+{
+	nouveau_teximage(ctx, 3, ti, 0, 0, 0, NULL,
+			 &ctx->DefaultPacking, GL_FALSE);
+	return GL_TRUE;
+}
+
 static void
 nouveau_texsubimage(struct gl_context *ctx, GLint dims,
 		    struct gl_texture_image *ti,
@@ -634,6 +642,7 @@ nouveau_texture_functions_init(struct dd_function_table *functions)
 	functions->DeleteTexture = nouveau_texture_free;
 	functions->NewTextureImage = nouveau_teximage_new;
 	functions->FreeTextureImageBuffer = nouveau_teximage_free;
+	functions->AllocTextureImageBuffer = nouveau_teximage_alloc;
 	functions->ChooseTextureFormat = nouveau_choose_tex_format;
 	functions->TexImage = nouveau_teximage_123d;
 	functions->TexSubImage = nouveau_texsubimage_123d;
diff --git a/src/mesa/drivers/dri/r200/r200_context.c b/src/mesa/drivers/dri/r200/r200_context.c
index b2e1f36..8da9438 100644
--- a/src/mesa/drivers/dri/r200/r200_context.c
+++ b/src/mesa/drivers/dri/r200/r200_context.c
@@ -212,20 +212,6 @@ GLboolean r200CreateContext( gl_api api,
    int i;
    int tcl_mode;
 
-   switch (api) {
-   case API_OPENGL_COMPAT:
-      if (major_version > 1 || minor_version > 3) {
-         *error = __DRI_CTX_ERROR_BAD_VERSION;
-         return GL_FALSE;
-      }
-      break;
-   case API_OPENGLES:
-      break;
-   default:
-      *error = __DRI_CTX_ERROR_BAD_API;
-      return GL_FALSE;
-   }
-
    /* Flag filtering is handled in dri2CreateContextAttribs.
     */
    (void) flags;
diff --git a/src/mesa/drivers/dri/radeon/radeon_context.c b/src/mesa/drivers/dri/radeon/radeon_context.c
index 60c39fa..592a65b 100644
--- a/src/mesa/drivers/dri/radeon/radeon_context.c
+++ b/src/mesa/drivers/dri/radeon/radeon_context.c
@@ -179,20 +179,6 @@ r100CreateContext( gl_api api,
    int i;
    int tcl_mode, fthrottle_mode;
 
-   switch (api) {
-   case API_OPENGL_COMPAT:
-      if (major_version > 1 || minor_version > 3) {
-         *error = __DRI_CTX_ERROR_BAD_VERSION;
-         return GL_FALSE;
-      }
-      break;
-   case API_OPENGLES:
-      break;
-   default:
-      *error = __DRI_CTX_ERROR_BAD_API;
-      return GL_FALSE;
-   }
-
    /* Flag filtering is handled in dri2CreateContextAttribs.
     */
    (void) flags;
diff --git a/src/mesa/drivers/dri/radeon/radeon_screen.c b/src/mesa/drivers/dri/radeon/radeon_screen.c
index dc44d4a..1a8dc6c 100644
--- a/src/mesa/drivers/dri/radeon/radeon_screen.c
+++ b/src/mesa/drivers/dri/radeon/radeon_screen.c
@@ -719,6 +719,9 @@ __DRIconfig **radeonInitScreen2(__DRIscreen *psp)
    int color;
    __DRIconfig **configs = NULL;
 
+   psp->max_gl_compat_version = 13;
+   psp->max_gl_es1_version = 11;
+
    if (!radeonInitDriver(psp)) {
        return NULL;
     }
diff --git a/src/mesa/drivers/dri/swrast/Makefile.am b/src/mesa/drivers/dri/swrast/Makefile.am
index 9652583..c51ad2d 100644
--- a/src/mesa/drivers/dri/swrast/Makefile.am
+++ b/src/mesa/drivers/dri/swrast/Makefile.am
@@ -30,6 +30,7 @@ AM_CFLAGS = \
 	-I$(top_srcdir)/src/mapi \
 	-I$(top_srcdir)/src/mesa/ \
 	-I$(top_srcdir)/src/mesa/drivers/dri/common \
+	-I$(top_builddir)/src/mesa/drivers/dri/common \
 	$(DEFINES) \
 	$(VISIBILITY_CFLAGS)
 
diff --git a/src/mesa/drivers/dri/swrast/Makefile.sources b/src/mesa/drivers/dri/swrast/Makefile.sources
index 7630dba..fc7ef32 100644
--- a/src/mesa/drivers/dri/swrast/Makefile.sources
+++ b/src/mesa/drivers/dri/swrast/Makefile.sources
@@ -3,7 +3,8 @@ SWRAST_DRIVER_FILES = \
 
 SWRAST_COMMON_FILES = \
 	../common/utils.c \
-	../common/drisw_util.c
+	../common/dri_util.c \
+	../common/xmlconfig.c
 
 SWRAST_C_FILES = \
 	$(SWRAST_COMMON_FILES) \
diff --git a/src/mesa/drivers/dri/swrast/swrast.c b/src/mesa/drivers/dri/swrast/swrast.c
index 332c7b7..4725a7f 100644
--- a/src/mesa/drivers/dri/swrast/swrast.c
+++ b/src/mesa/drivers/dri/swrast/swrast.c
@@ -200,6 +200,10 @@ dri_init_screen(__DRIscreen * psp)
 
     TRACE;
 
+    psp->max_gl_compat_version = 21;
+    psp->max_gl_es1_version = 11;
+    psp->max_gl_es2_version = 20;
+
     psp->extensions = dri_screen_extensions;
 
     configs16 = swrastFillInModes(psp, 16, 16, 0, 1);
@@ -674,22 +678,6 @@ dri_create_context(gl_api api,
      */
     (void) flags;
 
-    switch (api) {
-    case API_OPENGL_COMPAT:
-        if (major_version > 2
-	    || (major_version == 2 && minor_version > 1)) {
-            *error = __DRI_CTX_ERROR_BAD_VERSION;
-            return GL_FALSE;
-        }
-        break;
-    case API_OPENGLES:
-    case API_OPENGLES2:
-        break;
-    case API_OPENGL_CORE:
-        *error = __DRI_CTX_ERROR_BAD_API;
-        return GL_FALSE;
-    }
-
     ctx = CALLOC_STRUCT(dri_context);
     if (ctx == NULL) {
 	*error = __DRI_CTX_ERROR_NO_MEMORY;
diff --git a/src/mesa/main/api_validate.c b/src/mesa/main/api_validate.c
index 0029921..f285c97 100644
--- a/src/mesa/main/api_validate.c
+++ b/src/mesa/main/api_validate.c
@@ -330,26 +330,43 @@ _mesa_valid_prim_mode(struct gl_context *ctx, GLenum mode, const char *name)
    if (_mesa_is_xfb_active_and_unpaused(ctx)) {
       GLboolean pass = GL_TRUE;
 
-      switch (mode) {
-      case GL_POINTS:
-         pass = ctx->TransformFeedback.Mode == GL_POINTS;
-	 break;
-      case GL_LINES:
-      case GL_LINE_STRIP:
-      case GL_LINE_LOOP:
-         pass = ctx->TransformFeedback.Mode == GL_LINES;
-	 break;
-      default:
-         pass = ctx->TransformFeedback.Mode == GL_TRIANGLES;
-	 break;
+      if(ctx->Shader.CurrentGeometryProgram) {
+         switch (ctx->Shader.CurrentGeometryProgram->Geom.OutputType) {
+         case GL_POINTS:
+            pass = ctx->TransformFeedback.Mode == GL_POINTS;
+            break;
+         case GL_LINE_STRIP:
+            pass = ctx->TransformFeedback.Mode == GL_LINES;
+            break;
+         case GL_TRIANGLE_STRIP:
+            pass = ctx->TransformFeedback.Mode == GL_TRIANGLES;
+            break;
+         default:
+            pass = GL_FALSE;
+         }
+      }
+      else {
+         switch (mode) {
+         case GL_POINTS:
+            pass = ctx->TransformFeedback.Mode == GL_POINTS;
+            break;
+         case GL_LINES:
+         case GL_LINE_STRIP:
+         case GL_LINE_LOOP:
+            pass = ctx->TransformFeedback.Mode == GL_LINES;
+            break;
+         default:
+            pass = ctx->TransformFeedback.Mode == GL_TRIANGLES;
+            break;
+         }
       }
       if (!pass) {
-	 _mesa_error(ctx, GL_INVALID_OPERATION,
-		     "%s(mode=%s vs transform feedback %s)",
-		     name,
-		     _mesa_lookup_prim_by_nr(mode),
-		     _mesa_lookup_prim_by_nr(ctx->TransformFeedback.Mode));
-	 return GL_FALSE;
+         _mesa_error(ctx, GL_INVALID_OPERATION,
+	                 "%s(mode=%s vs transform feedback %s)",
+	                 name,
+	                 _mesa_lookup_prim_by_nr(mode),
+	                 _mesa_lookup_prim_by_nr(ctx->TransformFeedback.Mode));
+         return GL_FALSE;
       }
    }
 
diff --git a/src/mesa/main/dd.h b/src/mesa/main/dd.h
index 0806e41..29469ce 100644
--- a/src/mesa/main/dd.h
+++ b/src/mesa/main/dd.h
@@ -575,7 +575,8 @@ struct dd_function_table {
                               GLintptr readOffset, GLintptr writeOffset,
                               GLsizeiptr size );
 
-   /* May return NULL if MESA_MAP_NOWAIT_BIT is set in access:
+   /* Returns pointer to the start of the mapped range.
+    * May return NULL if MESA_MAP_NOWAIT_BIT is set in access:
     */
    void * (*MapBufferRange)( struct gl_context *ctx, GLintptr offset,
                              GLsizeiptr length, GLbitfield access,
diff --git a/src/mesa/main/extensions.c b/src/mesa/main/extensions.c
index c0f17c5..2507fdf 100644
--- a/src/mesa/main/extensions.c
+++ b/src/mesa/main/extensions.c
@@ -146,6 +146,7 @@ static const struct extension extension_table[] = {
    { "GL_ARB_texture_mirrored_repeat",             o(dummy_true),                              GLL,            2001 },
    { "GL_ARB_texture_multisample",                 o(ARB_texture_multisample),                 GL,             2009 },
    { "GL_ARB_texture_non_power_of_two",            o(ARB_texture_non_power_of_two),            GL,             2003 },
+   { "GL_ARB_texture_query_levels",                o(ARB_texture_query_levels),                GL,             2012 },
    { "GL_ARB_texture_query_lod",                   o(ARB_texture_query_lod),                   GL,             2009 },
    { "GL_ARB_texture_rectangle",                   o(NV_texture_rectangle),                    GL,             2004 },
    { "GL_ARB_texture_rgb10_a2ui",                  o(ARB_texture_rgb10_a2ui),                  GL,             2009 },
diff --git a/src/mesa/main/fbobject.c b/src/mesa/main/fbobject.c
index 1034c7a..9dd7161 100644
--- a/src/mesa/main/fbobject.c
+++ b/src/mesa/main/fbobject.c
@@ -3585,6 +3585,7 @@ invalidate_framebuffer_storage(GLenum target, GLsizei numAttachments,
                            "%s(attachment >= max. color attachments)", name);
                return;
             }
+            break;
          }
          default:
             goto invalid_enum;
diff --git a/src/mesa/main/get_hash_params.py b/src/mesa/main/get_hash_params.py
index e80a23c..9c54af0 100644
--- a/src/mesa/main/get_hash_params.py
+++ b/src/mesa/main/get_hash_params.py
@@ -303,7 +303,7 @@ descriptor=[
   [ "MAX_VERTEX_UNIFORM_VECTORS", "LOC_CUSTOM, TYPE_INT, 0, extra_ARB_ES2_compatibility_api_es2" ],
   [ "MAX_FRAGMENT_UNIFORM_VECTORS", "LOC_CUSTOM, TYPE_INT, 0, extra_ARB_ES2_compatibility_api_es2" ],
   [ "NUM_SHADER_BINARY_FORMATS", "CONST(0), extra_ARB_ES2_compatibility_api_es2" ],
-  [ "SHADER_BINARY_FORMATS", "CONST(0), extra_ARB_ES2_compatibility_api_es2" ],
+  [ "SHADER_BINARY_FORMATS", "LOC_CUSTOM, TYPE_INVALID, 0, extra_ARB_ES2_compatibility_api_es2" ],
 
 # GL_ARB_get_program_binary / GL_OES_get_program_binary
   [ "NUM_PROGRAM_BINARY_FORMATS", "CONST(0), NO_EXTRA" ],
diff --git a/src/mesa/main/imports.c b/src/mesa/main/imports.c
index ca6b1d5..277e947 100644
--- a/src/mesa/main/imports.c
+++ b/src/mesa/main/imports.c
@@ -566,7 +566,8 @@ float
 _mesa_strtof( const char *s, char **end )
 {
 #if defined(_GNU_SOURCE) && !defined(__CYGWIN__) && !defined(__FreeBSD__) && \
-   !defined(ANDROID) && !defined(__HAIKU__) && !defined(__UCLIBC__)
+   !defined(ANDROID) && !defined(__HAIKU__) && !defined(__UCLIBC__) && \
+   !defined(__NetBSD__)
    static locale_t loc = NULL;
    if (!loc) {
       loc = newlocale(LC_CTYPE_MASK, "C", NULL);
diff --git a/src/mesa/main/macros.h b/src/mesa/main/macros.h
index 1052f75..880c656 100644
--- a/src/mesa/main/macros.h
+++ b/src/mesa/main/macros.h
@@ -184,6 +184,28 @@ static inline GLfloat UINT_AS_FLT(GLuint u)
    return tmp.f;
 }
 
+/**
+ * Convert a floating point value to an unsigned fixed point value.
+ *
+ * \param frac_bits   The number of bits used to store the fractional part.
+ */
+static INLINE uint32_t
+U_FIXED(float value, uint32_t frac_bits)
+{
+   value *= (1 << frac_bits);
+   return value < 0 ? 0 : value;
+}
+
+/**
+ * Convert a floating point value to an signed fixed point value.
+ *
+ * \param frac_bits   The number of bits used to store the fractional part.
+ */
+static INLINE uint32_t
+S_FIXED(float value, uint32_t frac_bits)
+{
+   return value * (1 << frac_bits);
+}
 /*@}*/
 
 
@@ -673,8 +695,20 @@ minify(unsigned value, unsigned levels)
  *
  * \sa ROUND_DOWN_TO()
  */
-#define ALIGN(value, alignment)  (((value) + alignment - 1) & ~(alignment - 1))
+#define ALIGN(value, alignment)  (((value) + (alignment) - 1) & ~((alignment) - 1))
 
+/**
+ * Align a value down to an alignment value
+ *
+ * If \c value is not already aligned to the requested alignment value, it
+ * will be rounded down.
+ *
+ * \param value  Value to be rounded
+ * \param alignment  Alignment value to be used.  This must be a power of two.
+ *
+ * \sa ALIGN()
+ */
+#define ROUND_DOWN_TO(value, alignment) ((value) & ~(alignment - 1))
 
 
 /** Cross product of two 3-element vectors */
diff --git a/src/mesa/main/mtypes.h b/src/mesa/main/mtypes.h
index 514f810..15893ec 100644
--- a/src/mesa/main/mtypes.h
+++ b/src/mesa/main/mtypes.h
@@ -3220,6 +3220,7 @@ struct gl_extensions
    GLboolean ARB_texture_gather;
    GLboolean ARB_texture_multisample;
    GLboolean ARB_texture_non_power_of_two;
+   GLboolean ARB_texture_query_levels;
    GLboolean ARB_texture_query_lod;
    GLboolean ARB_texture_rg;
    GLboolean ARB_texture_rgb10_a2ui;
diff --git a/src/mesa/main/shaderapi.c b/src/mesa/main/shaderapi.c
index 4c0484a..d3677c8 100644
--- a/src/mesa/main/shaderapi.c
+++ b/src/mesa/main/shaderapi.c
@@ -743,12 +743,6 @@ compile_shader(struct gl_context *ctx, GLuint shaderObj)
    if (!sh)
       return;
 
-   /* Geometry shaders are not yet fully supported, so issue a warning message
-    * if we're compiling one.
-    */
-   if (sh->Type == GL_GEOMETRY_SHADER)
-      printf("WARNING: Geometry shader support is currently experimental.\n");
-
    options = &ctx->ShaderCompilerOptions[_mesa_shader_type_to_index(sh->Type)];
 
    /* set default pragma state for shader */
diff --git a/src/mesa/main/texgetimage.c b/src/mesa/main/texgetimage.c
index 7050f10..d66ca1a 100644
--- a/src/mesa/main/texgetimage.c
+++ b/src/mesa/main/texgetimage.c
@@ -319,7 +319,7 @@ get_tex_rgba_compressed(struct gl_context *ctx, GLuint dimensions,
  * Return a base GL format given the user-requested format
  * for glGetTexImage().
  */
-static GLenum
+GLenum
 _mesa_base_pack_format(GLenum format)
 {
    switch (format) {
diff --git a/src/mesa/main/texgetimage.h b/src/mesa/main/texgetimage.h
index 91ae6e2..a292fab 100644
--- a/src/mesa/main/texgetimage.h
+++ b/src/mesa/main/texgetimage.h
@@ -33,6 +33,9 @@ struct gl_context;
 struct gl_texture_image;
 struct gl_texture_object;
 
+extern GLenum
+_mesa_base_pack_format(GLenum format);
+
 extern void
 _mesa_get_teximage(struct gl_context *ctx,
                    GLenum format, GLenum type, GLvoid *pixels,
diff --git a/src/mesa/main/teximage.c b/src/mesa/main/teximage.c
index e6cae00..793c5d3 100644
--- a/src/mesa/main/teximage.c
+++ b/src/mesa/main/teximage.c
@@ -1112,7 +1112,6 @@ _mesa_get_tex_max_num_levels(GLenum target, GLsizei width, GLsizei height,
    case GL_TEXTURE_CUBE_MAP_ARRAY:
    case GL_PROXY_TEXTURE_CUBE_MAP:
    case GL_PROXY_TEXTURE_CUBE_MAP_ARRAY:
-      ASSERT(width == height);
       size = width;
       break;
    case GL_TEXTURE_2D:
@@ -1447,6 +1446,8 @@ _mesa_legal_texture_dimensions(struct gl_context *ctx, GLenum target,
    case GL_PROXY_TEXTURE_CUBE_MAP_ARB:
       maxSize = 1 << (ctx->Const.MaxCubeTextureLevels - 1);
       maxSize >>= level;
+      if (width != height)
+         return GL_FALSE;
       if (width < 2 * border || width > 2 * border + maxSize)
          return GL_FALSE;
       if (height < 2 * border || height > 2 * border + maxSize)
@@ -1500,7 +1501,9 @@ _mesa_legal_texture_dimensions(struct gl_context *ctx, GLenum target,
          return GL_FALSE;
       if (height < 2 * border || height > 2 * border + maxSize)
          return GL_FALSE;
-      if (depth < 1 || depth > ctx->Const.MaxArrayTextureLayers)
+      if (depth < 1 || depth > ctx->Const.MaxArrayTextureLayers || depth % 6)
+         return GL_FALSE;
+      if (width != height)
          return GL_FALSE;
       if (level >= ctx->Const.MaxCubeTextureLevels)
          return GL_FALSE;
@@ -1991,27 +1994,6 @@ texture_error_check( struct gl_context *ctx,
       }
    }
 
-   if ((target == GL_PROXY_TEXTURE_CUBE_MAP_ARB ||
-        _mesa_is_cube_face(target)) && width != height) {
-      _mesa_error(ctx, GL_INVALID_VALUE,
-                  "glTexImage2D(cube width != height)");
-      return GL_TRUE;
-   }
-
-   if ((target == GL_PROXY_TEXTURE_CUBE_MAP_ARRAY ||
-        target == GL_TEXTURE_CUBE_MAP_ARRAY) && width != height) {
-      _mesa_error(ctx, GL_INVALID_VALUE,
-                  "glTexImage3D(cube array width != height)");
-      return GL_TRUE;
-   }
-
-   if ((target == GL_PROXY_TEXTURE_CUBE_MAP_ARRAY ||
-        target == GL_TEXTURE_CUBE_MAP_ARRAY) && (depth % 6)) {
-      _mesa_error(ctx, GL_INVALID_VALUE,
-                  "glTexImage3D(cube array depth not multiple of 6)");
-      return GL_TRUE;
-   }
-
    /* Check internalFormat */
    if (_mesa_base_tex_format(ctx, internalFormat) < 0) {
       _mesa_error(ctx, GL_INVALID_VALUE,
@@ -2243,14 +2225,6 @@ compressed_texture_error_check(struct gl_context *ctx, GLint dimensions,
       goto error;
    }
 
-   /* For cube map, width must equal height */
-   if ((target == GL_PROXY_TEXTURE_CUBE_MAP_ARB ||
-        _mesa_is_cube_face(target)) && width != height) {
-      reason = "width != height";
-      error = GL_INVALID_VALUE;
-      goto error;
-   }
-
    /* check image size in bytes */
    if (expectedSize != imageSize) {
       /* Per GL_ARB_texture_compression:  GL_INVALID_VALUE is generated [...]
@@ -2596,13 +2570,6 @@ copytexture_error_check( struct gl_context *ctx, GLuint dimensions,
       }
    }
 
-   if ((target == GL_PROXY_TEXTURE_CUBE_MAP_ARB ||
-        _mesa_is_cube_face(target)) && width != height) {
-      _mesa_error(ctx, GL_INVALID_VALUE,
-                  "glTexImage2D(cube width != height)");
-      return GL_TRUE;
-   }
-
    if (_mesa_is_compressed_format(ctx, internalFormat)) {
       if (!target_can_be_compressed(ctx, target, internalFormat)) {
          _mesa_error(ctx, GL_INVALID_ENUM,
@@ -4388,7 +4355,7 @@ teximagemultisample(GLuint dims, GLenum target, GLsizei samples,
 
 void GLAPIENTRY
 _mesa_TexImage2DMultisample(GLenum target, GLsizei samples,
-                            GLint internalformat, GLsizei width,
+                            GLenum internalformat, GLsizei width,
                             GLsizei height, GLboolean fixedsamplelocations)
 {
    teximagemultisample(2, target, samples, internalformat,
@@ -4399,7 +4366,7 @@ _mesa_TexImage2DMultisample(GLenum target, GLsizei samples,
 
 void GLAPIENTRY
 _mesa_TexImage3DMultisample(GLenum target, GLsizei samples,
-                            GLint internalformat, GLsizei width,
+                            GLenum internalformat, GLsizei width,
                             GLsizei height, GLsizei depth,
                             GLboolean fixedsamplelocations)
 {
diff --git a/src/mesa/main/teximage.h b/src/mesa/main/teximage.h
index 8895247..792383d 100644
--- a/src/mesa/main/teximage.h
+++ b/src/mesa/main/teximage.h
@@ -296,12 +296,12 @@ _mesa_TexBufferRange(GLenum target, GLenum internalFormat, GLuint buffer,
 
 extern void GLAPIENTRY
 _mesa_TexImage2DMultisample(GLenum target, GLsizei samples,
-                            GLint internalformat, GLsizei width,
+                            GLenum internalformat, GLsizei width,
                             GLsizei height, GLboolean fixedsamplelocations);
 
 extern void GLAPIENTRY
 _mesa_TexImage3DMultisample(GLenum target, GLsizei samples,
-                            GLint internalformat, GLsizei width,
+                            GLenum internalformat, GLsizei width,
                             GLsizei height, GLsizei depth,
                             GLboolean fixedsamplelocations);
 
diff --git a/src/mesa/main/texstore.c b/src/mesa/main/texstore.c
index 04385e1..76d8d9b 100644
--- a/src/mesa/main/texstore.c
+++ b/src/mesa/main/texstore.c
@@ -3961,6 +3961,7 @@ store_texsubimage(struct gl_context *ctx,
    case GL_TEXTURE_2D:
    case GL_TEXTURE_RECTANGLE:
    case GL_TEXTURE_CUBE_MAP:
+   case GL_TEXTURE_EXTERNAL_OES:
       /* one image slice, nothing special needs to be done */
       break;
    case GL_TEXTURE_1D:
diff --git a/src/mesa/program/ir_to_mesa.cpp b/src/mesa/program/ir_to_mesa.cpp
index f180a7f..cfad91b 100644
--- a/src/mesa/program/ir_to_mesa.cpp
+++ b/src/mesa/program/ir_to_mesa.cpp
@@ -1497,6 +1497,9 @@ ir_to_mesa_visitor::visit(ir_expression *ir)
    case ir_quadop_bitfield_insert:
    case ir_binop_ldexp:
    case ir_triop_csel:
+   case ir_binop_carry:
+   case ir_binop_borrow:
+   case ir_binop_imul_high:
       assert(!"not supported");
       break;
 
@@ -2069,6 +2072,9 @@ ir_to_mesa_visitor::visit(ir_texture *ir)
    case ir_tg4:
       assert(!"Unexpected ir_tg4 opcode");
       break;
+   case ir_query_levels:
+      assert(!"Unexpected ir_query_levels opcode");
+      break;
    }
 
    const glsl_type *sampler_type = ir->sampler->type;
diff --git a/src/mesa/state_tracker/st_atom.c b/src/mesa/state_tracker/st_atom.c
index 1abaf8f..682073e 100644
--- a/src/mesa/state_tracker/st_atom.c
+++ b/src/mesa/state_tracker/st_atom.c
@@ -66,6 +66,7 @@ static const struct st_tracked_state *atoms[] =
    &st_update_fs_constants,
    &st_bind_vs_ubos,
    &st_bind_fs_ubos,
+   &st_bind_gs_ubos,
    &st_update_pixel_transfer,
 
    /* this must be done after the vertex program update */
diff --git a/src/mesa/state_tracker/st_atom.h b/src/mesa/state_tracker/st_atom.h
index 101a3a6..ef24fac 100644
--- a/src/mesa/state_tracker/st_atom.h
+++ b/src/mesa/state_tracker/st_atom.h
@@ -69,6 +69,7 @@ extern const struct st_tracked_state st_update_gs_constants;
 extern const struct st_tracked_state st_update_vs_constants;
 extern const struct st_tracked_state st_bind_fs_ubos;
 extern const struct st_tracked_state st_bind_vs_ubos;
+extern const struct st_tracked_state st_bind_gs_ubos;
 extern const struct st_tracked_state st_update_pixel_transfer;
 
 
diff --git a/src/mesa/state_tracker/st_atom_constbuf.c b/src/mesa/state_tracker/st_atom_constbuf.c
index 723ab56..f3c4576 100644
--- a/src/mesa/state_tracker/st_atom_constbuf.c
+++ b/src/mesa/state_tracker/st_atom_constbuf.c
@@ -254,4 +254,21 @@ const struct st_tracked_state st_bind_fs_ubos = {
    bind_fs_ubos
 };
 
+static void bind_gs_ubos(struct st_context *st)
+{
+   struct gl_shader_program *prog = st->ctx->Shader.CurrentGeometryProgram;
+
+   if (!prog)
+      return;
+
+   st_bind_ubos(st, prog->_LinkedShaders[MESA_SHADER_GEOMETRY], PIPE_SHADER_GEOMETRY);
+}
 
+const struct st_tracked_state st_bind_gs_ubos = {
+   "st_bind_gs_ubos",
+   {
+      0,
+      ST_NEW_GEOMETRY_PROGRAM | ST_NEW_UNIFORM_BUFFER,
+   },
+   bind_gs_ubos
+};
diff --git a/src/mesa/state_tracker/st_cb_bufferobjects.c b/src/mesa/state_tracker/st_cb_bufferobjects.c
index 25cc61a..7fa4cbd 100644
--- a/src/mesa/state_tracker/st_cb_bufferobjects.c
+++ b/src/mesa/state_tracker/st_cb_bufferobjects.c
@@ -1,8 +1,8 @@
 /**************************************************************************
- * 
+ *
  * Copyright 2007 Tungsten Graphics, Inc., Cedar Park, Texas.
  * All Rights Reserved.
- * 
+ *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
@@ -10,11 +10,11 @@
  * distribute, sub license, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject to
  * the following conditions:
- * 
+ *
  * The above copyright notice and this permission notice (including the
  * next paragraph) shall be included in all copies or substantial portions
  * of the Software.
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
@@ -22,7 +22,7 @@
  * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- * 
+ *
  **************************************************************************/
 
 
@@ -78,7 +78,7 @@ st_bufferobj_free(struct gl_context *ctx, struct gl_buffer_object *obj)
    assert(obj->RefCount == 0);
    assert(st_obj->transfer == NULL);
 
-   if (st_obj->buffer) 
+   if (st_obj->buffer)
       pipe_resource_reference(&st_obj->buffer, NULL);
 
    free(st_obj->Base.Label);
@@ -175,7 +175,7 @@ st_bufferobj_data(struct gl_context *ctx,
 		  GLenum target,
 		  GLsizeiptrARB size,
 		  const GLvoid * data,
-		  GLenum usage, 
+		  GLenum usage,
 		  struct gl_buffer_object *obj)
 {
    struct st_context *st = st_context(ctx);
@@ -200,8 +200,8 @@ st_bufferobj_data(struct gl_context *ctx,
 
    st_obj->Base.Size = size;
    st_obj->Base.Usage = usage;
-   
-   switch(target) {
+
+   switch (target) {
    case GL_PIXEL_PACK_BUFFER_ARB:
    case GL_PIXEL_UNPACK_BUFFER_ARB:
       bind = PIPE_BIND_RENDER_TARGET | PIPE_BIND_SAMPLER_VIEW;
@@ -302,7 +302,7 @@ st_bufferobj_map_range(struct gl_context *ctx,
       else
          flags |= PIPE_TRANSFER_DISCARD_RANGE;
    }
-   
+
    if (access & GL_MAP_UNSYNCHRONIZED_BIT)
       flags |= PIPE_TRANSFER_UNSYNCHRONIZED;
 
@@ -348,11 +348,11 @@ st_bufferobj_flush_mapped_range(struct gl_context *ctx,
    assert(length >= 0);
    assert(offset + length <= obj->Length);
    assert(obj->Pointer);
-   
+
    if (!length)
       return;
 
-   pipe_buffer_flush_mapped_range(pipe, st_obj->transfer, 
+   pipe_buffer_flush_mapped_range(pipe, st_obj->transfer,
                                   obj->Offset + offset, length);
 }
 
@@ -392,7 +392,7 @@ st_copy_buffer_subdata(struct gl_context *ctx,
    struct st_buffer_object *dstObj = st_buffer_object(dst);
    struct pipe_box box;
 
-   if(!size)
+   if (!size)
       return;
 
    /* buffer should not already be mapped */
diff --git a/src/mesa/state_tracker/st_context.c b/src/mesa/state_tracker/st_context.c
index 80393cf..4e0d98c 100644
--- a/src/mesa/state_tracker/st_context.c
+++ b/src/mesa/state_tracker/st_context.c
@@ -125,6 +125,9 @@ st_create_context_priv( struct gl_context *ctx, struct pipe_context *pipe,
    st->dirty.mesa = ~0;
    st->dirty.st = ~0;
 
+   /* Create upload manager for vertex data for glBitmap, glDrawPixels,
+    * glClear, etc.
+    */
    st->uploader = u_upload_create(st->pipe, 65536, 4, PIPE_BIND_VERTEX_BUFFER);
 
    if (!screen->get_param(screen, PIPE_CAP_USER_INDEX_BUFFERS)) {
@@ -148,7 +151,8 @@ st_create_context_priv( struct gl_context *ctx, struct pipe_context *pipe,
    st_init_draw( st );
    st_init_generate_mipmap(st);
 
-   if(pipe->screen->get_param(pipe->screen, PIPE_CAP_NPOT_TEXTURES))
+   /* Choose texture target for glDrawPixels, glBitmap, renderbuffers */
+   if (pipe->screen->get_param(pipe->screen, PIPE_CAP_NPOT_TEXTURES))
       st->internal_target = PIPE_TEXTURE_2D;
    else
       st->internal_target = PIPE_TEXTURE_RECT;
diff --git a/src/mesa/state_tracker/st_format.c b/src/mesa/state_tracker/st_format.c
index 64bfd1f..33c2ca6 100644
--- a/src/mesa/state_tracker/st_format.c
+++ b/src/mesa/state_tracker/st_format.c
@@ -35,6 +35,8 @@
 #include "main/imports.h"
 #include "main/context.h"
 #include "main/glformats.h"
+#include "main/texgetimage.h"
+#include "main/teximage.h"
 #include "main/texstore.h"
 #include "main/image.h"
 #include "main/macros.h"
@@ -1745,6 +1747,40 @@ st_ChooseTextureFormat(struct gl_context *ctx, GLenum target,
 	 bindings |= PIPE_BIND_RENDER_TARGET;
    }
 
+   /* GLES allows the driver to choose any format which matches
+    * the format+type combo, because GLES only supports unsized internal
+    * formats and expects the driver to choose whatever suits it.
+    */
+   if (_mesa_is_gles(ctx)) {
+      GLenum baseFormat = _mesa_base_tex_format(ctx, internalFormat);
+      GLenum basePackFormat = _mesa_base_pack_format(format);
+      GLenum iformat = internalFormat;
+
+      /* Treat GL_BGRA as GL_RGBA. */
+      if (iformat == GL_BGRA)
+         iformat = GL_RGBA;
+
+      /* Check if the internalformat is unsized and compatible
+       * with the "format".
+       */
+      if (iformat == baseFormat && iformat == basePackFormat) {
+         pFormat = st_choose_matching_format(st->pipe->screen, bindings,
+                                             format, type,
+                                             ctx->Unpack.SwapBytes);
+
+         if (pFormat != PIPE_FORMAT_NONE)
+            return st_pipe_format_to_mesa_format(pFormat);
+
+         /* try choosing format again, this time without render target bindings */
+         pFormat = st_choose_matching_format(st->pipe->screen,
+                                             PIPE_BIND_SAMPLER_VIEW,
+                                             format, type,
+                                             ctx->Unpack.SwapBytes);
+         if (pFormat != PIPE_FORMAT_NONE)
+            return st_pipe_format_to_mesa_format(pFormat);
+      }
+   }
+
    pFormat = st_choose_format(st, internalFormat, format, type,
                               PIPE_TEXTURE_2D, 0, bindings, ctx->Mesa_DXTn);
 
diff --git a/src/mesa/state_tracker/st_glsl_to_tgsi.cpp b/src/mesa/state_tracker/st_glsl_to_tgsi.cpp
index a5d0b84..3e11cce 100644
--- a/src/mesa/state_tracker/st_glsl_to_tgsi.cpp
+++ b/src/mesa/state_tracker/st_glsl_to_tgsi.cpp
@@ -114,6 +114,8 @@ public:
       this->index2D = 0;
       this->type = type ? type->base_type : GLSL_TYPE_ERROR;
       this->reladdr = NULL;
+      this->reladdr2 = NULL;
+      this->has_index2 = false;
    }
 
    st_src_reg(gl_register_file file, int index, int type)
@@ -125,6 +127,8 @@ public:
       this->swizzle = SWIZZLE_XYZW;
       this->negate = 0;
       this->reladdr = NULL;
+      this->reladdr2 = NULL;
+      this->has_index2 = false;
    }
 
    st_src_reg(gl_register_file file, int index, int type, int index2D)
@@ -136,6 +140,8 @@ public:
       this->swizzle = SWIZZLE_XYZW;
       this->negate = 0;
       this->reladdr = NULL;
+      this->reladdr2 = NULL;
+      this->has_index2 = false;
    }
 
    st_src_reg()
@@ -147,6 +153,8 @@ public:
       this->swizzle = 0;
       this->negate = 0;
       this->reladdr = NULL;
+      this->reladdr2 = NULL;
+      this->has_index2 = false;
    }
 
    explicit st_src_reg(st_dst_reg reg);
@@ -159,10 +167,22 @@ public:
    int type; /** GLSL_TYPE_* from GLSL IR (enum glsl_base_type) */
    /** Register index should be offset by the integer in this reg. */
    st_src_reg *reladdr;
+   st_src_reg *reladdr2;
+   bool has_index2;
 };
 
 class st_dst_reg {
 public:
+   st_dst_reg(gl_register_file file, int writemask, int type, int index)
+   {
+      this->file = file;
+      this->index = index;
+      this->writemask = writemask;
+      this->cond_mask = COND_TR;
+      this->reladdr = NULL;
+      this->type = type;
+   }
+
    st_dst_reg(gl_register_file file, int writemask, int type)
    {
       this->file = file;
@@ -203,6 +223,8 @@ st_src_reg::st_src_reg(st_dst_reg reg)
    this->negate = 0;
    this->reladdr = reg.reladdr;
    this->index2D = 0;
+   this->reladdr2 = NULL;
+   this->has_index2 = false;
 }
 
 st_dst_reg::st_dst_reg(st_src_reg reg)
@@ -449,7 +471,8 @@ static st_src_reg undef_src = st_src_reg(PROGRAM_UNDEFINED, 0, GLSL_TYPE_ERROR);
 
 static st_dst_reg undef_dst = st_dst_reg(PROGRAM_UNDEFINED, SWIZZLE_NOOP, GLSL_TYPE_ERROR);
 
-static st_dst_reg address_reg = st_dst_reg(PROGRAM_ADDRESS, WRITEMASK_X, GLSL_TYPE_FLOAT);
+static st_dst_reg address_reg = st_dst_reg(PROGRAM_ADDRESS, WRITEMASK_X, GLSL_TYPE_FLOAT, 0);
+static st_dst_reg address_reg2 = st_dst_reg(PROGRAM_ADDRESS, WRITEMASK_X, GLSL_TYPE_FLOAT, 1);
 
 static void
 fail_link(struct gl_shader_program *prog, const char *fmt, ...) PRINTFLIKE(2, 3);
@@ -515,9 +538,9 @@ glsl_to_tgsi_visitor::emit(ir_instruction *ir, unsigned op,
     * sources into temps.
     */
    num_reladdr += dst.reladdr != NULL;
-   num_reladdr += src0.reladdr != NULL;
-   num_reladdr += src1.reladdr != NULL;
-   num_reladdr += src2.reladdr != NULL;
+   num_reladdr += src0.reladdr != NULL || src0.reladdr2 != NULL;
+   num_reladdr += src1.reladdr != NULL || src1.reladdr2 != NULL;
+   num_reladdr += src2.reladdr != NULL || src2.reladdr2 != NULL;
 
    reladdr_to_temp(ir, &src2, &num_reladdr);
    reladdr_to_temp(ir, &src1, &num_reladdr);
@@ -539,9 +562,6 @@ glsl_to_tgsi_visitor::emit(ir_instruction *ir, unsigned op,
 
    inst->function = NULL;
    
-   if (op == TGSI_OPCODE_ARL || op == TGSI_OPCODE_UARL)
-      this->num_address_regs = 1;
-   
    /* Update indirect addressing status used by TGSI */
    if (dst.reladdr) {
       switch(dst.file) {
@@ -765,6 +785,10 @@ glsl_to_tgsi_visitor::emit_arl(ir_instruction *ir,
    if (src0.type == GLSL_TYPE_INT || src0.type == GLSL_TYPE_UINT)
       op = TGSI_OPCODE_UARL;
 
+   assert(dst.file == PROGRAM_ADDRESS);
+   if (dst.index >= this->num_address_regs)
+      this->num_address_regs = dst.index + 1;
+
    emit(NULL, op, dst, src0);
 }
 
@@ -1328,10 +1352,11 @@ void
 glsl_to_tgsi_visitor::reladdr_to_temp(ir_instruction *ir,
         			    st_src_reg *reg, int *num_reladdr)
 {
-   if (!reg->reladdr)
+   if (!reg->reladdr && !reg->reladdr2)
       return;
 
-   emit_arl(ir, address_reg, *reg->reladdr);
+   if (reg->reladdr) emit_arl(ir, address_reg, *reg->reladdr);
+   if (reg->reladdr2) emit_arl(ir, address_reg2, *reg->reladdr2);
 
    if (*num_reladdr != 1) {
       st_src_reg temp = get_temp(glsl_type::vec4_type);
@@ -1978,6 +2003,9 @@ glsl_to_tgsi_visitor::visit(ir_expression *ir)
    case ir_binop_vector_extract:
    case ir_triop_vector_insert:
    case ir_binop_ldexp:
+   case ir_binop_carry:
+   case ir_binop_borrow:
+   case ir_binop_imul_high:
       /* This operation is not supported, or should have already been handled.
        */
       assert(!"Invalid ir opcode in glsl_to_tgsi_visitor::visit()");
@@ -2095,14 +2123,26 @@ glsl_to_tgsi_visitor::visit(ir_dereference_array *ir)
    ir_constant *index;
    st_src_reg src;
    int element_size = type_size(ir->type);
+   bool is_2D_input;
 
    index = ir->array_index->constant_expression_value();
 
    ir->array->accept(this);
    src = this->result;
 
+   is_2D_input = this->prog->Target == GL_GEOMETRY_PROGRAM_NV &&
+                 src.file == PROGRAM_INPUT &&
+                 ir->array->ir_type != ir_type_dereference_array;
+
+   if (is_2D_input)
+      element_size = 1;
+
    if (index) {
-      src.index += index->value.i[0] * element_size;
+      if (is_2D_input) {
+         src.index2D = index->value.i[0];
+         src.has_index2 = true;
+      } else
+         src.index += index->value.i[0] * element_size;
    } else {
       /* Variable index array dereference.  It eats the "vec4" of the
        * base of the array and an index that offsets the TGSI register
@@ -2125,7 +2165,7 @@ glsl_to_tgsi_visitor::visit(ir_dereference_array *ir)
       /* If there was already a relative address register involved, add the
        * new and the old together to get the new offset.
        */
-      if (src.reladdr != NULL) {
+      if (!is_2D_input && src.reladdr != NULL) {
          st_src_reg accum_reg = get_temp(native_integers ?
                                 glsl_type::int_type : glsl_type::float_type);
 
@@ -2135,8 +2175,15 @@ glsl_to_tgsi_visitor::visit(ir_dereference_array *ir)
          index_reg = accum_reg;
       }
 
-      src.reladdr = ralloc(mem_ctx, st_src_reg);
-      memcpy(src.reladdr, &index_reg, sizeof(index_reg));
+      if (is_2D_input) {
+         src.reladdr2 = ralloc(mem_ctx, st_src_reg);
+         memcpy(src.reladdr2, &index_reg, sizeof(index_reg));
+         src.index2D = 0;
+         src.has_index2 = true;
+      } else {
+         src.reladdr = ralloc(mem_ctx, st_src_reg);
+         memcpy(src.reladdr, &index_reg, sizeof(index_reg));
+      }
    }
 
    /* If the type is smaller than a vec4, replicate the last channel out. */
@@ -2788,6 +2835,12 @@ glsl_to_tgsi_visitor::visit(ir_texture *ir)
    case ir_lod:
       assert(!"Unexpected ir_lod opcode");
       break;
+   case ir_tg4:
+      assert(!"Unexpected ir_tg4 opcode");
+      break;
+   case ir_query_levels:
+      assert(!"Unexpected ir_query_levels opcode");
+      break;
    }
 
    if (ir->projector) {
@@ -3009,16 +3062,19 @@ glsl_to_tgsi_visitor::visit(ir_if *ir)
    if_inst = emit(ir->condition, TGSI_OPCODE_ENDIF);
 }
 
+
 void
 glsl_to_tgsi_visitor::visit(ir_emit_vertex *ir)
 {
-   assert(!"Geometry shaders not supported.");
+   assert(this->prog->Target == GL_GEOMETRY_PROGRAM_NV);
+   emit(ir, TGSI_OPCODE_EMIT);
 }
 
 void
 glsl_to_tgsi_visitor::visit(ir_end_primitive *ir)
 {
-   assert(!"Geometry shaders not supported.");
+   assert(this->prog->Target == GL_GEOMETRY_PROGRAM_NV);
+   emit(ir, TGSI_OPCODE_ENDPRIM);
 }
 
 glsl_to_tgsi_visitor::glsl_to_tgsi_visitor()
@@ -3431,7 +3487,8 @@ glsl_to_tgsi_visitor::copy_propagate(void)
          int acp_base = inst->src[r].index * 4;
 
          if (inst->src[r].file != PROGRAM_TEMPORARY ||
-             inst->src[r].reladdr)
+             inst->src[r].reladdr ||
+             inst->src[r].reladdr2)
             continue;
 
          /* See if we can find entries in the ACP consisting of MOVs
@@ -3466,6 +3523,8 @@ glsl_to_tgsi_visitor::copy_propagate(void)
              */
             inst->src[r].file = first->src[0].file;
             inst->src[r].index = first->src[0].index;
+            inst->src[r].index2D = first->src[0].index2D;
+            inst->src[r].has_index2 = first->src[0].has_index2;
 
             int swizzle = 0;
             for (int i = 0; i < 4; i++) {
@@ -3570,6 +3629,7 @@ glsl_to_tgsi_visitor::copy_propagate(void)
           !inst->dst.reladdr &&
           !inst->saturate &&
           !inst->src[0].reladdr &&
+          !inst->src[0].reladdr2 &&
           !inst->src[0].negate) {
          for (int i = 0; i < 4; i++) {
             if (inst->dst.writemask & (1 << i)) {
@@ -4069,7 +4129,7 @@ struct st_translate {
    struct ureg_src *immediates;
    struct ureg_dst outputs[PIPE_MAX_SHADER_OUTPUTS];
    struct ureg_src inputs[PIPE_MAX_SHADER_INPUTS];
-   struct ureg_dst address[1];
+   struct ureg_dst address[2];
    struct ureg_src samplers[PIPE_MAX_SAMPLERS];
    struct ureg_src systemValues[SYSTEM_VALUE_MAX];
 
@@ -4346,6 +4406,15 @@ translate_src(struct st_translate *t, const st_src_reg *src_reg)
 {
    struct ureg_src src = src_register(t, src_reg->file, src_reg->index, src_reg->index2D);
 
+   if (t->procType == TGSI_PROCESSOR_GEOMETRY && src_reg->has_index2) {
+      src = src_register(t, src_reg->file, src_reg->index, src_reg->index2D);
+      if (src_reg->reladdr2)
+         src = ureg_src_dimension_indirect(src, ureg_src(t->address[1]),
+                                           src_reg->index2D);
+      else
+         src = ureg_src_dimension(src, src_reg->index2D);
+   }
+
    src = ureg_swizzle(src,
                       GET_SWZ(src_reg->swizzle, 0) & 0x3,
                       GET_SWZ(src_reg->swizzle, 1) & 0x3,
@@ -4835,8 +4904,10 @@ st_translate_program(
    /* Declare address register.
     */
    if (program->num_address_regs > 0) {
-      assert(program->num_address_regs == 1);
+      assert(program->num_address_regs <= 2);
       t->address[0] = ureg_DECL_address(ureg);
+      if (program->num_address_regs == 2)
+         t->address[1] = ureg_DECL_address(ureg);
    }
 
    /* Declare misc input registers
@@ -5157,6 +5228,9 @@ get_mesa_program(struct gl_context *ctx,
    case GL_GEOMETRY_SHADER:
       stgp = (struct st_geometry_program *)prog;
       stgp->glsl_to_tgsi = v;
+      stgp->Base.InputType = shader_program->Geom.InputType;
+      stgp->Base.OutputType = shader_program->Geom.OutputType;
+      stgp->Base.VerticesOut = shader_program->Geom.VerticesOut;
       break;
    default:
       assert(!"should not be reached");
diff --git a/src/mesa/state_tracker/st_program.c b/src/mesa/state_tracker/st_program.c
index 60cc37c..f010e18 100644
--- a/src/mesa/state_tracker/st_program.c
+++ b/src/mesa/state_tracker/st_program.c
@@ -828,7 +828,6 @@ st_translate_geometry_program(struct st_context *st,
    GLuint attr;
    GLbitfield64 inputsRead;
    GLuint vslot = 0;
-   GLuint num_generic = 0;
 
    uint gs_num_inputs = 0;
    uint gs_builtin_inputs = 0;
@@ -848,7 +847,9 @@ st_translate_geometry_program(struct st_context *st,
    if (!gpv)
       return NULL;
 
-   _mesa_remove_output_reads(&stgp->Base.Base, PROGRAM_OUTPUT);
+   if (!stgp->glsl_to_tgsi) {
+      _mesa_remove_output_reads(&stgp->Base.Base, PROGRAM_OUTPUT);
+   }
 
    ureg = ureg_create( TGSI_PROCESSOR_GEOMETRY );
    if (ureg == NULL) {
@@ -910,15 +911,42 @@ st_translate_geometry_program(struct st_context *st,
             stgp->input_semantic_name[slot] = TGSI_SEMANTIC_FOG;
             stgp->input_semantic_index[slot] = 0;
             break;
+         case VARYING_SLOT_CLIP_VERTEX:
+            stgp->input_semantic_name[slot] = TGSI_SEMANTIC_CLIPVERTEX;
+            stgp->input_semantic_index[slot] = 0;
+            break;
+         case VARYING_SLOT_CLIP_DIST0:
+            stgp->input_semantic_name[slot] = TGSI_SEMANTIC_CLIPDIST;
+            stgp->input_semantic_index[slot] = 0;
+            break;
+         case VARYING_SLOT_CLIP_DIST1:
+            stgp->input_semantic_name[slot] = TGSI_SEMANTIC_CLIPDIST;
+            stgp->input_semantic_index[slot] = 1;
+            break;
+         case VARYING_SLOT_PSIZ:
+            stgp->input_semantic_name[slot] = TGSI_SEMANTIC_PSIZE;
+            stgp->input_semantic_index[slot] = 0;
+            break;
          case VARYING_SLOT_TEX0:
+         case VARYING_SLOT_TEX1:
+         case VARYING_SLOT_TEX2:
+         case VARYING_SLOT_TEX3:
+         case VARYING_SLOT_TEX4:
+         case VARYING_SLOT_TEX5:
+         case VARYING_SLOT_TEX6:
+         case VARYING_SLOT_TEX7:
             stgp->input_semantic_name[slot] = TGSI_SEMANTIC_GENERIC;
-            stgp->input_semantic_index[slot] = num_generic++;
+            stgp->input_semantic_index[slot] = (attr - VARYING_SLOT_TEX0);
             break;
          case VARYING_SLOT_VAR0:
-            /* fall-through */
          default:
+            assert(attr >= VARYING_SLOT_VAR0 && attr < VARYING_SLOT_MAX);
             stgp->input_semantic_name[slot] = TGSI_SEMANTIC_GENERIC;
-            stgp->input_semantic_index[slot] = num_generic++;
+            stgp->input_semantic_index[slot] = (VARYING_SLOT_VAR0 -
+                                                VARYING_SLOT_TEX0 +
+                                                attr -
+                                                VARYING_SLOT_VAR0);
+         break;
          }
       }
    }
@@ -929,7 +957,6 @@ st_translate_geometry_program(struct st_context *st,
       gs_output_semantic_index[i] = 0;
    }
 
-   num_generic = 0;
    /*
     * Determine number of outputs, the (default) output register
     * mapping and the semantic information for each output.
@@ -972,6 +999,26 @@ st_translate_geometry_program(struct st_context *st,
             gs_output_semantic_name[slot] = TGSI_SEMANTIC_PSIZE;
             gs_output_semantic_index[slot] = 0;
             break;
+         case VARYING_SLOT_CLIP_VERTEX:
+            gs_output_semantic_name[slot] = TGSI_SEMANTIC_CLIPVERTEX;
+            gs_output_semantic_index[slot] = 0;
+            break;
+         case VARYING_SLOT_CLIP_DIST0:
+            gs_output_semantic_name[slot] = TGSI_SEMANTIC_CLIPDIST;
+            gs_output_semantic_index[slot] = 0;
+            break;
+         case VARYING_SLOT_CLIP_DIST1:
+            gs_output_semantic_name[slot] = TGSI_SEMANTIC_CLIPDIST;
+            gs_output_semantic_index[slot] = 1;
+            break;
+         case VARYING_SLOT_LAYER:
+            gs_output_semantic_name[slot] = TGSI_SEMANTIC_LAYER;
+            gs_output_semantic_index[slot] = 0;
+            break;
+         case VARYING_SLOT_PRIMITIVE_ID:
+            gs_output_semantic_name[slot] = TGSI_SEMANTIC_PRIMID;
+            gs_output_semantic_index[slot] = 0;
+            break;
          case VARYING_SLOT_TEX0:
          case VARYING_SLOT_TEX1:
          case VARYING_SLOT_TEX2:
@@ -980,20 +1027,22 @@ st_translate_geometry_program(struct st_context *st,
          case VARYING_SLOT_TEX5:
          case VARYING_SLOT_TEX6:
          case VARYING_SLOT_TEX7:
-            /* fall-through */
+            gs_output_semantic_name[slot] = TGSI_SEMANTIC_GENERIC;
+            gs_output_semantic_index[slot] = (attr - VARYING_SLOT_TEX0);
+            break;
          case VARYING_SLOT_VAR0:
-            /* fall-through */
          default:
             assert(slot < Elements(gs_output_semantic_name));
-            /* use default semantic info */
+            assert(attr >= VARYING_SLOT_VAR0);
             gs_output_semantic_name[slot] = TGSI_SEMANTIC_GENERIC;
-            gs_output_semantic_index[slot] = num_generic++;
+            gs_output_semantic_index[slot] = (VARYING_SLOT_VAR0 -
+                                              VARYING_SLOT_TEX0 +
+                                              attr - 
+                                              VARYING_SLOT_VAR0);
          }
       }
    }
 
-   assert(gs_output_semantic_name[0] == TGSI_SEMANTIC_POSITION);
-
    /* find max output slot referenced to compute gs_num_outputs */
    for (attr = 0; attr < VARYING_SLOT_MAX; attr++) {
       if (outputMapping[attr] != ~0 && outputMapping[attr] > maxSlot)
@@ -1031,23 +1080,44 @@ st_translate_geometry_program(struct st_context *st,
    ureg_property_gs_output_prim(ureg, stgp->Base.OutputType);
    ureg_property_gs_max_vertices(ureg, stgp->Base.VerticesOut);
 
-   st_translate_mesa_program(st->ctx,
-                             TGSI_PROCESSOR_GEOMETRY,
-                             ureg,
-                             &stgp->Base.Base,
-                             /* inputs */
-                             gs_num_inputs,
-                             inputMapping,
-                             stgp->input_semantic_name,
-                             stgp->input_semantic_index,
-                             NULL,
-                             /* outputs */
-                             gs_num_outputs,
-                             outputMapping,
-                             gs_output_semantic_name,
-                             gs_output_semantic_index,
-                             FALSE,
-                             FALSE);
+   if (stgp->glsl_to_tgsi)
+      st_translate_program(st->ctx,
+                           TGSI_PROCESSOR_GEOMETRY,
+                           ureg,
+                           stgp->glsl_to_tgsi,
+                           &stgp->Base.Base,
+                           /* inputs */
+                           gs_num_inputs,
+                           inputMapping,
+                           stgp->input_semantic_name,
+                           stgp->input_semantic_index,
+                           NULL,
+                           NULL,
+                           /* outputs */
+                           gs_num_outputs,
+                           outputMapping,
+                           gs_output_semantic_name,
+                           gs_output_semantic_index,
+                           FALSE,
+                           FALSE);
+   else
+      st_translate_mesa_program(st->ctx,
+                                TGSI_PROCESSOR_GEOMETRY,
+                                ureg,
+                                &stgp->Base.Base,
+                                /* inputs */
+                                gs_num_inputs,
+                                inputMapping,
+                                stgp->input_semantic_name,
+                                stgp->input_semantic_index,
+                                NULL,
+                                /* outputs */
+                                gs_num_outputs,
+                                outputMapping,
+                                gs_output_semantic_name,
+                                gs_output_semantic_index,
+                                FALSE,
+                                FALSE);
 
    stgp->num_inputs = gs_num_inputs;
    stgp->tgsi.tokens = ureg_get_tokens( ureg, NULL );
diff --git a/src/mesa/vbo/vbo_exec.c b/src/mesa/vbo/vbo_exec.c
index aa2c7b0..2f05e00 100644
--- a/src/mesa/vbo/vbo_exec.c
+++ b/src/mesa/vbo/vbo_exec.c
@@ -100,7 +100,7 @@ void vbo_exec_invalidate_state( struct gl_context *ctx, GLuint new_state )
    }
 
    if (new_state & _NEW_EVAL)
-      exec->eval.recalculate_maps = 1;
+      exec->eval.recalculate_maps = GL_TRUE;
 
    _ae_invalidate_state(ctx, new_state);
 }
diff --git a/src/mesa/vbo/vbo_exec_eval.c b/src/mesa/vbo/vbo_exec_eval.c
index 71155ce..2bd1b21 100644
--- a/src/mesa/vbo/vbo_exec_eval.c
+++ b/src/mesa/vbo/vbo_exec_eval.c
@@ -117,7 +117,7 @@ void vbo_exec_eval_update( struct vbo_exec_context *exec )
    else if (ctx->Eval.Map2Vertex3) 
       set_active_eval2( exec, VBO_ATTRIB_POS, 3, &ctx->EvalMap.Map2Vertex3 );
 
-   exec->eval.recalculate_maps = 0;
+   exec->eval.recalculate_maps = GL_FALSE;
 }
 
 
diff --git a/src/mesa/vbo/vbo_save.h b/src/mesa/vbo/vbo_save.h
index aa075bb..a810bef 100644
--- a/src/mesa/vbo/vbo_save.h
+++ b/src/mesa/vbo/vbo_save.h
@@ -63,7 +63,7 @@ struct vbo_save_copied_vtx {
 struct vbo_save_vertex_list {
    GLubyte attrsz[VBO_ATTRIB_MAX];
    GLenum attrtype[VBO_ATTRIB_MAX];
-   GLuint vertex_size;
+   GLuint vertex_size;  /**< size in GLfloats */
 
    /* Copy of the final vertex from node->vertex_store->bufferobj.
     * Keep this in regular (non-VBO) memory to avoid repeated
diff --git a/src/mesa/vbo/vbo_save_api.c b/src/mesa/vbo/vbo_save_api.c
index 2028d8b..411c006 100644
--- a/src/mesa/vbo/vbo_save_api.c
+++ b/src/mesa/vbo/vbo_save_api.c
@@ -41,7 +41,7 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
  * example by building a list that consists of one very long primitive
  * (eg Begin(Triangles), 1000 vertices, End), and calling that list
  * from inside a different begin/end object (Begin(Lines), CallList,
- * End).  
+ * End).
  *
  * In that case the code will have to replay the list as individual
  * commands through the Exec dispatch table, or fix up the copied
@@ -60,7 +60,7 @@ USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
  * The list compiler currently doesn't attempt to compile lists
  * containing EvalCoord or EvalPoint commands.  On encountering one of
- * these, compilation falls back to opcodes.  
+ * these, compilation falls back to opcodes.
  *
  * This could be improved to fallback only when a mix of EvalCoord and
  * Vertex commands are issued within a single primitive.
@@ -237,16 +237,31 @@ GLfloat *
 vbo_save_map_vertex_store(struct gl_context *ctx,
                           struct vbo_save_vertex_store *vertex_store)
 {
+   const GLbitfield access = (GL_MAP_WRITE_BIT |
+                              GL_MAP_INVALIDATE_RANGE_BIT |
+                              GL_MAP_UNSYNCHRONIZED_BIT |
+                              GL_MAP_FLUSH_EXPLICIT_BIT);
+
    assert(vertex_store->bufferobj);
-   assert(!vertex_store->buffer);
+   assert(!vertex_store->buffer);  /* the buffer should not be mapped */
+
    if (vertex_store->bufferobj->Size > 0) {
-      vertex_store->buffer =
-         (GLfloat *) ctx->Driver.MapBufferRange(ctx, 0,
-                                                vertex_store->bufferobj->Size,
-                                                GL_MAP_WRITE_BIT,  /* not used */
-                                                vertex_store->bufferobj);
-      assert(vertex_store->buffer);
-      return vertex_store->buffer + vertex_store->used;
+      /* Map the remaining free space in the VBO */
+      GLintptr offset = vertex_store->used * sizeof(GLfloat);
+      GLsizeiptr size = vertex_store->bufferobj->Size - offset;
+      GLfloat *range = (GLfloat *)
+         ctx->Driver.MapBufferRange(ctx, offset, size, access,
+                                    vertex_store->bufferobj);
+      if (range) {
+         /* compute address of start of whole buffer (needed elsewhere) */
+         vertex_store->buffer = range - vertex_store->used;
+         assert(vertex_store->buffer);
+         return range;
+      }
+      else {
+         vertex_store->buffer = NULL;
+         return NULL;
+      }
    }
    else {
       /* probably ran out of memory for buffers */
@@ -260,6 +275,14 @@ vbo_save_unmap_vertex_store(struct gl_context *ctx,
                             struct vbo_save_vertex_store *vertex_store)
 {
    if (vertex_store->bufferobj->Size > 0) {
+      GLintptr offset = 0;
+      GLsizeiptr length = vertex_store->used * sizeof(GLfloat)
+         - vertex_store->bufferobj->Offset;
+
+      /* Explicitly flush the region we wrote to */
+      ctx->Driver.FlushMappedBufferRange(ctx, offset, length,
+                                         vertex_store->bufferobj);
+
       ctx->Driver.UnmapBuffer(ctx, vertex_store->bufferobj);
    }
    vertex_store->buffer = NULL;
@@ -289,15 +312,15 @@ _save_reset_counters(struct gl_context *ctx)
    assert(save->buffer == save->buffer_ptr);
 
    if (save->vertex_size)
-      save->max_vert = ((VBO_SAVE_BUFFER_SIZE - save->vertex_store->used) /
-                        save->vertex_size);
+      save->max_vert = (VBO_SAVE_BUFFER_SIZE - save->vertex_store->used) /
+                        save->vertex_size;
    else
       save->max_vert = 0;
 
    save->vert_count = 0;
    save->prim_count = 0;
    save->prim_max = VBO_SAVE_PRIM_SIZE - save->prim_store->used;
-   save->dangling_attr_ref = 0;
+   save->dangling_attr_ref = GL_FALSE;
 }
 
 /**
@@ -410,7 +433,7 @@ _save_compile_vertex_list(struct gl_context *ctx)
    save->vertex_store->used += save->vertex_size * node->count;
    save->prim_store->used += node->prim_count;
 
-   /* Copy duplicated vertices 
+   /* Copy duplicated vertices
     */
    save->copied.nr = _save_copy_vertices(ctx, node, save->buffer);
 
@@ -514,7 +537,7 @@ _save_wrap_buffers(struct gl_context *ctx)
 
 /**
  * Called only when buffers are wrapped as the result of filling the
- * vertex_store struct.  
+ * vertex_store struct.
  */
 static void
 _save_wrap_filled_vertex(struct gl_context *ctx)
@@ -603,7 +626,7 @@ _save_upgrade_vertex(struct gl_context *ctx, GLuint attr, GLuint newsz)
 
    /* Do a COPY_TO_CURRENT to ensure back-copying works for the case
     * when the attribute already exists in the vertex and is having
-    * its size increased.  
+    * its size increased.
     */
    _save_copy_to_current(ctx);
 
@@ -856,7 +879,7 @@ dlist_fallback(struct gl_context *ctx)
        * unfortunately, otherwise this primitive won't be handled
        * properly:
        */
-      save->dangling_attr_ref = 1;
+      save->dangling_attr_ref = GL_TRUE;
 
       _save_compile_vertex_list(ctx);
    }
@@ -1433,13 +1456,13 @@ vbo_save_EndList(struct gl_context *ctx)
          GLint i = save->prim_count - 1;
          ctx->Driver.CurrentSavePrimitive = PRIM_OUTSIDE_BEGIN_END;
          save->prim[i].end = 0;
-         save->prim[i].count = (save->vert_count - save->prim[i].start);
+         save->prim[i].count = save->vert_count - save->prim[i].start;
       }
 
       /* Make sure this vertex list gets replayed by the "loopback"
        * mechanism:
        */
-      save->dangling_attr_ref = 1;
+      save->dangling_attr_ref = GL_TRUE;
       vbo_save_SaveFlushVertices(ctx);
 
       /* Swap out this vertex format while outside begin/end.  Any color,
