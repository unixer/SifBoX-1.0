diff --git a/addons/metadata.local/icon.png b/addons/metadata.local/icon.png
new file mode 100644
index 0000000..6ab89fa
Binary files /dev/null and b/addons/metadata.local/icon.png differ
diff --git a/addons/skin.confluence/720p/DialogProgress.xml b/addons/skin.confluence/720p/DialogProgress.xml
index 433eb65..196b9bf 100644
--- a/addons/skin.confluence/720p/DialogProgress.xml
+++ b/addons/skin.confluence/720p/DialogProgress.xml
@@ -62,41 +62,16 @@
 			<ondown>10</ondown>
 			<visible>system.getbool(input.enablemouse)</visible>
 		</control>
-		<control type="label" id="2">
-			<description>dialog line 1</description>
+		<control type="textbox" id="9">
+			<description>text</description>
 			<left>30</left>
 			<top>60</top>
 			<width>550</width>
-			<height>30</height>
-			<align>left</align>
-			<aligny>center</aligny>
-			<label>-</label>
-			<haspath>true</haspath>
-			<font>font13</font>
-		</control>
-		<control type="label" id="3">
-			<description>dialog line 2</description>
-			<left>30</left>
-			<top>85</top>
-			<width>550</width>
-			<height>30</height>
+			<height>80</height>
 			<align>left</align>
-			<aligny>center</aligny>
-			<label>-</label>
-			<haspath>true</haspath>
-			<font>font13</font>
-		</control>
-		<control type="label" id="4">
-			<description>dialog line 3</description>
-			<left>30</left>
-			<top>110</top>
-			<width>550</width>
-			<height>30</height>
-			<align>left</align>
-			<aligny>center</aligny>
 			<label>-</label>
-			<haspath>true</haspath>
 			<font>font13</font>
+			<autoscroll time="3000" delay="4000" repeat="5000">Skin.HasSetting(AutoScroll)</autoscroll>
 		</control>
 		<control type="progress">
 			<description>Progressbar</description>
diff --git a/addons/skin.confluence/720p/weather/10DayForecast.xml b/addons/skin.confluence/720p/weather/10DayForecast.xml
index 0e19b38..2afa597 100644
--- a/addons/skin.confluence/720p/weather/10DayForecast.xml
+++ b/addons/skin.confluence/720p/weather/10DayForecast.xml
@@ -251,7 +251,7 @@
 			<control type="label">
 				<animation effect="slide" start="0,0" end="-90,0" time="0" condition="system.getbool(input.enablemouse)">Conditional</animation>
 				<description>number of files/pages</description>
-				<right>660</right>
+				<right>40</right>
 				<top>627</top>
 				<width>570</width>
 				<font>font12</font>
diff --git a/addons/skin.confluence/720p/weather/36HourForecast.xml b/addons/skin.confluence/720p/weather/36HourForecast.xml
index 8477968..c42f5cb 100644
--- a/addons/skin.confluence/720p/weather/36HourForecast.xml
+++ b/addons/skin.confluence/720p/weather/36HourForecast.xml
@@ -80,7 +80,7 @@
 						<label>[COLOR=grey2]$INFO[Window.Property(36Hour.1.TemperatureHeading)][CR][/COLOR]$INFO[Window.Property(36Hour.1.Temperature),[B] ,[/B]]</label>
 					</control>
 					<control type="label">
-						<right>590</right>
+						<right>90</right>
 						<top>60</top>
 						<width>390</width>
 						<height>20</height>
@@ -145,7 +145,7 @@
 						<label>[COLOR=grey2]$INFO[Window.Property(36Hour.2.TemperatureHeading)][CR][/COLOR]$INFO[Window.Property(36Hour.2.Temperature),[B] ,[/B]]</label>
 					</control>
 					<control type="label">
-						<right>590</right>
+						<right>90</right>
 						<top>60</top>
 						<width>390</width>
 						<height>20</height>
@@ -210,7 +210,7 @@
 						<label>[COLOR=grey2]$INFO[Window.Property(36Hour.3.TemperatureHeading)][CR][/COLOR]$INFO[Window.Property(36Hour.3.Temperature),[B] ,[/B]]</label>
 					</control>
 					<control type="label">
-						<right>590</right>
+						<right>90</right>
 						<top>60</top>
 						<width>390</width>
 						<height>20</height>
diff --git a/addons/skin.confluence/720p/weather/HourlyForecast.xml b/addons/skin.confluence/720p/weather/HourlyForecast.xml
index 58b62c8..e368277 100644
--- a/addons/skin.confluence/720p/weather/HourlyForecast.xml
+++ b/addons/skin.confluence/720p/weather/HourlyForecast.xml
@@ -267,7 +267,7 @@
 			<control type="label">
 				<animation effect="slide" start="0,0" end="-90,0" time="0" condition="system.getbool(input.enablemouse)">Conditional</animation>
 				<description>number of files/pages</description>
-				<right>660</right>
+				<right>40</right>
 				<top>627</top>
 				<width>570</width>
 				<font>font12</font>
diff --git a/addons/xbmc.python/addon.xml b/addons/xbmc.python/addon.xml
index 86cb77a..8b24f0e 100644
--- a/addons/xbmc.python/addon.xml
+++ b/addons/xbmc.python/addon.xml
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<addon id="xbmc.python" version="2.13.0" provider-name="Team XBMC">
+<addon id="xbmc.python" version="2.14.0" provider-name="Team XBMC">
   <backwards-compatibility abi="2.1.0"/>
   <requires>
     <import addon="xbmc.core" version="0.1.0"/>
diff --git a/lib/ffmpeg/libavcodec/aacdec.c b/lib/ffmpeg/libavcodec/aacdec.c
index 7a871c4..12dbfcf 100644
--- a/lib/ffmpeg/libavcodec/aacdec.c
+++ b/lib/ffmpeg/libavcodec/aacdec.c
@@ -505,6 +505,25 @@ static int set_default_channel_config(AVCodecContext *avctx,
     }
     *tags = tags_per_config[channel_config];
     memcpy(layout_map, aac_channel_layout_map[channel_config-1], *tags * sizeof(*layout_map));
+
+    /*
+     * AAC specification has 7.1(wide) as a default layout for 8-channel streams.
+     * However, at least Nero AAC encoder encodes 7.1 streams using the default
+     * channel config 7, mapping the side channels of the original audio stream
+     * to the second AAC_CHANNEL_FRONT pair in the AAC stream. Similarly, e.g. FAAD
+     * decodes the second AAC_CHANNEL_FRONT pair as side channels, therefore decoding
+     * the incorrect streams as if they were correct (and as the encoder intended).
+     *
+     * As actual intended 7.1(wide) streams are very rare, default to assuming a
+     * 7.1 layout was intended.
+     */
+    if (channel_config == 7 && avctx->strict_std_compliance < FF_COMPLIANCE_STRICT) {
+        av_log(avctx, AV_LOG_INFO, "Assuming an incorrectly encoded 7.1 channel layout"
+               " instead of a spec-compliant 7.1(wide) layout, use -strict %d to decode"
+               " according to the specification instead.\n", FF_COMPLIANCE_STRICT);
+        layout_map[2][2] = AAC_CHANNEL_SIDE;
+    }
+
     return 0;
 }
 
diff --git a/lib/ffmpeg/patches/0060-ffmpeg-backport-avcodec-aacdec-default-to-non-wide-7.patch b/lib/ffmpeg/patches/0060-ffmpeg-backport-avcodec-aacdec-default-to-non-wide-7.patch
new file mode 100644
index 0000000..53a385c
--- /dev/null
+++ b/lib/ffmpeg/patches/0060-ffmpeg-backport-avcodec-aacdec-default-to-non-wide-7.patch
@@ -0,0 +1,67 @@
+From 59f16d529fdcb4c5db53ce3bd289aa8148a13de4 Mon Sep 17 00:00:00 2001
+From: Anssi Hannula <anssi.hannula@iki.fi>
+Date: Tue, 17 Dec 2013 23:04:31 +0200
+Subject: [PATCH] [ffmpeg] - backport - avcodec/aacdec: default to non-wide 7.1
+ in non-strict mode
+
+Upstream commit e10fccf62a36e09b54ad6ea3d5fa6638f298d5ae, for
+http://trac.xbmc.org/ticket/13758.
+
+AAC specification has 7.1(wide) as a default layout for 8-channel
+streams (channel config 7). However, at least Nero AAC encoder encodes
+non-wide 7.1 streams using the default channel config 7, mapping the
+side channels of the original audio stream to the second
+AAC_CHANNEL_FRONT pair in the AAC stream. Similarly, e.g. FAAD decodes
+the second AAC_CHANNEL_FRONT pair as side channels, therefore decoding
+the incorrect streams as if they were correct (and as the encoder
+intended).
+
+FFmpeg currently decodes such files by-the-spec, i.e. after decoding the
+original front pair will be in AV_CH_FRONT_x_OF_CENTER and the original
+side pair will be in AV_CH_FRONT_x.
+
+As actual intended 7.1(wide) streams are very rare while misencoded 7.1
+files actually exist in the wild, default to assuming a 7.1 layout was
+intended unless in strict mode.
+
+Fixes playback of e.g. 8_Channel_ID.m4a in samples.
+
+Signed-off-by: Anssi Hannula <anssi.hannula@iki.fi>
+Signed-off-by: Michael Niedermayer <michaelni@gmx.at>
+---
+ lib/ffmpeg/libavcodec/aacdec.c | 19 +++++++++++++++++++
+ 1 file changed, 19 insertions(+)
+
+diff --git a/lib/ffmpeg/libavcodec/aacdec.c b/lib/ffmpeg/libavcodec/aacdec.c
+index 7a871c4..12dbfcf 100644
+--- a/lib/ffmpeg/libavcodec/aacdec.c
++++ b/lib/ffmpeg/libavcodec/aacdec.c
+@@ -505,6 +505,25 @@ static int set_default_channel_config(AVCodecContext *avctx,
+     }
+     *tags = tags_per_config[channel_config];
+     memcpy(layout_map, aac_channel_layout_map[channel_config-1], *tags * sizeof(*layout_map));
++
++    /*
++     * AAC specification has 7.1(wide) as a default layout for 8-channel streams.
++     * However, at least Nero AAC encoder encodes 7.1 streams using the default
++     * channel config 7, mapping the side channels of the original audio stream
++     * to the second AAC_CHANNEL_FRONT pair in the AAC stream. Similarly, e.g. FAAD
++     * decodes the second AAC_CHANNEL_FRONT pair as side channels, therefore decoding
++     * the incorrect streams as if they were correct (and as the encoder intended).
++     *
++     * As actual intended 7.1(wide) streams are very rare, default to assuming a
++     * 7.1 layout was intended.
++     */
++    if (channel_config == 7 && avctx->strict_std_compliance < FF_COMPLIANCE_STRICT) {
++        av_log(avctx, AV_LOG_INFO, "Assuming an incorrectly encoded 7.1 channel layout"
++               " instead of a spec-compliant 7.1(wide) layout, use -strict %d to decode"
++               " according to the specification instead.\n", FF_COMPLIANCE_STRICT);
++        layout_map[2][2] = AAC_CHANNEL_SIDE;
++    }
++
+     return 0;
+ }
+ 
+-- 
+1.8.1.5
+
diff --git a/lib/libcec/Makefile b/lib/libcec/Makefile
index 7dc3e30..262b0d5 100644
--- a/lib/libcec/Makefile
+++ b/lib/libcec/Makefile
@@ -7,8 +7,8 @@
 
 # lib name, version
 LIBNAME=libcec
-VERSION=2.1.1
-SOURCE=$(LIBNAME)-$(VERSION)
+VERSION=2.1.4
+SOURCE=$(LIBNAME)-$(VERSION)-2
 
 # download location and format
 BASE_URL=http://mirrors.xbmc.org/build-deps/darwin-libs
diff --git a/lib/libexif/IptcParse.cpp b/lib/libexif/IptcParse.cpp
index 1fc7dfb..a0bba16 100644
--- a/lib/libexif/IptcParse.cpp
+++ b/lib/libexif/IptcParse.cpp
@@ -201,8 +201,10 @@ bool CIptcParse::Process (const unsigned char* const Data, const unsigned short
         // there may be multiple keywords - lets join them
         size_t maxLen = MAX_IPTC_STRING - strlen(tag);
         if (maxLen > 2)
+        {
           strcat(tag, ", ");
-        strncat(tag, pos, min(length, MAX_IPTC_STRING - maxLen - 3));
+          strncat(tag, pos, min(length, maxLen - 3));
+        }
       }
 /*      if (id == SLIDE_IPTC_CAPTION)
       {
diff --git a/project/BuildDependencies/scripts/libcec_d.txt b/project/BuildDependencies/scripts/libcec_d.txt
index 065ce3a..a126c74 100644
--- a/project/BuildDependencies/scripts/libcec_d.txt
+++ b/project/BuildDependencies/scripts/libcec_d.txt
@@ -1,3 +1,3 @@
 ; filename                        source of the file
 
-libcec-2.1.1.zip                  http://mirrors.xbmc.org/build-deps/win32/
+libcec-2.1.4.zip                  http://mirrors.xbmc.org/build-deps/win32/
diff --git a/tools/EventClients/Clients/WiiRemote/CWIID_WiiRemote.cpp b/tools/EventClients/Clients/WiiRemote/CWIID_WiiRemote.cpp
index fb88cf5..87af359 100644
--- a/tools/EventClients/Clients/WiiRemote/CWIID_WiiRemote.cpp
+++ b/tools/EventClients/Clients/WiiRemote/CWIID_WiiRemote.cpp
@@ -83,7 +83,7 @@ void CWiiRemote::MessageCallback(cwiid_wiimote_t *wiiremote, int mesg_count, uni
                                           mesg[i].ir_mesg.src[1].pos[CWIID_Y]);
       }
       else if (valid_source > 2)
-      { //TODO Make this care with the strenght of the sources
+      { //TODO Make this care with the strength of the sources
         g_WiiRemote.CalculateMousePointer(mesg[i].ir_mesg.src[0].pos[CWIID_X],
                                           mesg[i].ir_mesg.src[0].pos[CWIID_Y],
                                           mesg[i].ir_mesg.src[1].pos[CWIID_X],
@@ -97,7 +97,7 @@ void CWiiRemote::MessageCallback(cwiid_wiimote_t *wiiremote, int mesg_count, uni
       g_WiiRemote.ProcessKey(mesg[i].btn_mesg.buttons);
     break;	  
     case CWIID_MESG_STATUS:
-      //Here we can figure out Extensiontypes and such
+      //Here we can figure out Extension types and such
     break;
     case CWIID_MESG_NUNCHUK:
       g_WiiRemote.ProcessNunchuck(mesg[i].nunchuk_mesg);
@@ -237,12 +237,12 @@ void CWiiRemote::Initialize(CAddress Addr, int Socket)
   ToggleBit(m_ledState, CWIID_LED4_ON);
 }
 
-/* Update is run regulary and we gather the state of the Wiiremote and see if the user have pressed on a button or moved the wiiremote
+/* Update is run regularly and we gather the state of the Wiiremote and see if the user have pressed on a button or moved the wiiremote
    This could have been done with callbacks instead but it doesn't look nice in C++*/
 void CWiiRemote::Update()
 {
   if (m_DisconnectWhenPossible)
-  {//If the user have choosen to disconnect or lost comunication
+  {//If the user has chosen to disconnect or lost communication
     DisconnectNow(true);
     m_DisconnectWhenPossible = false;
   }
@@ -311,7 +311,7 @@ void CWiiRemote::Disconnect()
 		
 #ifdef CWIID_OLD		
 /* This function is mostly a hack as CWIID < 6.0 doesn't report on disconnects, this function is called everytime
-   a message is sent to the callback (Will be once every 10 ms or so) this is to see if the connection is interupted. */
+   a message is sent to the callback (Will be once every 10 ms or so) this is to see if the connection is interrupted. */
 void CWiiRemote::CheckIn()
 { //This is always called from a criticalsection
   m_LastMsgTime = getTicks();
@@ -357,12 +357,12 @@ bool CWiiRemote::Connect()
       }
 #ifdef CWIID_OLD
       /* CheckIn to say that this is the last msg, If this isn't called it could give issues if we Connects -> Disconnect and then try to connect again 
-         the CWIID_OLD hack would automaticly disconnect the wiiremote as the lastmsg is too old. */
+         the CWIID_OLD hack would automatically disconnect the wiiremote as the lastmsg is too old. */
       CheckIn();
 #endif      
       m_connected = true;
 
-      CPacketLOG log(LOGNOTICE, "Sucessfully connected a WiiRemote");
+      CPacketLOG log(LOGNOTICE, "Successfully connected a WiiRemote");
       log.Send(m_Socket, m_MyAddr);
       return true;
     }
@@ -390,7 +390,7 @@ void CWiiRemote::DisconnectNow(bool startConnectThread)
       notification.Send(m_Socket, m_MyAddr);
     }
 
-    CPacketLOG log(LOGNOTICE, "Sucessfully disconnected a WiiRemote");
+    CPacketLOG log(LOGNOTICE, "Successfully disconnected a WiiRemote");
     log.Send(m_Socket, m_MyAddr);
   }
   m_connected = false;
@@ -415,7 +415,7 @@ bool CWiiRemote::CheckConnection()
 
 /* Sets rpt mode when a new wiiremote is connected */
 void CWiiRemote::SetupWiiRemote()
-{ //Lights up the apropriate led and setups the rapport mode, so buttons and IR work
+{ //Lights up the appropriate led and setups the rapport mode, so buttons and IR work
   SetRptMode();
   SetLedState();
 
diff --git a/tools/depends/target/libcec/Makefile b/tools/depends/target/libcec/Makefile
index 0a42317..e30c549 100644
--- a/tools/depends/target/libcec/Makefile
+++ b/tools/depends/target/libcec/Makefile
@@ -3,8 +3,8 @@ DEPS= ../../Makefile.include Makefile
 
 # lib name, version
 LIBNAME=libcec
-VERSION=2.1.1
-SOURCE=$(LIBNAME)-$(VERSION)
+VERSION=2.1.4
+SOURCE=$(LIBNAME)-$(VERSION)-2
 ARCHIVE=$(SOURCE).tar.gz
 
 # configuration settings
diff --git a/xbmc/TextureCache.cpp b/xbmc/TextureCache.cpp
index 2c1da1f..8b45d39 100644
--- a/xbmc/TextureCache.cpp
+++ b/xbmc/TextureCache.cpp
@@ -66,6 +66,7 @@ bool CTextureCache::IsCachedImage(const CStdString &url) const
   if (url != "-" && !CURL::IsFullPath(url))
     return true;
   if (URIUtils::IsInPath(url, "special://skin/") ||
+      URIUtils::IsInPath(url, "special://temp/") ||
       URIUtils::IsInPath(url, "androidapp://")   ||
       URIUtils::IsInPath(url, CProfilesManager::Get().GetThumbnailsFolder()))
     return true;
diff --git a/xbmc/android/jni/AudioFormat.cpp b/xbmc/android/jni/AudioFormat.cpp
new file mode 100644
index 0000000..760fe13
--- /dev/null
+++ b/xbmc/android/jni/AudioFormat.cpp
@@ -0,0 +1,41 @@
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "AudioFormat.h"
+#include "JNIBase.h"
+#include "jutils/jutils-details.hpp"
+
+using namespace jni;
+
+int CJNIAudioFormat::ENCODING_PCM_16BIT = 0x00000002;
+int CJNIAudioFormat::CHANNEL_OUT_STEREO = 0x0000000c;
+
+void CJNIAudioFormat::PopulateStaticFields()
+{
+  int sdk = CJNIBase::GetSDKVersion();
+  if (sdk >= 3)
+  {
+    jhclass c = find_class("android/media/AudioFormat");
+    CJNIAudioFormat::ENCODING_PCM_16BIT = get_static_field<int>(c, "ENCODING_PCM_16BIT");
+    if (sdk >= 5)
+      CJNIAudioFormat::CHANNEL_OUT_STEREO = get_static_field<int>(c, "CHANNEL_OUT_STEREO");
+  }
+}
+
diff --git a/xbmc/android/jni/AudioFormat.h b/xbmc/android/jni/AudioFormat.h
new file mode 100644
index 0000000..ab50254
--- /dev/null
+++ b/xbmc/android/jni/AudioFormat.h
@@ -0,0 +1,35 @@
+#pragma once
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+namespace jni
+{
+
+class CJNIAudioFormat
+{
+  public:
+    static void PopulateStaticFields();
+
+    static int ENCODING_PCM_16BIT;
+    static int CHANNEL_OUT_STEREO;
+};
+
+};
+
diff --git a/xbmc/android/jni/AudioManager.h b/xbmc/android/jni/AudioManager.h
index 85256f8..0eb8291 100644
--- a/xbmc/android/jni/AudioManager.h
+++ b/xbmc/android/jni/AudioManager.h
@@ -33,9 +33,9 @@ public:
   void setStreamVolume(int index = 0, int flags = 0);
 
   static void PopulateStaticFields();
+  static int STREAM_MUSIC;
 
 private:
   CJNIAudioManager();
-
-  static int STREAM_MUSIC;
 };
+
diff --git a/xbmc/android/jni/AudioTrack.cpp b/xbmc/android/jni/AudioTrack.cpp
new file mode 100644
index 0000000..e28e803
--- /dev/null
+++ b/xbmc/android/jni/AudioTrack.cpp
@@ -0,0 +1,118 @@
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "AudioTrack.h"
+#include "jutils/jutils-details.hpp"
+
+using namespace jni;
+
+int CJNIAudioTrack::MODE_STREAM       = 0x00000001;
+int CJNIAudioTrack::PLAYSTATE_PLAYING = 0x00000003;
+
+void CJNIAudioTrack::PopulateStaticFields()
+{
+  if (CJNIBase::GetSDKVersion() >= 3)
+  {
+    jhclass c = find_class("android/media/AudioTrack");
+    CJNIAudioTrack::PLAYSTATE_PLAYING = get_static_field<int>(c, "PLAYSTATE_PLAYING");
+    if (CJNIBase::GetSDKVersion() >= 5)
+      CJNIAudioTrack::MODE_STREAM = get_static_field<int>(c, "MODE_STREAM");
+  }
+}
+
+CJNIAudioTrack::CJNIAudioTrack(int streamType, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes, int mode)
+  : CJNIBase("android/media/AudioTrack")
+{
+  m_object = new_object(GetClassName(), "<init>", "(IIIIII)V",
+                        streamType, sampleRateInHz, channelConfig,
+                        audioFormat, bufferSizeInBytes, mode);
+  m_buffer = jharray(xbmc_jnienv()->NewByteArray(bufferSizeInBytes));
+
+  m_object.setGlobal();
+  m_buffer.setGlobal();
+}
+
+void CJNIAudioTrack::play()
+{
+  call_method<void>(m_object, "play", "()V");
+}
+
+void CJNIAudioTrack::stop()
+{
+  call_method<void>(m_object, "stop", "()V");
+
+  JNIEnv* jenv = xbmc_jnienv();
+
+  // might toss an exception on release so catch it.
+  jthrowable exception = jenv->ExceptionOccurred();
+  if (exception)
+  {
+    jenv->ExceptionDescribe();
+    jenv->ExceptionClear();
+  }
+}
+
+void CJNIAudioTrack::flush()
+{
+  call_method<void>(m_object, "flush", "()V");
+}
+
+void CJNIAudioTrack::release()
+{
+  call_method<void>(m_object, "release", "()V");
+
+  JNIEnv* jenv  = xbmc_jnienv();
+}
+
+int CJNIAudioTrack::write(char* audioData, int offsetInBytes, int sizeInBytes)
+{
+  int     written = 0;
+  JNIEnv* jenv    = xbmc_jnienv();
+  char*   pArray;
+  
+  // Write a buffer of audio data to Java AudioTrack.
+  // Warning, no other JNI function can be called after
+  // GetPrimitiveArrayCritical until ReleasePrimitiveArrayCritical.
+  if ((pArray = (char*)jenv->GetPrimitiveArrayCritical(m_buffer, NULL)))
+  {
+    memcpy(pArray + offsetInBytes, audioData, sizeInBytes);
+    jenv->ReleasePrimitiveArrayCritical(m_buffer, pArray, 0);
+    written = call_method<int>(m_object, "write", "([BII)I", m_buffer, offsetInBytes, sizeInBytes);
+  }
+
+  return written;
+}
+
+int CJNIAudioTrack::getPlayState()
+{
+  return call_method<int>(m_object, "getPlayState", "()I");
+}
+
+int CJNIAudioTrack::getPlaybackHeadPosition()
+{
+  return call_method<int>(m_object, "getPlaybackHeadPosition", "()I");
+}
+
+int CJNIAudioTrack::getMinBufferSize(int sampleRateInHz, int channelConfig, int audioFormat)
+{
+  return call_static_method<int>( "android/media/AudioTrack", "getMinBufferSize", "(III)I",
+                                  sampleRateInHz, channelConfig, audioFormat);
+}
+
diff --git a/xbmc/android/jni/AudioTrack.h b/xbmc/android/jni/AudioTrack.h
new file mode 100644
index 0000000..627edac
--- /dev/null
+++ b/xbmc/android/jni/AudioTrack.h
@@ -0,0 +1,51 @@
+#pragma once
+/*
+ *      Copyright (C) 2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "JNIBase.h"
+#include "ByteBuffer.h"
+
+namespace jni
+{
+
+class CJNIAudioTrack : public CJNIBase
+{
+  jharray m_buffer;
+
+  public:
+    CJNIAudioTrack(int streamType, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes, int mode);
+
+    void  play();
+    void  stop();
+    void  flush();
+    void  release();
+    int   write(char* audioData, int offsetInBytes, int sizeInBytes);
+    int   getPlayState();
+    int   getPlaybackHeadPosition();
+
+    static int  MODE_STREAM;
+    static int  PLAYSTATE_PLAYING;
+    
+    static void PopulateStaticFields();
+    static int  getMinBufferSize(int sampleRateInHz, int channelConfig, int audioFormat);
+};
+
+};
+
diff --git a/xbmc/android/jni/Context.cpp b/xbmc/android/jni/Context.cpp
index 70e26e9..d989ee9 100644
--- a/xbmc/android/jni/Context.cpp
+++ b/xbmc/android/jni/Context.cpp
@@ -35,7 +35,9 @@
 #include "PowerManager.h"
 #include "Cursor.h"
 #include "ConnectivityManager.h"
+#include "AudioFormat.h"
 #include "AudioManager.h"
+#include "AudioTrack.h"
 #include "Surface.h"
 #include "MediaCodec.h"
 #include "MediaCodecInfo.h"
@@ -76,7 +78,9 @@ void CJNIContext::PopulateStaticFields()
   CJNICursor::PopulateStaticFields();
   CJNIContentResolver::PopulateStaticFields();
   CJNIConnectivityManager::PopulateStaticFields();
+  CJNIAudioFormat::PopulateStaticFields();
   CJNIAudioManager::PopulateStaticFields();
+  CJNIAudioTrack::PopulateStaticFields();
   CJNISurface::PopulateStaticFields();
   CJNIMediaCodec::PopulateStaticFields();
   CJNIMediaCodecInfoCodecProfileLevel::PopulateStaticFields();
diff --git a/xbmc/android/jni/Makefile.in b/xbmc/android/jni/Makefile.in
index 35cb840..c4deaab 100644
--- a/xbmc/android/jni/Makefile.in
+++ b/xbmc/android/jni/Makefile.in
@@ -4,7 +4,9 @@ SRCS      += Context.cpp
 SRCS      += BroadcastReceiver.cpp
 SRCS      += Intent.cpp
 SRCS      += PackageManager.cpp
+SRCS      += AudioFormat.cpp
 SRCS      += AudioManager.cpp
+SRCS      += AudioTrack.cpp
 SRCS      += PowerManager.cpp
 SRCS      += WakeLock.cpp
 SRCS      += Environment.cpp
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index a488b92..7ba4761 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -1007,6 +1007,9 @@ void CActiveAE::Configure(AEAudioFormat *desiredFmt)
         (*it)->m_inputBuffers = new CActiveAEBufferPool((*it)->m_format);
         (*it)->m_inputBuffers->Create(MAX_CACHE_LEVEL*1000);
         (*it)->m_streamSpace = (*it)->m_format.m_frameSize * (*it)->m_format.m_frames;
+
+        // if input format does not follow ffmpeg channel mask, we may need to remap channels
+        (*it)->InitRemapper();
       }
       if (initSink && (*it)->m_resampleBuffers)
       {
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp
index e2e4aa5..ca19263 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp
@@ -25,6 +25,9 @@ using namespace ActiveAE;
 CActiveAEResample::CActiveAEResample()
 {
   m_pContext = NULL;
+  m_loaded = false;
+  if (m_dllAvUtil.Load() && m_dllSwResample.Load())
+    m_loaded = true;
 }
 
 CActiveAEResample::~CActiveAEResample()
@@ -38,7 +41,7 @@ CActiveAEResample::~CActiveAEResample()
 
 bool CActiveAEResample::Init(uint64_t dst_chan_layout, int dst_channels, int dst_rate, AVSampleFormat dst_fmt, int dst_bits, uint64_t src_chan_layout, int src_channels, int src_rate, AVSampleFormat src_fmt, int src_bits, bool upmix, bool normalize, CAEChannelInfo *remapLayout, AEQuality quality)
 {
-  if (!m_dllAvUtil.Load() || !m_dllSwResample.Load())
+  if (!m_loaded)
     return false;
 
   m_dst_chan_layout = dst_chan_layout;
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h
index 792ff12..7e8937e 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h
@@ -51,6 +51,7 @@ public:
 protected:
   DllAvUtil m_dllAvUtil;
   DllSwResample m_dllSwResample;
+  bool m_loaded;
   uint64_t m_src_chan_layout, m_dst_chan_layout;
   int m_src_rate, m_dst_rate;
   int m_src_channels, m_dst_channels;
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
index d5b01ea..4a75f9e 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
@@ -56,11 +56,15 @@ CActiveAEStream::CActiveAEStream(AEAudioFormat *format)
   m_leftoverBuffer = new uint8_t[m_format.m_frameSize];
   m_leftoverBytes = 0;
   m_forceResampler = false;
+  m_remapper = NULL;
+  m_remapBuffer = NULL;
 }
 
 CActiveAEStream::~CActiveAEStream()
 {
   delete [] m_leftoverBuffer;
+  delete m_remapper;
+  delete m_remapBuffer;
 }
 
 void CActiveAEStream::IncFreeBuffers()
@@ -81,6 +85,105 @@ void CActiveAEStream::ResetFreeBuffers()
   m_streamFreeBuffers = 0;
 }
 
+void CActiveAEStream::InitRemapper()
+{
+  // check if input format follows ffmpeg channel mask
+  bool needRemap = false;
+  unsigned int avLast, avCur = 0;
+  for(unsigned int i=0; i<m_format.m_channelLayout.Count(); i++)
+  {
+    avLast = avCur;
+    avCur = CActiveAEResample::GetAVChannel(m_format.m_channelLayout[i]);
+    if(avCur < avLast)
+    {
+      needRemap = true;
+      break;
+    }
+  }
+
+  if(needRemap)
+  {
+    CLog::Log(LOGDEBUG, "CActiveAEStream::%s - initialize remapper", __FUNCTION__);
+
+    m_remapper = new CActiveAEResample();
+    uint64_t avLayout = CActiveAEResample::GetAVChannelLayout(m_format.m_channelLayout);
+
+    // build layout according to ffmpeg channel order
+    // we need this for reference
+    CAEChannelInfo ffmpegLayout;
+    ffmpegLayout.Reset();
+    int idx = 0;
+    for(unsigned int i=0; i<m_format.m_channelLayout.Count(); i++)
+    {
+      for(unsigned int j=0; j<m_format.m_channelLayout.Count(); j++)
+      {
+        idx = m_remapper->GetAVChannelIndex(m_format.m_channelLayout[j], avLayout);
+        if (idx == i)
+        {
+          ffmpegLayout += m_format.m_channelLayout[j];
+          break;
+        }
+      }
+    }
+
+    // build remap layout we can pass to resampler as destination layout
+    CAEChannelInfo remapLayout;
+    remapLayout.Reset();
+    for(unsigned int i=0; i<m_format.m_channelLayout.Count(); i++)
+    {
+      for(unsigned int j=0; j<m_format.m_channelLayout.Count(); j++)
+      {
+        idx = m_remapper->GetAVChannelIndex(m_format.m_channelLayout[j], avLayout);
+        if (idx == i)
+        {
+          remapLayout += ffmpegLayout[j];
+          break;
+        }
+      }
+    }
+
+    // initialize resampler for only doing remapping
+    m_remapper->Init(avLayout,
+                     m_format.m_channelLayout.Count(),
+                     m_format.m_sampleRate,
+                     CActiveAEResample::GetAVSampleFormat(m_format.m_dataFormat),
+                     CAEUtil::DataFormatToUsedBits(m_format.m_dataFormat),
+                     avLayout,
+                     m_format.m_channelLayout.Count(),
+                     m_format.m_sampleRate,
+                     CActiveAEResample::GetAVSampleFormat(m_format.m_dataFormat),
+                     CAEUtil::DataFormatToUsedBits(m_format.m_dataFormat),
+                     false,
+                     false,
+                     &remapLayout,
+                     AE_QUALITY_LOW); // not used for remapping
+
+    // extra sound packet, we can't resample to the same buffer
+    m_remapBuffer = new CSoundPacket(m_inputBuffers->m_allSamples[0]->pkt->config, m_inputBuffers->m_allSamples[0]->pkt->max_nb_samples);
+  }
+}
+
+void CActiveAEStream::RemapBuffer()
+{
+  if(m_remapper)
+  {
+    int samples = m_remapper->Resample(m_remapBuffer->data, m_remapBuffer->max_nb_samples,
+                                       m_currentBuffer->pkt->data, m_currentBuffer->pkt->nb_samples,
+                                       1.0);
+
+    if (samples != m_currentBuffer->pkt->nb_samples)
+    {
+      CLog::Log(LOGERROR, "CActiveAEStream::%s - error remapping", __FUNCTION__);
+    }
+
+    // swap sound packets
+    CSoundPacket *tmp = m_remapBuffer;
+    tmp = m_currentBuffer->pkt;
+    m_currentBuffer->pkt = m_remapBuffer;
+    m_remapBuffer = tmp;
+  }
+}
+
 unsigned int CActiveAEStream::GetSpace()
 {
   CSingleLock lock(m_streamLock);
@@ -150,6 +253,7 @@ unsigned int CActiveAEStream::AddData(void *data, unsigned int size)
         MsgStreamSample msgData;
         msgData.buffer = m_currentBuffer;
         msgData.stream = this;
+        RemapBuffer();
         m_streamPort->SendOutMessage(CActiveAEDataProtocol::STREAMSAMPLE, &msgData, sizeof(MsgStreamSample));
         m_currentBuffer = NULL;
       }
@@ -234,6 +338,7 @@ void CActiveAEStream::Drain(bool wait)
     MsgStreamSample msgData;
     msgData.buffer = m_currentBuffer;
     msgData.stream = this;
+    RemapBuffer();
     m_streamPort->SendOutMessage(CActiveAEDataProtocol::STREAMSAMPLE, &msgData, sizeof(MsgStreamSample));
     m_currentBuffer = NULL;
   }
@@ -248,6 +353,7 @@ void CActiveAEStream::Drain(bool wait)
         MsgStreamSample msgData;
         msgData.stream = this;
         msgData.buffer = *((CSampleBuffer**)msg->data);
+        RemapBuffer();
         msg->Reply(CActiveAEDataProtocol::STREAMSAMPLE, &msgData, sizeof(MsgStreamSample));
         DecFreeBuffers();
         continue;
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h
index 607e4ca..1d820ca 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h
@@ -38,6 +38,8 @@ protected:
   void IncFreeBuffers();
   void DecFreeBuffers();
   void ResetFreeBuffers();
+  void InitRemapper();
+  void RemapBuffer();
 
 public:
   virtual unsigned int GetSpace();
@@ -94,12 +96,14 @@ protected:
   CCriticalSection m_streamLock;
   uint8_t *m_leftoverBuffer;
   int m_leftoverBytes;
+  CSampleBuffer *m_currentBuffer;
+  CSoundPacket *m_remapBuffer;
+  CActiveAEResample *m_remapper;
 
   // only accessed by engine
   CActiveAEBufferPool *m_inputBuffers;
   CActiveAEBufferPoolResample *m_resampleBuffers;
   std::deque<CSampleBuffer*> m_processingSamples;
-  CSampleBuffer *m_currentBuffer;
   CActiveAEDataProtocol *m_streamPort;
   CEvent m_inMsgEvent;
   CCriticalSection *m_statsLock;
diff --git a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp
index 71458ee..1cd49cb 100644
--- a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.cpp
@@ -83,6 +83,7 @@ void RegisterDeviceChangedCB(bool bRegister, void *ref){}
 
 CCoreAudioAE::CCoreAudioAE() :
   m_Initialized        (false         ),
+  m_deviceLost         (false         ),
   m_callbackRunning    (false         ),
   m_lastStreamFormat   (AE_FMT_INVALID),
   m_lastChLayoutCount  (0             ),
@@ -141,20 +142,26 @@ void CCoreAudioAE::Shutdown()
 
 void CCoreAudioAE::AudioDevicesChanged()
 {
-  if (!m_Initialized)
+  if (!m_Initialized && !m_deviceLost)
     return;
 
-  // give CA a bit time to realise that maybe the 
-  // default device might have changed now - else
-  // OpenCoreAudio might open the old default device
-  // again (yeah that really is the case - duh)
-  Sleep(500);
   CSingleLock engineLock(m_engineLock);
 
   // re-check initialized since it can have changed when we waited and grabbed the lock
-  if (!m_Initialized)
+  if (!m_Initialized && !m_deviceLost)
     return;
+
   OpenCoreAudio(m_lastSampleRate, COREAUDIO_IS_RAW(m_lastStreamFormat), m_lastStreamFormat, m_transcode);
+
+  // when we tried to open the default device or the last device
+  // again there was an error preventing us from doing it (mostly
+  // the device couldn't be found) - in that case
+  // mark our device as lost and hope that another callback
+  // for changed device list fires (e.x. device reappears)
+  if (!m_Initialized)
+      m_deviceLost = true;
+  else
+      m_deviceLost = false;
 }
 
 bool CCoreAudioAE::Initialize()
diff --git a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.h b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.h
index f31dada..3f465c4 100644
--- a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.h
+++ b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAE.h
@@ -148,6 +148,7 @@ private:
 
   // Prevent multiple init/deinit
   bool              m_Initialized;
+  bool              m_deviceLost;
   bool              m_callbackRunning;
 
   AEAudioFormat     m_format;
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
index 6b7cf7a..8ef0ebc 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
@@ -51,12 +51,6 @@ static enum AEChannel ALSAChannelMap51Wide[ALSA_MAX_CHANNELS + 1] = {
   AE_CH_NULL
 };
 
-static enum AEChannel ALSAChannelMap71Wide[ALSA_MAX_CHANNELS + 1] = {
-  AE_CH_FLOC    , AE_CH_FROC    , AE_CH_BL      , AE_CH_BR      , AE_CH_FC      , AE_CH_LFE     , AE_CH_FL        , AE_CH_FR        ,
-  AE_CH_UNKNOWN1, AE_CH_UNKNOWN2, AE_CH_UNKNOWN3, AE_CH_UNKNOWN4, AE_CH_UNKNOWN5, AE_CH_UNKNOWN6, AE_CH_UNKNOWN7, AE_CH_UNKNOWN8, /* for p16v devices */
-  AE_CH_NULL
-};
-
 static enum AEChannel ALSAChannelMapPassthrough[ALSA_MAX_CHANNELS + 1] = {
   AE_CH_RAW     , AE_CH_RAW     , AE_CH_RAW     , AE_CH_RAW     , AE_CH_RAW     , AE_CH_RAW     , AE_CH_RAW      , AE_CH_RAW      ,
   AE_CH_UNKNOWN1, AE_CH_UNKNOWN2, AE_CH_UNKNOWN3, AE_CH_UNKNOWN4, AE_CH_UNKNOWN5, AE_CH_UNKNOWN6, AE_CH_UNKNOWN7, AE_CH_UNKNOWN8, /* for p16v devices */
@@ -126,10 +120,6 @@ inline CAEChannelInfo CAESinkALSA::GetChannelLayout(AEAudioFormat format, unsign
     {
       channelMap = ALSAChannelMap51Wide;
     }
-    else if (maxChannels >= 8 && format.m_channelLayout.HasChannel(AE_CH_FLOC) && !format.m_channelLayout.HasChannel(AE_CH_SL))
-    {
-      channelMap = ALSAChannelMap71Wide;
-    }
     for (unsigned int c = 0; c < 8; ++c)
     {
       for (unsigned int i = 0; i < format.m_channelLayout.Count(); ++i)
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
index 2bd9619..f499af4 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
@@ -28,12 +28,15 @@
 #endif
 #include "utils/log.h"
 
-#include <jni.h>
+#include "android/jni/AudioFormat.h"
+#include "android/jni/AudioManager.h"
+#include "android/jni/AudioTrack.h"
 
-#if defined(__ARM_NEON__)
+using namespace jni;
+
+#if 0 //defined(__ARM_NEON__)
 #include <arm_neon.h>
 #include "utils/CPUInfo.h"
-#include "android/jni/JNIThreading.h"
 
 // LGPLv2 from PulseAudio
 // float values from AE are pre-clamped so we do not need to clamp again here
@@ -58,46 +61,28 @@ static void pa_sconv_s16le_from_f32ne_neon(unsigned n, const float32_t *a, int16
 }
 #endif
 
-static jint GetStaticIntField(JNIEnv *jenv, std::string class_name, std::string field_name)
-{
-  class_name.insert(0, "android/media/");
-  jclass cls = jenv->FindClass(class_name.c_str());
-  jfieldID field = jenv->GetStaticFieldID(cls, field_name.c_str(), "I");
-  jint int_field = jenv->GetStaticIntField(cls, field);
-  jenv->DeleteLocalRef(cls);
-  return int_field;
-}
-
 CAEDeviceInfo CAESinkAUDIOTRACK::m_info;
 ////////////////////////////////////////////////////////////////////////////////////////////
 CAESinkAUDIOTRACK::CAESinkAUDIOTRACK()
-  : CThread("AudioTrack")
 {
-  m_sinkbuffer = NULL;
   m_alignedS16 = NULL;
-  m_volume_changed = false;
   m_min_frames = 0;
   m_sink_frameSize = 0;
-  m_sinkbuffer_sec = 0.0;
-  m_sinkbuffer_sec_per_byte = 0.0;
-  m_draining = false;
   m_audiotrackbuffer_sec = 0.0;
-  m_audiotrack_empty_sec = 0.0;
-  m_audiotrack_empty_sec_tweaks = 0.0;
-#if defined(HAS_LIBAMCODEC)
-  if (aml_present())
-    m_audiotrack_empty_sec_tweaks = 0.250;
-#endif
   m_volume = 1.0;
+  m_at_jni = NULL;
+  m_frames_written = 0;
 }
 
 CAESinkAUDIOTRACK::~CAESinkAUDIOTRACK()
 {
+  Deinitialize();
 }
 
 bool CAESinkAUDIOTRACK::Initialize(AEAudioFormat &format, std::string &device)
 {
-  m_format = format;
+  m_lastFormat  = format;
+  m_format      = format;
 
   if (AE_IS_RAW(m_format.m_dataFormat))
     m_passthrough = true;
@@ -133,126 +118,119 @@ bool CAESinkAUDIOTRACK::Initialize(AEAudioFormat &format, std::string &device)
       break;
     }
   }
-  m_format.m_dataFormat = dataFormat;
-
-  m_format.m_channelLayout = m_info.m_channels;
-  m_format.m_frameSize = m_format.m_channelLayout.Count() * (CAEUtil::DataFormatToBits(m_format.m_dataFormat) >> 3);
-
-  m_draining = false;
-  m_volume_changed = false;
-  // launch the process thread and wait for the
-  // AutoTrack jni object to get created and setup.
-  m_wake.Reset();
-  m_inited.Reset();
-  Create();
-  if(!m_inited.WaitMSec(100))
-  {
-    while(!m_inited.WaitMSec(1))
-      Sleep(10);
-  }
 
-  // m_min_frames is volatile and has been setup by Process()
-  m_format.m_frames = m_min_frames;
-  m_format.m_frameSamples = m_format.m_frames * m_format.m_channelLayout.Count();
-  format = m_format;
+  m_format.m_dataFormat     = dataFormat;
+  m_format.m_channelLayout  = m_info.m_channels;
+  m_format.m_frameSize      = m_format.m_channelLayout.Count() *
+                              (CAEUtil::DataFormatToBits(m_format.m_dataFormat) / 8);
+  int min_buffer_size       = CJNIAudioTrack::getMinBufferSize( m_format.m_sampleRate,
+                                                                CJNIAudioFormat::CHANNEL_OUT_STEREO,
+                                                                CJNIAudioFormat::ENCODING_PCM_16BIT);
+  m_sink_frameSize          = m_format.m_channelLayout.Count() *
+                              (CAEUtil::DataFormatToBits(AE_FMT_S16LE) / 8);
+  m_min_frames              = min_buffer_size / m_sink_frameSize;
+  m_audiotrackbuffer_sec    = (double)m_min_frames / (double)m_format.m_sampleRate;
+  m_at_jni                  = new CJNIAudioTrack( CJNIAudioManager::STREAM_MUSIC,
+                                                  m_format.m_sampleRate,
+                                                  CJNIAudioFormat::CHANNEL_OUT_STEREO,
+                                                  CJNIAudioFormat::ENCODING_PCM_16BIT,
+                                                  min_buffer_size,
+                                                  CJNIAudioTrack::MODE_STREAM);
+  m_format.m_frames         = m_min_frames / 2;
+
+  m_format.m_frameSamples   = m_format.m_frames * m_format.m_channelLayout.Count();
+  format                    = m_format;
+
+  JNIEnv* jenv = xbmc_jnienv();
+  // Set the initial volume
+  float volume = 1.0;
+  if (!m_passthrough)
+    volume = m_volume;
+  CXBMCApp::SetSystemVolume(jenv, volume);
 
   return true;
 }
 
 void CAESinkAUDIOTRACK::Deinitialize()
 {
-  // force m_bStop and set m_wake, if might be sleeping.
-  m_bStop = true;
-  m_wake.Set();
-  StopThread();
-  delete m_sinkbuffer, m_sinkbuffer = NULL;
-  if (m_alignedS16)
-    _aligned_free(m_alignedS16), m_alignedS16 = NULL;
+  if (!m_at_jni)
+    return;
+
+  m_at_jni->stop();
+  m_at_jni->flush();
+  m_at_jni->release();
+  
+  m_frames_written = 0;
+
+  delete m_at_jni;
+  m_at_jni = NULL;
 }
 
 bool CAESinkAUDIOTRACK::IsCompatible(const AEAudioFormat &format, const std::string &device)
 {
-  return ((m_format.m_sampleRate    == format.m_sampleRate) &&
-          (m_format.m_dataFormat    == format.m_dataFormat) &&
-          (m_format.m_channelLayout == format.m_channelLayout));
+  return m_lastFormat == format || m_format == format;
 }
 
 double CAESinkAUDIOTRACK::GetDelay()
 {
-  // this includes any latency due to AudioTrack buffer,
-  // AudioMixer (if any) and audio hardware driver.
-
-  double sinkbuffer_seconds_to_empty = m_sinkbuffer_sec_per_byte * (double)m_sinkbuffer->GetReadSize();
-  sinkbuffer_seconds_to_empty += m_audiotrack_empty_sec;
-  if (sinkbuffer_seconds_to_empty > 0.0)
-    sinkbuffer_seconds_to_empty += m_audiotrack_empty_sec_tweaks;
-  return sinkbuffer_seconds_to_empty;
+  if (!m_at_jni)
+    return 0.0;
+
+  // In their infinite wisdom, Google decided to make getPlaybackHeadPosition
+  // return a 32bit "int" that you should "interpret as unsigned."  As such,
+  // for wrap saftey, we need to do all ops on it in 32bit integer math.
+  uint32_t head_pos = (uint32_t)m_at_jni->getPlaybackHeadPosition();
+
+  double delay = (double)(m_frames_written - head_pos) / m_format.m_sampleRate;
+
+  return delay;
 }
 
 double CAESinkAUDIOTRACK::GetCacheTime()
 {
-  // returns the time in seconds that it will take
-  // to underrun the buffer if no sample is added.
-
-  double sinkbuffer_seconds_to_empty = m_sinkbuffer_sec_per_byte * (double)m_sinkbuffer->GetReadSize();
-  sinkbuffer_seconds_to_empty += m_audiotrack_empty_sec;
-  if (sinkbuffer_seconds_to_empty > 0.0)
-    sinkbuffer_seconds_to_empty += m_audiotrack_empty_sec_tweaks;
-  return sinkbuffer_seconds_to_empty;
+  // depreciated, not used by ActiveAE
+  return 0;
 }
 
 double CAESinkAUDIOTRACK::GetCacheTotal()
 {
   // total amount that the audio sink can buffer in units of seconds
-
-  return m_sinkbuffer_sec + m_audiotrackbuffer_sec;
+  return m_audiotrackbuffer_sec;
 }
 
+// this method is supposed to block until all frames are written to the device buffer
+// when it returns ActiveAESink will take the next buffer out of a queue
 unsigned int CAESinkAUDIOTRACK::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio, bool blocking)
 {
-  // write as many frames of audio as we can fit into our internal buffer.
-
-  // our internal sink buffer is always AE_FMT_S16
-  unsigned int write_frames = m_sinkbuffer->GetWriteSize() / m_sink_frameSize;
-  if (write_frames > frames)
-    write_frames = frames;
+  if (!m_at_jni)
+    return INT_MAX;
 
-  if (hasAudio && write_frames)
+  // write as many frames of audio as we can fit into our internal buffer.
+  int written = 0;
+  if (frames)
   {
-    switch(m_format.m_dataFormat)
-    {
-      case AE_FMT_S16LE:
-        m_sinkbuffer->Write(data, write_frames * m_sink_frameSize);
-        m_wake.Set();
-        break;
-#if defined(__ARM_NEON__)
-      case AE_FMT_FLOAT:
-        if (!m_alignedS16)
-          m_alignedS16 = (int16_t*)_aligned_malloc(m_format.m_frames * m_sink_frameSize, 16);
-        // neon convert AE_FMT_S16LE to AE_FMT_FLOAT
-        pa_sconv_s16le_from_f32ne_neon(write_frames * m_format.m_channelLayout.Count(), (const float32_t *)data, m_alignedS16);
-        m_sinkbuffer->Write((unsigned char*)m_alignedS16, write_frames * m_sink_frameSize);
-        m_wake.Set();
-        break;
-#endif
-      default:
-        break;
-    }
+    // android will auto pause the playstate when it senses idle,
+    // check it and set playing if it does this. Do this before
+    // writing into its buffer.
+    if (m_at_jni->getPlayState() != CJNIAudioTrack::PLAYSTATE_PLAYING)
+      m_at_jni->play();
+
+    written = m_at_jni->write((char*)data, 0, frames * m_sink_frameSize);
+    m_frames_written += written / m_sink_frameSize;
   }
-  // AddPackets runs under a non-idled AE thread we must block or sleep.
-  // Trying to calc the optimal sleep is tricky so just a minimal sleep.
-  if(blocking)
-    Sleep(10);
 
-  return hasAudio ? write_frames:frames;
+  return (unsigned int)(written/m_sink_frameSize);
 }
 
 void CAESinkAUDIOTRACK::Drain()
 {
-  CLog::Log(LOGDEBUG, "CAESinkAUDIOTRACK::Drain");
-  CSingleLock lock(m_drain_lock);
-  m_draining = true;
-  m_wake.Set();
+  if (!m_at_jni)
+    return;
+
+  // TODO: does this block until last samples played out?
+  // we should not return from drain as long the device is in playing state
+  m_at_jni->stop();
+  m_frames_written = 0;
 }
 
 bool CAESinkAUDIOTRACK::HasVolume()
@@ -262,13 +240,15 @@ bool CAESinkAUDIOTRACK::HasVolume()
 
 void  CAESinkAUDIOTRACK::SetVolume(float scale)
 {
+  if (!m_at_jni)
+    return;
+
   // Android uses fixed steps, reverse scale back to percent
   float gain = CAEUtil::ScaleToGain(scale);
   m_volume = CAEUtil::GainToPercent(gain);
   if (!m_passthrough)
   {
-    CSingleLock lock(m_volume_lock);
-    m_volume_changed = true;
+    CXBMCApp::SetSystemVolume(xbmc_jnienv(), m_volume);
   }
 }
 
@@ -287,7 +267,7 @@ void CAESinkAUDIOTRACK::EnumerateDevicesEx(AEDeviceInfoList &list, bool force)
   m_info.m_sampleRates.push_back(44100);
   m_info.m_sampleRates.push_back(48000);
   m_info.m_dataFormats.push_back(AE_FMT_S16LE);
-#if defined(__ARM_NEON__)
+#if 0 //defined(__ARM_NEON__)
   if (g_cpuInfo.GetCPUFeatures() & CPU_FEATURE_NEON)
     m_info.m_dataFormats.push_back(AE_FMT_FLOAT);
 #endif
@@ -295,157 +275,3 @@ void CAESinkAUDIOTRACK::EnumerateDevicesEx(AEDeviceInfoList &list, bool force)
   list.push_back(m_info);
 }
 
-void CAESinkAUDIOTRACK::Process()
-{
-  CLog::Log(LOGDEBUG, "CAESinkAUDIOTRACK::Process");
-
-  JNIEnv *jenv = xbmc_jnienv();
-
-  jclass jcAudioTrack = jenv->FindClass("android/media/AudioTrack");
-
-  jmethodID jmInit              = jenv->GetMethodID(jcAudioTrack, "<init>", "(IIIIII)V");
-  jmethodID jmPlay              = jenv->GetMethodID(jcAudioTrack, "play", "()V");
-  jmethodID jmStop              = jenv->GetMethodID(jcAudioTrack, "stop", "()V");
-  jmethodID jmFlush             = jenv->GetMethodID(jcAudioTrack, "flush", "()V");
-  jmethodID jmRelease           = jenv->GetMethodID(jcAudioTrack, "release", "()V");
-  jmethodID jmWrite             = jenv->GetMethodID(jcAudioTrack, "write", "([BII)I");
-  jmethodID jmPlayState         = jenv->GetMethodID(jcAudioTrack, "getPlayState", "()I");
-  jmethodID jmPlayHeadPosition  = jenv->GetMethodID(jcAudioTrack, "getPlaybackHeadPosition", "()I");
-  jmethodID jmGetMinBufferSize  = jenv->GetStaticMethodID(jcAudioTrack, "getMinBufferSize", "(III)I");
-
-  jint audioFormat    = GetStaticIntField(jenv, "AudioFormat", "ENCODING_PCM_16BIT");
-  jint channelConfig  = GetStaticIntField(jenv, "AudioFormat", "CHANNEL_OUT_STEREO");
-
-  jint min_buffer_size = jenv->CallStaticIntMethod(jcAudioTrack, jmGetMinBufferSize,
-    m_format.m_sampleRate, channelConfig, audioFormat);
-
-  m_sink_frameSize = m_format.m_channelLayout.Count() * CAEUtil::DataFormatToBits(AE_FMT_S16LE) >> 3;
-  m_min_frames = min_buffer_size / m_sink_frameSize;
-
-  m_audiotrackbuffer_sec = (double)m_min_frames / (double)m_format.m_sampleRate;
-  m_audiotrack_empty_sec = 0.0;
-
-  // setup a 1/4 second internal sink lockless ring buffer
-  m_sinkbuffer = new AERingBuffer(m_sink_frameSize * m_format.m_sampleRate / 4);
-  m_sinkbuffer_sec_per_byte = 1.0 / (double)(m_sink_frameSize * m_format.m_sampleRate);
-  m_sinkbuffer_sec = (double)m_sinkbuffer_sec_per_byte * m_sinkbuffer->GetMaxSize();
-
-  jobject joAudioTrack = jenv->NewObject(jcAudioTrack, jmInit,
-    GetStaticIntField(jenv, "AudioManager", "STREAM_MUSIC"),
-    m_format.m_sampleRate,
-    channelConfig,
-    audioFormat,
-    min_buffer_size,
-    GetStaticIntField(jenv, "AudioTrack", "MODE_STREAM"));
-
-  // Set the initial volume
-  float volume = 1.0;
-  if (!m_passthrough)
-    volume = m_volume;
-  CXBMCApp::SetSystemVolume(jenv, volume);
-
-  // The AudioTrack object has been created and waiting to play,
-  m_inited.Set();
-  // yield to give other threads a chance to do some work.
-  sched_yield();
-
-  // cache the playing int value.
-  jint playing = GetStaticIntField(jenv, "AudioTrack", "PLAYSTATE_PLAYING");
-
-  // create a java byte buffer for writing pcm data to AudioTrack.
-  jarray jbuffer = jenv->NewByteArray(min_buffer_size);
-
-  int64_t frames_written = 0;
-  int64_t frame_position = 0;
-
-  while (!m_bStop)
-  {
-    if (m_volume_changed && !m_passthrough)
-    {
-      // check of volume changes and make them,
-      // do it here to keep jni calls local to this thread.
-      CXBMCApp::SetSystemVolume(jenv, m_volume);
-      CSingleLock lock(m_volume_lock);
-      m_volume_changed = false;
-    }
-    if (m_draining)
-    {
-      unsigned char byte_drain[1024];
-      unsigned int  byte_drain_size = m_sinkbuffer->GetReadSize();
-      if (byte_drain_size > 1024)
-        byte_drain_size = 1024;
-      while (byte_drain_size)
-      {
-        m_sinkbuffer->Read(byte_drain, byte_drain_size);
-        byte_drain_size = m_sinkbuffer->GetReadSize();
-        if (byte_drain_size > 1024)
-          byte_drain_size = 1024;
-      }
-      jenv->CallVoidMethod(joAudioTrack, jmStop);
-      jenv->CallVoidMethod(joAudioTrack, jmFlush);
-      CSingleLock lock(m_drain_lock);
-      m_draining = false;
-    }
-
-    unsigned int read_bytes = m_sinkbuffer->GetReadSize();
-    if (read_bytes > (unsigned int)min_buffer_size)
-      read_bytes = min_buffer_size;
-
-    if (read_bytes > 0)
-    {
-      // android will auto pause the playstate when it senses idle,
-      // check it and set playing if it does this. Do this before
-      // writing into its buffer.
-      if (jenv->CallIntMethod(joAudioTrack, jmPlayState) != playing)
-        jenv->CallVoidMethod( joAudioTrack, jmPlay);
-
-      // Write a buffer of audio data to Java AudioTrack.
-      // Warning, no other JNI function can be called after
-      // GetPrimitiveArrayCritical until ReleasePrimitiveArrayCritical.
-      void *pBuffer = jenv->GetPrimitiveArrayCritical(jbuffer, NULL);
-      if (pBuffer)
-      {
-        m_sinkbuffer->Read((unsigned char*)pBuffer, read_bytes);
-        jenv->ReleasePrimitiveArrayCritical(jbuffer, pBuffer, 0);
-        // jmWrite is blocking and returns when the data has been transferred
-        // from the Java layer and queued for playback.
-        jenv->CallIntMethod(joAudioTrack, jmWrite, jbuffer, 0, read_bytes);
-      }
-    }
-    // calc the number of seconds until audiotrack buffer is empty.
-    frame_position = jenv->CallIntMethod(joAudioTrack, jmPlayHeadPosition);
-    if (frame_position == 0)
-      frames_written = 0;
-    frames_written += read_bytes / m_sink_frameSize;
-    m_audiotrack_empty_sec = (double)(frames_written - frame_position) / m_format.m_sampleRate;
-    // some times, we can get frame_position
-    // ahead of frames_written, not a clue why. clamp it.
-    if (m_audiotrack_empty_sec < 0.0f)
-      m_audiotrack_empty_sec = 0.0f;
-
-    if (m_sinkbuffer->GetReadSize() == 0)
-    {
-      // the sink buffer is empty, stop playback.
-      // Audiotrack will playout any written contents.
-      jenv->CallVoidMethod(joAudioTrack, jmStop);
-      // sleep this audio thread, we will get woken when we have audio data.
-      m_wake.WaitMSec(250);
-    }
-  }
-
-  jenv->CallVoidMethod(joAudioTrack, jmStop);
-  jenv->CallVoidMethod(joAudioTrack, jmFlush);
-  jenv->CallVoidMethod(joAudioTrack, jmRelease);
-
-  // might toss an exception on jmRelease so catch it.
-  jthrowable exception = jenv->ExceptionOccurred();
-  if (exception)
-  {
-    jenv->ExceptionDescribe();
-    jenv->ExceptionClear();
-  }
-
-  jenv->DeleteLocalRef(jbuffer);
-  jenv->DeleteLocalRef(joAudioTrack);
-  jenv->DeleteLocalRef(jcAudioTrack);
-}
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.h b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.h
index 30c6f59..ccca678 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.h
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.h
@@ -24,8 +24,12 @@
 #include "threads/CriticalSection.h"
 
 class AERingBuffer;
+namespace jni
+{
+class CJNIAudioTrack;
+};
 
-class CAESinkAUDIOTRACK : public CThread, public IAESink
+class CAESinkAUDIOTRACK : public IAESink
 {
 public:
   virtual const char *GetName() { return "AUDIOTRACK"; }
@@ -47,27 +51,17 @@ public:
   static void          EnumerateDevicesEx(AEDeviceInfoList &list, bool force = false);
 
 private:
-  virtual void Process();
+  jni::CJNIAudioTrack  *m_at_jni;
+  // m_frames_written must wrap at UINT32_MAX
+  uint32_t              m_frames_written;
 
   static CAEDeviceInfo m_info;
   AEAudioFormat      m_format;
+  AEAudioFormat      m_lastFormat;
   double             m_volume;
-  bool               m_volume_changed;
-  CCriticalSection   m_volume_lock;
   volatile int       m_min_frames;
   int16_t           *m_alignedS16;
-  AERingBuffer      *m_sinkbuffer;
   unsigned int       m_sink_frameSize;
-  double             m_sinkbuffer_sec;
-  double             m_sinkbuffer_sec_per_byte;
-
-  CEvent             m_wake;
-  CEvent             m_inited;
-  volatile bool      m_draining;
-  CCriticalSection   m_drain_lock;
   bool               m_passthrough;
-
   double             m_audiotrackbuffer_sec;
-  double             m_audiotrack_empty_sec;
-  double             m_audiotrack_empty_sec_tweaks;
 };
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp
index 6619e5f..007983c 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp
@@ -1017,18 +1017,9 @@ bool CAESinkWASAPI::InitializeExclusive(AEAudioFormat &format)
 {
   WAVEFORMATEXTENSIBLE_IEC61937 wfxex_iec61937;
   WAVEFORMATEXTENSIBLE &wfxex = wfxex_iec61937.FormatExt;
-  bool obsolete71Wide = false;
 
   if (format.m_dataFormat <= AE_FMT_FLOAT)
-  {
     BuildWaveFormatExtensible(format, wfxex);
-    // handle obsolete 7.1 wide
-    if (wfxex.dwChannelMask == KSAUDIO_SPEAKER_7POINT1)
-    {
-      obsolete71Wide = true;
-      wfxex.dwChannelMask = KSAUDIO_SPEAKER_7POINT1_SURROUND;
-    }
-  }
   else
     BuildWaveFormatExtensibleIEC61397(format, wfxex_iec61937);
 
@@ -1146,22 +1137,7 @@ bool CAESinkWASAPI::InitializeExclusive(AEAudioFormat &format)
 
 initialize:
 
-  // check if 7.1 wide was requested and we were able to open 8 channels
-  if (obsolete71Wide && (wfxex.dwChannelMask == KSAUDIO_SPEAKER_7POINT1_SURROUND))
-  {
-    // build layout for 7.1 Wide and map it into KSAUDIO_SPEAKER_7POINT1_SURROUND
-    m_channelLayout.Reset();
-    m_channelLayout += AE_CH_FLOC;  // FLOC/FROC go into FL/FR
-    m_channelLayout += AE_CH_FROC;
-    m_channelLayout += AE_CH_FC;
-    m_channelLayout += AE_CH_LFE;
-    m_channelLayout += AE_CH_FL;    // FL/FR go into SL/SR
-    m_channelLayout += AE_CH_FR;
-    m_channelLayout += AE_CH_BL;
-    m_channelLayout += AE_CH_BR;
-  }
-  else
-    AEChannelsFromSpeakerMask(wfxex.dwChannelMask);
+  AEChannelsFromSpeakerMask(wfxex.dwChannelMask);
   format.m_channelLayout = m_channelLayout;
 
   /* When the stream is raw, the values in the format structure are set to the link    */
diff --git a/xbmc/cores/AudioEngine/Utils/AEAudioFormat.h b/xbmc/cores/AudioEngine/Utils/AEAudioFormat.h
index 88abac7..9ac5c79 100644
--- a/xbmc/cores/AudioEngine/Utils/AEAudioFormat.h
+++ b/xbmc/cores/AudioEngine/Utils/AEAudioFormat.h
@@ -125,6 +125,17 @@ typedef struct AEAudioFormat{
     m_frameSamples = 0;
     m_frameSize = 0;
   }
+
+  bool operator==(const AEAudioFormat& fmt) const
+  {
+    return  m_dataFormat    ==  fmt.m_dataFormat    &&
+            m_sampleRate    ==  fmt.m_sampleRate    &&
+            m_encodedRate   ==  fmt.m_encodedRate   &&
+            m_channelLayout ==  fmt.m_channelLayout &&
+            m_frames        ==  fmt.m_frames        &&
+            m_frameSamples  ==  fmt.m_frameSamples  &&
+            m_frameSize     ==  fmt.m_frameSize;
+  }
  
 } AEAudioFormat;
 
diff --git a/xbmc/cores/AudioEngine/Utils/AEChannelInfo.cpp b/xbmc/cores/AudioEngine/Utils/AEChannelInfo.cpp
index 5d48571..a051cf5 100644
--- a/xbmc/cores/AudioEngine/Utils/AEChannelInfo.cpp
+++ b/xbmc/cores/AudioEngine/Utils/AEChannelInfo.cpp
@@ -101,10 +101,6 @@ void CAEChannelInfo::ResolveChannels(const CAEChannelInfo& rhs)
       newInfo += m_channels[i];
   }
 
-  // we let the sink do the mapping later on
-  if (m_channelCount == 8 && m_channelCount == rhs.Count())
-    return;
-
   /* we need to ensure we end up with rear or side channels for downmix to work */
   if (srcHasSL && !dstHasSL && dstHasRL)
     newInfo += AE_CH_BL;
@@ -192,7 +188,7 @@ CAEChannelInfo& CAEChannelInfo::operator=(const enum AEStdChLayout rhs)
   return *this;
 }
 
-bool CAEChannelInfo::operator==(const CAEChannelInfo& rhs)
+bool CAEChannelInfo::operator==(const CAEChannelInfo& rhs) const
 {
   /* if the channel count doesnt match, no need to check further */
   if (m_channelCount != rhs.m_channelCount)
diff --git a/xbmc/cores/AudioEngine/Utils/AEChannelInfo.h b/xbmc/cores/AudioEngine/Utils/AEChannelInfo.h
index ab114ea..2f1bca6 100644
--- a/xbmc/cores/AudioEngine/Utils/AEChannelInfo.h
+++ b/xbmc/cores/AudioEngine/Utils/AEChannelInfo.h
@@ -78,7 +78,7 @@ public:
   CAEChannelInfo& operator=(const CAEChannelInfo& rhs);
   CAEChannelInfo& operator=(const enum AEChannel* rhs);
   CAEChannelInfo& operator=(const enum AEStdChLayout rhs);
-  bool operator==(const CAEChannelInfo& rhs);
+  bool operator==(const CAEChannelInfo& rhs) const;
   bool operator!=(const CAEChannelInfo& rhs);
   CAEChannelInfo& operator+=(const enum AEChannel& rhs);
   CAEChannelInfo& operator-=(const enum AEChannel& rhs);
diff --git a/xbmc/filesystem/AFPFile.cpp b/xbmc/filesystem/AFPFile.cpp
index 4620d92..8b24831 100644
--- a/xbmc/filesystem/AFPFile.cpp
+++ b/xbmc/filesystem/AFPFile.cpp
@@ -221,7 +221,7 @@ CAfpConnection::afpConnnectError CAfpConnection::Connect(const CURL& url)
     CLog::Log(LOGDEBUG, "AFP: Could not parse url: %s!\n", nonConstUrl.Get().c_str());
     return AfpFailed;
   }
-  else // parsed successfull
+  else // parsed successfully
   {
     // this is our current url object whe are connected to (at least we try)
     *m_pAfpUrl = tmpurl;
diff --git a/xbmc/guilib/GUIBaseContainer.cpp b/xbmc/guilib/GUIBaseContainer.cpp
index 29a7a5b..82b051e 100644
--- a/xbmc/guilib/GUIBaseContainer.cpp
+++ b/xbmc/guilib/GUIBaseContainer.cpp
@@ -58,6 +58,10 @@ CGUIBaseContainer::CGUIBaseContainer(int parentID, int controlID, float posX, fl
   m_scrollItemsPerFrame = 0.0f;
   m_type = VIEW_TYPE_NONE;
   m_listProvider = NULL;
+  m_autoScrollMoveTime = 0;
+  m_autoScrollDelayTime = 0;
+  m_autoScrollIsReversed = false;
+  m_lastRenderTime = 0;
 }
 
 CGUIBaseContainer::~CGUIBaseContainer(void)
@@ -72,10 +76,19 @@ void CGUIBaseContainer::DoProcess(unsigned int currentTime, CDirtyRegionList &di
   if (m_pageChangeTimer.GetElapsedMilliseconds() > 200)
     m_pageChangeTimer.Stop();
   m_wasReset = false;
+
+  // if not visible, we reset the autoscroll timer
+  if (!IsVisible() && m_autoScrollMoveTime)
+  {
+    ResetAutoScrolling();
+  }
 }
 
 void CGUIBaseContainer::Process(unsigned int currentTime, CDirtyRegionList &dirtyregions)
 {
+  // update our auto-scrolling as necessary
+  UpdateAutoScrolling(currentTime);
+
   ValidateOffset();
 
   if (m_bInvalidated)
@@ -131,6 +144,8 @@ void CGUIBaseContainer::Process(unsigned int currentTime, CDirtyRegionList &dirt
   // to have same behaviour when scrolling down, we need to set page control to offset+1
   UpdatePageControl(offset + (m_scroller.IsScrollingDown() ? 1 : 0));
 
+  m_lastRenderTime = currentTime;
+
   CGUIControl::Process(currentTime, dirtyregions);
 }
 
@@ -607,6 +622,7 @@ bool CGUIBaseContainer::MoveDown(bool wrapAround)
 // scrolls the said amount
 void CGUIBaseContainer::Scroll(int amount)
 {
+  ResetAutoScrolling();
   ScrollToOffset(GetOffset() + amount);
 }
 
@@ -974,6 +990,42 @@ void CGUIBaseContainer::ScrollToOffset(int offset)
   SetOffset(offset);
 }
 
+void CGUIBaseContainer::SetAutoScrolling(const TiXmlNode *node)
+{
+  if (!node) return;
+  const TiXmlElement *scroll = node->FirstChildElement("autoscroll");
+  if (scroll)
+  {
+    scroll->Attribute("time", &m_autoScrollMoveTime);
+    if (scroll->Attribute("reverse"))
+      m_autoScrollIsReversed = true;
+    if (scroll->FirstChild())
+      m_autoScrollCondition = g_infoManager.Register(scroll->FirstChild()->ValueStr(), GetParentID());
+  }
+}
+
+void CGUIBaseContainer::ResetAutoScrolling()
+{
+  m_autoScrollDelayTime = 0;
+}
+
+void CGUIBaseContainer::UpdateAutoScrolling(unsigned int currentTime)
+{
+  if (m_autoScrollCondition && m_autoScrollCondition->Get())
+  {
+    if (m_lastRenderTime)
+      m_autoScrollDelayTime += currentTime - m_lastRenderTime;
+    if (m_autoScrollDelayTime > (unsigned int)m_autoScrollMoveTime && !m_scroller.IsScrolling())
+    { // delay is finished - start moving
+      m_autoScrollDelayTime = 0;
+      // Move up or down whether reversed moving is true or false
+      m_autoScrollIsReversed ? MoveUp(true) : MoveDown(true);
+    }
+  }
+  else
+    ResetAutoScrolling();
+}
+
 void CGUIBaseContainer::SetContainerMoving(int direction)
 {
   if (direction)
@@ -1001,6 +1053,7 @@ void CGUIBaseContainer::Reset()
   m_wasReset = true;
   m_items.clear();
   m_lastItem.reset();
+  ResetAutoScrolling();
 }
 
 void CGUIBaseContainer::LoadLayout(TiXmlElement *layout)
diff --git a/xbmc/guilib/GUIBaseContainer.h b/xbmc/guilib/GUIBaseContainer.h
index 0006dd2..fcba8a0 100644
--- a/xbmc/guilib/GUIBaseContainer.h
+++ b/xbmc/guilib/GUIBaseContainer.h
@@ -89,6 +89,10 @@ public:
    */
   void SetRenderOffset(const CPoint &offset);
 
+  void SetAutoScrolling(const TiXmlNode *node);
+  void ResetAutoScrolling();
+  void UpdateAutoScrolling(unsigned int currentTime);
+
 #ifdef _DEBUG
   virtual void DumpTextureUse();
 #endif
@@ -194,6 +198,14 @@ protected:
   */
   inline int GetItemOffset() const { return CorrectOffset(GetOffset(), 0); }
 
+  // autoscrolling
+  INFO::InfoPtr m_autoScrollCondition;
+  int           m_autoScrollMoveTime;   // time between to moves
+  unsigned int  m_autoScrollDelayTime;  // current offset into the delay
+  bool          m_autoScrollIsReversed; // scroll backwards
+
+  unsigned int m_lastRenderTime;
+
 private:
   int m_cursor;
   int m_offset;
diff --git a/xbmc/guilib/GUIControlFactory.cpp b/xbmc/guilib/GUIControlFactory.cpp
index 3bc59bd..29eef75 100644
--- a/xbmc/guilib/GUIControlFactory.cpp
+++ b/xbmc/guilib/GUIControlFactory.cpp
@@ -1328,6 +1328,7 @@ CGUIControl* CGUIControlFactory::Create(int parentID, const CRect &rect, TiXmlEl
     ((CGUIListContainer *)control)->SetType(viewType, viewLabel);
     ((CGUIListContainer *)control)->SetPageControl(pageControl);
     ((CGUIListContainer *)control)->SetRenderOffset(offset);
+    ((CGUIListContainer *)control)->SetAutoScrolling(pControlNode);
   }
   else if (type == CGUIControl::GUICONTAINER_WRAPLIST)
   {
@@ -1340,6 +1341,7 @@ CGUIControl* CGUIControlFactory::Create(int parentID, const CRect &rect, TiXmlEl
     ((CGUIWrappingListContainer *)control)->SetType(viewType, viewLabel);
     ((CGUIWrappingListContainer *)control)->SetPageControl(pageControl);
     ((CGUIWrappingListContainer *)control)->SetRenderOffset(offset);
+    ((CGUIWrappingListContainer *)control)->SetAutoScrolling(pControlNode);
   }
   else if (type == CGUIControl::GUICONTAINER_EPGGRID)
   {
@@ -1359,6 +1361,7 @@ CGUIControl* CGUIControlFactory::Create(int parentID, const CRect &rect, TiXmlEl
     ((CGUIFixedListContainer *)control)->SetType(viewType, viewLabel);
     ((CGUIFixedListContainer *)control)->SetPageControl(pageControl);
     ((CGUIFixedListContainer *)control)->SetRenderOffset(offset);
+    ((CGUIFixedListContainer *)control)->SetAutoScrolling(pControlNode);
   }
   else if (type == CGUIControl::GUICONTAINER_PANEL)
   {
@@ -1371,6 +1374,7 @@ CGUIControl* CGUIControlFactory::Create(int parentID, const CRect &rect, TiXmlEl
     ((CGUIPanelContainer *)control)->SetType(viewType, viewLabel);
     ((CGUIPanelContainer *)control)->SetPageControl(pageControl);
     ((CGUIPanelContainer *)control)->SetRenderOffset(offset);
+    ((CGUIPanelContainer *)control)->SetAutoScrolling(pControlNode);
   }
   else if (type == CGUIControl::GUICONTROL_TEXTBOX)
   {
diff --git a/xbmc/guilib/GUIWindowManager.cpp b/xbmc/guilib/GUIWindowManager.cpp
index a8ab387..744baaa 100644
--- a/xbmc/guilib/GUIWindowManager.cpp
+++ b/xbmc/guilib/GUIWindowManager.cpp
@@ -186,6 +186,7 @@ void CGUIWindowManager::Add(CGUIWindow* pWindow)
   }
   // push back all the windows if there are more than one covered by this class
   CSingleLock lock(g_graphicsContext);
+  m_idCache.Invalidate();
   const vector<int>& idRange = pWindow->GetIDRange();
   for (vector<int>::const_iterator idIt = idRange.begin(); idIt != idRange.end() ; ++idIt)
   {
@@ -219,6 +220,7 @@ void CGUIWindowManager::AddModeless(CGUIWindow* dialog)
 void CGUIWindowManager::Remove(int id)
 {
   CSingleLock lock(g_graphicsContext);
+  m_idCache.Invalidate();
   WindowMap::iterator it = m_mapWindows.find(id);
   if (it != m_mapWindows.end())
   {
@@ -642,16 +644,21 @@ void CGUIWindowManager::FrameMove()
 
 CGUIWindow* CGUIWindowManager::GetWindow(int id) const
 {
-  if (id == WINDOW_INVALID)
-  {
+  CGUIWindow *window;
+  if (id == 0 || id == WINDOW_INVALID)
     return NULL;
-  }
+  window = m_idCache.Get(id);
+  if (window)
+    return window;
 
   CSingleLock lock(g_graphicsContext);
   WindowMap::const_iterator it = m_mapWindows.find(id);
   if (it != m_mapWindows.end())
-    return (*it).second;
-  return NULL;
+    window = (*it).second;
+  else
+    window = NULL;
+  m_idCache.Set(id, window);
+  return window;
 }
 
 void CGUIWindowManager::ProcessRenderLoop(bool renderOnly /*= false*/)
diff --git a/xbmc/guilib/GUIWindowManager.h b/xbmc/guilib/GUIWindowManager.h
index 70d9b9a..0654996 100644
--- a/xbmc/guilib/GUIWindowManager.h
+++ b/xbmc/guilib/GUIWindowManager.h
@@ -33,6 +33,7 @@
 #include "IMsgTargetCallback.h"
 #include "DirtyRegionTracker.h"
 #include "utils/GlobalsHandling.h"
+#include "guilib/WindowIDs.h"
 #include <list>
 
 class CGUIDialog;
@@ -177,6 +178,32 @@ private:
   bool m_initialized;
 
   CDirtyRegionTracker m_tracker;
+
+private:
+  class CGUIWindowManagerIdCache
+  {
+  public:
+    CGUIWindowManagerIdCache(void) : m_id(WINDOW_INVALID) {}
+    CGUIWindow *Get(int id)
+    {
+      if (id == m_id)
+        return m_window;
+      return NULL;
+    }
+    void Set(int id, CGUIWindow *window)
+    {
+      m_id = id;
+      m_window = window;
+    }
+    void Invalidate(void)
+    {
+      m_id = WINDOW_INVALID;
+    }
+  private:
+    int m_id;
+    CGUIWindow *m_window;
+  };
+  mutable CGUIWindowManagerIdCache m_idCache;
 };
 
 /*!
diff --git a/xbmc/input/linux/LIRC.cpp b/xbmc/input/linux/LIRC.cpp
index f2af9ce..3b3ebba 100644
--- a/xbmc/input/linux/LIRC.cpp
+++ b/xbmc/input/linux/LIRC.cpp
@@ -168,7 +168,7 @@ void CRemoteControl::Initialize()
                   if ((m_inotify_wd = inotify_add_watch(m_inotify_fd, m_deviceName.c_str(), IN_DELETE_SELF)) != -1)
                   {
                     m_bInitialized = true;
-                    CLog::Log(LOGINFO, "LIRC %s: sucessfully started", __FUNCTION__);
+                    CLog::Log(LOGINFO, "LIRC %s: successfully started", __FUNCTION__);
                   }
                   else
                     CLog::Log(LOGDEBUG, "LIRC: Failed to initialize Inotify. LIRC device will not be monitored.");
@@ -177,7 +177,7 @@ void CRemoteControl::Initialize()
             }
 #else
             m_bInitialized = true;
-            CLog::Log(LOGINFO, "LIRC %s: sucessfully started", __FUNCTION__);
+            CLog::Log(LOGINFO, "LIRC %s: successfully started", __FUNCTION__);
 #endif
           }
           else
diff --git a/xbmc/interfaces/legacy/Control.cpp b/xbmc/interfaces/legacy/Control.cpp
index fe8c73b..ae9831e 100644
--- a/xbmc/interfaces/legacy/Control.cpp
+++ b/xbmc/interfaces/legacy/Control.cpp
@@ -585,8 +585,7 @@ namespace XBMCAddon
                                            long _textOffsetX, long _textOffsetY, 
                                            long alignment, const char* font, const char* _textColor,
                                            const char* _disabledColor, long angle,
-                                           const char* _shadowColor, const char* _focusedColor,
-                                           const char* TextureRadioFocus, const char* TextureRadioNoFocus) :
+                                           const char* _shadowColor, const char* _focusedColor) :
       strFont("font13"), textColor(0xffffffff), disabledColor(0x60ffffff), 
       textOffsetX(_textOffsetX), textOffsetY(_textOffsetY), align(alignment), iAngle(angle), 
       shadowColor(0), focusedColor(0xffffffff)
diff --git a/xbmc/interfaces/legacy/Control.h b/xbmc/interfaces/legacy/Control.h
index b01ea46..55a4d4b 100644
--- a/xbmc/interfaces/legacy/Control.h
+++ b/xbmc/interfaces/legacy/Control.h
@@ -1295,30 +1295,30 @@ namespace XBMCAddon
     /**
      * ControlRadioButton class.
      * 
-     * ControlRadioButton(x, y, width, height, label[, focusOnTexture, noFocusOnTexture,
-     *                   focusOffTexture, noFocusOffTexture, focusTexture, noFocusTexture,
+     * ControlRadioButton(x, y, width, height, label[, focusOnTexture, noFocusOnTexture,\n
+     *                   focusOffTexture, noFocusOffTexture, focusTexture, noFocusTexture,\n
      *                   textOffsetX, textOffsetY, alignment, font, textColor, disabledColor])
      * 
-     * x                 : integer - x coordinate of control.
-     * y                 : integer - y coordinate of control.
-     * width             : integer - width of control.
-     * height            : integer - height of control.
-     * label             : string or unicode - text string.
-     * focusOnTexture    : [opt] string - filename for radio ON focused texture.
-     * noFocusOnTexture  : [opt] string - filename for radio ON not focused texture.
-     * focusOfTexture    : [opt] string - filename for radio OFF focused texture.
-     * noFocusOffTexture : [opt] string - filename for radio OFF not focused texture.
-     * focusTexture      : [opt] string - filename for radio ON texture (deprecated, use focusOnTexture and noFocusOnTexture).
-     * noFocusTexture    : [opt] string - filename for radio OFF texture (deprecated, use focusOffTexture and noFocusOffTexture).
-     * textOffsetX       : [opt] integer - horizontal text offset
-     * textOffsetY       : [opt] integer - vertical text offset
-     * alignment         : [opt] integer - alignment of label - *Note, see xbfont.h
-     * font              : [opt] string - font used for label text. (e.g. 'font13')
-     * textColor         : [opt] hexstring - color of enabled checkmark's label. (e.g. '0xFFFFFFFF')
+     * x                 : integer - x coordinate of control.\n
+     * y                 : integer - y coordinate of control.\n
+     * width             : integer - width of control.\n
+     * height            : integer - height of control.\n
+     * label             : string or unicode - text string.\n
+     * focusOnTexture    : [opt] string - filename for radio ON focused texture.\n
+     * noFocusOnTexture  : [opt] string - filename for radio ON not focused texture.\n
+     * focusOfTexture    : [opt] string - filename for radio OFF focused texture.\n
+     * noFocusOffTexture : [opt] string - filename for radio OFF not focused texture.\n
+     * focusTexture      : [opt] string - filename for radio ON texture (deprecated, use focusOnTexture and noFocusOnTexture).\n
+     * noFocusTexture    : [opt] string - filename for radio OFF texture (deprecated, use focusOffTexture and noFocusOffTexture).\n
+     * textOffsetX       : [opt] integer - horizontal text offset\n
+     * textOffsetY       : [opt] integer - vertical text offset\n
+     * alignment         : [opt] integer - alignment of label - *Note, see xbfont.h\n
+     * font              : [opt] string - font used for label text. (e.g. 'font13')\n
+     * textColor         : [opt] hexstring - color of enabled checkmark's label. (e.g. '0xFFFFFFFF')\n
      * disabledColor     : [opt] hexstring - color of disabled checkmark's label. (e.g. '0xFFFF3300')
      * 
-     * *Note, You can use the above as keywords for arguments and skip certain optional arguments.
-     *        Once you use a keyword, all following arguments require the keyword.
+     * *Note, You can use the above as keywords for arguments and skip certain optional arguments.\n
+     *        Once you use a keyword, all following arguments require the keyword.\n
      *        After you create the control, you need to add it to the window with addControl().
      * 
      * example:
@@ -1336,9 +1336,7 @@ namespace XBMCAddon
                          long _alignment = (XBFONT_LEFT | XBFONT_CENTER_Y), 
                          const char* font = NULL, const char* textColor = NULL,
                          const char* disabledColor = NULL, long angle = 0,
-                         const char* shadowColor = NULL, const char* focusedColor = NULL,
-                         const char* TextureRadioFocus = NULL, 
-                         const char* TextureRadioNoFocus = NULL);
+                         const char* shadowColor = NULL, const char* focusedColor = NULL);
 
       // setSelected() Method
       /**
diff --git a/xbmc/interfaces/legacy/ListItem.cpp b/xbmc/interfaces/legacy/ListItem.cpp
index 2222921..f19574f 100644
--- a/xbmc/interfaces/legacy/ListItem.cpp
+++ b/xbmc/interfaces/legacy/ListItem.cpp
@@ -129,6 +129,21 @@ namespace XBMCAddon
       }
     }
 
+    void ListItem::setArt(const Dictionary& dictionary)
+    {
+      if (!item) return;
+      {
+        LOCKGUI;
+        for (Dictionary::const_iterator it = dictionary.begin(); it != dictionary.end(); ++it)
+        {
+          CStdString artName = it->first;
+          StringUtils::ToLower(artName);
+          const CStdString artFilename(it->second.c_str());
+          item->SetArt(artName, artFilename);
+        }
+      }
+    }
+
     void ListItem::select(bool selected)
     {
       if (!item) return;
diff --git a/xbmc/interfaces/legacy/ListItem.h b/xbmc/interfaces/legacy/ListItem.h
index f88bbdf..40fa95c 100644
--- a/xbmc/interfaces/legacy/ListItem.h
+++ b/xbmc/interfaces/legacy/ListItem.h
@@ -125,6 +125,25 @@ namespace XBMCAddon
       void setThumbnailImage(const String& thumbFilename);
 
       /**
+       * setArt(values) -- Sets the listitem's art
+       * \n
+       * values              : dictionary - pairs of { label: value }.\n
+       *
+       * - Some default art values (any string possible):
+       *     - thumb         : string - image filename
+       *     - poster        : string - image filename
+       *     - banner        : string - image filename
+       *     - fanart        : string - image filename
+       *     - clearart      : string - image filename
+       *     - clearlogo     : string - image filename
+       *     - landscape     : string - image filename
+       *
+       * example:
+       *   - self.list.getSelectedItem().setArt({ 'poster': 'poster.png', 'banner' : 'banner.png' })
+       */
+      void setArt(const Dictionary& dictionary);
+
+      /**
        * select(selected) -- Sets the listitem's selected status.\n
        * \n
        * selected        : bool - True=selected/False=not selected\n
diff --git a/xbmc/interfaces/legacy/Window.cpp b/xbmc/interfaces/legacy/Window.cpp
index 9044a50..f97d1e4 100644
--- a/xbmc/interfaces/legacy/Window.cpp
+++ b/xbmc/interfaces/legacy/Window.cpp
@@ -83,7 +83,7 @@ namespace XBMCAddon
 
     CGUIWindow* ProxyExistingWindowInterceptor::get() { XBMC_TRACE; return cguiwindow; }
 
-    Window::Window() throw (WindowException): 
+    Window::Window(bool discrim) throw (WindowException): 
       isDisposed(false), window(NULL), iWindowId(-1),
       iOldWindowId(0), iCurrentControlId(3000), bModal(false), m_actionEvent(true),
       canPulse(true), existingWindow(false), destroyAfterDeInit(false)
diff --git a/xbmc/interfaces/legacy/Window.h b/xbmc/interfaces/legacy/Window.h
index c508e4a..9816213 100644
--- a/xbmc/interfaces/legacy/Window.h
+++ b/xbmc/interfaces/legacy/Window.h
@@ -134,7 +134,10 @@ namespace XBMCAddon
       bool existingWindow;
       bool destroyAfterDeInit;
 
-      Window() throw (WindowException);
+      // This only takes a boolean to allow subclasses to explicitly use it. A default
+      //  constructor can be used as a concrete class and we need to tell the difference.
+      //  subclasses should use this constructor and not the other.
+      Window(bool discrim) throw (WindowException);
 
       virtual void deallocating();
 
@@ -169,7 +172,7 @@ namespace XBMCAddon
 #endif
 
     public:
-      Window(int existingWindowId) throw (WindowException);
+      Window(int existingWindowId = -1) throw (WindowException);
 
       virtual ~Window();
 
diff --git a/xbmc/interfaces/legacy/WindowDialog.cpp b/xbmc/interfaces/legacy/WindowDialog.cpp
index c312cb3..6606c52 100644
--- a/xbmc/interfaces/legacy/WindowDialog.cpp
+++ b/xbmc/interfaces/legacy/WindowDialog.cpp
@@ -28,7 +28,7 @@ namespace XBMCAddon
   namespace xbmcgui
   {
     WindowDialog::WindowDialog() throw(WindowException) :
-      WindowDialogMixin(this)
+      Window(true), WindowDialogMixin(this)
     {
       CSingleLock lock(g_graphicsContext);
       setWindow(new Interceptor<CGUIWindow>("CGUIWindow",this,getNextAvailalbeWindowId()));
diff --git a/xbmc/interfaces/legacy/WindowXML.cpp b/xbmc/interfaces/legacy/WindowXML.cpp
index b52a972..da8dceb 100644
--- a/xbmc/interfaces/legacy/WindowXML.cpp
+++ b/xbmc/interfaces/legacy/WindowXML.cpp
@@ -97,7 +97,8 @@ namespace XBMCAddon
     WindowXML::WindowXML(const String& xmlFilename,
                          const String& scriptPath,
                          const String& defaultSkin,
-                         const String& defaultRes) throw(WindowException)
+                         const String& defaultRes) throw(WindowException) :
+      Window(true)
     {
       XBMC_TRACE;
       RESOLUTION_INFO res;
diff --git a/xbmc/interfaces/python/PythonSwig.cpp.template b/xbmc/interfaces/python/PythonSwig.cpp.template
index 5550113..9e1d66c 100644
--- a/xbmc/interfaces/python/PythonSwig.cpp.template
+++ b/xbmc/interfaces/python/PythonSwig.cpp.template
@@ -827,7 +827,7 @@ namespace PythonBindings
    // constants
    PyModule_AddStringConstant(module, (char*)"__author__", (char*)"Team XBMC <http://xbmc.org>");
    PyModule_AddStringConstant(module, (char*)"__date__", (char*)"${new Date().toString()}");
-   PyModule_AddStringConstant(module, (char*)"__version__", (char*)"2.13.0");
+   PyModule_AddStringConstant(module, (char*)"__version__", (char*)"2.14.0");
    PyModule_AddStringConstant(module, (char*)"__credits__", (char*)"Team XBMC");
    PyModule_AddStringConstant(module, (char*)"__platform__", (char*)"ALL");
 
diff --git a/xbmc/linux/HALManager.cpp b/xbmc/linux/HALManager.cpp
index aed9c07..cfb699c 100644
--- a/xbmc/linux/HALManager.cpp
+++ b/xbmc/linux/HALManager.cpp
@@ -175,7 +175,7 @@ void CHALManager::Initialize()
 
   GenerateGDL();
 
-  CLog::Log(LOGINFO, "HAL: Sucessfully initialized");
+  CLog::Log(LOGINFO, "HAL: Successfully initialized");
   m_Notifications = true;
 }
 
diff --git a/xbmc/storage/linux/DeviceKitDisksProvider.cpp b/xbmc/storage/linux/DeviceKitDisksProvider.cpp
index c5a8890..d037dfe 100644
--- a/xbmc/storage/linux/DeviceKitDisksProvider.cpp
+++ b/xbmc/storage/linux/DeviceKitDisksProvider.cpp
@@ -126,7 +126,7 @@ bool CDeviceKitDiskDevice::Mount()
       if (dbus_message_get_args (reply, NULL, DBUS_TYPE_STRING, &mountPoint, DBUS_TYPE_INVALID))
       {
         m_MountPath = mountPoint;
-        CLog::Log(LOGDEBUG, "DeviceKit.Disks: Sucessfully mounted %s on %s", m_DeviceKitUDI.c_str(), mountPoint);
+        CLog::Log(LOGDEBUG, "DeviceKit.Disks: Successfully mounted %s on %s", m_DeviceKitUDI.c_str(), mountPoint);
         m_isMountedByUs = m_isMounted = true;
       }
     }
diff --git a/xbmc/storage/linux/UDisksProvider.cpp b/xbmc/storage/linux/UDisksProvider.cpp
index ce4c632..dd1bf43 100644
--- a/xbmc/storage/linux/UDisksProvider.cpp
+++ b/xbmc/storage/linux/UDisksProvider.cpp
@@ -101,7 +101,7 @@ bool CUDiskDevice::Mount()
       if (dbus_message_get_args (reply, NULL, DBUS_TYPE_STRING, &mountPoint, DBUS_TYPE_INVALID))
       {
         m_MountPath = mountPoint;
-        CLog::Log(LOGDEBUG, "UDisks: Sucessfully mounted %s on %s", m_DeviceKitUDI.c_str(), mountPoint);
+        CLog::Log(LOGDEBUG, "UDisks: Successfully mounted %s on %s", m_DeviceKitUDI.c_str(), mountPoint);
         m_isMountedByUs = m_isMounted = true;
       }
     }
diff --git a/xbmc/utils/HttpResponse.cpp b/xbmc/utils/HttpResponse.cpp
index d17cba6..9d741c2 100644
--- a/xbmc/utils/HttpResponse.cpp
+++ b/xbmc/utils/HttpResponse.cpp
@@ -103,7 +103,7 @@ unsigned int CHttpResponse::Create(char *&response)
     m_buffer.append(HEADER_CONTENT_LENGTH);
     m_buffer.append(SEPARATOR);
     char lengthBuffer[11];
-    sprintf(lengthBuffer, "%d", m_contentLength);
+    sprintf(lengthBuffer, "%u", m_contentLength);
     m_buffer.append(lengthBuffer);
     m_buffer.append(LINEBREAK);
   }
diff --git a/xbmc/windowing/WinEventsSDL.cpp b/xbmc/windowing/WinEventsSDL.cpp
index fadc620..4713cdb 100644
--- a/xbmc/windowing/WinEventsSDL.cpp
+++ b/xbmc/windowing/WinEventsSDL.cpp
@@ -436,7 +436,10 @@ bool CWinEventsSDL::ProcessOSXShortcuts(SDL_Event& event)
       g_application.OnAction(CAction(ACTION_TAKE_SCREENSHOT));
       return true;
 
-    case SDLK_h: // CMD-h to hide (but we minimize for now)
+    case SDLK_h: // CMD-h to hide
+      g_Windowing.Hide();
+      return true;
+
     case SDLK_m: // CMD-m to minimize
       CApplicationMessenger::Get().Minimize();
       return true;
