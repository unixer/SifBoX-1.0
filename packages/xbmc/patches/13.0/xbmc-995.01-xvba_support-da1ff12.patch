From 16898b6bd8f19f416c9f4765ee20858fb42ead11 Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Mon, 15 Apr 2013 20:27:39 +0200
Subject: [PATCH 001/123] AE: Start of planar format internally

---
 xbmc/cores/AudioEngine/AEAudioFormat.h  |  7 +++++++
 xbmc/cores/AudioEngine/Utils/AEUtil.cpp | 14 ++++++++++++++
 2 files changed, 21 insertions(+)

diff --git a/xbmc/cores/AudioEngine/AEAudioFormat.h b/xbmc/cores/AudioEngine/AEAudioFormat.h
index 369811c..64be36f 100644
--- a/xbmc/cores/AudioEngine/AEAudioFormat.h
+++ b/xbmc/cores/AudioEngine/AEAudioFormat.h
@@ -31,26 +31,33 @@ enum AEDataFormat
   AE_FMT_INVALID = -1,
 
   AE_FMT_U8,
+  AE_FMT_U8P,
   AE_FMT_S8,
 
   AE_FMT_S16BE,
   AE_FMT_S16LE,
   AE_FMT_S16NE,
+  AE_FMT_S16NEP,
 
   AE_FMT_S32BE,
   AE_FMT_S32LE,
   AE_FMT_S32NE,
+  AE_FMT_S32NEP,
 
   AE_FMT_S24BE4,
   AE_FMT_S24LE4,
   AE_FMT_S24NE4, /* S24 in 4 bytes */
+  AE_FMT_S24NE4P,
 
   AE_FMT_S24BE3,
   AE_FMT_S24LE3,
   AE_FMT_S24NE3, /* S24 in 3 bytes */
+  AE_FMT_S24NE3P,
 
   AE_FMT_DOUBLE,
+  AE_FMT_DOUBLEP,
   AE_FMT_FLOAT,
+  AE_FMT_FLOATP,
 
   /* Bitstream formats */
   AE_FMT_AAC,
diff --git a/xbmc/cores/AudioEngine/Utils/AEUtil.cpp b/xbmc/cores/AudioEngine/Utils/AEUtil.cpp
index 6de84dc..3322226 100644
--- a/xbmc/cores/AudioEngine/Utils/AEUtil.cpp
+++ b/xbmc/cores/AudioEngine/Utils/AEUtil.cpp
@@ -82,26 +82,33 @@ const unsigned int CAEUtil::DataFormatToBits(const enum AEDataFormat dataFormat)
   static const unsigned int formats[AE_FMT_MAX] =
   {
     8,                   /* U8     */
+    8,                   /* U8P    */
     8,                   /* S8     */
 
     16,                  /* S16BE  */
     16,                  /* S16LE  */
     16,                  /* S16NE  */
+    16,                  /* S16NEP */
 
     32,                  /* S32BE  */
     32,                  /* S32LE  */
     32,                  /* S32NE  */
+    32,                  /* S32NEP */
 
     32,                  /* S24BE  */
     32,                  /* S24LE  */
     32,                  /* S24NE  */
+    32,                  /* S24NEP */
 
     24,                  /* S24BE3 */
     24,                  /* S24LE3 */
     24,                  /* S24NE3 */
+    24,                  /* S24NE3P*/
 
     sizeof(double) << 3, /* DOUBLE */
+    sizeof(double) << 3, /* DOUBLEP */
     sizeof(float ) << 3, /* FLOAT  */
+    sizeof(float ) << 3, /* FLOATP  */
 
     16,                  /* AAC    */
     16,                  /* AC3    */
@@ -123,26 +130,33 @@ const char* CAEUtil::DataFormatToStr(const enum AEDataFormat dataFormat)
   static const char *formats[AE_FMT_MAX] =
   {
     "AE_FMT_U8",
+    "AE_FMT_U8P",
     "AE_FMT_S8",
 
     "AE_FMT_S16BE",
     "AE_FMT_S16LE",
     "AE_FMT_S16NE",
+    "AE_FMT_S16NEP",
 
     "AE_FMT_S32BE",
     "AE_FMT_S32LE",
     "AE_FMT_S32NE",
+    "AE_FMT_S32NEP",
 
     "AE_FMT_S24BE4",
     "AE_FMT_S24LE4",
     "AE_FMT_S24NE4",  /* S24 in 4 bytes */
+    "AE_FMT_S24NE4P",
 
     "AE_FMT_S24BE3",
     "AE_FMT_S24LE3",
     "AE_FMT_S24NE3", /* S24 in 3 bytes */
+    "AE_FMT_S24NE3P",
 
     "AE_FMT_DOUBLE",
+    "AE_FMT_DOUBLEP",
     "AE_FMT_FLOAT",
+    "AE_FMT_FLOATP",
 
     /* for passthrough streams and the like */
     "AE_FMT_AAC",
-- 
1.8.1.6


From 7be39700ca76a23e1f51315a77e4fba5dfdfbc39 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 31 May 2013 16:28:30 +0200
Subject: [PATCH 002/123] AE: register callback for all audio settings

---
 xbmc/settings/Settings.cpp | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index 65e685a..ee97753 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -840,8 +840,18 @@ void CSettings::InitializeISettingCallbacks()
   m_settingsManager->RegisterCallback(&CDisplaySettings::Get(), settingSet);
 
   settingSet.clear();
+  settingSet.insert("audiooutput.mode");
   settingSet.insert("audiooutput.channels");
   settingSet.insert("audiooutput.guisoundmode");
+  settingSet.insert("audiooutput.stereoupmix");
+  settingSet.insert("audiooutput.ac3passthrough");
+  settingSet.insert("audiooutput.dtspassthrough");
+  settingSet.insert("audiooutput.passthroughaac");
+  settingSet.insert("audiooutput.truehdpassthrough");
+  settingSet.insert("audiooutput.dtshdpassthrough");
+  settingSet.insert("audiooutput.multichannellpcm");
+  settingSet.insert("audiooutput.audiodevice");
+  settingSet.insert("audiooutput.passthroughdevice");
   settingSet.insert("lookandfeel.skin");
   settingSet.insert("lookandfeel.skinsettings");
   settingSet.insert("lookandfeel.font");
-- 
1.8.1.6


From a2070bcc6555822f98e8bb5d846dee36c3b98028 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 23 May 2013 10:05:11 +0200
Subject: [PATCH 003/123] AESinkALSA: drop unneeded member

---
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp | 11 ++++++-----
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.h   |  1 -
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
index 9d3cefa..32fb450 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
@@ -131,19 +131,20 @@ void CAESinkALSA::GetAESParams(AEAudioFormat format, std::string& params)
 
 bool CAESinkALSA::Initialize(AEAudioFormat &format, std::string &device)
 {
+  CAEChannelInfo channelLayout;
   m_initDevice = device;
   m_initFormat = format;
 
   /* if we are raw, correct the data format */
   if (AE_IS_RAW(format.m_dataFormat))
   {
-    m_channelLayout     = GetChannelLayout(format);
+    channelLayout     = GetChannelLayout(format);
     format.m_dataFormat = AE_FMT_S16NE;
     m_passthrough       = true;
   }
   else
   {
-    m_channelLayout = GetChannelLayout(format);
+    channelLayout = GetChannelLayout(format);
     m_passthrough   = false;
   }
 #if defined(HAS_AMLPLAYER) || defined(HAS_LIBAMCODEC)
@@ -154,13 +155,13 @@ bool CAESinkALSA::Initialize(AEAudioFormat &format, std::string &device)
   }
 #endif
 
-  if (m_channelLayout.Count() == 0)
+  if (channelLayout.Count() == 0)
   {
     CLog::Log(LOGERROR, "CAESinkALSA::Initialize - Unable to open the requested channel layout");
     return false;
   }
 
-  format.m_channelLayout = m_channelLayout;
+  format.m_channelLayout = channelLayout;
 
   AEDeviceType devType = AEDeviceTypeFromName(device);
 
@@ -176,7 +177,7 @@ bool CAESinkALSA::Initialize(AEAudioFormat &format, std::string &device)
   snd_config_t *config;
   snd_config_copy(&config, snd_config);
 
-  if (!OpenPCMDevice(device, AESParams, m_channelLayout.Count(), &m_pcm, config))
+  if (!OpenPCMDevice(device, AESParams, channelLayout.Count(), &m_pcm, config))
   {
     CLog::Log(LOGERROR, "CAESinkALSA::Initialize - failed to initialize device \"%s\"", device.c_str());
     snd_config_delete(config);
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
index e2b4e4f..73615a5 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
@@ -64,7 +64,6 @@ class CAESinkALSA : public IAESink
   unsigned int      m_bufferSize;
   double            m_formatSampleRateMul;
   bool              m_passthrough;
-  CAEChannelInfo    m_channelLayout;
   std::string       m_device;
   snd_pcm_t        *m_pcm;
   int               m_timeout;
-- 
1.8.1.6


From 1871f8bc6bb5828299b57db0fbf131392e2ea5a1 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sat, 27 Apr 2013 10:47:01 +0200
Subject: [PATCH 004/123] ffmpeg: add methods to the interface needed for
 resampling

---
 lib/DllAvUtil.h     | 14 ++++++++++++++
 lib/DllSwResample.h | 15 +++++++++++++++
 2 files changed, 29 insertions(+)

diff --git a/lib/DllAvUtil.h b/lib/DllAvUtil.h
index 1afee5e..bbe9be2 100644
--- a/lib/DllAvUtil.h
+++ b/lib/DllAvUtil.h
@@ -95,6 +95,9 @@ class DllAvUtilInterface
   virtual void av_dict_free(AVDictionary **pm) = 0;
   virtual int av_samples_get_buffer_size (int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align) = 0;
   virtual int64_t av_get_default_channel_layout(int nb_channels)=0;
+  virtual int av_samples_alloc(uint8_t **audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align) = 0;
+  virtual int av_sample_fmt_is_planar(enum AVSampleFormat sample_fmt) = 0;
+  virtual int av_get_channel_layout_channel_index (uint64_t channel_layout, uint64_t channel) = 0;
 };
 
 #if defined (USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN)
@@ -133,6 +136,10 @@ class DllAvUtilBase : public DllDynamic, DllAvUtilInterface
   virtual int av_samples_get_buffer_size (int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
     { return ::av_samples_get_buffer_size(linesize, nb_channels, nb_samples, sample_fmt, align); }
   virtual int64_t av_get_default_channel_layout(int nb_channels) { return ::av_get_default_channel_layout(nb_channels); }
+  virtual int av_samples_alloc(uint8_t **audio_data, int *linesize, int nb_channels, int nb_samples, enum AVSampleFormat sample_fmt, int align)
+    { return ::av_samples_alloc(audio_data, linesize, nb_channels, nb_samples, sample_fmt, align); }
+  virtual int av_sample_fmt_is_planar(enum AVSampleFormat sample_fmt) { return ::av_sample_fmt_is_planar(sample_fmt); }
+  virtual int av_get_channel_layout_channel_index (uint64_t channel_layout, uint64_t channel) { return ::av_get_channel_layout_channel_index(channel_layout, channel); }
 
    // DLL faking.
    virtual bool ResolveExports() { return true; }
@@ -178,6 +185,9 @@ class DllAvUtilBase : public DllDynamic, DllAvUtilInterface
   DEFINE_METHOD1(void, av_dict_free, (AVDictionary **p1));
   DEFINE_METHOD5(int, av_samples_get_buffer_size, (int *p1, int p2, int p3, enum AVSampleFormat p4, int p5))
   DEFINE_METHOD1(int64_t, av_get_default_channel_layout, (int p1))
+  DEFINE_METHOD6(int, av_samples_alloc, (uint8_t **p1, int *p2, int p3, int p4, enum AVSampleFormat p5, int p6))
+  DEFINE_METHOD1(int, av_sample_fmt_is_planar, (enum AVSampleFormat p1))
+  DEFINE_METHOD2(int, av_get_channel_layout_channel_index, (uint64_t p1, uint64_t p2))
 
   public:
   BEGIN_METHOD_RESOLVE()
@@ -206,6 +216,10 @@ class DllAvUtilBase : public DllDynamic, DllAvUtilInterface
     RESOLVE_METHOD(av_dict_free)
     RESOLVE_METHOD(av_samples_get_buffer_size)
     RESOLVE_METHOD(av_get_default_channel_layout)
+    RESOLVE_METHOD(av_samples_alloc)
+    RESOLVE_METHOD(av_sample_fmt_is_planar)
+    RESOLVE_METHOD(av_get_channel_layout_channel_index)
+
   END_METHOD_RESOLVE()
 };
 
diff --git a/lib/DllSwResample.h b/lib/DllSwResample.h
index e9613d3..320b3a7 100644
--- a/lib/DllSwResample.h
+++ b/lib/DllSwResample.h
@@ -60,6 +60,9 @@ class DllSwResampleInterface
   virtual int swr_init(struct SwrContext *s)=0;
   virtual void swr_free(struct SwrContext **s)=0;
   virtual int swr_convert(struct SwrContext *s, uint8_t **out, int out_count, const uint8_t **in , int in_count)=0;
+  virtual int64_t swr_get_delay(struct SwrContext *s, int64_t base) = 0;
+  virtual int swr_set_channel_mapping(struct SwrContext *s, const int *channel_map) = 0;
+  virtual int swr_set_matrix(struct SwrContext *s, const double *matrix, int stride) = 0;
 };
 
 #if (defined USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN) 
@@ -84,6 +87,9 @@ class DllSwResample : public DllDynamic, DllSwResampleInterface
   virtual int swr_init(struct SwrContext *s) { return ::swr_init(s); }
   virtual void swr_free(struct SwrContext **s){ return ::swr_free(s); }
   virtual int swr_convert(struct SwrContext *s, uint8_t **out, int out_count, const uint8_t **in , int in_count){ return ::swr_convert(s, out, out_count, in, in_count); }
+  virtual int64_t swr_get_delay(struct SwrContext *s, int64_t base) { return ::swr_get_delay(s, base); }
+  virtual int swr_set_channel_mapping (struct SwrContext *s, const int *channel_map) { return ::swr_set_channel_mapping(s, channel_map); }
+  virtual int swr_set_matrix(struct SwrContext *s, const double *matrix, int stride) { return ::swr_set_matrix(s, matrix, stride); }
 };
 #else
 // Wrap the same API through libavresample.
@@ -114,6 +120,9 @@ class DllSwResample : public DllDynamic, DllSwResampleInterface
   virtual int swr_init(struct SwrContext *s) { return ::avresample_open(s); }
   virtual void swr_free(struct SwrContext **s){ ::avresample_close(*s); *s = NULL; }
   virtual int swr_convert(struct SwrContext *s, uint8_t **out, int out_count, const uint8_t **in , int in_count){ return ::avresample_convert(s, out, 0, out_count, (uint8_t**)in, 0,in_count); }
+  virtual int64_t swr_get_delay(struct SwrContext *s, int64_t base){return ::swr_get_delay(s, base);}
+  virtual int swr_set_channel_mapping (struct SwrContext *s, const int *channel_map){return ::swr_set_channel_mapping(s, channel_map);}
+  virtual int swr_set_matrix(struct SwrContext *s, const double *matrix, int stride) { return ::swr_set_matrix(s, matrix, stride);}
 };
 #endif
 
@@ -129,12 +138,18 @@ class DllSwResample : public DllDynamic, DllSwResampleInterface
   DEFINE_METHOD1(int, swr_init, (struct SwrContext *p1))
   DEFINE_METHOD1(void, swr_free, (struct SwrContext **p1))
   DEFINE_METHOD5(int, swr_convert, (struct SwrContext *p1, uint8_t **p2, int p3, const uint8_t **p4, int p5))
+  DEFINE_METHOD2(int64_t, swr_get_delay, (struct SwrContext *p1, int64_t p2))
+  DEFINE_METHOD2(int, swr_set_channel_mapping, (struct SwrContext *p1, const int *p2))
+  DEFINE_METHOD3(int, swr_set_matrix, (struct SwrContext *p1, const double *p2, int p3))
 
   BEGIN_METHOD_RESOLVE()
     RESOLVE_METHOD(swr_alloc_set_opts)
     RESOLVE_METHOD(swr_init)
     RESOLVE_METHOD(swr_free)
     RESOLVE_METHOD(swr_convert)
+    RESOLVE_METHOD(swr_get_delay)
+    RESOLVE_METHOD(swr_set_channel_mapping)
+    RESOLVE_METHOD(swr_set_matrix)
   END_METHOD_RESOLVE()
 
   /* dependencies of libavformat */
-- 
1.8.1.6


From efe72091a8b488b8bb11063149252b6de292f66b Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Wed, 26 Jun 2013 15:12:28 +0200
Subject: [PATCH 005/123] AE: allow encoder to be fed with planar format

---
 .../cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp | 66 +++++++++++++++++++++-
 xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h  |  3 +-
 xbmc/cores/AudioEngine/Interfaces/AEEncoder.h      | 13 ++++-
 3 files changed, 78 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp b/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp
index 99d9a47..36bae54 100644
--- a/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp
+++ b/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.cpp
@@ -98,7 +98,7 @@ unsigned int CAEEncoderFFmpeg::BuildChannelLayout(const int64_t ffmap, CAEChanne
   return layout.Count();
 }
 
-bool CAEEncoderFFmpeg::Initialize(AEAudioFormat &format)
+bool CAEEncoderFFmpeg::Initialize(AEAudioFormat &format, bool allow_planar_input)
 {
   Reset();
 
@@ -150,6 +150,7 @@ bool CAEEncoderFFmpeg::Initialize(AEAudioFormat &format)
     bool hasS32    = false;
     bool hasS16    = false;
     bool hasU8     = false;
+    bool hasFloatP = false;
     bool hasUnknownFormat = false;
 
     for(int i = 0; codec->sample_fmts[i] != AV_SAMPLE_FMT_NONE; ++i)
@@ -161,6 +162,12 @@ bool CAEEncoderFFmpeg::Initialize(AEAudioFormat &format)
         case AV_SAMPLE_FMT_S32: hasS32    = true; break;
         case AV_SAMPLE_FMT_S16: hasS16    = true; break;
         case AV_SAMPLE_FMT_U8 : hasU8     = true; break;
+        case AV_SAMPLE_FMT_FLTP:
+          if (allow_planar_input)
+            hasFloatP  = true;
+          else
+            hasUnknownFormat = true;
+          break;
         case AV_SAMPLE_FMT_NONE: return false;
         default: hasUnknownFormat = true; break;
       }
@@ -171,6 +178,11 @@ bool CAEEncoderFFmpeg::Initialize(AEAudioFormat &format)
       m_CodecCtx->sample_fmt = AV_SAMPLE_FMT_FLT;
       format.m_dataFormat    = AE_FMT_FLOAT;
     }
+    else if (hasFloatP)
+    {
+      m_CodecCtx->sample_fmt = AV_SAMPLE_FMT_FLTP;
+      format.m_dataFormat    = AE_FMT_FLOATP;
+    }
     else if (hasDouble)
     {
       m_CodecCtx->sample_fmt = AV_SAMPLE_FMT_DBL;
@@ -214,7 +226,6 @@ bool CAEEncoderFFmpeg::Initialize(AEAudioFormat &format)
     return false;
   }
 
-  format.m_dataFormat    = AE_FMT_FLOAT;
   format.m_frames        = m_CodecCtx->frame_size;
   format.m_frameSamples  = m_CodecCtx->frame_size * m_CodecCtx->channels;
   format.m_frameSize     = m_CodecCtx->channels * (CAEUtil::DataFormatToBits(format.m_dataFormat) >> 3);
@@ -351,6 +362,57 @@ int CAEEncoderFFmpeg::Encode(float *data, unsigned int frames)
   return m_NeededFrames;
 }
 
+int CAEEncoderFFmpeg::Encode(uint8_t *in, int in_size, uint8_t *out, int out_size)
+{
+  int got_output;
+  AVFrame *frame;
+
+  if (!m_CodecCtx)
+    return 0;
+
+  /* allocate the input frame
+   * sadly, we have to alloc/dealloc it everytime since we have no guarantee the
+   * data argument will be constant over iterated calls and the frame needs to
+   * setup pointers inside data */
+  frame = m_dllAvCodec.avcodec_alloc_frame();
+  if (!frame)
+    return 0;
+
+  frame->nb_samples     = m_CodecCtx->frame_size;
+  frame->format         = m_CodecCtx->sample_fmt;
+  frame->channel_layout = m_CodecCtx->channel_layout;
+
+  m_dllAvCodec.avcodec_fill_audio_frame(frame, m_CodecCtx->channels, m_CodecCtx->sample_fmt,
+                    in, in_size, 0);
+
+  /* initialize the output packet */
+  m_dllAvCodec.av_init_packet(&m_Pkt);
+  m_Pkt.size      = out_size - IEC61937_DATA_OFFSET;
+  m_Pkt.data      = out + IEC61937_DATA_OFFSET;
+
+  /* encode it */
+  int ret = m_dllAvCodec.avcodec_encode_audio2(m_CodecCtx, &m_Pkt, frame, &got_output);
+
+  /* free temporary data */
+  m_dllAvCodec.avcodec_free_frame(&frame);
+
+  if (ret < 0 || !got_output)
+  {
+    CLog::Log(LOGERROR, "CAEEncoderFFmpeg::Encode - Encoding failed");
+    return 0;
+  }
+
+  /* pack it into an IEC958 frame */
+  m_PackFunc(NULL, m_Pkt.size, out);
+
+  /* free the packet */
+  m_dllAvCodec.av_free_packet(&m_Pkt);
+
+  /* return the number of frames used */
+  return m_NeededFrames;
+}
+
+
 int CAEEncoderFFmpeg::GetData(uint8_t **data)
 {
   int size;
diff --git a/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h b/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h
index d422ab6..2d442df 100644
--- a/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h
+++ b/xbmc/cores/AudioEngine/Encoders/AEEncoderFFmpeg.h
@@ -36,7 +36,7 @@ class CAEEncoderFFmpeg: public IAEEncoder
   virtual ~CAEEncoderFFmpeg();
 
   virtual bool IsCompatible(AEAudioFormat format);
-  virtual bool Initialize(AEAudioFormat &format);
+  virtual bool Initialize(AEAudioFormat &format, bool allow_planar_input = false);
   virtual void Reset();
 
   virtual unsigned int GetBitRate    ();
@@ -44,6 +44,7 @@ class CAEEncoderFFmpeg: public IAEEncoder
   virtual unsigned int GetFrames     ();
 
   virtual int Encode (float *data, unsigned int frames);
+  virtual int Encode (uint8_t *in, int in_size, uint8_t *out, int out_size);
   virtual int GetData(uint8_t **data);
   virtual double GetDelay(unsigned int bufferSize);
 private:
diff --git a/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h b/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h
index e304908..0e6f1f8 100644
--- a/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h
+++ b/xbmc/cores/AudioEngine/Interfaces/AEEncoder.h
@@ -48,9 +48,10 @@ class IAEEncoder
   /**
    * Called to setup the encoder to accept data in the specified format
    * @param format the desired audio format, may be changed to suit the encoder
+   * @param allow_planar_input allow engine to use with planar formats
    * @return true on success, false on failure
    */
-  virtual bool Initialize(AEAudioFormat &format) = 0;
+  virtual bool Initialize(AEAudioFormat &format, bool allow_planar_input = false) = 0;
 
   /**
    * Reset the encoder for new data
@@ -84,6 +85,16 @@ class IAEEncoder
   virtual int Encode(float *data, unsigned int frames) = 0;
 
   /**
+   * Encodes the supplied samples into a provided buffer
+   * @param in the PCM samples encoder requested format
+   * @param in_size input buffer size
+   * @param output buffer
+   * @param out_size output buffer size
+   * @return the number of samples consumed
+   */
+  virtual int Encode (uint8_t *in, int in_size, uint8_t *out, int out_size) { return 0; };
+
+  /**
    * Get the encoded data
    * @param data return pointer to the buffer with the current encoded block
    * @return the size in bytes of *data
-- 
1.8.1.6


From 796f1dbc328099fd3527756675795b8708436468 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Wed, 26 Jun 2013 15:13:22 +0200
Subject: [PATCH 006/123] AE: alsa - close device in blocking mode, fixes
 device busy

---
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
index 32fb450..91cfc08 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
@@ -196,8 +196,8 @@ bool CAESinkALSA::Initialize(AEAudioFormat &format, std::string &device)
   if (!InitializeHW(format) || !InitializeSW(format))
     return false;
 
-  snd_pcm_nonblock(m_pcm, 1);
   snd_pcm_prepare (m_pcm);
+  snd_pcm_nonblock(m_pcm, 1);
 
   m_format              = format;
   m_formatSampleRateMul = 1.0 / (double)m_format.m_sampleRate;
@@ -436,10 +436,10 @@ bool CAESinkALSA::InitializeSW(AEAudioFormat &format)
 
 void CAESinkALSA::Deinitialize()
 {
-  Stop();
-
   if (m_pcm)
   {
+    snd_pcm_nonblock(m_pcm, 0);
+    Stop();
     snd_pcm_close(m_pcm);
     m_pcm = NULL;
   }
-- 
1.8.1.6


From 5cdc044bbfdf1740992d930501d48f78ea104d5d Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Wed, 26 Jun 2013 18:48:30 +0200
Subject: [PATCH 007/123] AE: alsa - set to prepared after drain

---
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
index 91cfc08..ee7b549 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
@@ -196,8 +196,8 @@ bool CAESinkALSA::Initialize(AEAudioFormat &format, std::string &device)
   if (!InitializeHW(format) || !InitializeSW(format))
     return false;
 
-  snd_pcm_prepare (m_pcm);
   snd_pcm_nonblock(m_pcm, 1);
+  snd_pcm_prepare (m_pcm);
 
   m_format              = format;
   m_formatSampleRateMul = 1.0 / (double)m_format.m_sampleRate;
@@ -574,6 +574,7 @@ void CAESinkALSA::Drain()
 
   snd_pcm_nonblock(m_pcm, 0);
   snd_pcm_drain(m_pcm);
+  snd_pcm_prepare(m_pcm);
   snd_pcm_nonblock(m_pcm, 1);
 }
 
-- 
1.8.1.6


From a28f4c46f39407d1e155a6b300a38eadca67a2c6 Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Fri, 5 Jul 2013 21:02:00 +0200
Subject: [PATCH 008/123] AE: Add blocking option to AddPackets, makes Sink
 behaviour choosable after c2493d5bf6bc2be2fb45f563affdd214bf9862fb

---
 xbmc/cores/AudioEngine/Interfaces/AESink.h         |  2 +-
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp        | 11 +++++++++--
 xbmc/cores/AudioEngine/Sinks/AESinkALSA.h          |  2 +-
 xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp  |  2 +-
 xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.h    |  2 +-
 xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.cpp |  4 ++--
 xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.h   |  2 +-
 xbmc/cores/AudioEngine/Sinks/AESinkNULL.cpp        |  2 +-
 xbmc/cores/AudioEngine/Sinks/AESinkNULL.h          |  2 +-
 xbmc/cores/AudioEngine/Sinks/AESinkOSS.cpp         |  2 +-
 xbmc/cores/AudioEngine/Sinks/AESinkOSS.h           |  2 +-
 xbmc/cores/AudioEngine/Sinks/AESinkProfiler.cpp    |  2 +-
 xbmc/cores/AudioEngine/Sinks/AESinkProfiler.h      |  2 +-
 xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp      |  2 +-
 xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.h        |  2 +-
 15 files changed, 24 insertions(+), 17 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Interfaces/AESink.h b/xbmc/cores/AudioEngine/Interfaces/AESink.h
index cb9c04b..65395bf 100644
--- a/xbmc/cores/AudioEngine/Interfaces/AESink.h
+++ b/xbmc/cores/AudioEngine/Interfaces/AESink.h
@@ -71,7 +71,7 @@ class IAESink
   /*
     Adds packets to be sent out, this routine MUST block or sleep.
   */
-  virtual unsigned int AddPackets(uint8_t *data, unsigned int frames, bool hasAudio) = 0;
+  virtual unsigned int AddPackets(uint8_t *data, unsigned int frames, bool hasAudio, bool blocking = false) = 0;
 
   /*
     Drain the sink
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
index ee7b549..8d2e6a1 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
@@ -497,7 +497,7 @@ double CAESinkALSA::GetCacheTotal()
   return (double)m_bufferSize * m_formatSampleRateMul;
 }
 
-unsigned int CAESinkALSA::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio)
+unsigned int CAESinkALSA::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio, bool blocking)
 {
   if (!m_pcm)
   {
@@ -518,7 +518,14 @@ unsigned int CAESinkALSA::AddPackets(uint8_t *data, unsigned int frames, bool ha
   }
 
   if ((unsigned int)ret < frames)
-    return 0;
+    if(blocking)
+    {
+      ret = snd_pcm_wait(m_pcm, m_timeout);
+      if (ret < 0)
+        HandleError("snd_pcm_wait", ret);
+    }
+    else
+      return 0;
 
   ret = snd_pcm_writei(m_pcm, (void*)data, frames);
   if (ret < 0)
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
index 73615a5..69c8a85 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkALSA.h
@@ -47,7 +47,7 @@ class CAESinkALSA : public IAESink
   virtual double       GetDelay        ();
   virtual double       GetCacheTime    ();
   virtual double       GetCacheTotal   ();
-  virtual unsigned int AddPackets      (uint8_t *data, unsigned int frames, bool hasAudio);
+  virtual unsigned int AddPackets      (uint8_t *data, unsigned int frames, bool hasAudio, bool blocking = false);
   virtual void         Drain           ();
   virtual bool         SoftSuspend();
   virtual bool         SoftResume();
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
index c37bf2d..66e4c6a 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
@@ -212,7 +212,7 @@ double CAESinkAUDIOTRACK::GetCacheTotal()
   return m_sinkbuffer_sec + m_audiotrackbuffer_sec;
 }
 
-unsigned int CAESinkAUDIOTRACK::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio)
+unsigned int CAESinkAUDIOTRACK::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio, bool blocking)
 {
   // write as many frames of audio as we can fit into our internal buffer.
 
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.h b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.h
index d07ab8d..e923cd6 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.h
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.h
@@ -39,7 +39,7 @@ class CAESinkAUDIOTRACK : public CThread, public IAESink
   virtual double       GetDelay        ();
   virtual double       GetCacheTime    ();
   virtual double       GetCacheTotal   ();
-  virtual unsigned int AddPackets      (uint8_t *data, unsigned int frames, bool hasAudio);
+  virtual unsigned int AddPackets      (uint8_t *data, unsigned int frames, bool hasAudio, bool blocking = false);
   virtual void         Drain           ();
   virtual bool         HasVolume       ();
   virtual void         SetVolume       (float scale);
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.cpp
index e3a3695..8df9cab 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.cpp
@@ -367,7 +367,7 @@ bool CAESinkDirectSound::IsCompatible(const AEAudioFormat format, const std::str
   return false;
 }
 
-unsigned int CAESinkDirectSound::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio)
+unsigned int CAESinkDirectSound::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio, bool blocking = false)
 {
   if (!m_initialized)
     return 0;
@@ -910,4 +910,4 @@ bool CAESinkDirectSound::SoftResume()
 {
   /* Return false to force re-init by engine */
   return false;
-}
\ No newline at end of file
+}
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.h b/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.h
index 944e598..f06e929 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.h
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.h
@@ -42,7 +42,7 @@ class CAESinkDirectSound : public IAESink
   virtual double       GetDelay           ();
   virtual double       GetCacheTime       ();
   virtual double       GetCacheTotal      ();
-  virtual unsigned int AddPackets         (uint8_t *data, unsigned int frames, bool hasAudio);
+  virtual unsigned int AddPackets         (uint8_t *data, unsigned int frames, bool hasAudio, bool blocking = false);
   virtual bool         SoftSuspend        ();
   virtual bool         SoftResume         ();
   static  std::string  GetDefaultDevice   ();
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkNULL.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkNULL.cpp
index 9f980f8..28cadcc 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkNULL.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkNULL.cpp
@@ -99,7 +99,7 @@ double CAESinkNULL::GetCacheTotal()
   return m_sinkbuffer_sec_per_byte * (double)m_sinkbuffer_size;
 }
 
-unsigned int CAESinkNULL::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio)
+unsigned int CAESinkNULL::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio, bool blocking)
 {
   unsigned int max_frames = (m_sinkbuffer_size - m_sinkbuffer_level) / m_sink_frameSize;
   if (frames > max_frames)
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkNULL.h b/xbmc/cores/AudioEngine/Sinks/AESinkNULL.h
index 47bf18f..09e49f0 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkNULL.h
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkNULL.h
@@ -38,7 +38,7 @@ class CAESinkNULL : public CThread, public IAESink
   virtual double       GetDelay        ();
   virtual double       GetCacheTime    ();
   virtual double       GetCacheTotal   ();
-  virtual unsigned int AddPackets      (uint8_t *data, unsigned int frames, bool hasAudio);
+  virtual unsigned int AddPackets      (uint8_t *data, unsigned int frames, bool hasAudio, bool blocking = false);
   virtual void         Drain           ();
 
   static void          EnumerateDevices(AEDeviceList &devices, bool passthrough);
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkOSS.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkOSS.cpp
index 00f57d0..97d1725 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkOSS.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkOSS.cpp
@@ -408,7 +408,7 @@ double CAESinkOSS::GetDelay()
   return (double)delay / (m_format.m_frameSize * m_format.m_sampleRate);
 }
 
-unsigned int CAESinkOSS::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio)
+unsigned int CAESinkOSS::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio, bool blocking)
 {
   int size = frames * m_format.m_frameSize;
   if (m_fd == -1)
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkOSS.h b/xbmc/cores/AudioEngine/Sinks/AESinkOSS.h
index ab1b457..18cadce 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkOSS.h
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkOSS.h
@@ -41,7 +41,7 @@ class CAESinkOSS : public IAESink
   virtual double       GetDelay        ();
   virtual double       GetCacheTime    () { return 0.0; } /* FIXME */
   virtual double       GetCacheTotal   () { return 0.0; } /* FIXME */
-  virtual unsigned int AddPackets      (uint8_t *data, unsigned int frames, bool hasAudio);
+  virtual unsigned int AddPackets      (uint8_t *data, unsigned int frames, bool hasAudio, bool blocking = false);
   virtual void         Drain           ();
   static  void         EnumerateDevicesEx(AEDeviceInfoList &list, bool force = false);
 private:
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkProfiler.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkProfiler.cpp
index 7c01573..1cf4843 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkProfiler.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkProfiler.cpp
@@ -71,7 +71,7 @@ double CAESinkProfiler::GetDelay()
   return 0.0f;
 }
 
-unsigned int CAESinkProfiler::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio)
+unsigned int CAESinkProfiler::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio, bool blocking)
 {
   int64_t ts = CurrentHostCounter();
   CLog::Log(LOGDEBUG, "CAESinkProfiler::AddPackets - latency %f ms", (float)(ts - m_ts) / 1000000.0f);
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkProfiler.h b/xbmc/cores/AudioEngine/Sinks/AESinkProfiler.h
index 621e0f3..814670a 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkProfiler.h
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkProfiler.h
@@ -39,7 +39,7 @@ class CAESinkProfiler : public IAESink
   virtual double       GetDelay        ();
   virtual double       GetCacheTime    () { return 0.0; }
   virtual double       GetCacheTotal   () { return 0.0; }
-  virtual unsigned int AddPackets      (uint8_t *data, unsigned int frames, bool hasAudio);
+  virtual unsigned int AddPackets      (uint8_t *data, unsigned int frames, bool hasAudio, bool blocking = false);
   virtual void         Drain           ();
   static void          EnumerateDevices(AEDeviceList &devices, bool passthrough);
 private:
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp
index 472366d..6d6e477 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp
@@ -423,7 +423,7 @@ double CAESinkWASAPI::GetCacheTotal()
   return m_sinkLatency;
 }
 
-unsigned int CAESinkWASAPI::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio)
+unsigned int CAESinkWASAPI::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio, bool blocking)
 {
   if (!m_initialized)
     return 0;
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.h b/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.h
index 312866c..c88dd91 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.h
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.h
@@ -42,7 +42,7 @@ class CAESinkWASAPI : public IAESink
     virtual double       GetDelay                    ();
     virtual double       GetCacheTime                ();
     virtual double       GetCacheTotal               ();
-    virtual unsigned int AddPackets                  (uint8_t *data, unsigned int frames, bool hasAudio);
+    virtual unsigned int AddPackets                  (uint8_t *data, unsigned int frames, bool hasAudio, bool blocking = false);
     virtual bool         SoftSuspend                 ();
     virtual bool         SoftResume                  ();
     static  void         EnumerateDevicesEx          (AEDeviceInfoList &deviceInfoList, bool force = false);
-- 
1.8.1.6


From d6064a357c0423d7601c50568f78496fc7fd89ea Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Sat, 6 Jul 2013 08:07:30 +0200
Subject: [PATCH 009/123] AE: Give Sinks the possibility to be used in a
 blocking way

---
 xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp  |  5 ++++
 xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.cpp | 11 +++++---
 xbmc/cores/AudioEngine/Sinks/AESinkOSS.cpp         |  2 +-
 xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp      | 29 +++++++++++++++++++---
 4 files changed, 40 insertions(+), 7 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
index 66e4c6a..bd179d5 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkAUDIOTRACK.cpp
@@ -243,6 +243,11 @@ unsigned int CAESinkAUDIOTRACK::AddPackets(uint8_t *data, unsigned int frames, b
         break;
     }
   }
+  // AddPackets runs under a non-idled AE thread we must block or sleep.
+  // Trying to calc the optimal sleep is tricky so just a minimal sleep.
+  if(blocking)
+    Sleep(10);
+
   return hasAudio ? write_frames:frames;
 }
 
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.cpp
index 8df9cab..6f4353d 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkDirectSound.cpp
@@ -367,7 +367,7 @@ bool CAESinkDirectSound::IsCompatible(const AEAudioFormat format, const std::str
   return false;
 }
 
-unsigned int CAESinkDirectSound::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio, bool blocking = false)
+unsigned int CAESinkDirectSound::AddPackets(uint8_t *data, unsigned int frames, bool hasAudio, bool blocking)
 {
   if (!m_initialized)
     return 0;
@@ -386,10 +386,15 @@ unsigned int CAESinkDirectSound::AddPackets(uint8_t *data, unsigned int frames,
 
   while (GetSpace() < total)
   {
-    if (m_isDirtyDS)
+    if(m_isDirtyDS)
       return INT_MAX;
     else
-      return 0;
+    {
+      if(blocking)
+        Sleep(total * 1000 / m_AvgBytesPerSec);
+      else
+        return 0;
+    }
   }
 
   while (len)
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkOSS.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkOSS.cpp
index 97d1725..ab13671 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkOSS.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkOSS.cpp
@@ -420,7 +420,7 @@ unsigned int CAESinkOSS::AddPackets(uint8_t *data, unsigned int frames, bool has
   int wrote = write(m_fd, data, size);
   if (wrote < 0)
   {
-    if(errno == EAGAIN || errno == EWOULDBLOCK)
+    if(!blocking && (errno == EAGAIN || errno == EWOULDBLOCK))
       return 0;
 
     CLog::Log(LOGERROR, "CAESinkOSS::AddPackets - Failed to write");
diff --git a/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp b/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp
index 6d6e477..5aebb47 100644
--- a/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp
+++ b/xbmc/cores/AudioEngine/Sinks/AESinkWASAPI.cpp
@@ -488,10 +488,33 @@ unsigned int CAESinkWASAPI::AddPackets(uint8_t *data, unsigned int frames, bool
 #endif
 
   /* Wait for Audio Driver to tell us it's got a buffer available */
-  DWORD eventAudioCallback = WaitForSingleObject(m_needDataEvent, 0);
+  DWORD eventAudioCallback;
+  if(!blocking)
+    eventAudioCallback = WaitForSingleObject(m_needDataEvent, 0);
+  else
+    eventAudioCallback = WaitForSingleObject(m_needDataEvent, 1100);
+
+  if (!blocking)
+  {
+    if(eventAudioCallback != WAIT_OBJECT_0)
+	  return 0;
+  }
+  else
+  {
+    if(eventAudioCallback != WAIT_OBJECT_0 || !&buf)
+    {
+      /* Event handle timed out - flag sink as dirty for re-initializing */
+      CLog::Log(LOGERROR, __FUNCTION__": Endpoint Buffer timed out");
+      if (g_advancedSettings.m_streamSilence)
+      {
+        m_isDirty = true; //flag new device or re-init needed
+        Deinitialize();
+        m_running = false;
+        return INT_MAX;
+      }
+    }
+  }
 
-  if (eventAudioCallback != WAIT_OBJECT_0)
-    return 0;
 
   if (!m_running)
     return 0;
-- 
1.8.1.6


From feafa929a610c5de9ebdaf7f1fd1657348d48945 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 7 Jul 2013 18:22:04 +0200
Subject: [PATCH 010/123] AE: allow to register audio callback directly into
 engine

---
 xbmc/cores/AudioEngine/AEFactory.cpp   | 12 ++++++++++++
 xbmc/cores/AudioEngine/AEFactory.h     |  3 +++
 xbmc/cores/AudioEngine/Interfaces/AE.h |  5 +++++
 xbmc/cores/dvdplayer/DVDPlayer.h       |  5 +++--
 xbmc/cores/paplayer/PAPlayer.cpp       |  2 ++
 5 files changed, 25 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/AudioEngine/AEFactory.cpp b/xbmc/cores/AudioEngine/AEFactory.cpp
index 7141dd3..0befba9 100644
--- a/xbmc/cores/AudioEngine/AEFactory.cpp
+++ b/xbmc/cores/AudioEngine/AEFactory.cpp
@@ -358,3 +358,15 @@ void CAEFactory::SettingOptionsAudioDevicesFillerGeneral(const CSetting *setting
   if (!foundValue)
     current = firstDevice;
 }
+
+void CAEFactory::RegisterAudioCallback(IAudioCallback* pCallback)
+{
+  if (AE)
+    AE->RegisterAudioCallback(pCallback);
+}
+
+void CAEFactory::UnregisterAudioCallback()
+{
+  if (AE)
+    AE->UnregisterAudioCallback();
+}
diff --git a/xbmc/cores/AudioEngine/AEFactory.h b/xbmc/cores/AudioEngine/AEFactory.h
index 56a1e27..9e15f79 100644
--- a/xbmc/cores/AudioEngine/AEFactory.h
+++ b/xbmc/cores/AudioEngine/AEFactory.h
@@ -67,6 +67,9 @@ class CAEFactory
   static void SettingOptionsAudioDevicesPassthroughFiller(const CSetting *setting, std::vector< std::pair<std::string, std::string> > &list, std::string &current);
   static void SettingOptionsAudioOutputModesFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current);
 
+  static void RegisterAudioCallback(IAudioCallback* pCallback);
+  static void UnregisterAudioCallback();
+
 private:
   static bool LoadEngine(enum AEEngine engine);
   static IAE *AE;
diff --git a/xbmc/cores/AudioEngine/Interfaces/AE.h b/xbmc/cores/AudioEngine/Interfaces/AE.h
index cbfa8ed..5741cd8 100644
--- a/xbmc/cores/AudioEngine/Interfaces/AE.h
+++ b/xbmc/cores/AudioEngine/Interfaces/AE.h
@@ -34,6 +34,7 @@
 class IAEStream;
 class IAESound;
 class IAEPacketizer;
+class IAudioCallback;
 
 /* sound options */
 #define AE_SOUND_OFF    0 /* disable sounds */
@@ -183,5 +184,9 @@ class IAE
    * @returns true if the AudioEngine is capable of RAW output
    */
   virtual bool SupportsRaw() { return false; }
+
+  virtual void RegisterAudioCallback(IAudioCallback* pCallback) {}
+
+  virtual void UnregisterAudioCallback() {}
 };
 
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.h b/xbmc/cores/dvdplayer/DVDPlayer.h
index ceb9996..6da30eb 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.h
+++ b/xbmc/cores/dvdplayer/DVDPlayer.h
@@ -39,6 +39,7 @@
 #include "Edl.h"
 #include "FileItem.h"
 #include "threads/SingleLock.h"
+#include "cores/AudioEngine/AEFactory.h"
 
 
 class CDVDInputStream;
@@ -185,8 +186,8 @@ class CDVDPlayer : public IPlayer, public CThread, public IDVDPlayer
   virtual float GetPercentage();
   virtual float GetCachePercentage();
 
-  virtual void RegisterAudioCallback(IAudioCallback* pCallback) { m_dvdPlayerAudio.RegisterAudioCallback(pCallback); }
-  virtual void UnRegisterAudioCallback()                        { m_dvdPlayerAudio.UnRegisterAudioCallback(); }
+  virtual void RegisterAudioCallback(IAudioCallback* pCallback) { CAEFactory::RegisterAudioCallback(pCallback); m_dvdPlayerAudio.RegisterAudioCallback(pCallback); }
+  virtual void UnRegisterAudioCallback()                        { CAEFactory::UnregisterAudioCallback(); m_dvdPlayerAudio.UnRegisterAudioCallback(); }
   virtual void SetVolume(float nVolume)                         { m_dvdPlayerAudio.SetVolume(nVolume); }
   virtual void SetDynamicRangeCompression(long drc)             { m_dvdPlayerAudio.SetDynamicRangeCompression(drc); }
   virtual void GetAudioInfo(CStdString& strAudioInfo);
diff --git a/xbmc/cores/paplayer/PAPlayer.cpp b/xbmc/cores/paplayer/PAPlayer.cpp
index cfde8fb..c9d56ac 100644
--- a/xbmc/cores/paplayer/PAPlayer.cpp
+++ b/xbmc/cores/paplayer/PAPlayer.cpp
@@ -717,6 +717,7 @@ void PAPlayer::OnExit()
 void PAPlayer::RegisterAudioCallback(IAudioCallback* pCallback)
 {
   CSharedLock lock(m_streamsLock);
+  CAEFactory::RegisterAudioCallback(pCallback);
   m_audioCallback = pCallback;
   if (m_currentStream && m_currentStream->m_stream)
     m_currentStream->m_stream->RegisterAudioCallback(pCallback);
@@ -725,6 +726,7 @@ void PAPlayer::RegisterAudioCallback(IAudioCallback* pCallback)
 void PAPlayer::UnRegisterAudioCallback()
 {
   CSharedLock lock(m_streamsLock);
+  CAEFactory::UnregisterAudioCallback();
   /* only one stream should have the callback, but we do it to all just incase */
   for(StreamList::iterator itt = m_streams.begin(); itt != m_streams.end(); ++itt)
     if ((*itt)->m_stream)
-- 
1.8.1.6


From 6df9543d4e87cc038938efb44bc44c4e8eba9c45 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Mon, 1 Jul 2013 13:52:29 +0200
Subject: [PATCH 011/123] AE: add parameter wait to drain, dvdplayer wants to
 wait for the stream to be drained, papayer does not

---
 xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.cpp | 2 +-
 xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.h   | 2 +-
 xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.cpp       | 2 +-
 xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.h         | 2 +-
 xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.cpp         | 2 +-
 xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.h           | 2 +-
 xbmc/cores/AudioEngine/Interfaces/AEStream.h                   | 2 +-
 xbmc/cores/dvdplayer/DVDAudio.cpp                              | 2 +-
 xbmc/cores/paplayer/PAPlayer.cpp                               | 2 +-
 9 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.cpp b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.cpp
index a9422f7..073769a 100644
--- a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.cpp
+++ b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.cpp
@@ -603,7 +603,7 @@ void CCoreAudioAEStream::Resume()
   m_paused = false;
 }
 
-void CCoreAudioAEStream::Drain()
+void CCoreAudioAEStream::Drain(bool wait)
 {
   m_draining = true;
 }
diff --git a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.h b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.h
index 18c52ed..1366808 100644
--- a/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.h
+++ b/xbmc/cores/AudioEngine/Engines/CoreAudio/CoreAudioAEStream.h
@@ -73,7 +73,7 @@ class CCoreAudioAEStream : public IAEStream, public ICoreAudioSource
 
   virtual void Pause();
   virtual void Resume();
-  virtual void Drain();
+  virtual void Drain(bool wait);
   virtual void Flush();
 
   virtual float GetVolume();
diff --git a/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.cpp b/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.cpp
index 443c844..e1e1903 100644
--- a/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.cpp
+++ b/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.cpp
@@ -386,7 +386,7 @@ void CPulseAEStream::Resume()
     m_Paused = Cork(false);
 }
 
-void CPulseAEStream::Drain()
+void CPulseAEStream::Drain(bool wait)
 {
   if (!m_Initialized)
     return;
diff --git a/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.h b/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.h
index 51aeda8..8d9435b 100644
--- a/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.h
+++ b/xbmc/cores/AudioEngine/Engines/PulseAE/PulseAEStream.h
@@ -48,7 +48,7 @@ class CPulseAEStream : public IAEStream
 
   virtual void Pause   ();
   virtual void Resume  ();
-  virtual void Drain   ();
+  virtual void Drain   (bool wait);
   virtual void Flush   ();
 
   virtual float GetVolume    ();
diff --git a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.cpp b/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.cpp
index 05ee1b0..b5c2da3 100644
--- a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.cpp
+++ b/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.cpp
@@ -555,7 +555,7 @@ void CSoftAEStream::Resume()
   AE.ResumeStream(this);
 }
 
-void CSoftAEStream::Drain()
+void CSoftAEStream::Drain(bool wait)
 {
   CSingleLock lock(m_lock);
   m_draining = true;
diff --git a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.h b/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.h
index f7410e3..1475c83 100644
--- a/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.h
+++ b/xbmc/cores/AudioEngine/Engines/SoftAE/SoftAEStream.h
@@ -59,7 +59,7 @@ class CSoftAEStream : public IAEStream
 
   virtual void              Pause           ();
   virtual void              Resume          ();
-  virtual void              Drain           ();
+  virtual void              Drain           (bool wait);
   virtual bool              IsDraining      () { return m_draining;    }
   virtual bool              IsDrained       ();
   virtual void              Flush           ();
diff --git a/xbmc/cores/AudioEngine/Interfaces/AEStream.h b/xbmc/cores/AudioEngine/Interfaces/AEStream.h
index 67fa5e2..92d5fef 100644
--- a/xbmc/cores/AudioEngine/Interfaces/AEStream.h
+++ b/xbmc/cores/AudioEngine/Interfaces/AEStream.h
@@ -97,7 +97,7 @@ class IAEStream
    * Start draining the stream
    * @note Once called AddData will not consume more data.
    */
-  virtual void Drain() = 0;
+  virtual void Drain(bool wait) = 0;
 
   /**
    * Returns true if the is stream draining
diff --git a/xbmc/cores/dvdplayer/DVDAudio.cpp b/xbmc/cores/dvdplayer/DVDAudio.cpp
index 3d77f0a..d304026 100644
--- a/xbmc/cores/dvdplayer/DVDAudio.cpp
+++ b/xbmc/cores/dvdplayer/DVDAudio.cpp
@@ -298,7 +298,7 @@ void CDVDAudio::Drain()
   Finish();
   CSingleLock lock (m_critSection);
   if (m_pAudioStream)
-    m_pAudioStream->Drain();
+    m_pAudioStream->Drain(true);
 }
 
 void CDVDAudio::RegisterAudioCallback(IAudioCallback* pCallback)
diff --git a/xbmc/cores/paplayer/PAPlayer.cpp b/xbmc/cores/paplayer/PAPlayer.cpp
index c9d56ac..f2e288c 100644
--- a/xbmc/cores/paplayer/PAPlayer.cpp
+++ b/xbmc/cores/paplayer/PAPlayer.cpp
@@ -568,7 +568,7 @@ inline void PAPlayer::ProcessStreams(double &delay, double &buffer)
       /* unregister the audio callback */
       si->m_stream->UnRegisterAudioCallback();
       si->m_decoder.Destroy();      
-      si->m_stream->Drain();
+      si->m_stream->Drain(false);
       m_finishing.push_back(si);
       return;
     }
-- 
1.8.1.6


From 2381ed88238ff8445cc23ac227e59e37b809e513 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 25 Mar 2013 13:58:11 +0100
Subject: [PATCH 012/123] ActiveAE: add new audio engine, co-author: fritsch

---
 xbmc/cores/AudioEngine/AEFactory.cpp               |    3 +
 xbmc/cores/AudioEngine/AEFactory.h                 |    3 +-
 .../AudioEngine/Engines/ActiveAE/ActiveAE.cpp      | 2189 ++++++++++++++++++++
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h |  332 +++
 .../Engines/ActiveAE/ActiveAEBuffer.cpp            |  368 ++++
 .../AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h  |  110 +
 .../Engines/ActiveAE/ActiveAEResample.cpp          |  251 +++
 .../Engines/ActiveAE/ActiveAEResample.h            |   61 +
 .../AudioEngine/Engines/ActiveAE/ActiveAESink.cpp  |  813 ++++++++
 .../AudioEngine/Engines/ActiveAE/ActiveAESink.h    |  133 ++
 .../AudioEngine/Engines/ActiveAE/ActiveAESound.cpp |  164 ++
 .../AudioEngine/Engines/ActiveAE/ActiveAESound.h   |   73 +
 .../Engines/ActiveAE/ActiveAEStream.cpp            |  357 ++++
 .../AudioEngine/Engines/ActiveAE/ActiveAEStream.h  |  115 +
 xbmc/cores/AudioEngine/Makefile.in                 |    7 +
 xbmc/utils/ActorProtocol.cpp                       |  253 +++
 xbmc/utils/ActorProtocol.h                         |   87 +
 xbmc/utils/Makefile.in                             |    1 +
 18 files changed, 5319 insertions(+), 1 deletion(-)
 create mode 100644 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
 create mode 100644 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
 create mode 100644 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.cpp
 create mode 100644 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h
 create mode 100644 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp
 create mode 100644 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h
 create mode 100644 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
 create mode 100644 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h
 create mode 100644 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.cpp
 create mode 100644 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.h
 create mode 100644 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
 create mode 100644 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h
 create mode 100644 xbmc/utils/ActorProtocol.cpp
 create mode 100644 xbmc/utils/ActorProtocol.h

diff --git a/xbmc/cores/AudioEngine/AEFactory.cpp b/xbmc/cores/AudioEngine/AEFactory.cpp
index 0befba9..4f9f566 100644
--- a/xbmc/cores/AudioEngine/AEFactory.cpp
+++ b/xbmc/cores/AudioEngine/AEFactory.cpp
@@ -27,6 +27,8 @@
   #include "settings/SettingsManager.h"
 #else
   #include "Engines/SoftAE/SoftAE.h"
+  #include "Engines/ActiveAE/ActiveAE.h"
+  using namespace ActiveAE;
 #endif
 
 #if defined(HAS_PULSEAUDIO)
@@ -99,6 +101,7 @@ bool CAEFactory::LoadEngine(enum AEEngine engine)
     case AE_ENGINE_COREAUDIO: AE = new CCoreAudioAE(); break;
 #else
     case AE_ENGINE_SOFT     : AE = new CSoftAE(); break;
+    case AE_ENGINE_ACTIVE   : AE = new CActiveAE(); break;
 #endif
 #if defined(HAS_PULSEAUDIO)
     case AE_ENGINE_PULSE    : AE = new CPulseAE(); break;
diff --git a/xbmc/cores/AudioEngine/AEFactory.h b/xbmc/cores/AudioEngine/AEFactory.h
index 9e15f79..3059001 100644
--- a/xbmc/cores/AudioEngine/AEFactory.h
+++ b/xbmc/cores/AudioEngine/AEFactory.h
@@ -31,7 +31,8 @@ enum AEEngine
   AE_ENGINE_NULL,
   AE_ENGINE_SOFT,
   AE_ENGINE_COREAUDIO,
-  AE_ENGINE_PULSE
+  AE_ENGINE_PULSE,
+  AE_ENGINE_ACTIVE
 };
 
 class CAEFactory
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
new file mode 100644
index 0000000..dc79da7
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -0,0 +1,2189 @@
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "ActiveAE.h"
+
+using namespace ActiveAE;
+#include "ActiveAESound.h"
+#include "ActiveAEStream.h"
+#include "Utils/AEUtil.h"
+#include "Encoders/AEEncoderFFmpeg.h"
+
+#include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
+#include "windowing/WindowingFactory.h"
+
+#define MAX_CACHE_LEVEL 0.5   // total cache time of stream in seconds
+#define MAX_WATER_LEVEL 0.25  // buffered time after stream stages in seconds
+
+void CEngineStats::Reset(unsigned int sampleRate)
+{
+  CSingleLock lock(m_lock);
+  m_sinkUpdate = XbmcThreads::SystemClockMillis();
+  m_sinkDelay = 0;
+  m_sinkSampleRate = sampleRate;
+  m_bufferedSamples = 0;
+  m_suspended = false;
+}
+
+void CEngineStats::UpdateSinkDelay(double delay, int samples)
+{
+  CSingleLock lock(m_lock);
+  m_sinkUpdate = XbmcThreads::SystemClockMillis();
+  m_sinkDelay = delay;
+  if (samples > m_bufferedSamples)
+  {
+    CLog::Log(LOGERROR, "CEngineStats::UpdateSinkDelay - inconsistency in buffer time");
+  }
+  else
+    m_bufferedSamples -= samples;
+}
+
+void CEngineStats::AddSamples(int samples, std::list<CActiveAEStream*> &streams)
+{
+  CSingleLock lock(m_lock);
+  m_bufferedSamples += samples;
+
+  //update buffered time of streams
+  std::list<CActiveAEStream*>::iterator it;
+  for(it=streams.begin(); it!=streams.end(); ++it)
+  {
+    float delay = 0;
+    std::deque<CSampleBuffer*>::iterator itBuf;
+    for(itBuf=(*it)->m_processingSamples.begin(); itBuf!=(*it)->m_processingSamples.end(); ++itBuf)
+    {
+      delay += (float)(*itBuf)->pkt->nb_samples / (*itBuf)->pkt->config.sample_rate;
+    }
+    delay += (*it)->m_resampleBuffers->GetDelay();
+    (*it)->m_bufferedTime = delay;
+  }
+}
+
+float CEngineStats::GetDelay()
+{
+  CSingleLock lock(m_lock);
+  unsigned int now = XbmcThreads::SystemClockMillis();
+  float delay = m_sinkDelay - (double)(now-m_sinkUpdate) / 1000;
+  delay += (float)m_bufferedSamples / m_sinkSampleRate;
+
+  return delay;
+}
+
+float CEngineStats::GetDelay(CActiveAEStream *stream)
+{
+  CSingleLock lock(m_lock);
+  unsigned int now = XbmcThreads::SystemClockMillis();
+  float delay = m_sinkDelay - (double)(now-m_sinkUpdate) / 1000;
+  delay += (float)m_bufferedSamples / m_sinkSampleRate;
+
+  delay += stream->m_bufferedTime;
+  return delay;
+}
+
+float CEngineStats::GetCacheTime(CActiveAEStream *stream)
+{
+  CSingleLock lock(m_lock);
+  float delay = (float)m_bufferedSamples / m_sinkSampleRate;
+
+  delay += stream->m_bufferedTime;
+  return delay;
+}
+
+float CEngineStats::GetCacheTotal(CActiveAEStream *stream)
+{
+  return MAX_CACHE_LEVEL + m_sinkCacheTotal;
+}
+
+float CEngineStats::GetWaterLevel()
+{
+  return (float)m_bufferedSamples / m_sinkSampleRate;
+}
+
+void CEngineStats::SetSuspended(bool state)
+{
+  CSingleLock lock(m_lock);
+  m_suspended = state;
+}
+
+bool CEngineStats::IsSuspended()
+{
+  CSingleLock lock(m_lock);
+  return m_suspended;
+}
+
+CActiveAE::CActiveAE() :
+  CThread("ActiveAE"),
+  m_controlPort("OutputControlPort", &m_inMsgEvent, &m_outMsgEvent),
+  m_dataPort("OutputDataPort", &m_inMsgEvent, &m_outMsgEvent),
+  m_sink(&m_outMsgEvent)
+{
+  m_sinkBuffers = NULL;
+  m_silenceBuffers = NULL;
+  m_encoderBuffers = NULL;
+  m_vizBuffers = NULL;
+  m_volume = 1.0;
+  m_aeVolume = 1.0;
+  m_muted = false;
+  m_aeMuted = false;
+  m_mode = MODE_PCM;
+  m_encoder = NULL;
+  m_audioCallback = NULL;
+  m_vizInitialized = false;
+}
+
+CActiveAE::~CActiveAE()
+{
+  Dispose();
+}
+
+void CActiveAE::Dispose()
+{
+#if defined(HAS_GLX) || defined(TARGET_DARWIN_OSX)
+  g_Windowing.Unregister(this);
+#endif
+
+  m_bStop = true;
+  m_outMsgEvent.Set();
+  StopThread();
+  m_controlPort.Purge();
+  m_dataPort.Purge();
+  m_sink.Dispose();
+
+  m_dllAvFormat.Unload();
+  m_dllAvCodec.Unload();
+  m_dllAvUtil.Unload();
+}
+
+//-----------------------------------------------------------------------------
+// Behavior
+//-----------------------------------------------------------------------------
+
+enum AE_STATES
+{
+  AE_TOP = 0,                      // 0
+  AE_TOP_ERROR,                    // 1
+  AE_TOP_UNCONFIGURED,             // 2
+  AE_TOP_RECONFIGURING,            // 3
+  AE_TOP_CONFIGURED,               // 4
+  AE_TOP_CONFIGURED_SUSPEND,       // 5
+  AE_TOP_CONFIGURED_IDLE,          // 6
+  AE_TOP_CONFIGURED_PLAY,          // 7
+};
+
+int AE_parentStates[] = {
+    -1,
+    0, //TOP_ERROR
+    0, //TOP_UNCONFIGURED
+    0, //TOP_CONFIGURED
+    0, //TOP_RECONFIGURING
+    4, //TOP_CONFIGURED_SUSPEND
+    4, //TOP_CONFIGURED_IDLE
+    4, //TOP_CONFIGURED_PLAY
+};
+
+void CActiveAE::StateMachine(int signal, Protocol *port, Message *msg)
+{
+  for (int state = m_state; ; state = AE_parentStates[state])
+  {
+    switch (state)
+    {
+    case AE_TOP: // TOP
+      if (port == &m_controlPort)
+      {
+        switch (signal)
+        {
+        case CActiveAEControlProtocol::GETSTATE:
+          msg->Reply(CActiveAEControlProtocol::ACC, &m_state, sizeof(m_state));
+          return;
+        case CActiveAEControlProtocol::SOUNDMODE:
+          m_soundMode = *(int*)msg->data;
+          return;
+        case CActiveAEControlProtocol::VOLUME:
+          m_volume = *(float*)msg->data;
+          return;
+        case CActiveAEControlProtocol::MUTE:
+          m_muted = *(bool*)msg->data;
+          return;
+        default:
+          break;
+        }
+      }
+      else if (port == &m_dataPort)
+      {
+        switch (signal)
+        {
+        case CActiveAEDataProtocol::NEWSOUND:
+          CActiveAESound *sound;
+          sound = *(CActiveAESound**)msg->data;
+          if (sound)
+          {
+            m_sounds.push_back(sound);
+            ResampleSounds();
+          }
+          return;
+        case CActiveAEDataProtocol::FREESTREAM:
+          CActiveAEStream *stream;
+          stream = *(CActiveAEStream**)msg->data;
+          DiscardStream(stream);
+          return;
+        case CActiveAEDataProtocol::FREESOUND:
+          sound = *(CActiveAESound**)msg->data;
+          DiscardSound(sound);
+          return;
+        case CActiveAEDataProtocol::DRAINSTREAM:
+          stream = *(CActiveAEStream**)msg->data;
+          stream->m_drain = true;
+          stream->m_resampleBuffers->m_drain = true;
+          msg->Reply(CActiveAEDataProtocol::ACC);
+          stream->m_streamPort->SendInMessage(CActiveAEDataProtocol::STREAMDRAINED);
+          return;
+        default:
+          break;
+        }
+      }
+      else if (&m_sink.m_dataPort)
+      {
+        switch (signal)
+        {
+        case CSinkDataProtocol::RETURNSAMPLE:
+          CSampleBuffer **buffer;
+          buffer = (CSampleBuffer**)msg->data;
+          if (buffer)
+          {
+            (*buffer)->Return();
+          }
+          return;
+        default:
+          break;
+        }
+      }
+      {
+        std::string portName = port == NULL ? "timer" : port->portName;
+        CLog::Log(LOGWARNING, "CActiveAE::%s - signal: %d from port: %s not handled for state: %d", __FUNCTION__, signal, portName.c_str(), m_state);
+      }
+      return;
+
+    case AE_TOP_ERROR:
+      break;
+
+    case AE_TOP_UNCONFIGURED:
+      if (port == &m_controlPort)
+      {
+        switch (signal)
+        {
+        case CActiveAEControlProtocol::INIT:
+          m_extError = false;
+          m_sink.EnumerateSinkList();
+          LoadSettings();
+          Configure();
+          msg->Reply(CActiveAEControlProtocol::ACC);
+          if (!m_extError)
+          {
+            m_state = AE_TOP_CONFIGURED_IDLE;
+            m_extTimeout = 0;
+          }
+          else
+          {
+            m_state = AE_TOP_ERROR;
+          }
+          return;
+
+        default:
+          break;
+        }
+      }
+      break;
+
+    case AE_TOP_RECONFIGURING:
+      if (port == NULL) // timeout
+      {
+        switch (signal)
+        {
+        case CActiveAEControlProtocol::TIMEOUT:
+          // drain
+          if (RunStages())
+          {
+            m_extTimeout = 0;
+            return;
+          }
+          if (HasWork())
+          {
+            m_extTimeout = 100;
+            return;
+          }
+          if (NeedReconfigureSink())
+            DrainSink();
+          Configure();
+          if (!m_extError)
+          {
+            m_state = AE_TOP_CONFIGURED_PLAY;
+            m_extTimeout = 0;
+          }
+          else
+          {
+            m_state = AE_TOP_ERROR;
+            m_extTimeout = 1000;
+          }
+          m_dataPort.DeferOut(false);
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case AE_TOP_CONFIGURED:
+      if (port == &m_controlPort)
+      {
+        switch (signal)
+        {
+        case CActiveAEControlProtocol::RECONFIGURE:
+          LoadSettings();
+          if (!NeedReconfigureBuffers() && !NeedReconfigureSink())
+            return;
+          m_state = AE_TOP_RECONFIGURING;
+          m_extTimeout = 0;
+          // don't accept any data until we are reconfigured
+          m_dataPort.DeferOut(true);
+          return;
+        case CActiveAEControlProtocol::SUSPEND:
+          UnconfigureSink();
+          m_stats.SetSuspended(true);
+          m_state = AE_TOP_CONFIGURED_SUSPEND;
+          return;
+        case CActiveAEControlProtocol::DISPLAYLOST:
+          if (m_settings.mode == AUDIO_HDMI)
+          {
+            UnconfigureSink();
+            m_stats.SetSuspended(true);
+            m_state = AE_TOP_CONFIGURED_SUSPEND;
+          }
+          return;
+        case CActiveAEControlProtocol::PAUSESTREAM:
+          CActiveAEStream *stream;
+          stream = *(CActiveAEStream**)msg->data;
+          stream->m_paused = true;
+          return;
+        case CActiveAEControlProtocol::RESUMESTREAM:
+          stream = *(CActiveAEStream**)msg->data;
+          stream->m_paused = false;
+          m_state = AE_TOP_CONFIGURED_PLAY;
+          m_extTimeout = 0;
+          return;
+        case CActiveAEControlProtocol::STREAMAMP:
+          MsgStreamParameter *par;
+          par = (MsgStreamParameter*)msg->data;
+          par->stream->m_limiter.SetAmplification(par->parameter.float_par);
+          return;
+        case CActiveAEControlProtocol::STREAMVOLUME:
+          par = (MsgStreamParameter*)msg->data;
+          par->stream->m_volume = par->parameter.float_par;
+          return;
+        case CActiveAEControlProtocol::STREAMRGAIN:
+          par = (MsgStreamParameter*)msg->data;
+          par->stream->m_rgain = par->parameter.float_par;
+          return;
+        case CActiveAEControlProtocol::STREAMRESAMPLERATIO:
+          par = (MsgStreamParameter*)msg->data;
+          if (par->stream->m_resampleBuffers)
+          {
+            par->stream->m_resampleBuffers->m_resampleRatio = par->parameter.double_par;
+            par->stream->m_resampleBuffers->m_changeRatio = true;
+          }
+          return;
+        case CActiveAEControlProtocol::STREAMFADE:
+          MsgStreamFade *fade;
+          fade = (MsgStreamFade*)msg->data;
+          fade->stream->m_fadingBase = fade->from;
+          fade->stream->m_fadingTarget = fade->target;
+          fade->stream->m_fadingTime = fade->millis;
+          fade->stream->m_fadingSamples = -1;
+          return;
+        case CActiveAEControlProtocol::STOPSOUND:
+          CActiveAESound *sound;
+          sound = *(CActiveAESound**)msg->data;
+          SStopSound(sound);
+          return;
+        default:
+          break;
+        }
+      }
+      else if (port == &m_dataPort)
+      {
+        switch (signal)
+        {
+        case CActiveAEDataProtocol::PLAYSOUND:
+          CActiveAESound *sound;
+          sound = *(CActiveAESound**)msg->data;
+          if (m_soundMode == AE_SOUND_OFF ||
+             (m_soundMode == AE_SOUND_IDLE && !m_streams.empty()))
+            return;
+          if (sound)
+          {
+            SoundState st = {sound, 0};
+            m_sounds_playing.push_back(st);
+            m_extTimeout = 0;
+            m_state = AE_TOP_CONFIGURED_PLAY;
+          }
+          return;
+        case CActiveAEDataProtocol::NEWSTREAM:
+          MsgStreamNew *streamMsg;
+          CActiveAEStream *stream;
+          streamMsg = (MsgStreamNew*)msg->data;
+          stream = CreateStream(streamMsg);
+          if(stream)
+          {
+            msg->Reply(CActiveAEDataProtocol::ACC, &stream, sizeof(CActiveAEStream*));
+            Configure();
+            m_extTimeout = 0;
+            m_state = AE_TOP_CONFIGURED_PLAY;
+          }
+          else
+            msg->Reply(CActiveAEDataProtocol::ERR);
+          return;
+        case CActiveAEDataProtocol::STREAMSAMPLE:
+          MsgStreamSample *msgData;
+          CSampleBuffer *samples;
+          msgData = (MsgStreamSample*)msg->data;
+          samples = msgData->stream->m_processingSamples.front();
+          msgData->stream->m_processingSamples.pop_front();
+          if (samples != msgData->buffer)
+            CLog::Log(LOGERROR, "CActiveAE - inconsistency in stream sample message");
+          if (msgData->buffer->pkt->nb_samples == 0)
+            msgData->buffer->Return();
+          else
+            msgData->stream->m_resampleBuffers->m_inputSamples.push_back(msgData->buffer);
+          m_extTimeout = 0;
+          m_state = AE_TOP_CONFIGURED_PLAY;
+          return;
+        case CActiveAEDataProtocol::FREESTREAM:
+          stream = *(CActiveAEStream**)msg->data;
+          DiscardStream(stream);
+          if (m_streams.empty())
+          {
+            m_extDrainTimer.Set(m_stats.GetDelay() * 1000);
+            m_extDrain = true;
+          }
+          m_extTimeout = 0;
+          m_state = AE_TOP_CONFIGURED_PLAY;
+          return;
+        case CActiveAEDataProtocol::DRAINSTREAM:
+          stream = *(CActiveAEStream**)msg->data;
+          stream->m_drain = true;
+          stream->m_resampleBuffers->m_drain = true;
+          m_extTimeout = 0;
+          m_state = AE_TOP_CONFIGURED_PLAY;
+          msg->Reply(CActiveAEDataProtocol::ACC);
+          return;
+        case CActiveAEDataProtocol::FLUSHSTREAM:
+          stream = *(CActiveAEStream**)msg->data;
+          SFlushStream(stream);
+          msg->Reply(CActiveAEDataProtocol::ACC);
+          return;
+        default:
+          break;
+        }
+      }
+      else if (&m_sink.m_dataPort)
+      {
+        switch (signal)
+        {
+        case CSinkDataProtocol::RETURNSAMPLE:
+          CSampleBuffer **buffer;
+          buffer = (CSampleBuffer**)msg->data;
+          if (buffer)
+          {
+            (*buffer)->Return();
+          }
+          m_extTimeout = 0;
+          m_state = AE_TOP_CONFIGURED_PLAY;
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case AE_TOP_CONFIGURED_SUSPEND:
+      if (port == &m_controlPort)
+      {
+        bool displayReset = false;
+        switch (signal)
+        {
+        case CActiveAEControlProtocol::DISPLAYRESET:
+          displayReset = true;
+        case CActiveAEControlProtocol::INIT:
+          m_extError = false;
+          if (!displayReset)
+          {
+            m_sink.EnumerateSinkList();
+            LoadSettings();
+          }
+          Configure();
+          if (!displayReset)
+            msg->Reply(CActiveAEControlProtocol::ACC);
+          if (!m_extError)
+          {
+            m_stats.SetSuspended(false);
+            m_state = AE_TOP_CONFIGURED_PLAY;
+            m_extTimeout = 0;
+          }
+          else
+          {
+            m_state = AE_TOP_ERROR;
+          }
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case AE_TOP_CONFIGURED_IDLE:
+      if (port == NULL) // timeout
+      {
+        switch (signal)
+        {
+        case CActiveAEControlProtocol::TIMEOUT:
+          ResampleSounds();
+          ClearDiscardedBuffers();
+          if (m_extDrain)
+          {
+            if (m_extDrainTimer.IsTimePast())
+            {
+              Configure();
+              m_state = AE_TOP_CONFIGURED_PLAY;
+              m_extTimeout = 0;
+            }
+            else
+              m_extTimeout = m_extDrainTimer.MillisLeft();
+          }
+          else
+            m_extTimeout = 5000;
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case AE_TOP_CONFIGURED_PLAY:
+      if (port == NULL) // timeout
+      {
+        switch (signal)
+        {
+        case CActiveAEControlProtocol::TIMEOUT:
+          if (RunStages())
+          {
+            m_extTimeout = 0;
+            return;
+          }
+          if (!m_extDrain && HasWork())
+          {
+            ResampleSounds();
+            ClearDiscardedBuffers();
+            m_extTimeout = 100;
+            return;
+          }
+          m_extTimeout = 0;
+          m_state = AE_TOP_CONFIGURED_IDLE;
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    default: // we are in no state, should not happen
+      CLog::Log(LOGERROR, "CActiveAE::%s - no valid state: %d", __FUNCTION__, m_state);
+      return;
+    }
+  } // for
+}
+
+void CActiveAE::Process()
+{
+  Message *msg = NULL;
+  Protocol *port = NULL;
+  bool gotMsg;
+  bool deferData;
+
+  m_state = AE_TOP_UNCONFIGURED;
+  m_extTimeout = 1000;
+  m_bStateMachineSelfTrigger = false;
+  m_extDrain = false;
+
+  // start sink
+  m_sink.Start();
+
+  while (!m_bStop)
+  {
+    gotMsg = false;
+    deferData = (m_state == AE_TOP_CONFIGURED_SUSPEND);
+
+    if (m_bStateMachineSelfTrigger)
+    {
+      m_bStateMachineSelfTrigger = false;
+      // self trigger state machine
+      StateMachine(msg->signal, port, msg);
+      if (!m_bStateMachineSelfTrigger)
+      {
+        msg->Release();
+        msg = NULL;
+      }
+      continue;
+    }
+    // check control port
+    else if (m_controlPort.ReceiveOutMessage(&msg))
+    {
+      gotMsg = true;
+      port = &m_controlPort;
+    }
+    else if (!deferData)
+    {
+      // check data port
+      if (m_dataPort.ReceiveOutMessage(&msg))
+      {
+        gotMsg = true;
+        port = &m_dataPort;
+      }
+      // check sink data port
+      else if (m_sink.m_dataPort.ReceiveInMessage(&msg))
+      {
+        gotMsg = true;
+        port = &m_sink.m_dataPort;
+      }
+      // stream data ports
+      else
+      {
+        std::list<CActiveAEStream*>::iterator it;
+        for(it=m_streams.begin(); it!=m_streams.end(); ++it)
+        {
+          if((*it)->m_streamPort->ReceiveOutMessage(&msg))
+          {
+            gotMsg = true;
+            port = &m_dataPort;
+            break;
+          }
+        }
+      }
+    }
+
+    if (gotMsg)
+    {
+      StateMachine(msg->signal, port, msg);
+      if (!m_bStateMachineSelfTrigger)
+      {
+        msg->Release();
+        msg = NULL;
+      }
+      continue;
+    }
+
+    // wait for message
+    else if (m_outMsgEvent.WaitMSec(m_extTimeout))
+    {
+      continue;
+    }
+    // time out
+    else
+    {
+      msg = m_controlPort.GetMessage();
+      msg->signal = CActiveAEControlProtocol::TIMEOUT;
+      port = 0;
+      // signal timeout to state machine
+      StateMachine(msg->signal, port, msg);
+      if (!m_bStateMachineSelfTrigger)
+      {
+        msg->Release();
+        msg = NULL;
+      }
+    }
+  }
+}
+
+void CActiveAE::Configure()
+{
+  bool initSink = false;
+  AEAudioFormat sinkInputFormat, inputFormat;
+  m_mode = MODE_PCM;
+
+  if (m_streams.empty())
+  {
+    inputFormat.m_dataFormat    = AE_FMT_FLOAT;
+    inputFormat.m_sampleRate    = 44100;
+    inputFormat.m_encodedRate   = 0;
+    inputFormat.m_channelLayout = AE_CH_LAYOUT_2_0;
+    inputFormat.m_frames        = 0;
+    inputFormat.m_frameSamples  = 0;
+    inputFormat.m_frameSize     = 0;
+    UnregisterAudioCallback();
+  }
+  else
+  {
+    inputFormat = m_streams.front()->m_format;
+  }
+
+  m_sinkRequestFormat = inputFormat;
+  ApplySettingsToFormat(m_sinkRequestFormat, m_settings);
+  std::string device = AE_IS_RAW(m_sinkRequestFormat.m_dataFormat) ? m_settings.passthoughdevice : m_settings.device;
+  std::string driver;
+  CAESinkFactory::ParseDevice(device, driver);
+  if (!m_sink.IsCompatible(m_sinkRequestFormat, device) || m_settings.driver.compare(driver) != 0)
+  {
+    InitSink();
+    m_settings.driver = driver;
+    initSink = true;
+    m_stats.Reset(m_sinkFormat.m_sampleRate);
+  }
+
+  if (m_silenceBuffers)
+  {
+    m_discardBufferPools.push_back(m_silenceBuffers);
+    m_silenceBuffers = NULL;
+  }
+
+  // buffers for driving gui sounds if no streams are active
+  if (m_streams.empty())
+  {
+    inputFormat = m_sinkFormat;
+    inputFormat.m_dataFormat = AE_FMT_FLOAT;
+    inputFormat.m_frameSize = inputFormat.m_channelLayout.Count() *
+                              (CAEUtil::DataFormatToBits(inputFormat.m_dataFormat) >> 3);
+    m_silenceBuffers = new CActiveAEBufferPool(inputFormat);
+    m_silenceBuffers->Create(MAX_WATER_LEVEL*1000);
+    sinkInputFormat = inputFormat;
+    m_internalFormat = inputFormat;
+
+    bool silence = false;
+    m_sink.m_controlPort.SendOutMessage(CSinkControlProtocol::SILENCEMODE, &silence, sizeof(bool));
+
+    if (m_encoder)
+    {
+      delete m_encoder;
+      m_encoder = NULL;
+    }
+    if (m_encoderBuffers)
+    {
+      m_discardBufferPools.push_back(m_encoderBuffers);
+      m_encoderBuffers = NULL;
+    }
+    if (m_vizBuffers)
+    {
+      m_discardBufferPools.push_back(m_vizBuffers);
+      m_vizBuffers = NULL;
+    }
+  }
+  // resample buffers for streams
+  else
+  {
+    bool silence = true;
+    m_sink.m_controlPort.SendOutMessage(CSinkControlProtocol::SILENCEMODE, &silence, sizeof(bool));
+
+    AEAudioFormat outputFormat;
+    if (AE_IS_RAW(inputFormat.m_dataFormat))
+    {
+      outputFormat = inputFormat;
+      sinkInputFormat = m_sinkFormat;
+      m_mode = MODE_RAW;
+    }
+    // transcode
+    else if (m_settings.ac3passthrough && !m_settings.multichannellpcm)
+    {
+      outputFormat = inputFormat;
+      outputFormat.m_dataFormat = AE_FMT_FLOATP;
+
+      if (g_advancedSettings.m_audioResample)
+      {
+        outputFormat.m_sampleRate = g_advancedSettings.m_audioResample;
+        CLog::Log(LOGINFO, "CActiveAE::Configure - Forcing samplerate to %d", inputFormat.m_sampleRate);
+      }
+
+      // setup encoder
+      if (!m_encoder)
+      {
+        m_encoder = new CAEEncoderFFmpeg();
+        m_encoder->Initialize(outputFormat, true);
+        m_encoderFormat = outputFormat;
+      }
+      else
+        outputFormat = m_encoderFormat;
+
+      outputFormat.m_channelLayout = m_encoderFormat.m_channelLayout;
+      outputFormat.m_frames = m_encoderFormat.m_frames;
+
+      // encoder buffer
+      if (m_encoder->GetCodecID() == CODEC_ID_AC3)
+      {
+        AEAudioFormat format;
+        format.m_channelLayout = AE_CH_LAYOUT_2_0;
+        format.m_dataFormat = AE_FMT_S16NE;
+        format.m_frameSize = 2* (CAEUtil::DataFormatToBits(format.m_dataFormat) >> 3);
+        format.m_frames = AC3_FRAME_SIZE;
+        format.m_sampleRate = 48000;
+        if (m_encoderBuffers && initSink)
+        {
+          m_discardBufferPools.push_back(m_encoderBuffers);
+          m_encoderBuffers = NULL;
+        }
+        if (!m_encoderBuffers)
+        {
+          m_encoderBuffers = new CActiveAEBufferPool(format);
+          m_encoderBuffers->Create(MAX_WATER_LEVEL*1000);
+        }
+      }
+
+      m_mode = MODE_TRANSCODE;
+      sinkInputFormat = m_sinkFormat;
+    }
+    else
+    {
+      outputFormat = m_sinkFormat;
+      outputFormat.m_channelLayout = m_sinkRequestFormat.m_channelLayout;
+      outputFormat.m_channelLayout.ResolveChannels(m_sinkFormat.m_channelLayout);
+      outputFormat.m_dataFormat = AE_FMT_FLOAT;
+      outputFormat.m_frameSize = outputFormat.m_channelLayout.Count() *
+                                 (CAEUtil::DataFormatToBits(outputFormat.m_dataFormat) >> 3);
+      // TODO: adjust to decoder
+      sinkInputFormat = outputFormat;
+    }
+    m_internalFormat = outputFormat;
+
+    std::list<CActiveAEStream*>::iterator it;
+    for(it=m_streams.begin(); it!=m_streams.end(); ++it)
+    {
+      if (!(*it)->m_inputBuffers)
+      {
+        // align input buffers with period of sink
+        (*it)->m_format.m_frames = m_sinkFormat.m_frames * ((float)(*it)->m_format.m_sampleRate / m_sinkFormat.m_sampleRate);
+
+        // create buffer pool
+        (*it)->m_inputBuffers = new CActiveAEBufferPool((*it)->m_format);
+        (*it)->m_inputBuffers->Create(MAX_CACHE_LEVEL*1000);
+      }
+      if (initSink && (*it)->m_resampleBuffers)
+      {
+        m_discardBufferPools.push_back((*it)->m_resampleBuffers);
+        (*it)->m_resampleBuffers = NULL;
+      }
+      if (!(*it)->m_resampleBuffers)
+      {
+        (*it)->m_resampleBuffers = new CActiveAEBufferPoolResample((*it)->m_inputBuffers->m_format, outputFormat);
+        (*it)->m_resampleBuffers->Create(MAX_CACHE_LEVEL*1000, false);
+      }
+      if (m_mode == MODE_TRANSCODE || m_streams.size() > 1)
+        (*it)->m_resampleBuffers->m_fillPackets = true;
+    }
+
+    // buffers for viz
+    if (!AE_IS_RAW(inputFormat.m_dataFormat))
+    {
+      if (initSink && m_vizBuffers)
+      {
+        m_discardBufferPools.push_back(m_vizBuffers);
+        m_vizBuffers = NULL;
+      }
+      if (!m_vizBuffers)
+      {
+        AEAudioFormat vizFormat = m_internalFormat;
+        vizFormat.m_channelLayout = AE_CH_LAYOUT_2_0;
+        vizFormat.m_dataFormat = AE_FMT_FLOAT;
+        m_vizBuffers = new CActiveAEBufferPoolResample(m_internalFormat, vizFormat);
+        // TODO use cache of sync + water level
+        m_vizBuffers->Create(2000, false);
+      }
+    }
+  }
+
+  // resample buffers for sink
+  if (m_sinkBuffers && !m_sink.IsCompatible(m_sinkBuffers->m_format, device))
+  {
+    m_discardBufferPools.push_back(m_sinkBuffers);
+    m_sinkBuffers = NULL;
+  }
+  if (!m_sinkBuffers)
+  {
+    m_sinkBuffers = new CActiveAEBufferPoolResample(sinkInputFormat, m_sinkFormat);
+    m_sinkBuffers->Create(MAX_WATER_LEVEL*1000, true);
+  }
+
+  // reset gui sounds
+  std::vector<CActiveAESound*>::iterator it;
+  for (it = m_sounds.begin(); it != m_sounds.end(); ++it)
+  {
+    (*it)->SetConverted(false);
+  }
+
+  ClearDiscardedBuffers();
+  m_extDrain = false;
+}
+
+CActiveAEStream* CActiveAE::CreateStream(MsgStreamNew *streamMsg)
+{
+  // we only can handle a single pass through stream
+  if (!m_streams.empty())
+  {
+    if (AE_IS_RAW(m_streams.front()->m_format.m_dataFormat) || AE_IS_RAW(streamMsg->format.m_dataFormat))
+      return NULL;
+  }
+
+  // create the stream
+  CActiveAEStream *stream;
+  stream = new CActiveAEStream(&streamMsg->format);
+  stream->m_streamPort = new CActiveAEDataProtocol("stream",
+                             &stream->m_inMsgEvent, &m_outMsgEvent);
+
+  // create buffer pool
+  stream->m_inputBuffers = NULL; // create in Configure when we know the sink format
+  stream->m_resampleBuffers = NULL; // create in Configure when we know the sink format
+  stream->m_statsLock = m_stats.GetLock();
+  stream->m_fadingSamples = 0;
+  stream->m_started = false;
+
+  if (streamMsg->options & AESTREAM_PAUSED)
+    stream->m_paused = true;
+
+  m_streams.push_back(stream);
+
+  return stream;
+}
+
+void CActiveAE::DiscardStream(CActiveAEStream *stream)
+{
+  std::list<CActiveAEStream*>::iterator it;
+  for (it=m_streams.begin(); it!=m_streams.end(); )
+  {
+    if (stream == (*it))
+    {
+      while (!(*it)->m_processingSamples.empty())
+      {
+        (*it)->m_processingSamples.front()->Return();
+        (*it)->m_processingSamples.pop_front();
+      }
+      m_discardBufferPools.push_back((*it)->m_inputBuffers);
+      m_discardBufferPools.push_back((*it)->m_resampleBuffers);
+      CLog::Log(LOGDEBUG, "CActiveAE::DiscardStream - audio stream deleted");
+      delete (*it)->m_streamPort;
+      delete (*it);
+      it = m_streams.erase(it);
+    }
+    else
+      ++it;
+  }
+
+  ClearDiscardedBuffers();
+}
+
+void CActiveAE::SFlushStream(CActiveAEStream *stream)
+{
+  while (!stream->m_processingSamples.empty())
+  {
+    stream->m_processingSamples.front()->Return();
+    stream->m_processingSamples.pop_front();
+  }
+  stream->m_resampleBuffers->Flush();
+  stream->m_streamPort->Purge();
+  stream->m_bufferedTime = 0.0;
+  stream->m_paused = true;
+}
+
+void CActiveAE::ClearDiscardedBuffers()
+{
+  std::list<CActiveAEBufferPool*>::iterator it;
+  for (it=m_discardBufferPools.begin(); it!=m_discardBufferPools.end(); ++it)
+  {
+    CActiveAEBufferPoolResample *rbuf = dynamic_cast<CActiveAEBufferPoolResample*>(*it);
+    if (rbuf)
+    {
+      rbuf->Flush();
+    }
+    // if all buffers have returned, we can delete the buffer pool
+    if ((*it)->m_allSamples.size() == (*it)->m_freeSamples.size())
+    {
+      delete (*it);
+      CLog::Log(LOGDEBUG, "CActiveAE::ClearDiscardedBuffers - buffer pool deleted");
+      m_discardBufferPools.erase(it);
+      return;
+    }
+  }
+}
+
+void CActiveAE::SStopSound(CActiveAESound *sound)
+{
+  std::list<SoundState>::iterator it;
+  for (it=m_sounds_playing.begin(); it!=m_sounds_playing.end(); ++it)
+  {
+    if (it->sound == sound)
+    {
+      m_sounds_playing.erase(it);
+      return;
+    }
+  }
+}
+
+void CActiveAE::DiscardSound(CActiveAESound *sound)
+{
+  SStopSound(sound);
+
+  std::vector<CActiveAESound*>::iterator it;
+  for (it=m_sounds.begin(); it!=m_sounds.end(); ++it)
+  {
+    if ((*it) == sound)
+    {
+      m_sounds.erase(it);
+      return;
+    }
+  }
+}
+
+float CActiveAE::CalcStreamAmplification(CActiveAEStream *stream, CSampleBuffer *buf)
+{
+  float amp = 1.0f;
+  int nb_floats = buf->pkt->nb_samples * buf->pkt->config.channels / buf->pkt->planes;
+  float tamp;
+  for(int i=0; i<buf->pkt->planes; i++)
+  {
+    tamp = stream->m_limiter.Run((float*)buf->pkt->data[i], nb_floats);
+    amp = std::min(amp, tamp);
+  }
+  return amp;
+}
+
+void CActiveAE::ApplySettingsToFormat(AEAudioFormat &format, AudioSettings &settings)
+{
+  // raw pass through
+  if (m_settings.mode != AUDIO_ANALOG && AE_IS_RAW(format.m_dataFormat))
+  {
+    if ((format.m_dataFormat == AE_FMT_AC3 && !settings.ac3passthrough) ||
+        (format.m_dataFormat == AE_FMT_TRUEHD && !settings.truehdpassthrough) ||
+        (format.m_dataFormat == AE_FMT_DTS && !settings.dtspassthrough) ||
+        (format.m_dataFormat == AE_FMT_DTSHD && !settings.dtshdpassthrough))
+    {
+      CLog::Log(LOGERROR, "CActiveAE::ApplySettingsToFormat - input audio format is wrong");
+    }
+  }
+  // transcode
+  else if (m_settings.mode != AUDIO_ANALOG && settings.ac3passthrough && !settings.multichannellpcm && !m_streams.empty())
+  {
+    format.m_dataFormat = AE_FMT_AC3;
+    format.m_sampleRate = 48000;
+  }
+  else
+  {
+    if ((format.m_channelLayout.Count() > 2) || settings.stereoupmix)
+    {
+      switch (settings.channels)
+      {
+        default:
+        case  0: format.m_channelLayout = AE_CH_LAYOUT_2_0; break;
+        case  1: format.m_channelLayout = AE_CH_LAYOUT_2_0; break;
+        case  2: format.m_channelLayout = AE_CH_LAYOUT_2_1; break;
+        case  3: format.m_channelLayout = AE_CH_LAYOUT_3_0; break;
+        case  4: format.m_channelLayout = AE_CH_LAYOUT_3_1; break;
+        case  5: format.m_channelLayout = AE_CH_LAYOUT_4_0; break;
+        case  6: format.m_channelLayout = AE_CH_LAYOUT_4_1; break;
+        case  7: format.m_channelLayout = AE_CH_LAYOUT_5_0; break;
+        case  8: format.m_channelLayout = AE_CH_LAYOUT_5_1; break;
+        case  9: format.m_channelLayout = AE_CH_LAYOUT_7_0; break;
+        case 10: format.m_channelLayout = AE_CH_LAYOUT_7_1; break;
+      }
+    }
+
+    if (g_advancedSettings.m_audioResample)
+    {
+      format.m_sampleRate = g_advancedSettings.m_audioResample;
+      CLog::Log(LOGINFO, "CActiveAE::ApplySettings - Forcing samplerate to %d", format.m_sampleRate);
+    }
+
+    // for IEC958 limit to 2 channels
+    if (m_settings.mode == AUDIO_IEC958)
+    {
+      format.m_channelLayout = AE_CH_LAYOUT_2_0;
+    }
+
+    CAEChannelInfo stdLayout = format.m_channelLayout;
+    format.m_channelLayout.ResolveChannels(stdLayout);
+  }
+}
+
+bool CActiveAE::NeedReconfigureBuffers()
+{
+  AEAudioFormat newFormat = m_sinkRequestFormat;
+  ApplySettingsToFormat(newFormat, m_settings);
+
+  if (newFormat.m_dataFormat != m_sinkRequestFormat.m_dataFormat ||
+      newFormat.m_channelLayout != m_sinkRequestFormat.m_channelLayout ||
+      newFormat.m_sampleRate != m_sinkRequestFormat.m_sampleRate)
+    return true;
+
+  return false;
+}
+
+bool CActiveAE::NeedReconfigureSink()
+{
+  AEAudioFormat newFormat = m_sinkRequestFormat;
+  ApplySettingsToFormat(newFormat, m_settings);
+
+  std::string device = AE_IS_RAW(newFormat.m_dataFormat) ? m_settings.passthoughdevice : m_settings.device;
+  std::string driver;
+  CAESinkFactory::ParseDevice(device, driver);
+  if (m_settings.driver.compare(driver) != 0)
+    return true;
+
+  if (!m_sink.IsCompatible(newFormat, device))
+    return true;
+
+  return false;
+}
+
+void CActiveAE::InitSink()
+{
+  SinkConfig config;
+  config.format = m_sinkRequestFormat;
+  config.stats = &m_stats;
+
+  // send message to sink
+  Message *reply;
+  if (m_sink.m_controlPort.SendOutMessageSync(CSinkControlProtocol::CONFIGURE,
+                                                 &reply,
+                                                 5000,
+                                                 &config, sizeof(config)))
+  {
+    bool success = reply->signal == CSinkControlProtocol::ACC ? true : false;
+    if (!success)
+    {
+      reply->Release();
+      CLog::Log(LOGERROR, "ActiveAE::%s - returned error", __FUNCTION__);
+      m_extError = true;
+      return;
+    }
+    AEAudioFormat *data;
+    data = (AEAudioFormat*)reply->data;
+    if (data)
+    {
+      m_sinkFormat = *data;
+    }
+    reply->Release();
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "ActiveAE::%s - failed to init", __FUNCTION__);
+    m_extError = true;
+    return;
+  }
+
+  m_inMsgEvent.Reset();
+}
+
+void CActiveAE::DrainSink()
+{
+  // send message to sink
+  Message *reply;
+  if (m_sink.m_dataPort.SendOutMessageSync(CSinkDataProtocol::DRAIN,
+                                                 &reply,
+                                                 2000))
+  {
+    bool success = reply->signal == CSinkDataProtocol::ACC ? true : false;
+    if (!success)
+    {
+      reply->Release();
+      CLog::Log(LOGERROR, "ActiveAE::%s - returned error on drain", __FUNCTION__);
+      m_extError = true;
+      return;
+    }
+    reply->Release();
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "ActiveAE::%s - failed to drain", __FUNCTION__);
+    m_extError = true;
+    return;
+  }
+}
+
+void CActiveAE::UnconfigureSink()
+{
+  // send message to sink
+  Message *reply;
+  if (m_sink.m_controlPort.SendOutMessageSync(CSinkControlProtocol::UNCONFIGURE,
+                                                 &reply,
+                                                 2000))
+  {
+    bool success = reply->signal == CSinkControlProtocol::ACC ? true : false;
+    if (!success)
+    {
+      CLog::Log(LOGERROR, "ActiveAE::%s - returned error", __FUNCTION__);
+      m_extError = true;
+    }
+    reply->Release();
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "ActiveAE::%s - failed to unconfigure", __FUNCTION__);
+    m_extError = true;
+  }
+
+  m_inMsgEvent.Reset();
+}
+
+
+bool CActiveAE::RunStages()
+{
+  bool busy = false;
+
+  // serve input streams
+  std::list<CActiveAEStream*>::iterator it;
+  for (it = m_streams.begin(); it != m_streams.end(); ++it)
+  {
+    if ((*it)->m_resampleBuffers && !(*it)->m_paused)
+      busy = (*it)->m_resampleBuffers->ResampleBuffers();
+    else if ((*it)->m_resampleBuffers && !(*it)->m_resampleBuffers->m_inputSamples.empty())
+    {
+      CSingleLock lock((*it)->m_streamLock);
+      (*it)->m_streamIsBuffering = false;
+    }
+
+    // provide buffers to stream
+    float time = m_stats.GetCacheTime((*it));
+    CSampleBuffer *buffer;
+    if (!(*it)->m_drain)
+    {
+      while (time < MAX_CACHE_LEVEL && !(*it)->m_inputBuffers->m_freeSamples.empty())
+      {
+        buffer = (*it)->m_inputBuffers->GetFreeBuffer();
+        (*it)->m_processingSamples.push_back(buffer);
+        (*it)->m_streamPort->SendInMessage(CActiveAEDataProtocol::STREAMBUFFER, &buffer, sizeof(CSampleBuffer*));
+        (*it)->IncFreeBuffers();
+        time += (float)buffer->pkt->max_nb_samples / buffer->pkt->config.sample_rate;
+      }
+    }
+    else
+    {
+      if ((*it)->m_inputBuffers->m_allSamples.size() == (*it)->m_inputBuffers->m_freeSamples.size())
+      {
+        (*it)->m_streamPort->SendInMessage(CActiveAEDataProtocol::STREAMDRAINED);
+        (*it)->m_drain = false;
+        (*it)->m_resampleBuffers->m_drain = false;
+        (*it)->m_started = false;
+
+        // set variables being polled via stream interface
+        CSingleLock lock((*it)->m_streamLock);
+        if ((*it)->m_streamSlave)
+        {
+          ((CActiveAEStream*)(*it)->m_streamSlave)->m_paused = false;;
+          (*it)->m_streamSlave = NULL;
+        }
+        (*it)->m_streamDrained = true;
+        (*it)->m_streamDraining = false;
+      }
+    }
+  }
+
+  if (m_stats.GetWaterLevel() < MAX_WATER_LEVEL &&
+     (m_mode != MODE_TRANSCODE || (m_encoderBuffers && !m_encoderBuffers->m_freeSamples.empty())))
+  {
+    // mix streams and sounds sounds
+    if (m_mode != MODE_RAW)
+    {
+      CSampleBuffer *out = NULL;
+      if (!m_sounds_playing.empty() && m_streams.empty())
+      {
+        if (m_silenceBuffers && !m_silenceBuffers->m_freeSamples.empty())
+        {
+          out = m_silenceBuffers->GetFreeBuffer();
+          for (int i=0; i<out->pkt->planes; i++)
+          {
+            memset(out->pkt->data[i], 0, out->pkt->linesize);
+          }
+          out->pkt->nb_samples = out->pkt->max_nb_samples;
+        }
+      }
+
+      // mix streams
+      std::list<CActiveAEStream*>::iterator it;
+
+      // if we deal with more than a single stream, all streams
+      // must provide samples for mixing
+      bool allStreamsReady = true;
+      for (it = m_streams.begin(); it != m_streams.end(); ++it)
+      {
+        if ((*it)->m_paused || !(*it)->m_started || !(*it)->m_resampleBuffers)
+          continue;
+
+        if ((*it)->m_resampleBuffers->m_outputSamples.empty())
+          allStreamsReady = false;
+      }
+
+      for (it = m_streams.begin(); it != m_streams.end() && allStreamsReady; ++it)
+      {
+        if ((*it)->m_paused || !(*it)->m_resampleBuffers)
+          continue;
+
+        if (!(*it)->m_resampleBuffers->m_outputSamples.empty())
+        {
+          (*it)->m_started = true;
+
+          if (!out)
+          {
+            out = (*it)->m_resampleBuffers->m_outputSamples.front();
+            (*it)->m_resampleBuffers->m_outputSamples.pop_front();
+
+            // volume for stream
+            float amp = (*it)->m_rgain * CalcStreamAmplification((*it), out);
+
+            int nb_floats = out->pkt->nb_samples * out->pkt->config.channels / out->pkt->planes;
+            int nb_loops = 1;
+            float fadingStep;
+
+            // fading
+            if ((*it)->m_fadingSamples == -1)
+            {
+              (*it)->m_fadingSamples = m_internalFormat.m_sampleRate * (float)(*it)->m_fadingTime / 1000.0f;
+              (*it)->m_volume = (*it)->m_fadingBase;
+            }
+            if ((*it)->m_fadingSamples > 0)
+            {
+              nb_floats = out->pkt->config.channels / out->pkt->planes;
+              nb_loops = out->pkt->nb_samples;
+              float delta = (*it)->m_fadingTarget - (*it)->m_fadingBase;
+              int samples = m_internalFormat.m_sampleRate * (float)(*it)->m_fadingTime / 1000.0f;
+              fadingStep = delta / samples;
+            }
+            for(int i=0; i<nb_loops; i++)
+            {
+              if ((*it)->m_fadingSamples > 0)
+              {
+                (*it)->m_volume += fadingStep;
+                (*it)->m_fadingSamples--;
+
+                if ((*it)->m_fadingSamples == 0)
+                {
+                  // set variables being polled via stream interface
+                  CSingleLock lock((*it)->m_streamLock);
+                  (*it)->m_streamFading = false;
+                }
+              }
+              float volume = (*it)->m_volume * amp;
+
+              for(int j=0; j<out->pkt->planes; j++)
+              {
+#ifdef __SSE__
+                CAEUtil::SSEMulArray((float*)out->pkt->data[j]+i*nb_floats, m_muted ? 0.0 : volume, nb_floats);
+#else
+                float* fbuffer = (float*) out->pkt->data[j]+i*nb_floats;
+                for (int k = 0; k < nb_floats; ++k)
+                  *fbuffer++ *= m_muted ? 0.0 : volume;
+#endif
+              }
+            }
+          }
+          else
+          {
+            CSampleBuffer *mix = NULL;
+            mix = (*it)->m_resampleBuffers->m_outputSamples.front();
+            (*it)->m_resampleBuffers->m_outputSamples.pop_front();
+
+            // volume for stream
+            float amp = (*it)->m_volume * (*it)->m_rgain * CalcStreamAmplification((*it), mix);
+
+            int nb_floats = mix->pkt->nb_samples * mix->pkt->config.channels / mix->pkt->planes;
+            int nb_loops = 1;
+            float fadingStep;
+
+            // fading
+            if ((*it)->m_fadingSamples == -1)
+            {
+              (*it)->m_fadingSamples = m_internalFormat.m_sampleRate * (float)(*it)->m_fadingTime / 1000.0f;
+              (*it)->m_volume = (*it)->m_fadingBase;
+            }
+            if ((*it)->m_fadingSamples > 0)
+            {
+              nb_floats = mix->pkt->config.channels / mix->pkt->planes;
+              nb_loops = mix->pkt->nb_samples;
+              float delta = (*it)->m_fadingTarget - (*it)->m_fadingBase;
+              int samples = m_internalFormat.m_sampleRate * (float)(*it)->m_fadingTime / 1000.0f;
+              fadingStep = delta / samples;
+            }
+            for(int i=0; i<nb_loops; i++)
+            {
+              if ((*it)->m_fadingSamples > 0)
+              {
+                (*it)->m_volume += fadingStep;
+                (*it)->m_fadingSamples--;
+
+                if ((*it)->m_fadingSamples == 0)
+                {
+                  // set variables being polled via stream interface
+                  CSingleLock lock((*it)->m_streamLock);
+                  (*it)->m_streamFading = false;
+                }
+              }
+              float volume = (*it)->m_volume * amp;
+
+              for(int j=0; j<out->pkt->planes && j<mix->pkt->planes; j++)
+              {
+                float *dst = (float*)out->pkt->data[j]+i*nb_floats;
+                float *src = (float*)mix->pkt->data[j]+i*nb_floats;
+#ifdef __SSE__
+                CAEUtil::SSEMulAddArray(dst, src, m_muted ? 0.0 : volume, nb_floats);
+#else
+                for (int k = 0; k < nb_floats; ++k)
+                  *dst++ += *src++ * m_muted ? 0.0 : volume;
+#endif
+              }
+            }
+            mix->Return();
+          }
+          busy = true;
+        }
+      }
+
+      // process output buffer, gui sounds, encode, viz
+      if (out)
+      {
+        // mix gui sounds
+        MixSounds(*(out->pkt));
+        Deamplify(*(out->pkt));
+
+        // viz
+        {
+          CSingleLock lock(m_vizLock);
+          if (m_audioCallback)
+          {
+            if (!m_vizInitialized)
+            {
+              m_audioCallback->OnInitialize(2, m_vizBuffers->m_format.m_sampleRate, 32);
+              m_vizInitialized = true;
+            }
+
+            // if viz has no free buffer, it won't return current buffer "out"
+            if (!m_vizBuffers->m_freeSamples.empty())
+            {
+              out->Acquire();
+              m_vizBuffers->m_inputSamples.push_back(out);
+            }
+            else
+              CLog::Log(LOGWARNING,"ActiveAE::%s - viz ran out of free buffers", __FUNCTION__);
+            unsigned int now = XbmcThreads::SystemClockMillis();
+            unsigned int timestamp = now + m_stats.GetDelay() * 1000;
+            m_vizBuffers->ResampleBuffers(timestamp);
+            while(!m_vizBuffers->m_outputSamples.empty())
+            {
+              CSampleBuffer *buf = m_vizBuffers->m_outputSamples.front();
+              if ((now - buf->timestamp) & 0x80000000)
+                break;
+              else
+              {
+                int submitted = 0;
+                int samples;
+                while(submitted < buf->pkt->nb_samples)
+                {
+                  samples = std::min(512, buf->pkt->nb_samples-submitted);
+                  m_audioCallback->OnAudioData((float*)(buf->pkt->data[0]+2*submitted), samples);
+                  submitted += samples;
+                }
+                buf->Return();
+                m_vizBuffers->m_outputSamples.pop_front();
+              }
+            }
+          }
+          else if (m_vizBuffers)
+            m_vizBuffers->Flush();
+        }
+
+        // encode
+        if (m_mode == MODE_TRANSCODE && m_encoder)
+        {
+          CSampleBuffer *buf = m_encoderBuffers->GetFreeBuffer();
+          int ret = m_encoder->Encode(out->pkt->data[0], out->pkt->planes*out->pkt->linesize,
+                            buf->pkt->data[0], buf->pkt->planes*buf->pkt->linesize);
+          buf->pkt->nb_samples = buf->pkt->max_nb_samples;
+          out->Return();
+          out = buf;
+        }
+
+        // update stats
+        m_stats.AddSamples(out->pkt->nb_samples, m_streams);
+        m_sinkBuffers->m_inputSamples.push_back(out);
+
+        busy = true;
+      }
+    }
+    // pass through
+    else
+    {
+      std::list<CActiveAEStream*>::iterator it;
+      CSampleBuffer *buffer;
+      for (it = m_streams.begin(); it != m_streams.end(); ++it)
+      {
+        if (!(*it)->m_resampleBuffers->m_outputSamples.empty())
+        {
+          buffer =  (*it)->m_resampleBuffers->m_outputSamples.front();
+          (*it)->m_resampleBuffers->m_outputSamples.pop_front();
+          m_stats.AddSamples(buffer->pkt->nb_samples, m_streams);
+          m_sinkBuffers->m_inputSamples.push_back(buffer);
+        }
+      }
+    }
+
+    // serve sink buffers
+    busy = m_sinkBuffers->ResampleBuffers();
+    while(!m_sinkBuffers->m_outputSamples.empty())
+    {
+      CSampleBuffer *out = NULL;
+      out = m_sinkBuffers->m_outputSamples.front();
+      m_sinkBuffers->m_outputSamples.pop_front();
+      m_sink.m_dataPort.SendOutMessage(CSinkDataProtocol::SAMPLE,
+          &out, sizeof(CSampleBuffer*));
+      busy = true;
+    }
+  }
+
+  return busy;
+}
+
+bool CActiveAE::HasWork()
+{
+  if (!m_sounds_playing.empty())
+    return true;
+  if (!m_sinkBuffers->m_inputSamples.empty())
+    return true;
+  if (!m_sinkBuffers->m_outputSamples.empty())
+    return true;
+
+  std::list<CActiveAEStream*>::iterator it;
+  for (it = m_streams.begin(); it != m_streams.end(); ++it)
+  {
+    if (!(*it)->m_resampleBuffers->m_inputSamples.empty())
+      return true;
+    if (!(*it)->m_resampleBuffers->m_outputSamples.empty())
+      return true;
+    if (!(*it)->m_processingSamples.empty())
+      return true;
+  }
+
+  return false;
+}
+
+void CActiveAE::MixSounds(CSoundPacket &dstSample)
+{
+  if (m_sounds_playing.empty())
+    return;
+
+  float volume;
+  float *out;
+  float *sample_buffer;
+  int max_samples = dstSample.nb_samples;
+
+  std::list<SoundState>::iterator it;
+  for (it = m_sounds_playing.begin(); it != m_sounds_playing.end(); )
+  {
+    if (!it->sound->IsConverted())
+      ResampleSound(it->sound);
+    int available_samples = it->sound->GetSound(false)->nb_samples - it->samples_played;
+    int mix_samples = std::min(max_samples, available_samples);
+    int start = it->samples_played *
+                m_dllAvUtil.av_get_bytes_per_sample(it->sound->GetSound(false)->config.fmt) *
+                it->sound->GetSound(false)->config.channels /
+                it->sound->GetSound(false)->planes;
+
+    for(int j=0; j<dstSample.planes; j++)
+    {
+      volume = it->sound->GetVolume();
+      out = (float*)dstSample.data[j];
+      sample_buffer = (float*)(it->sound->GetSound(false)->data[j]+start);
+      int nb_floats = mix_samples * dstSample.config.channels / dstSample.planes;
+#ifdef __SSE__
+      CAEUtil::SSEMulAddArray(out, sample_buffer, volume, nb_floats);
+#else
+      for (int k = 0; k < nb_floats; ++k)
+        *out++ += *sample_buffer++ * volume;
+#endif
+    }
+
+    it->samples_played += mix_samples;
+
+    // no more frames, so remove it from the list
+    if (it->samples_played >= it->sound->GetSound(false)->nb_samples)
+    {
+      it = m_sounds_playing.erase(it);
+      continue;
+    }
+    ++it;
+  }
+}
+
+void CActiveAE::Deamplify(CSoundPacket &dstSample)
+{
+  if (m_volume < 1.0)
+  {
+    float *buffer;
+    int nb_floats = dstSample.nb_samples * dstSample.config.channels / dstSample.planes;
+
+    for(int j=0; j<dstSample.planes; j++)
+    {
+      buffer = (float*)dstSample.data[j];
+#ifdef __SSE__
+      CAEUtil::SSEMulArray(buffer, m_muted ? 0.0 : m_volume, nb_floats);
+#else
+      float *fbuffer = buffer;
+      for (unsigned int i = 0; i < nb_floats; i++)
+        *fbuffer++ *= m_volume;
+#endif
+    }
+  }
+}
+
+//-----------------------------------------------------------------------------
+// Configuration
+//-----------------------------------------------------------------------------
+
+void CActiveAE::LoadSettings()
+{
+  m_settings.device = CSettings::Get().GetString("audiooutput.audiodevice");
+  m_settings.passthoughdevice = CSettings::Get().GetString("audiooutput.passthroughdevice");
+
+  m_settings.mode = CSettings::Get().GetInt("audiooutput.mode");
+  m_settings.channels = CSettings::Get().GetInt("audiooutput.channels");
+
+  m_settings.stereoupmix = CSettings::Get().GetBool("audiooutput.stereoupmix");
+  m_settings.ac3passthrough = CSettings::Get().GetBool("audiooutput.ac3passthrough");
+  m_settings.truehdpassthrough = CSettings::Get().GetBool("audiooutput.truehdpassthrough");
+  m_settings.dtspassthrough = CSettings::Get().GetBool("audiooutput.dtspassthrough");
+  m_settings.dtshdpassthrough = CSettings::Get().GetBool("audiooutput.dtshdpassthrough");
+  m_settings.aacpassthrough = CSettings::Get().GetBool("audiooutput.passthroughaac");
+  m_settings.multichannellpcm = CSettings::Get().GetBool("audiooutput.multichannellpcm");
+}
+
+bool CActiveAE::Initialize()
+{
+  if (!m_dllAvUtil.Load() || !m_dllAvCodec.Load() || !m_dllAvFormat.Load())
+  {
+    CLog::Log(LOGERROR,"CActiveAE::Initialize - failed to load ffmpeg libraries");
+    return false;
+  }
+  m_dllAvFormat.av_register_all();
+
+  Create();
+  Message *reply;
+  if (m_controlPort.SendOutMessageSync(CActiveAEControlProtocol::INIT,
+                                                 &reply,
+                                                 5000))
+  {
+    bool success = reply->signal == CActiveAEControlProtocol::ACC ? true : false;
+    reply->Release();
+    if (!success)
+    {
+      CLog::Log(LOGERROR, "ActiveAE::%s - returned error", __FUNCTION__);
+      Dispose();
+      return false;
+    }
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "ActiveAE::%s - failed to init", __FUNCTION__);
+    Dispose();
+    return false;
+  }
+
+  // hook into windowing for receiving display reset events
+#if defined(HAS_GLX) || defined(TARGET_DARWIN_OSX)
+  g_Windowing.Register(this);
+#endif
+
+  m_inMsgEvent.Reset();
+  return true;
+}
+
+void CActiveAE::EnumerateOutputDevices(AEDeviceList &devices, bool passthrough)
+{
+  m_sink.EnumerateOutputDevices(devices, passthrough);
+}
+
+std::string CActiveAE::GetDefaultDevice(bool passthrough)
+{
+  return m_sink.GetDefaultDevice(passthrough);
+}
+
+void CActiveAE::OnSettingsChange(const std::string& setting)
+{
+  if (setting == "audiooutput.passthroughdevice" ||
+      setting == "audiooutput.audiodevice"       ||
+      setting == "audiooutput.mode"              ||
+      setting == "audiooutput.ac3passthrough"    ||
+      setting == "audiooutput.dtspassthrough"    ||
+      setting == "audiooutput.passthroughaac"    ||
+      setting == "audiooutput.truehdpassthrough" ||
+      setting == "audiooutput.dtshdpassthrough"  ||
+      setting == "audiooutput.channels"          ||
+      setting == "audiooutput.multichannellpcm"  ||
+      setting == "audiooutput.stereoupmix")
+  {
+    m_controlPort.SendOutMessage(CActiveAEControlProtocol::RECONFIGURE);
+  }
+}
+
+bool CActiveAE::SupportsRaw()
+{
+  return true;
+}
+
+void CActiveAE::Shutdown()
+{
+  Dispose();
+}
+
+bool CActiveAE::Suspend()
+{
+  return m_controlPort.SendOutMessage(CActiveAEControlProtocol::SUSPEND);
+}
+
+bool CActiveAE::Resume()
+{
+  Message *reply;
+  if (m_controlPort.SendOutMessageSync(CActiveAEControlProtocol::INIT,
+                                                 &reply,
+                                                 5000))
+  {
+    bool success = reply->signal == CActiveAEControlProtocol::ACC ? true : false;
+    reply->Release();
+    if (!success)
+    {
+      CLog::Log(LOGERROR, "ActiveAE::%s - returned error", __FUNCTION__);
+      return false;
+    }
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "ActiveAE::%s - failed to init", __FUNCTION__);
+    return false;
+  }
+
+  m_inMsgEvent.Reset();
+  return true;
+}
+
+bool CActiveAE::IsSuspended()
+{
+  return m_stats.IsSuspended();
+}
+
+float CActiveAE::GetVolume()
+{
+  return m_aeVolume;
+}
+
+void CActiveAE::SetVolume(const float volume)
+{
+  m_aeVolume = std::max( 0.0f, std::min(1.0f, volume));
+  m_controlPort.SendOutMessage(CActiveAEControlProtocol::VOLUME, &m_aeVolume, sizeof(float));
+}
+
+void CActiveAE::SetMute(const bool enabled)
+{
+  m_aeMuted = enabled;
+  m_controlPort.SendOutMessage(CActiveAEControlProtocol::MUTE, &m_aeMuted, sizeof(bool));
+}
+
+bool CActiveAE::IsMuted()
+{
+  return m_aeMuted;
+}
+
+void CActiveAE::SetSoundMode(const int mode)
+{
+  int soundmode = mode;
+  m_controlPort.SendOutMessage(CActiveAEControlProtocol::SOUNDMODE, &soundmode, sizeof(int));
+}
+
+
+void CActiveAE::OnLostDevice()
+{
+//  m_controlPort.SendOutMessage(CActiveAEControlProtocol::DISPLAYLOST);
+}
+
+void CActiveAE::OnResetDevice()
+{
+//  m_controlPort.SendOutMessage(CActiveAEControlProtocol::DISPLAYRESET);
+}
+
+//-----------------------------------------------------------------------------
+// Utils
+//-----------------------------------------------------------------------------
+
+uint8_t **CActiveAE::AllocSoundSample(SampleConfig &config, int &samples, int &bytes_per_sample, int &planes, int &linesize)
+{
+  uint8_t **buffer;
+  planes = m_dllAvUtil.av_sample_fmt_is_planar(config.fmt) ? config.channels : 1;
+  buffer = new uint8_t*[planes];
+  m_dllAvUtil.av_samples_alloc(buffer, &linesize, config.channels,
+                                 samples, config.fmt, 0);
+  bytes_per_sample = m_dllAvUtil.av_get_bytes_per_sample(config.fmt);
+  return buffer;
+}
+
+void CActiveAE::FreeSoundSample(uint8_t **data)
+{
+  m_dllAvUtil.av_freep(data);
+  delete [] data;
+}
+
+//-----------------------------------------------------------------------------
+// GUI Sounds
+//-----------------------------------------------------------------------------
+
+/**
+ * load sound from an audio file and store original format
+ * register the sound in ActiveAE
+ * later when the engine is idle it will convert the sound to sink format
+ */
+
+#define SOUNDBUFFER_SIZE 20480
+
+IAESound *CActiveAE::MakeSound(const std::string& file)
+{
+  AVFormatContext *fmt_ctx = NULL;
+  AVCodecContext *dec_ctx = NULL;
+  AVIOContext *io_ctx;
+  AVInputFormat *io_fmt;
+  AVCodec *dec = NULL;
+  int bit_rate;
+  CActiveAESound *sound = NULL;
+  SampleConfig config;
+
+  sound = new CActiveAESound(file);
+  if (!sound->Prepare())
+    return NULL;
+  int fileSize = sound->GetFileSize();
+
+  fmt_ctx = m_dllAvFormat.avformat_alloc_context();
+  unsigned char* buffer = (unsigned char*)m_dllAvUtil.av_malloc(SOUNDBUFFER_SIZE+FF_INPUT_BUFFER_PADDING_SIZE);
+  io_ctx = m_dllAvFormat.avio_alloc_context(buffer, SOUNDBUFFER_SIZE, 0,
+                                            sound, CActiveAESound::Read, NULL, CActiveAESound::Seek);
+  io_ctx->max_packet_size = sound->GetChunkSize();
+  if(io_ctx->max_packet_size)
+    io_ctx->max_packet_size *= SOUNDBUFFER_SIZE / io_ctx->max_packet_size;
+
+  if(!sound->IsSeekPosible())
+    io_ctx->seekable = 0;
+
+  fmt_ctx->pb = io_ctx;
+
+  m_dllAvFormat.av_probe_input_buffer(io_ctx, &io_fmt, file.c_str(), NULL, 0, 0);
+  if (!io_fmt)
+  {
+    m_dllAvFormat.avformat_close_input(&fmt_ctx);
+    delete sound;
+    return NULL;
+  }
+
+  // find decoder
+  if (m_dllAvFormat.avformat_open_input(&fmt_ctx, file.c_str(), NULL, NULL) == 0)
+  {
+    fmt_ctx->flags |= AVFMT_FLAG_NOPARSE;
+    if (m_dllAvFormat.avformat_find_stream_info(fmt_ctx, NULL) >= 0)
+    {
+      dec_ctx = fmt_ctx->streams[0]->codec;
+      dec = m_dllAvCodec.avcodec_find_decoder(dec_ctx->codec_id);
+      config.sample_rate = dec_ctx->sample_rate;
+      bit_rate = dec_ctx->bit_rate;
+      config.channels = dec_ctx->channels;
+      config.channel_layout = dec_ctx->channel_layout;
+    }
+  }
+  if (dec == NULL)
+  {
+    m_dllAvFormat.avformat_close_input(&fmt_ctx);
+    delete sound;
+    return NULL;
+  }
+
+  dec_ctx = m_dllAvCodec.avcodec_alloc_context3(dec);
+  dec_ctx->sample_rate = config.sample_rate;
+  dec_ctx->channels = config.channels;
+  if (!config.channel_layout)
+    config.channel_layout = m_dllAvUtil.av_get_default_channel_layout(config.channels);
+  dec_ctx->channel_layout = config.channel_layout;
+
+  AVPacket avpkt;
+  AVFrame *decoded_frame = NULL;
+  decoded_frame = m_dllAvCodec.avcodec_alloc_frame();
+
+  if (m_dllAvCodec.avcodec_open2(dec_ctx, dec, NULL) >= 0)
+  {
+    bool init = false;
+
+    // decode until eof
+    m_dllAvCodec.av_init_packet(&avpkt);
+    int len;
+    while (m_dllAvFormat.av_read_frame(fmt_ctx, &avpkt) >= 0)
+    {
+      int got_frame = 0;
+      len = m_dllAvCodec.avcodec_decode_audio4(dec_ctx, decoded_frame, &got_frame, &avpkt);
+      if (len < 0)
+      {
+        m_dllAvCodec.avcodec_close(dec_ctx);
+        m_dllAvUtil.av_free(dec_ctx);
+        m_dllAvUtil.av_free(&decoded_frame);
+        m_dllAvFormat.avformat_close_input(&fmt_ctx);
+        delete sound;
+        return NULL;
+      }
+      if (got_frame)
+      {
+        if (!init)
+        {
+          int samples = fileSize / m_dllAvUtil.av_get_bytes_per_sample(dec_ctx->sample_fmt) / config.channels;
+          config.fmt = dec_ctx->sample_fmt;
+          sound->InitSound(true, config, samples);
+          init = true;
+        }
+        sound->StoreSound(true, decoded_frame->extended_data,
+                          decoded_frame->nb_samples, decoded_frame->linesize[0]);
+      }
+    }
+    m_dllAvCodec.avcodec_close(dec_ctx);
+  }
+
+  m_dllAvUtil.av_free(dec_ctx);
+  m_dllAvUtil.av_free(decoded_frame);
+  m_dllAvFormat.avformat_close_input(&fmt_ctx);
+
+  sound->Finish();
+
+  // register sound
+  m_dataPort.SendOutMessage(CActiveAEDataProtocol::NEWSOUND, &sound, sizeof(CActiveAESound*));
+
+  return sound;
+}
+
+void CActiveAE::FreeSound(IAESound *sound)
+{
+  m_dataPort.SendOutMessage(CActiveAEDataProtocol::FREESOUND, &sound, sizeof(CActiveAESound*));
+}
+
+void CActiveAE::PlaySound(CActiveAESound *sound)
+{
+  m_dataPort.SendOutMessage(CActiveAEDataProtocol::PLAYSOUND, &sound, sizeof(CActiveAESound*));
+}
+
+void CActiveAE::StopSound(CActiveAESound *sound)
+{
+  m_controlPort.SendOutMessage(CActiveAEControlProtocol::STOPSOUND, &sound, sizeof(CActiveAESound*));
+}
+
+/**
+ * resample sounds to destination format for mixing
+ * destination format is either format of stream or
+ * default sink format when no stream is playing
+ */
+void CActiveAE::ResampleSounds()
+{
+  std::vector<CActiveAESound*>::iterator it;
+  for (it = m_sounds.begin(); it != m_sounds.end(); ++it)
+  {
+    if (!(*it)->IsConverted())
+      ResampleSound(*it);
+  }
+}
+
+bool CActiveAE::ResampleSound(CActiveAESound *sound)
+{
+  SampleConfig orig_config, dst_config;
+  uint8_t **dst_buffer;
+  int dst_samples;
+
+  if (m_mode == MODE_RAW || m_internalFormat.m_dataFormat == AE_FMT_INVALID)
+    return false;
+
+  if (!sound->GetSound(true))
+    return false;
+
+  orig_config = sound->GetSound(true)->config;
+
+  dst_config.channel_layout = CActiveAEResample::GetAVChannelLayout(m_internalFormat.m_channelLayout);
+  dst_config.channels = m_internalFormat.m_channelLayout.Count();
+  dst_config.sample_rate = m_internalFormat.m_sampleRate;
+  dst_config.fmt = CActiveAEResample::GetAVSampleFormat(m_internalFormat.m_dataFormat);
+
+  CActiveAEResample *resampler = new CActiveAEResample();
+  resampler->Init(dst_config.channel_layout,
+                  dst_config.channels,
+                  dst_config.sample_rate,
+                  dst_config.fmt,
+                  orig_config.channel_layout,
+                  orig_config.channels,
+                  orig_config.sample_rate,
+                  orig_config.fmt,
+                  NULL);
+
+  dst_samples = resampler->CalcDstSampleCount(sound->GetSound(true)->nb_samples,
+                                              m_internalFormat.m_sampleRate,
+                                              orig_config.sample_rate);
+
+  dst_buffer = sound->InitSound(false, dst_config, dst_samples);
+  if (!dst_buffer)
+  {
+    delete resampler;
+    return false;
+  }
+  int samples = resampler->Resample(dst_buffer, dst_samples,
+                                    sound->GetSound(true)->data,
+                                    sound->GetSound(true)->nb_samples);
+
+  sound->GetSound(false)->nb_samples = samples;
+
+  delete resampler;
+  sound->SetConverted(true);
+  return true;
+}
+
+//-----------------------------------------------------------------------------
+// Streams
+//-----------------------------------------------------------------------------
+
+IAEStream *CActiveAE::MakeStream(enum AEDataFormat dataFormat, unsigned int sampleRate, unsigned int encodedSampleRate, CAEChannelInfo channelLayout, unsigned int options)
+{
+  //TODO: pass number of samples in audio packet
+
+  AEAudioFormat format;
+  format.m_dataFormat = dataFormat;
+  format.m_sampleRate = sampleRate;
+  format.m_encodedRate = encodedSampleRate;
+  format.m_channelLayout = channelLayout;
+  format.m_frames = format.m_sampleRate / 10;
+  format.m_frameSize = format.m_channelLayout.Count() *
+                       (CAEUtil::DataFormatToBits(format.m_dataFormat) >> 3);
+
+  MsgStreamNew msg;
+  msg.format = format;
+  msg.options = options;
+
+  Message *reply;
+  if (m_dataPort.SendOutMessageSync(CActiveAEDataProtocol::NEWSTREAM,
+                                    &reply,1000,
+                                    &msg, sizeof(MsgStreamNew)))
+  {
+    bool success = reply->signal == CActiveAEControlProtocol::ACC ? true : false;
+    if (success)
+    {
+      CActiveAEStream *stream = *(CActiveAEStream**)reply->data;
+      reply->Release();
+      return stream;
+    }
+    reply->Release();
+  }
+
+  CLog::Log(LOGERROR, "ActiveAE::%s - could not create stream", __FUNCTION__);
+  return NULL;
+}
+
+IAEStream *CActiveAE::FreeStream(IAEStream *stream)
+{
+  m_dataPort.SendOutMessage(CActiveAEDataProtocol::FREESTREAM, &stream, sizeof(IAEStream*));
+  return NULL;
+}
+
+void CActiveAE::FlushStream(CActiveAEStream *stream)
+{
+  Message *reply;
+  if (m_dataPort.SendOutMessageSync(CActiveAEDataProtocol::FLUSHSTREAM,
+                                       &reply,1000,
+                                       &stream, sizeof(CActiveAEStream*)))
+  {
+    bool success = reply->signal == CActiveAEDataProtocol::ACC ? true : false;
+    reply->Release();
+    if (!success)
+    {
+      CLog::Log(LOGERROR, "CActiveAE::FlushStream - failed");
+    }
+  }
+}
+
+void CActiveAE::PauseStream(CActiveAEStream *stream, bool pause)
+{
+  // TODO pause sink, needs api change
+  if (pause)
+    m_controlPort.SendOutMessage(CActiveAEControlProtocol::PAUSESTREAM,
+                                   &stream, sizeof(CActiveAEStream*));
+  else
+    m_controlPort.SendOutMessage(CActiveAEControlProtocol::RESUMESTREAM,
+                                   &stream, sizeof(CActiveAEStream*));
+}
+
+void CActiveAE::SetStreamAmplification(CActiveAEStream *stream, float amplify)
+{
+  MsgStreamParameter msg;
+  msg.stream = stream;
+  msg.parameter.float_par = amplify;
+  m_controlPort.SendOutMessage(CActiveAEControlProtocol::STREAMAMP,
+                                     &msg, sizeof(MsgStreamParameter));
+}
+
+void CActiveAE::SetStreamReplaygain(CActiveAEStream *stream, float rgain)
+{
+  MsgStreamParameter msg;
+  msg.stream = stream;
+  msg.parameter.float_par = rgain;
+  m_controlPort.SendOutMessage(CActiveAEControlProtocol::STREAMRGAIN,
+                                     &msg, sizeof(MsgStreamParameter));
+}
+
+void CActiveAE::SetStreamVolume(CActiveAEStream *stream, float volume)
+{
+  MsgStreamParameter msg;
+  msg.stream = stream;
+  msg.parameter.float_par = volume;
+  m_controlPort.SendOutMessage(CActiveAEControlProtocol::STREAMVOLUME,
+                                     &msg, sizeof(MsgStreamParameter));
+}
+
+void CActiveAE::SetStreamResampleRatio(CActiveAEStream *stream, double ratio)
+{
+  MsgStreamParameter msg;
+  msg.stream = stream;
+  msg.parameter.double_par = ratio;
+  m_controlPort.SendOutMessage(CActiveAEControlProtocol::STREAMRESAMPLERATIO,
+                                     &msg, sizeof(MsgStreamParameter));
+}
+
+void CActiveAE::SetStreamFade(CActiveAEStream *stream, float from, float target, unsigned int millis)
+{
+  MsgStreamFade msg;
+  msg.stream = stream;
+  msg.from = from;
+  msg.target = target;
+  msg.millis = millis;
+  m_controlPort.SendOutMessage(CActiveAEControlProtocol::STREAMFADE,
+                                     &msg, sizeof(MsgStreamFade));
+}
+
+void CActiveAE::RegisterAudioCallback(IAudioCallback* pCallback)
+{
+  CSingleLock lock(m_vizLock);
+  m_audioCallback = pCallback;
+  m_vizInitialized = false;
+}
+
+void CActiveAE::UnregisterAudioCallback()
+{
+  CSingleLock lock(m_vizLock);
+  m_audioCallback = NULL;
+}
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
new file mode 100644
index 0000000..30da1ac
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
@@ -0,0 +1,332 @@
+#pragma once
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+#include "threads/Thread.h"
+
+#include "ActiveAESink.h"
+#include "ActiveAEResample.h"
+#include "Interfaces/AEStream.h"
+#include "Interfaces/AESound.h"
+#include "AEFactory.h"
+#include "guilib/DispResource.h"
+
+// ffmpeg
+#include "DllAvFormat.h"
+#include "DllAvCodec.h"
+#include "DllAvUtil.h"
+
+class IAESink;
+class IAEEncoder;
+
+namespace ActiveAE
+{
+
+class CActiveAESound;
+class CActiveAEStream;
+
+struct AudioSettings
+{
+  std::string device;
+  std::string driver;
+  std::string passthoughdevice;
+  int mode;
+  int channels;
+  bool ac3passthrough;
+  bool dtspassthrough;
+  bool aacpassthrough;
+  bool truehdpassthrough;
+  bool dtshdpassthrough;
+  bool multichannellpcm;
+  bool stereoupmix;
+};
+
+class CActiveAEControlProtocol : public Protocol
+{
+public:
+  CActiveAEControlProtocol(std::string name, CEvent* inEvent, CEvent *outEvent) : Protocol(name, inEvent, outEvent) {};
+  enum OutSignal
+  {
+    INIT = 0,
+    RECONFIGURE,
+    SUSPEND,
+    MUTE,
+    VOLUME,
+    PAUSESTREAM,
+    RESUMESTREAM,
+    STREAMRGAIN,
+    STREAMVOLUME,
+    STREAMAMP,
+    STREAMRESAMPLERATIO,
+    STREAMFADE,
+    STOPSOUND,
+    SOUNDMODE,
+    GETSTATE,
+    DISPLAYLOST,
+    DISPLAYRESET,
+    TIMEOUT,
+  };
+  enum InSignal
+  {
+    ACC,
+    ERR,
+    STATS,
+  };
+};
+
+class CActiveAEDataProtocol : public Protocol
+{
+public:
+  CActiveAEDataProtocol(std::string name, CEvent* inEvent, CEvent *outEvent) : Protocol(name, inEvent, outEvent) {};
+  enum OutSignal
+  {
+    NEWSOUND = 0,
+    PLAYSOUND,
+    FREESOUND,
+    NEWSTREAM,
+    FREESTREAM,
+    STREAMSAMPLE,
+    DRAINSTREAM,
+    FLUSHSTREAM,
+  };
+  enum InSignal
+  {
+    ACC,
+    ERR,
+    STREAMBUFFER,
+    STREAMDRAINED,
+  };
+};
+
+struct MsgStreamNew
+{
+  AEAudioFormat format;
+  unsigned int options;
+};
+
+struct MsgStreamSample
+{
+  CSampleBuffer *buffer;
+  CActiveAEStream *stream;
+};
+
+struct MsgStreamParameter
+{
+  CActiveAEStream *stream;
+  union
+  {
+    float float_par;
+    double double_par;
+  } parameter;
+};
+
+struct MsgStreamFade
+{
+  CActiveAEStream *stream;
+  float from;
+  float target;
+  unsigned int millis;
+};
+
+class CEngineStats
+{
+public:
+  void Reset(unsigned int sampleRate);
+  void UpdateSinkDelay(double delay, int samples);
+  void AddSamples(int samples, std::list<CActiveAEStream*> &streams);
+  float GetDelay();
+  float GetDelay(CActiveAEStream *stream);
+  float GetCacheTime(CActiveAEStream *stream);
+  float GetCacheTotal(CActiveAEStream *stream);
+  float GetWaterLevel();
+  void SetSuspended(bool state);
+  void SetSinkCacheTotal(float time) { m_sinkCacheTotal = time; }
+  bool IsSuspended();
+  CCriticalSection *GetLock() { return &m_lock; }
+protected:
+  float m_sinkDelay;
+  float m_sinkCacheTotal;
+  int m_bufferedSamples;
+  unsigned int m_sinkSampleRate;
+  unsigned int m_sinkUpdate;
+  bool m_suspended;
+  CCriticalSection m_lock;
+};
+
+#if defined(HAS_GLX) || defined(TARGET_DARWIN_OSX)
+class CActiveAE : public IAE, public IDispResource, private CThread
+#else
+class CActiveAE : public IAE, private CThread
+#endif
+{
+protected:
+  friend class ::CAEFactory;
+  friend class CActiveAESound;
+  friend class CActiveAEStream;
+  friend class CSoundPacket;
+  friend class CActiveAEBufferPoolResample;
+  CActiveAE();
+  virtual ~CActiveAE();
+  virtual bool  Initialize();
+
+public:
+  virtual void   Shutdown();
+  virtual bool   Suspend();
+  virtual bool   Resume();
+  virtual bool   IsSuspended();
+  virtual void   OnSettingsChange(const std::string& setting);
+
+  virtual float GetVolume();
+  virtual void  SetVolume(const float volume);
+  virtual void  SetMute(const bool enabled);
+  virtual bool  IsMuted();
+  virtual void  SetSoundMode(const int mode);
+
+  /* returns a new stream for data in the specified format */
+  virtual IAEStream *MakeStream(enum AEDataFormat dataFormat, unsigned int sampleRate, unsigned int encodedSampleRate, CAEChannelInfo channelLayout, unsigned int options = 0);
+  virtual IAEStream *FreeStream(IAEStream *stream);
+
+  /* returns a new sound object */
+  virtual IAESound *MakeSound(const std::string& file);
+  virtual void      FreeSound(IAESound *sound);
+
+  virtual void GarbageCollect() {};
+
+  virtual void EnumerateOutputDevices(AEDeviceList &devices, bool passthrough);
+  virtual std::string GetDefaultDevice(bool passthrough);
+  virtual bool SupportsRaw();
+
+  virtual void RegisterAudioCallback(IAudioCallback* pCallback);
+  virtual void UnregisterAudioCallback();
+
+  virtual void OnLostDevice();
+  virtual void OnResetDevice();
+
+protected:
+  void PlaySound(CActiveAESound *sound);
+  uint8_t **AllocSoundSample(SampleConfig &config, int &samples, int &bytes_per_sample, int &planes, int &linesize);
+  void FreeSoundSample(uint8_t **data);
+  float GetDelay(CActiveAEStream *stream) { return m_stats.GetDelay(stream); }
+  float GetCacheTime(CActiveAEStream *stream) { return m_stats.GetCacheTime(stream); }
+  float GetCacheTotal(CActiveAEStream *stream) { return m_stats.GetCacheTotal(stream); }
+  void FlushStream(CActiveAEStream *stream);
+  void PauseStream(CActiveAEStream *stream, bool pause);
+  void StopSound(CActiveAESound *sound);
+  void SetStreamAmplification(CActiveAEStream *stream, float amplify);
+  void SetStreamReplaygain(CActiveAEStream *stream, float rgain);
+  void SetStreamVolume(CActiveAEStream *stream, float volume);
+  void SetStreamResampleRatio(CActiveAEStream *stream, double ratio);
+  void SetStreamFade(CActiveAEStream *stream, float from, float target, unsigned int millis);
+
+protected:
+  void Process();
+  void StateMachine(int signal, Protocol *port, Message *msg);
+  void InitSink();
+  void DrainSink();
+  void UnconfigureSink();
+  void Start();
+  void Dispose();
+  void LoadSettings();
+  bool NeedReconfigureBuffers();
+  bool NeedReconfigureSink();
+  void ApplySettingsToFormat(AEAudioFormat &format, AudioSettings &settings);
+  void Configure();
+  CActiveAEStream* CreateStream(MsgStreamNew *streamMsg);
+  void DiscardStream(CActiveAEStream *stream);
+  void SFlushStream(CActiveAEStream *stream);
+  void ClearDiscardedBuffers();
+  void SStopSound(CActiveAESound *sound);
+  void DiscardSound(CActiveAESound *sound);
+  float CalcStreamAmplification(CActiveAEStream *stream, CSampleBuffer *buf);
+
+  bool RunStages();
+  bool HasWork();
+
+  void ResampleSounds();
+  bool ResampleSound(CActiveAESound *sound);
+  void MixSounds(CSoundPacket &dstSample);
+  void Deamplify(CSoundPacket &dstSample);
+
+  CEvent m_inMsgEvent;
+  CEvent m_outMsgEvent;
+  CActiveAEControlProtocol m_controlPort;
+  CActiveAEDataProtocol m_dataPort;
+  int m_state;
+  bool m_bStateMachineSelfTrigger;
+  int m_extTimeout;
+  bool m_extError;
+  bool m_extDrain;
+  XbmcThreads::EndTime m_extDrainTimer;
+
+  enum
+  {
+    MODE_RAW,
+    MODE_TRANSCODE,
+    MODE_PCM
+  }m_mode;
+
+  CActiveAESink m_sink;
+  AEAudioFormat m_sinkFormat;
+  AEAudioFormat m_sinkRequestFormat;
+  AEAudioFormat m_encoderFormat;
+  AEAudioFormat m_internalFormat;
+  AudioSettings m_settings;
+  CEngineStats m_stats;
+  IAEEncoder *m_encoder;
+
+  // buffers
+  CActiveAEBufferPoolResample *m_sinkBuffers;
+  CActiveAEBufferPoolResample *m_vizBuffers;
+  CActiveAEBufferPool *m_silenceBuffers;  // needed to drive gui sounds if we have no streams
+  CActiveAEBufferPool *m_encoderBuffers;
+
+  // streams
+  std::list<CActiveAEStream*> m_streams;
+  std::list<CActiveAEBufferPool*> m_discardBufferPools;
+
+  // gui sounds
+  struct SoundState
+  {
+    CActiveAESound *sound;
+    int samples_played;
+  };
+  std::list<SoundState> m_sounds_playing;
+  std::vector<CActiveAESound*> m_sounds;
+  int m_soundMode;
+
+  float m_volume;
+  bool m_muted;
+
+  // viz
+  IAudioCallback *m_audioCallback;
+  bool m_vizInitialized;
+  CCriticalSection m_vizLock;
+
+  // ffmpeg
+  DllAvFormat m_dllAvFormat;
+  DllAvCodec  m_dllAvCodec;
+  DllAvUtil   m_dllAvUtil;
+
+  // polled via the interface
+  float m_aeVolume;
+  bool m_aeMuted;
+};
+};
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.cpp
new file mode 100644
index 0000000..9a5f61e
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.cpp
@@ -0,0 +1,368 @@
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "ActiveAEBuffer.h"
+#include "AEFactory.h"
+#include "ActiveAE.h"
+
+using namespace ActiveAE;
+
+/* typecast AE to CActiveAE */
+#define AE (*((CActiveAE*)CAEFactory::GetEngine()))
+
+CSoundPacket::CSoundPacket(SampleConfig conf, int samples) : config(conf)
+{
+  data = AE.AllocSoundSample(config, samples, bytes_per_sample, planes, linesize);
+  max_nb_samples = samples;
+  nb_samples = 0;
+}
+
+CSoundPacket::~CSoundPacket()
+{
+  if (data)
+    AE.FreeSoundSample(data);
+}
+
+CSampleBuffer::CSampleBuffer() : pkt(NULL), pool(NULL)
+{
+  refCount = 0;
+}
+
+CSampleBuffer::~CSampleBuffer()
+{
+  if (pkt)
+    delete pkt;
+}
+
+CSampleBuffer* CSampleBuffer::Acquire()
+{
+  refCount++;
+  return this;
+}
+
+void CSampleBuffer::Return()
+{
+  refCount--;
+  if (pool && refCount <= 0)
+    pool->ReturnBuffer(this);
+}
+
+CActiveAEBufferPool::CActiveAEBufferPool(AEAudioFormat format)
+{
+  m_format = format;
+  if (AE_IS_RAW(m_format.m_dataFormat))
+    m_format.m_dataFormat = AE_FMT_S16NE;
+}
+
+CActiveAEBufferPool::~CActiveAEBufferPool()
+{
+  CSampleBuffer *buffer;
+  while(!m_allSamples.empty())
+  {
+    buffer = m_allSamples.front();
+    m_allSamples.pop_front();
+    delete buffer;
+  }
+}
+
+CSampleBuffer* CActiveAEBufferPool::GetFreeBuffer()
+{
+  CSampleBuffer* buf = NULL;
+
+  if (!m_freeSamples.empty())
+  {
+    buf = m_freeSamples.front();
+    m_freeSamples.pop_front();
+    buf->refCount = 1;
+  }
+  return buf;
+}
+
+void CActiveAEBufferPool::ReturnBuffer(CSampleBuffer *buffer)
+{
+  buffer->pkt->nb_samples = 0;
+  m_freeSamples.push_back(buffer);
+}
+
+bool CActiveAEBufferPool::Create(unsigned int totaltime)
+{
+  CSampleBuffer *buffer;
+  SampleConfig config;
+  config.fmt = CActiveAEResample::GetAVSampleFormat(m_format.m_dataFormat);
+  config.channels = m_format.m_channelLayout.Count();
+  config.sample_rate = m_format.m_sampleRate;
+  config.channel_layout = CActiveAEResample::GetAVChannelLayout(m_format.m_channelLayout);
+
+  unsigned int time = 0;
+  unsigned int buffertime = (m_format.m_frames*1000) / m_format.m_sampleRate;
+  unsigned int n = 0;
+  while (time < totaltime || n < 5)
+  {
+    buffer = new CSampleBuffer();
+    buffer->pool = this;
+    buffer->pkt = new CSoundPacket(config, m_format.m_frames);
+
+    m_allSamples.push_back(buffer);
+    m_freeSamples.push_back(buffer);
+    time += buffertime;
+    n++;
+  }
+
+  return true;
+}
+
+//-----------------------------------------------------------------------------
+
+CActiveAEBufferPoolResample::CActiveAEBufferPoolResample(AEAudioFormat inputFormat, AEAudioFormat outputFormat)
+  : CActiveAEBufferPool(outputFormat)
+{
+  m_inputFormat = inputFormat;
+  if (AE_IS_RAW(m_inputFormat.m_dataFormat))
+    m_inputFormat.m_dataFormat = AE_FMT_S16NE;
+  m_resampler = NULL;
+  m_fillPackets = false;
+  m_drain = false;
+  m_empty = true;
+  m_procSample = NULL;
+  m_resampleRatio = 1.0;
+  m_changeRatio = false;
+}
+
+CActiveAEBufferPoolResample::~CActiveAEBufferPoolResample()
+{
+  if (m_resampler)
+    delete m_resampler;
+}
+
+bool CActiveAEBufferPoolResample::Create(unsigned int totaltime, bool remap)
+{
+  CActiveAEBufferPool::Create(totaltime);
+
+  if (m_inputFormat.m_channelLayout != m_format.m_channelLayout ||
+      m_inputFormat.m_sampleRate != m_format.m_sampleRate ||
+      m_inputFormat.m_dataFormat != m_format.m_dataFormat)
+  {
+    m_resampler = new CActiveAEResample();
+    m_resampler->Init(CActiveAEResample::GetAVChannelLayout(m_format.m_channelLayout),
+                                m_format.m_channelLayout.Count(),
+                                m_format.m_sampleRate,
+                                CActiveAEResample::GetAVSampleFormat(m_format.m_dataFormat),
+                                CActiveAEResample::GetAVChannelLayout(m_inputFormat.m_channelLayout),
+                                m_inputFormat.m_channelLayout.Count(),
+                                m_inputFormat.m_sampleRate,
+                                CActiveAEResample::GetAVSampleFormat(m_inputFormat.m_dataFormat),
+                                remap ? &m_format.m_channelLayout : NULL);
+  }
+
+  // store output sampling rate, needed when ratio gets changed
+  m_outSampleRate = m_format.m_sampleRate;
+
+  return true;
+}
+
+void CActiveAEBufferPoolResample::ChangeRatio()
+{
+//  CLog::Log(LOGNOTICE,"---------- sample rate changed from: %d, to: %d",
+//      m_outSampleRate, (int)(m_format.m_sampleRate * m_resampleRatio));
+
+  m_outSampleRate = m_format.m_sampleRate * m_resampleRatio;
+
+  if (m_resampler)
+    delete m_resampler;
+
+  m_resampler = new CActiveAEResample();
+  m_resampler->Init(CActiveAEResample::GetAVChannelLayout(m_format.m_channelLayout),
+                                m_format.m_channelLayout.Count(),
+                                m_outSampleRate,
+                                CActiveAEResample::GetAVSampleFormat(m_format.m_dataFormat),
+                                CActiveAEResample::GetAVChannelLayout(m_inputFormat.m_channelLayout),
+                                m_inputFormat.m_channelLayout.Count(),
+                                m_inputFormat.m_sampleRate,
+                                CActiveAEResample::GetAVSampleFormat(m_inputFormat.m_dataFormat),
+                                NULL);
+
+  m_changeRatio = false;
+}
+
+bool CActiveAEBufferPoolResample::ResampleBuffers(unsigned int timestamp)
+{
+  bool busy = false;
+  CSampleBuffer *in;
+
+  if (m_changeRatio)
+  {
+    if ((unsigned int)(m_format.m_sampleRate * m_resampleRatio) == m_outSampleRate)
+      m_changeRatio = false;
+  }
+
+  if (!m_resampler)
+  {
+    if (m_changeRatio)
+    {
+      ChangeRatio();
+      return true;
+    }
+    while(!m_inputSamples.empty())
+    {
+      in = m_inputSamples.front();
+      m_inputSamples.pop_front();
+      m_outputSamples.push_back(in);
+      busy = true;
+    }
+  }
+  else if (m_procSample || !m_freeSamples.empty())
+  {
+    // GetBufferedSamples is not accurate because of rounding errors
+    int out_samples = m_resampler->GetBufferedSamples();
+    int free_samples;
+    if (m_procSample)
+      free_samples = m_procSample->pkt->max_nb_samples - m_procSample->pkt->nb_samples;
+    else
+      free_samples = m_format.m_frames;
+
+    bool skipInput = false;
+    // avoid that ffmpeg resample buffer grows too large
+    if (out_samples > free_samples * 2 && !m_empty)
+      skipInput = true;
+
+    bool hasInput = !m_inputSamples.empty();
+
+    if (hasInput || skipInput || m_drain || m_changeRatio)
+    {
+      if (!m_procSample)
+      {
+        m_procSample = GetFreeBuffer();
+      }
+
+      if (hasInput && !skipInput && !m_changeRatio)
+      {
+        in = m_inputSamples.front();
+        m_inputSamples.pop_front();
+      }
+      else
+        in = NULL;
+
+      int start = m_procSample->pkt->nb_samples *
+                  m_procSample->pkt->bytes_per_sample *
+                  m_procSample->pkt->config.channels /
+                  m_procSample->pkt->planes;
+
+      for(int i=0; i<m_procSample->pkt->planes; i++)
+      {
+        m_planes[i] = m_procSample->pkt->data[i] + start;
+      }
+
+      out_samples = m_resampler->Resample(m_planes,
+                                          m_procSample->pkt->max_nb_samples - m_procSample->pkt->nb_samples,
+                                          in ? in->pkt->data : NULL,
+                                          in ? in->pkt->nb_samples : 0);
+      m_procSample->pkt->nb_samples += out_samples;
+      busy = true;
+      m_empty = (out_samples == 0);
+
+      if ((m_drain || m_changeRatio) && m_empty)
+      {
+        if (m_fillPackets && m_procSample->pkt->nb_samples != 0)
+        {
+          // pad with zero
+          start = m_procSample->pkt->nb_samples *
+                  m_procSample->pkt->bytes_per_sample *
+                  m_procSample->pkt->config.channels /
+                  m_procSample->pkt->planes;
+          for(int i=0; i<m_procSample->pkt->planes; i++)
+          {
+            memset(m_procSample->pkt->data[i]+start, 0, m_procSample->pkt->linesize-start);
+          }
+        }
+        m_procSample->timestamp = timestamp;
+
+        // check if draining is finished
+        if (m_drain && m_procSample->pkt->nb_samples == 0)
+        {
+          m_procSample->Return();
+          busy = false;
+        }
+        else
+          m_outputSamples.push_back(m_procSample);
+
+        m_procSample = NULL;
+        if (m_changeRatio)
+          ChangeRatio();
+      }
+      // some methods like encode require completely filled packets
+      else if (!m_fillPackets || (m_procSample->pkt->nb_samples == m_procSample->pkt->max_nb_samples))
+      {
+        m_procSample->timestamp = timestamp;
+        m_outputSamples.push_back(m_procSample);
+        m_procSample = NULL;
+      }
+
+      if (in)
+        in->Return();
+    }
+  }
+  return busy;
+}
+
+float CActiveAEBufferPoolResample::GetDelay()
+{
+  float delay = 0;
+  std::deque<CSampleBuffer*>::iterator itBuf;
+
+  if (m_procSample)
+    delay += m_procSample->pkt->nb_samples / m_procSample->pkt->config.sample_rate;
+
+  for(itBuf=m_inputSamples.begin(); itBuf!=m_inputSamples.end(); ++itBuf)
+  {
+    delay += (float)(*itBuf)->pkt->nb_samples / (*itBuf)->pkt->config.sample_rate;
+  }
+
+  for(itBuf=m_outputSamples.begin(); itBuf!=m_outputSamples.end(); ++itBuf)
+  {
+    delay += (float)(*itBuf)->pkt->nb_samples / (*itBuf)->pkt->config.sample_rate;
+  }
+
+  if (m_resampler)
+  {
+    int samples = m_resampler->GetBufferedSamples();
+    delay += (float)samples / m_outSampleRate;
+  }
+
+  return delay;
+}
+
+void CActiveAEBufferPoolResample::Flush()
+{
+  if (m_procSample)
+  {
+    m_procSample->Return();
+    m_procSample = NULL;
+  }
+  while (!m_inputSamples.empty())
+  {
+    m_inputSamples.front()->Return();
+    m_inputSamples.pop_front();
+  }
+  while (!m_outputSamples.empty())
+  {
+    m_outputSamples.front()->Return();
+    m_outputSamples.pop_front();
+  }
+}
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h
new file mode 100644
index 0000000..183c49e
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEBuffer.h
@@ -0,0 +1,110 @@
+#pragma once
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "DllAvUtil.h"
+#include "DllSwResample.h"
+#include "AEAudioFormat.h"
+#include <deque>
+
+namespace ActiveAE
+{
+
+struct SampleConfig
+{
+  AVSampleFormat fmt;
+  uint64_t channel_layout;
+  int channels;
+  int sample_rate;
+};
+
+/**
+ * the variables here follow ffmpeg naming
+ */
+class CSoundPacket
+{
+public:
+  CSoundPacket(SampleConfig conf, int samples);
+  ~CSoundPacket();
+  uint8_t **data;                        // array with pointers to planes of data
+  SampleConfig config;
+  AEDataFormat internal_format;          // used when carrying pass through
+  int bytes_per_sample;                  // bytes per sample and per channel
+  int linesize;                          // see ffmpeg, required for planar formats
+  int planes;                            // 1 for non planar formats, #channels for planar
+  int nb_samples;                        // number of frames used
+  int max_nb_samples;                    // max number of frames this packet can hold
+};
+
+class CActiveAEBufferPool;
+
+class CSampleBuffer
+{
+public:
+  CSampleBuffer();
+  ~CSampleBuffer();
+  CSampleBuffer *Acquire();
+  void Return();
+  CSoundPacket *pkt;
+  CActiveAEBufferPool *pool;
+  unsigned int timestamp;
+  int refCount;
+};
+
+class CActiveAEBufferPool
+{
+public:
+  CActiveAEBufferPool(AEAudioFormat format);
+  virtual ~CActiveAEBufferPool();
+  virtual bool Create(unsigned int totaltime);
+  CSampleBuffer *GetFreeBuffer();
+  void ReturnBuffer(CSampleBuffer *buffer);
+  AEAudioFormat m_format;
+  std::deque<CSampleBuffer*> m_allSamples;
+  std::deque<CSampleBuffer*> m_freeSamples;
+};
+
+class CActiveAEResample;
+
+class CActiveAEBufferPoolResample : public CActiveAEBufferPool
+{
+public:
+  CActiveAEBufferPoolResample(AEAudioFormat inputFormat, AEAudioFormat outputFormat);
+  virtual ~CActiveAEBufferPoolResample();
+  virtual bool Create(unsigned int totaltime, bool remap);
+  void ChangeRatio();
+  bool ResampleBuffers(unsigned int timestamp = 0);
+  float GetDelay();
+  void Flush();
+  AEAudioFormat m_inputFormat;
+  std::deque<CSampleBuffer*> m_inputSamples;
+  std::deque<CSampleBuffer*> m_outputSamples;
+  CSampleBuffer *m_procSample;
+  CActiveAEResample *m_resampler;
+  uint8_t *m_planes[16];
+  bool m_fillPackets;
+  bool m_drain;
+  bool m_empty;
+  bool m_changeRatio;
+  double m_resampleRatio;
+  unsigned int m_outSampleRate;
+};
+
+}
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp
new file mode 100644
index 0000000..63df59c
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.cpp
@@ -0,0 +1,251 @@
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "ActiveAEResample.h"
+
+using namespace ActiveAE;
+
+CActiveAEResample::CActiveAEResample()
+{
+  m_pContext = NULL;
+}
+
+CActiveAEResample::~CActiveAEResample()
+{
+  if (m_pContext)
+    m_dllSwResample.swr_free(&m_pContext);
+
+  m_dllAvUtil.Unload();
+  m_dllSwResample.Unload();
+}
+
+bool CActiveAEResample::Init(uint64_t dst_chan_layout, int dst_channels, int dst_rate, AVSampleFormat dst_fmt, uint64_t src_chan_layout, int src_channels, int src_rate, AVSampleFormat src_fmt, CAEChannelInfo *remapLayout)
+{
+  if (!m_dllAvUtil.Load() || !m_dllSwResample.Load())
+    return false;
+
+  m_dst_chan_layout = dst_chan_layout;
+  m_dst_channels = dst_channels;
+  m_dst_rate = dst_rate;
+  m_dst_fmt = dst_fmt;
+  m_src_chan_layout = src_chan_layout;
+  m_src_channels = src_channels;
+  m_src_rate = src_rate;
+  m_src_fmt = src_fmt;
+
+  if (m_dst_chan_layout == 0)
+    m_dst_chan_layout = m_dllAvUtil.av_get_default_channel_layout(m_dst_channels);
+  if (m_src_chan_layout == 0)
+    m_src_chan_layout = m_dllAvUtil.av_get_default_channel_layout(m_src_channels);
+
+  m_pContext = m_dllSwResample.swr_alloc_set_opts(NULL, m_dst_chan_layout, m_dst_fmt, m_dst_rate,
+                                                        m_src_chan_layout, m_src_fmt, m_src_rate,
+                                                        0, NULL);
+
+  if(!m_pContext)
+  {
+    CLog::Log(LOGERROR, "CActiveAEResample::Init - create context failed");
+    return false;
+  }
+  if (remapLayout)
+  {
+    // one-to-one mapping of channels
+    // remapLayout is the layout of the sink, if the channel is in our src layout
+    // the channel is mapped by setting coef 1.0
+    memset(m_rematrix, 0, sizeof(m_rematrix));
+    for (unsigned int out=0; out<remapLayout->Count(); out++)
+    {
+      int idx = GetAVChannelIndex((*remapLayout)[out], m_src_chan_layout);
+      if (idx >= 0)
+      {
+        m_rematrix[out][idx] = 1.0;
+      }
+    }
+
+    if (m_dllSwResample.swr_set_matrix(m_pContext, (const double*)m_rematrix, AE_CH_MAX) < 0)
+    {
+      CLog::Log(LOGERROR, "CActiveAEResample::Init - setting channel matrix failed");
+      return false;
+    }
+  }
+  if(m_dllSwResample.swr_init(m_pContext) < 0)
+  {
+    CLog::Log(LOGERROR, "CActiveAEResample::Init - init resampler failed");
+    return false;
+  }
+  return true;
+}
+
+int CActiveAEResample::Resample(uint8_t **dst_buffer, int dst_samples, uint8_t **src_buffer, int src_samples)
+{
+  int ret = m_dllSwResample.swr_convert(m_pContext, dst_buffer, dst_samples, (const uint8_t**)src_buffer, src_samples);
+  if (ret < 0)
+  {
+    CLog::Log(LOGERROR, "CActiveAEResample::Resample - resample failed");
+    return 0;
+  }
+  return ret;
+}
+
+int64_t CActiveAEResample::GetDelay(int64_t base)
+{
+  return m_dllSwResample.swr_get_delay(m_pContext, base);
+}
+
+int CActiveAEResample::GetBufferedSamples()
+{
+  return m_dllAvUtil.av_rescale_rnd(m_dllSwResample.swr_get_delay(m_pContext, m_dst_rate),
+                                    m_src_rate, m_dst_rate, AV_ROUND_UP);
+}
+
+int CActiveAEResample::CalcDstSampleCount(int src_samples, int dst_rate, int src_rate)
+{
+  return m_dllAvUtil.av_rescale_rnd(src_samples, dst_rate, src_rate, AV_ROUND_UP);
+}
+
+int CActiveAEResample::GetSrcBufferSize(int samples)
+{
+  return m_dllAvUtil.av_samples_get_buffer_size(NULL, m_src_channels, samples, m_src_fmt, 1);
+}
+
+int CActiveAEResample::GetDstBufferSize(int samples)
+{
+  return m_dllAvUtil.av_samples_get_buffer_size(NULL, m_dst_channels, samples, m_dst_fmt, 1);
+}
+
+uint64_t CActiveAEResample::GetAVChannelLayout(CAEChannelInfo &info)
+{
+  uint64_t channelLayout = 0;
+  if (info.HasChannel(AE_CH_FL))   channelLayout |= AV_CH_FRONT_LEFT;
+  if (info.HasChannel(AE_CH_FR))   channelLayout |= AV_CH_FRONT_RIGHT;
+  if (info.HasChannel(AE_CH_FC))   channelLayout |= AV_CH_FRONT_CENTER;
+  if (info.HasChannel(AE_CH_LFE))  channelLayout |= AV_CH_LOW_FREQUENCY;
+  if (info.HasChannel(AE_CH_BL))   channelLayout |= AV_CH_BACK_LEFT;
+  if (info.HasChannel(AE_CH_BR))   channelLayout |= AV_CH_BACK_RIGHT;
+  if (info.HasChannel(AE_CH_FLOC)) channelLayout |= AV_CH_FRONT_LEFT_OF_CENTER;
+  if (info.HasChannel(AE_CH_FROC)) channelLayout |= AV_CH_FRONT_RIGHT_OF_CENTER;
+  if (info.HasChannel(AE_CH_BC))   channelLayout |= AV_CH_BACK_CENTER;
+  if (info.HasChannel(AE_CH_SL))   channelLayout |= AV_CH_SIDE_LEFT;
+  if (info.HasChannel(AE_CH_SR))   channelLayout |= AV_CH_SIDE_RIGHT;
+  if (info.HasChannel(AE_CH_TC))   channelLayout |= AV_CH_TOP_CENTER;
+  if (info.HasChannel(AE_CH_TFL))  channelLayout |= AV_CH_TOP_FRONT_LEFT;
+  if (info.HasChannel(AE_CH_TFC))  channelLayout |= AV_CH_TOP_FRONT_CENTER;
+  if (info.HasChannel(AE_CH_TFR))  channelLayout |= AV_CH_TOP_FRONT_RIGHT;
+  if (info.HasChannel(AE_CH_TBL))   channelLayout |= AV_CH_TOP_BACK_LEFT;
+  if (info.HasChannel(AE_CH_TBC))   channelLayout |= AV_CH_TOP_BACK_CENTER;
+  if (info.HasChannel(AE_CH_TBR))   channelLayout |= AV_CH_TOP_BACK_RIGHT;
+
+  return channelLayout;
+}
+
+//CAEChannelInfo CActiveAEResample::GetAEChannelLayout(uint64_t layout)
+//{
+//  CAEChannelInfo channelLayout;
+//  channelLayout.Reset();
+//
+//  if (layout & AV_CH_FRONT_LEFT           ) channelLayout += AE_CH_FL  ;
+//  if (layout & AV_CH_FRONT_RIGHT          ) channelLayout += AE_CH_FR  ;
+//  if (layout & AV_CH_FRONT_CENTER         ) channelLayout += AE_CH_FC  ;
+//  if (layout & AV_CH_LOW_FREQUENCY        ) channelLayout += AE_CH_LFE ;
+//  if (layout & AV_CH_BACK_LEFT            ) channelLayout += AE_CH_BL  ;
+//  if (layout & AV_CH_BACK_RIGHT           ) channelLayout += AE_CH_BR  ;
+//  if (layout & AV_CH_FRONT_LEFT_OF_CENTER ) channelLayout += AE_CH_FLOC;
+//  if (layout & AV_CH_FRONT_RIGHT_OF_CENTER) channelLayout += AE_CH_FROC;
+//  if (layout & AV_CH_BACK_CENTER          ) channelLayout += AE_CH_BC  ;
+//  if (layout & AV_CH_SIDE_LEFT            ) channelLayout += AE_CH_SL  ;
+//  if (layout & AV_CH_SIDE_RIGHT           ) channelLayout += AE_CH_SR  ;
+//  if (layout & AV_CH_TOP_CENTER           ) channelLayout += AE_CH_TC  ;
+//  if (layout & AV_CH_TOP_FRONT_LEFT       ) channelLayout += AE_CH_TFL ;
+//  if (layout & AV_CH_TOP_FRONT_CENTER     ) channelLayout += AE_CH_TFC ;
+//  if (layout & AV_CH_TOP_FRONT_RIGHT      ) channelLayout += AE_CH_TFR ;
+//  if (layout & AV_CH_TOP_BACK_LEFT        ) channelLayout += AE_CH_BL  ;
+//  if (layout & AV_CH_TOP_BACK_CENTER      ) channelLayout += AE_CH_BC  ;
+//  if (layout & AV_CH_TOP_BACK_RIGHT       ) channelLayout += AE_CH_BR  ;
+//
+//  return channelLayout;
+//}
+
+AVSampleFormat CActiveAEResample::GetAVSampleFormat(AEDataFormat format)
+{
+  if      (format == AE_FMT_U8)     return AV_SAMPLE_FMT_U8;
+  else if (format == AE_FMT_S16NE)  return AV_SAMPLE_FMT_S16;
+  else if (format == AE_FMT_S32NE)  return AV_SAMPLE_FMT_S32;
+  else if (format == AE_FMT_FLOAT)  return AV_SAMPLE_FMT_FLT;
+  else if (format == AE_FMT_DOUBLE) return AV_SAMPLE_FMT_DBL;
+
+  else if (format == AE_FMT_U8P)     return AV_SAMPLE_FMT_U8P;
+  else if (format == AE_FMT_S16NEP)  return AV_SAMPLE_FMT_S16P;
+  else if (format == AE_FMT_S32NEP)  return AV_SAMPLE_FMT_S32P;
+  else if (format == AE_FMT_FLOATP)  return AV_SAMPLE_FMT_FLTP;
+  else if (format == AE_FMT_DOUBLEP) return AV_SAMPLE_FMT_DBLP;
+
+  CLog::Log(LOGDEBUG, "CActiveAEResample::GetAVSampleFormat - format not supported");
+  return AV_SAMPLE_FMT_FLT;
+}
+
+AEDataFormat CActiveAEResample::GetAESampleFormat(AVSampleFormat format)
+{
+  if      (format == AV_SAMPLE_FMT_U8)   return AE_FMT_U8;
+  else if (format == AV_SAMPLE_FMT_S16)  return AE_FMT_S16NE;
+  else if (format == AV_SAMPLE_FMT_S32)  return AE_FMT_S32NE;
+  else if (format == AV_SAMPLE_FMT_FLT)  return AE_FMT_FLOAT;
+  else if (format == AV_SAMPLE_FMT_DBL)  return AE_FMT_DOUBLE;
+
+  else if (format == AV_SAMPLE_FMT_U8P)   return AE_FMT_U8P;
+  else if (format == AV_SAMPLE_FMT_S16P)  return AE_FMT_S16NEP;
+  else if (format == AV_SAMPLE_FMT_S32P)  return AE_FMT_S32NEP;
+  else if (format == AV_SAMPLE_FMT_FLTP)  return AE_FMT_FLOATP;
+  else if (format == AV_SAMPLE_FMT_DBLP)  return AE_FMT_DOUBLEP;
+
+  CLog::Log(LOGERROR, "CActiveAEResample::GetAESampleFormat - format not supported");
+  return AE_FMT_INVALID;
+}
+
+uint64_t CActiveAEResample::GetAVChannel(enum AEChannel aechannel)
+{
+  switch (aechannel)
+  {
+  case AE_CH_FL:   return AV_CH_FRONT_LEFT;
+  case AE_CH_FR:   return AV_CH_FRONT_RIGHT;
+  case AE_CH_FC:   return AV_CH_FRONT_CENTER;
+  case AE_CH_LFE:  return AV_CH_LOW_FREQUENCY;
+  case AE_CH_BL:   return AV_CH_BACK_LEFT;
+  case AE_CH_BR:   return AV_CH_BACK_RIGHT;
+  case AE_CH_FLOC: return AV_CH_FRONT_LEFT_OF_CENTER;
+  case AE_CH_FROC: return AV_CH_FRONT_RIGHT_OF_CENTER;
+  case AE_CH_BC:   return AV_CH_BACK_CENTER;
+  case AE_CH_SL:   return AV_CH_SIDE_LEFT;
+  case AE_CH_SR:   return AV_CH_SIDE_RIGHT;
+  case AE_CH_TC:   return AV_CH_TOP_CENTER;
+  case AE_CH_TFL:  return AV_CH_TOP_FRONT_LEFT;
+  case AE_CH_TFC:  return AV_CH_TOP_FRONT_CENTER;
+  case AE_CH_TFR:  return AV_CH_TOP_FRONT_RIGHT;
+  case AE_CH_TBL:  return AV_CH_TOP_BACK_LEFT;
+  case AE_CH_TBC:  return AV_CH_TOP_BACK_CENTER;
+  case AE_CH_TBR:  return AV_CH_TOP_BACK_RIGHT;
+  default:
+    return 0;
+  }
+}
+
+int CActiveAEResample::GetAVChannelIndex(enum AEChannel aechannel, uint64_t layout)
+{
+  return m_dllAvUtil.av_get_channel_layout_channel_index(layout, GetAVChannel(aechannel));
+}
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h
new file mode 100644
index 0000000..fa95a1d
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResample.h
@@ -0,0 +1,61 @@
+#pragma once
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "DllAvUtil.h"
+#include "DllSwResample.h"
+#include "Utils/AEChannelInfo.h"
+#include "AEAudioFormat.h"
+#include "ActiveAEBuffer.h"
+
+namespace ActiveAE
+{
+
+class CActiveAEResample
+{
+public:
+  CActiveAEResample();
+  virtual ~CActiveAEResample();
+  bool Init(uint64_t dst_chan_layout, int dst_channels, int dst_rate, AVSampleFormat dst_fmt, uint64_t src_chan_layout, int src_channels, int src_rate, AVSampleFormat src_fmt, CAEChannelInfo *remapLayout = NULL);
+  int Resample(uint8_t **dst_buffer, int dst_samples, uint8_t **src_buffer, int src_samples);
+  int64_t GetDelay(int64_t base);
+  int GetBufferedSamples();
+  int CalcDstSampleCount(int src_samples, int dst_rate, int src_rate);
+  int GetSrcBufferSize(int samples);
+  int GetDstBufferSize(int samples);
+  static uint64_t GetAVChannelLayout(CAEChannelInfo &info);
+//  static CAEChannelInfo GetAEChannelLayout(uint64_t layout);
+  static AVSampleFormat GetAVSampleFormat(AEDataFormat format);
+  static AEDataFormat GetAESampleFormat(AVSampleFormat format);
+  static uint64_t GetAVChannel(enum AEChannel aechannel);
+  int GetAVChannelIndex(enum AEChannel aechannel, uint64_t layout);
+
+protected:
+  DllAvUtil m_dllAvUtil;
+  DllSwResample m_dllSwResample;
+  uint64_t m_src_chan_layout, m_dst_chan_layout;
+  int m_src_rate, m_dst_rate;
+  int m_src_channels, m_dst_channels;
+  AVSampleFormat m_src_fmt, m_dst_fmt;
+  SwrContext *m_pContext;
+  double m_rematrix[AE_CH_MAX][AE_CH_MAX];
+};
+
+}
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
new file mode 100644
index 0000000..252f431
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
@@ -0,0 +1,813 @@
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <sstream>
+
+#include "ActiveAESink.h"
+#include "Utils/AEUtil.h"
+#include "utils/EndianSwap.h"
+#include "ActiveAE.h"
+
+#include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
+
+using namespace ActiveAE;
+
+CActiveAESink::CActiveAESink(CEvent *inMsgEvent) :
+  CThread("AESink"),
+  m_controlPort("SinkControlPort", inMsgEvent, &m_outMsgEvent),
+  m_dataPort("SinkDataPort", inMsgEvent, &m_outMsgEvent)
+{
+  m_inMsgEvent = inMsgEvent;
+  m_sink = NULL;
+  m_stats = NULL;
+  m_convertBuffer = NULL;
+}
+
+void CActiveAESink::Start()
+{
+  if (!IsRunning())
+  {
+    Create();
+    SetPriority(THREAD_PRIORITY_ABOVE_NORMAL);
+  }
+}
+
+void CActiveAESink::Dispose()
+{
+  m_bStop = true;
+  m_outMsgEvent.Set();
+  StopThread();
+  m_controlPort.Purge();
+  m_dataPort.Purge();
+
+  if (m_sink)
+  {
+    m_sink->Drain();
+    m_sink->Deinitialize();
+    delete m_sink;
+    m_sink = NULL;
+  }
+  if (m_sampleOfSilence.pkt)
+  {
+    delete m_sampleOfSilence.pkt;
+    m_sampleOfSilence.pkt = NULL;
+  }
+
+  delete m_sampleOfNoise.pkt;
+  m_sampleOfNoise.pkt = NULL;
+
+  if (m_convertBuffer)
+  {
+    _aligned_free(m_convertBuffer);
+    m_convertBuffer = NULL;
+  }
+}
+
+bool CActiveAESink::IsCompatible(const AEAudioFormat format, const std::string &device)
+{
+  if (!m_sink)
+    return false;
+  return m_sink->IsCompatible(format, device);
+}
+
+enum SINK_STATES
+{
+  S_TOP = 0,                      // 0
+  S_TOP_UNCONFIGURED,             // 1
+  S_TOP_CONFIGURED,               // 2
+  S_TOP_CONFIGURED_SUSPEND,       // 3
+  S_TOP_CONFIGURED_IDLE,          // 4
+  S_TOP_CONFIGURED_PLAY,          // 5
+  S_TOP_CONFIGURED_SILENCE,       // 6
+  S_TOP_CONFIGURED_WARMUP,        // 7
+};
+
+int SINK_parentStates[] = {
+    -1,
+    0, //TOP_UNCONFIGURED
+    0, //TOP_CONFIGURED
+    2, //TOP_CONFIGURED_SUSPEND
+    2, //TOP_CONFIGURED_IDLE
+    2, //TOP_CONFIGURED_PLAY
+    2, //TOP_CONFIGURED_SILENCE
+    2, //TOP_CONFIGURED_WARMUP
+};
+
+void CActiveAESink::StateMachine(int signal, Protocol *port, Message *msg)
+{
+  for (int state = m_state; ; state = SINK_parentStates[state])
+  {
+    switch (state)
+    {
+    case S_TOP: // TOP
+      if (port == &m_controlPort)
+      {
+        switch (signal)
+        {
+        case CSinkControlProtocol::CONFIGURE:
+          SinkConfig *data;
+          data = (SinkConfig*)msg->data;
+          if (data)
+          {
+            m_requestedFormat = data->format;
+            m_stats = data->stats;
+          }
+          m_extError = false;
+          m_extSilence = false;
+          ReturnBuffers();
+          OpenSink();
+
+          if (!m_extError)
+          {
+            m_stats->SetSinkCacheTotal(m_sink->GetCacheTotal());
+            m_state = S_TOP_CONFIGURED_IDLE;
+            m_extTimeout = 10000;
+            msg->Reply(CSinkControlProtocol::ACC, &m_sinkFormat, sizeof(AEAudioFormat));
+          }
+          else
+          {
+            m_state = S_TOP_UNCONFIGURED;
+            msg->Reply(CSinkControlProtocol::ERR);
+          }
+          return;
+
+        case CSinkControlProtocol::UNCONFIGURE:
+          ReturnBuffers();
+          if (m_sink)
+          {
+            m_sink->Drain();
+            m_sink->Deinitialize();
+            delete m_sink;
+            m_sink = NULL;
+          }
+          m_state = S_TOP_UNCONFIGURED;
+          msg->Reply(CSinkControlProtocol::ACC);
+          return;
+
+        default:
+          break;
+        }
+      }
+      else if (port == &m_dataPort)
+      {
+        switch (signal)
+        {
+        case CSinkDataProtocol::DRAIN:
+          msg->Reply(CSinkDataProtocol::ACC);
+          m_state = S_TOP_UNCONFIGURED;
+          m_extTimeout = 0;
+          return;
+        default:
+          break;
+        }
+      }
+      {
+        std::string portName = port == NULL ? "timer" : port->portName;
+        CLog::Log(LOGWARNING, "CActiveAESink::%s - signal: %d form port: %s not handled for state: %d", __FUNCTION__, signal, portName.c_str(), m_state);
+      }
+      return;
+
+    case S_TOP_UNCONFIGURED:
+      if (port == NULL) // timeout
+      {
+        switch (signal)
+        {
+        case CSinkControlProtocol::TIMEOUT:
+          m_extTimeout = 1000;
+          return;
+        default:
+          break;
+        }
+      }
+      else if (port == &m_dataPort)
+      {
+        switch (signal)
+        {
+        case CSinkDataProtocol::SAMPLE:
+          CSampleBuffer *samples;
+          int timeout;
+          samples = *((CSampleBuffer**)msg->data);
+          timeout = 1000*samples->pkt->nb_samples/samples->pkt->config.sample_rate;
+          Sleep(timeout);
+          msg->Reply(CSinkDataProtocol::RETURNSAMPLE, &samples, sizeof(CSampleBuffer*));
+          m_extTimeout = 0;
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case S_TOP_CONFIGURED:
+      if (port == &m_controlPort)
+      {
+        switch (signal)
+        {
+        case CSinkControlProtocol::SILENCEMODE:
+          m_extSilence = *(bool*)msg->data;
+          if (g_advancedSettings.m_streamSilence)
+            m_extSilence = true;
+          if (m_extSilence)
+          {
+            m_extCycleCounter = 5;
+            m_state = S_TOP_CONFIGURED_WARMUP;
+            m_extTimeout = 0;
+          }
+          return;
+        default:
+          break;
+        }
+      }
+      else if (port == &m_dataPort)
+      {
+        switch (signal)
+        {
+        case CSinkDataProtocol::DRAIN:
+          m_sink->Drain();
+          msg->Reply(CSinkDataProtocol::ACC);
+          m_state = S_TOP_CONFIGURED_IDLE;
+          m_extTimeout = 10000;
+          return;
+        case CSinkDataProtocol::SAMPLE:
+          CSampleBuffer *samples;
+          unsigned int delay;
+          samples = *((CSampleBuffer**)msg->data);
+          delay = OutputSamples(samples);
+          msg->Reply(CSinkDataProtocol::RETURNSAMPLE, &samples, sizeof(CSampleBuffer*));
+          if (m_extError)
+          {
+            m_sink->Deinitialize();
+            delete m_sink;
+            m_sink = NULL;
+            m_state = S_TOP_CONFIGURED_SUSPEND;
+            m_extTimeout = 0;
+          }
+          else
+          {
+            m_state = S_TOP_CONFIGURED_PLAY;
+            m_extTimeout = delay / 2;
+          }
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case S_TOP_CONFIGURED_SUSPEND:
+      if (port == &m_dataPort)
+      {
+        switch (signal)
+        {
+        case CSinkDataProtocol::SAMPLE:
+          m_extError = false;
+          OpenSink();
+          OutputSamples(&m_sampleOfNoise);
+          m_state = S_TOP_CONFIGURED_PLAY;
+          m_extTimeout = 0;
+          m_bStateMachineSelfTrigger = true;
+          return;
+        case CSinkDataProtocol::DRAIN:
+          msg->Reply(CSinkDataProtocol::ACC);
+          return;
+        default:
+          break;
+        }
+      }
+      else if (port == NULL) // timeout
+      {
+        switch (signal)
+        {
+        case CSinkControlProtocol::TIMEOUT:
+          m_extTimeout = 10000;
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case S_TOP_CONFIGURED_IDLE:
+      if (port == &m_dataPort)
+      {
+        switch (signal)
+        {
+        case CSinkDataProtocol::SAMPLE:
+          OutputSamples(&m_sampleOfNoise);
+          m_state = S_TOP_CONFIGURED_PLAY;
+          m_extTimeout = 0;
+          m_bStateMachineSelfTrigger = true;
+          return;
+        default:
+          break;
+        }
+      }
+      else if (port == NULL) // timeout
+      {
+        switch (signal)
+        {
+        case CSinkControlProtocol::TIMEOUT:
+          m_sink->Deinitialize();
+          delete m_sink;
+          m_sink = NULL;
+          m_state = S_TOP_CONFIGURED_SUSPEND;
+          m_extTimeout = 10000;
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case S_TOP_CONFIGURED_PLAY:
+      if (port == NULL) // timeout
+      {
+        switch (signal)
+        {
+        case CSinkControlProtocol::TIMEOUT:
+          if (m_extSilence)
+          {
+            m_state = S_TOP_CONFIGURED_SILENCE;
+            m_extTimeout = 0;
+          }
+          else
+          {
+            m_sink->Drain();
+            m_state = S_TOP_CONFIGURED_IDLE;
+            m_extTimeout = 10000;
+          }
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case S_TOP_CONFIGURED_SILENCE:
+      if (port == NULL) // timeout
+      {
+        switch (signal)
+        {
+        case CSinkControlProtocol::TIMEOUT:
+          unsigned int delay;
+          delay = OutputSamples(&m_sampleOfSilence);
+          m_extCycleCounter--;
+          if (m_extError)
+          {
+            m_sink->Deinitialize();
+            delete m_sink;
+            m_sink = NULL;
+            m_state = S_TOP_CONFIGURED_SUSPEND;
+          }
+          else if(m_extCycleCounter <= 0)
+          {
+            m_extCycleCounter = 2;
+            m_state = S_TOP_CONFIGURED_WARMUP;
+          }
+          m_extTimeout = 0;
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case S_TOP_CONFIGURED_WARMUP:
+      if (port == NULL) // timeout
+      {
+        switch (signal)
+        {
+        case CSinkControlProtocol::TIMEOUT:
+          unsigned int delay;
+          delay = OutputSamples(&m_sampleOfNoise);
+          m_extCycleCounter--;
+          if (m_extError)
+          {
+            m_sink->Deinitialize();
+            delete m_sink;
+            m_sink = NULL;
+            m_state = S_TOP_CONFIGURED_SUSPEND;
+          }
+          else if(m_extCycleCounter <= 0)
+          {
+            m_extCycleCounter = 30;
+            m_state = S_TOP_CONFIGURED_SILENCE;
+          }
+          m_extTimeout = 0;
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    default: // we are in no state, should not happen
+      CLog::Log(LOGERROR, "CActiveSink::%s - no valid state: %d", __FUNCTION__, m_state);
+      return;
+    }
+  } // for
+}
+
+void CActiveAESink::Process()
+{
+  Message *msg = NULL;
+  Protocol *port = NULL;
+  bool gotMsg;
+
+  m_state = S_TOP_UNCONFIGURED;
+  m_extTimeout = 1000;
+  m_bStateMachineSelfTrigger = false;
+
+  while (!m_bStop)
+  {
+    gotMsg = false;
+
+    if (m_bStateMachineSelfTrigger)
+    {
+      m_bStateMachineSelfTrigger = false;
+      // self trigger state machine
+      StateMachine(msg->signal, port, msg);
+      if (!m_bStateMachineSelfTrigger)
+      {
+        msg->Release();
+        msg = NULL;
+      }
+      continue;
+    }
+    // check control port
+    else if (m_controlPort.ReceiveOutMessage(&msg))
+    {
+      gotMsg = true;
+      port = &m_controlPort;
+    }
+    // check data port
+    else if (m_dataPort.ReceiveOutMessage(&msg))
+    {
+      gotMsg = true;
+      port = &m_dataPort;
+    }
+
+    if (gotMsg)
+    {
+      StateMachine(msg->signal, port, msg);
+      if (!m_bStateMachineSelfTrigger)
+      {
+        msg->Release();
+        msg = NULL;
+      }
+      continue;
+    }
+
+    // wait for message
+    else if (m_outMsgEvent.WaitMSec(m_extTimeout))
+    {
+      continue;
+    }
+    // time out
+    else
+    {
+      msg = m_controlPort.GetMessage();
+      msg->signal = CSinkControlProtocol::TIMEOUT;
+      port = 0;
+      // signal timeout to state machine
+      StateMachine(msg->signal, port, msg);
+      if (!m_bStateMachineSelfTrigger)
+      {
+        msg->Release();
+        msg = NULL;
+      }
+    }
+  }
+}
+
+void CActiveAESink::EnumerateSinkList()
+{
+  unsigned int c_retry = 5;
+  m_sinkInfoList.clear();
+  CAESinkFactory::EnumerateEx(m_sinkInfoList);
+  while(m_sinkInfoList.size() == 0 && c_retry > 0)
+  {
+    CLog::Log(LOGNOTICE, "No Devices found - retry: %d", c_retry);
+    Sleep(2000);
+    c_retry--;
+    // retry the enumeration
+    CAESinkFactory::EnumerateEx(m_sinkInfoList, true);
+  }
+  CLog::Log(LOGNOTICE, "Found %lu Lists of Devices", m_sinkInfoList.size());
+  PrintSinks();
+}
+
+void CActiveAESink::PrintSinks()
+{
+  for (AESinkInfoList::iterator itt = m_sinkInfoList.begin(); itt != m_sinkInfoList.end(); ++itt)
+  {
+    CLog::Log(LOGNOTICE, "Enumerated %s devices:", itt->m_sinkName.c_str());
+    int count = 0;
+    for (AEDeviceInfoList::iterator itt2 = itt->m_deviceInfoList.begin(); itt2 != itt->m_deviceInfoList.end(); ++itt2)
+    {
+      CLog::Log(LOGNOTICE, "    Device %d", ++count);
+      CAEDeviceInfo& info = *itt2;
+      std::stringstream ss((std::string)info);
+      std::string line;
+      while(std::getline(ss, line, '\n'))
+        CLog::Log(LOGNOTICE, "        %s", line.c_str());
+    }
+  }
+}
+
+void CActiveAESink::EnumerateOutputDevices(AEDeviceList &devices, bool passthrough)
+{
+  for (AESinkInfoList::iterator itt = m_sinkInfoList.begin(); itt != m_sinkInfoList.end(); ++itt)
+  {
+    AESinkInfo sinkInfo = *itt;
+    for (AEDeviceInfoList::iterator itt2 = sinkInfo.m_deviceInfoList.begin(); itt2 != sinkInfo.m_deviceInfoList.end(); ++itt2)
+    {
+      CAEDeviceInfo devInfo = *itt2;
+      if (passthrough && devInfo.m_deviceType == AE_DEVTYPE_PCM)
+        continue;
+
+      std::string device = sinkInfo.m_sinkName + ":" + devInfo.m_deviceName;
+
+      std::stringstream ss;
+
+      /* add the sink name if we have more then one sink type */
+      if (m_sinkInfoList.size() > 1)
+        ss << sinkInfo.m_sinkName << ": ";
+
+      ss << devInfo.m_displayName;
+      if (!devInfo.m_displayNameExtra.empty())
+        ss << ", " << devInfo.m_displayNameExtra;
+
+      devices.push_back(AEDevice(ss.str(), device));
+    }
+  }
+}
+
+std::string CActiveAESink::GetDefaultDevice(bool passthrough)
+{
+  for (AESinkInfoList::iterator itt = m_sinkInfoList.begin(); itt != m_sinkInfoList.end(); ++itt)
+  {
+    AESinkInfo sinkInfo = *itt;
+    for (AEDeviceInfoList::iterator itt2 = sinkInfo.m_deviceInfoList.begin(); itt2 != sinkInfo.m_deviceInfoList.end(); ++itt2)
+    {
+      CAEDeviceInfo devInfo = *itt2;
+      if (passthrough && devInfo.m_deviceType == AE_DEVTYPE_PCM)
+        continue;
+
+      std::string device = sinkInfo.m_sinkName + ":" + devInfo.m_deviceName;
+      return device;
+    }
+  }
+  return "default";
+}
+
+void CActiveAESink::GetDeviceFriendlyName(std::string &device)
+{
+  m_deviceFriendlyName = "Device not found";
+  /* Match the device and find its friendly name */
+  for (AESinkInfoList::iterator itt = m_sinkInfoList.begin(); itt != m_sinkInfoList.end(); ++itt)
+  {
+    AESinkInfo sinkInfo = *itt;
+    for (AEDeviceInfoList::iterator itt2 = sinkInfo.m_deviceInfoList.begin(); itt2 != sinkInfo.m_deviceInfoList.end(); ++itt2)
+    {
+      CAEDeviceInfo& devInfo = *itt2;
+      if (devInfo.m_deviceName == device)
+      {
+        m_deviceFriendlyName = devInfo.m_displayName;
+        break;
+      }
+    }
+  }
+  return;
+}
+
+void CActiveAESink::OpenSink()
+{
+  std::string device, driver;
+  bool passthrough = AE_IS_RAW(m_requestedFormat.m_dataFormat);
+  if (passthrough)
+    device = CSettings::Get().GetString("audiooutput.passthroughdevice");
+  else
+    device = CSettings::Get().GetString("audiooutput.audiodevice");
+
+  CAESinkFactory::ParseDevice(device, driver);
+  if (driver.empty() && m_sink)
+    driver = m_sink->GetName();
+
+  std::string sinkName;
+  if (m_sink)
+  {
+    sinkName = m_sink->GetName();
+    std::transform(sinkName.begin(), sinkName.end(), sinkName.begin(), ::toupper);
+  }
+
+  if (!m_sink || sinkName != driver || !m_sink->IsCompatible(m_requestedFormat, device))
+  {
+    CLog::Log(LOGINFO, "CActiveAE::OpenSink - sink incompatible, re-starting");
+
+    if (m_sink)
+    {
+      m_sink->Drain();
+      m_sink->Deinitialize();
+      delete m_sink;
+      m_sink = NULL;
+    }
+
+    // get the display name of the device
+    GetDeviceFriendlyName(device);
+
+    // if we already have a driver, prepend it to the device string
+    if (!driver.empty())
+      device = driver + ":" + device;
+
+    // WARNING: this changes format and does not use passthrough
+    m_sinkFormat = m_requestedFormat;
+    m_sink = CAESinkFactory::Create(device, m_sinkFormat, passthrough);
+
+    if (!m_sink)
+    {
+      m_extError = true;
+      return;
+    }
+
+    CLog::Log(LOGDEBUG, "CActiveAE::OpenSink - %s Initialized:", m_sink->GetName());
+    CLog::Log(LOGDEBUG, "  Output Device : %s", m_deviceFriendlyName.c_str());
+    CLog::Log(LOGDEBUG, "  Sample Rate   : %d", m_sinkFormat.m_sampleRate);
+    CLog::Log(LOGDEBUG, "  Sample Format : %s", CAEUtil::DataFormatToStr(m_sinkFormat.m_dataFormat));
+    CLog::Log(LOGDEBUG, "  Channel Count : %d", m_sinkFormat.m_channelLayout.Count());
+    CLog::Log(LOGDEBUG, "  Channel Layout: %s", ((std::string)m_sinkFormat.m_channelLayout).c_str());
+    CLog::Log(LOGDEBUG, "  Frames        : %d", m_sinkFormat.m_frames);
+    CLog::Log(LOGDEBUG, "  Frame Samples : %d", m_sinkFormat.m_frameSamples);
+    CLog::Log(LOGDEBUG, "  Frame Size    : %d", m_sinkFormat.m_frameSize);
+  }
+  else
+    CLog::Log(LOGINFO, "CActiveAE::OpenSink - keeping old sink with : %s, %s, %dhz",
+                          CAEUtil::DataFormatToStr(m_sinkFormat.m_dataFormat),
+                          ((std::string)m_sinkFormat.m_channelLayout).c_str(),
+                          m_sinkFormat.m_sampleRate);
+
+  // init sample of silence
+  SampleConfig config;
+  config.fmt = CActiveAEResample::GetAVSampleFormat(m_sinkFormat.m_dataFormat);
+  config.channel_layout = CActiveAEResample::GetAVChannelLayout(m_sinkFormat.m_channelLayout);
+  config.channels = m_sinkFormat.m_channelLayout.Count();
+  config.sample_rate = m_sinkFormat.m_sampleRate;
+  if (m_sampleOfSilence.pkt)
+    delete m_sampleOfSilence.pkt;
+  m_sampleOfSilence.pkt = new CSoundPacket(config, m_sinkFormat.m_frames);
+  m_sampleOfSilence.pkt->nb_samples = m_sampleOfSilence.pkt->max_nb_samples;
+
+  // init sample of noise
+  delete m_sampleOfNoise.pkt;
+  m_sampleOfNoise.pkt = new CSoundPacket(config, m_sinkFormat.m_frames);
+  m_sampleOfNoise.pkt->nb_samples = m_sampleOfNoise.pkt->max_nb_samples;
+  if (!passthrough)
+    GenerateNoise();
+
+  if (m_convertBuffer)
+  {
+    _aligned_free(m_convertBuffer);
+    m_convertBuffer = NULL;
+  }
+  m_convertState = CHECK_CONVERT;
+}
+
+void CActiveAESink::ReturnBuffers()
+{
+  Message *msg = NULL;
+  CSampleBuffer *samples;
+  while (m_dataPort.ReceiveOutMessage(&msg))
+  {
+    if (msg->signal == CSinkDataProtocol::SAMPLE)
+    {
+      samples = *((CSampleBuffer**)msg->data);
+      msg->Reply(CSinkDataProtocol::RETURNSAMPLE, &samples, sizeof(CSampleBuffer*));
+    }
+  }
+}
+
+unsigned int CActiveAESink::OutputSamples(CSampleBuffer* samples)
+{
+  uint8_t *buffer = samples->pkt->data[0];
+  unsigned int frames = samples->pkt->nb_samples;
+  unsigned int maxFrames;
+  int retry = 0;
+  int written = 0;
+  double sinkDelay = 0.0;
+
+  switch(m_convertState)
+  {
+  case SKIP_CONVERT:
+    break;
+  case NEED_CONVERT:
+    buffer = Convert(samples);
+    break;
+  case NEED_BYTESWAP:
+    Endian_Swap16_buf((uint16_t *)buffer, (uint16_t *)buffer, frames * samples->pkt->config.channels);
+    break;
+  case CHECK_CONVERT:
+    ConvertInit(samples);
+    break;
+  default:
+    break;
+  }
+
+  while(frames > 0)
+  {
+    maxFrames = std::min(frames, m_sinkFormat.m_frames);
+    written = m_sink->AddPackets(buffer, maxFrames, true, true);
+    if (written == 0)
+    {
+      Sleep(500*m_sinkFormat.m_frames/m_sinkFormat.m_sampleRate);
+      retry++;
+      if (retry > 4)
+      {
+        m_extError = true;
+        CLog::Log(LOGERROR, "CActiveAESink::OutputSamples - failed");
+        return 0;
+      }
+      else
+        continue;
+    }
+    frames -= written;
+    buffer += written*m_sinkFormat.m_frameSize;
+    sinkDelay = m_sink->GetDelay();
+    m_stats->UpdateSinkDelay(sinkDelay, samples->pool ? written : 0);
+  }
+  return sinkDelay*1000;
+}
+
+void CActiveAESink::ConvertInit(CSampleBuffer* samples)
+{
+  if (CActiveAEResample::GetAESampleFormat(samples->pkt->config.fmt) != m_sinkFormat.m_dataFormat)
+  {
+    m_convertFn = CAEConvert::FrFloat(m_sinkFormat.m_dataFormat);
+    if (m_convertBuffer)
+      _aligned_free(m_convertBuffer);
+    m_convertBuffer = (uint8_t*)_aligned_malloc(m_sinkFormat.m_frames * m_sinkFormat.m_channelLayout.Count() * m_sinkFormat.m_frameSize, 16);
+    memset(m_convertBuffer, 0, m_sinkFormat.m_frames * m_sinkFormat.m_channelLayout.Count() * m_sinkFormat.m_frameSize);
+    m_convertState = NEED_CONVERT;
+  }
+  else if (AE_IS_RAW(m_requestedFormat.m_dataFormat) && CAEUtil::S16NeedsByteSwap(AE_FMT_S16NE, m_sinkFormat.m_dataFormat))
+  {
+    m_convertState = NEED_BYTESWAP;
+  }
+  else
+    m_convertState = SKIP_CONVERT;
+}
+
+uint8_t* CActiveAESink::Convert(CSampleBuffer* samples)
+{
+  unsigned int nb_samples = m_convertFn((float*)samples->pkt->data[0], samples->pkt->nb_samples * samples->pkt->config.channels, m_convertBuffer);
+  return m_convertBuffer;
+}
+
+#define PI 3.1415926536f
+
+void CActiveAESink::GenerateNoise()
+{
+  int nb_floats = m_sinkFormat.m_frames*m_sinkFormat.m_channelLayout.Count();
+  float *noise = new float[nb_floats];
+
+  float R1, R2;
+  for(int i=0; i<nb_floats;i++)
+  {
+    do
+    {
+      R1 = (float) rand() / (float) RAND_MAX;
+      R2 = (float) rand() / (float) RAND_MAX;
+    }
+    while(R1 == 0.0f);
+    
+    noise[i] = (float) sqrt( -2.0f * log( R1 )) * cos( 2.0f * PI * R2 ) * 0.00001;
+  }
+
+  if (m_sinkFormat.m_dataFormat != AE_FMT_FLOAT)
+  {
+    CAEConvert::AEConvertFrFn convertFn = CAEConvert::FrFloat(m_sinkFormat.m_dataFormat);
+    convertFn(noise, nb_floats, m_sampleOfNoise.pkt->data[0]);
+  }
+  else
+  {
+    memcpy(m_sampleOfNoise.pkt->data[0], noise, nb_floats*sizeof(float));
+  }
+  delete [] noise;
+}
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h
new file mode 100644
index 0000000..ae19f38
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h
@@ -0,0 +1,133 @@
+#pragma once
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "threads/Event.h"
+#include "threads/Thread.h"
+#include "utils/ActorProtocol.h"
+#include "Interfaces/AE.h"
+#include "Interfaces/AESink.h"
+#include "AESinkFactory.h"
+#include "ActiveAEResample.h"
+#include "Utils/AEConvert.h"
+
+namespace ActiveAE
+{
+using namespace Actor;
+
+class CEngineStats;
+
+struct SinkConfig
+{
+  AEAudioFormat format;
+  CEngineStats *stats;
+};
+
+class CSinkControlProtocol : public Protocol
+{
+public:
+  CSinkControlProtocol(std::string name, CEvent* inEvent, CEvent *outEvent) : Protocol(name, inEvent, outEvent) {};
+  enum OutSignal
+  {
+    CONFIGURE,
+    UNCONFIGURE,
+    SILENCEMODE,
+    TIMEOUT,
+  };
+  enum InSignal
+  {
+    ACC,
+    ERR,
+    STATS,
+  };
+};
+
+class CSinkDataProtocol : public Protocol
+{
+public:
+  CSinkDataProtocol(std::string name, CEvent* inEvent, CEvent *outEvent) : Protocol(name, inEvent, outEvent) {};
+  enum OutSignal
+  {
+    SAMPLE = 0,
+    DRAIN,
+  };
+  enum InSignal
+  {
+    RETURNSAMPLE,
+    ACC,
+  };
+};
+
+class CActiveAESink : private CThread
+{
+public:
+  CActiveAESink(CEvent *inMsgEvent);
+  void EnumerateSinkList();
+  void EnumerateOutputDevices(AEDeviceList &devices, bool passthrough);
+  std::string GetDefaultDevice(bool passthrough);
+  void Start();
+  void Dispose();
+  bool IsCompatible(const AEAudioFormat format, const std::string &device);
+  CSinkControlProtocol m_controlPort;
+  CSinkDataProtocol m_dataPort;
+
+protected:
+  void Process();
+  void StateMachine(int signal, Protocol *port, Message *msg);
+  void PrintSinks();
+  void GetDeviceFriendlyName(std::string &device);
+  void OpenSink();
+  void ReturnBuffers();
+
+  unsigned int OutputSamples(CSampleBuffer* samples);
+  void ConvertInit(CSampleBuffer* samples);
+  inline uint8_t* Convert(CSampleBuffer* samples);
+
+  void GenerateNoise();
+
+  CEvent m_outMsgEvent;
+  CEvent *m_inMsgEvent;
+  int m_state;
+  bool m_bStateMachineSelfTrigger;
+  int m_extTimeout;
+  bool m_extError;
+  bool m_extSilence;
+  int m_extCycleCounter;
+
+  CSampleBuffer m_sampleOfSilence;
+  CSampleBuffer m_sampleOfNoise;
+  uint8_t *m_convertBuffer;
+  CAEConvert::AEConvertFrFn m_convertFn;
+  enum
+  {
+    CHECK_CONVERT,
+    NEED_CONVERT,
+    NEED_BYTESWAP,
+    SKIP_CONVERT,
+  } m_convertState;
+
+  std::string m_deviceFriendlyName;
+  AESinkInfoList m_sinkInfoList;
+  IAESink *m_sink;
+  AEAudioFormat m_sinkFormat, m_requestedFormat;
+  CEngineStats *m_stats;
+};
+
+}
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.cpp
new file mode 100644
index 0000000..3d79761
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.cpp
@@ -0,0 +1,164 @@
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "Interfaces/AESound.h"
+
+#include "AEFactory.h"
+#include "AEAudioFormat.h"
+#include "ActiveAE.h"
+#include "ActiveAESound.h"
+#include "utils/log.h"
+#include "DllAvUtil.h"
+
+using namespace ActiveAE;
+using namespace XFILE;
+
+/* typecast AE to CActiveAE */
+#define AE (*((CActiveAE*)CAEFactory::GetEngine()))
+
+CActiveAESound::CActiveAESound(const std::string &filename) :
+  IAESound         (filename),
+  m_filename       (filename),
+  m_volume         (1.0f    )
+{
+  m_orig_sound = NULL;
+  m_dst_sound = NULL;
+  m_pFile = NULL;
+}
+
+CActiveAESound::~CActiveAESound()
+{
+  if (m_orig_sound)
+    delete m_orig_sound;
+  if (m_dst_sound)
+    delete m_dst_sound;
+  Finish();
+}
+
+void CActiveAESound::Play()
+{
+  AE.PlaySound(this);
+}
+
+void CActiveAESound::Stop()
+{
+  AE.StopSound(this);
+}
+
+bool CActiveAESound::IsPlaying()
+{
+  // TODO
+  return false;
+}
+
+uint8_t** CActiveAESound::InitSound(bool orig, SampleConfig config, int nb_samples)
+{
+  CSoundPacket **info;
+  if (orig)
+    info = &m_orig_sound;
+  else
+    info = &m_dst_sound;
+
+  if (*info)
+    delete *info;
+  *info = new CSoundPacket(config, nb_samples);
+
+  (*info)->nb_samples = 0;
+  m_isConverted = false;
+  return (*info)->data;
+}
+
+bool CActiveAESound::StoreSound(bool orig, uint8_t **buffer, int samples, int linesize)
+{
+  CSoundPacket **info;
+  if (orig)
+    info = &m_orig_sound;
+  else
+    info = &m_dst_sound;
+
+  if ((*info)->nb_samples + samples > (*info)->max_nb_samples)
+  {
+    CLog::Log(LOGERROR, "CActiveAESound::StoreSound - exceeded max samples");
+    return false;
+  }
+
+  int bytes_to_copy = samples * (*info)->bytes_per_sample * (*info)->config.channels;
+  bytes_to_copy /= (*info)->planes;
+  int start = (*info)->nb_samples * (*info)->bytes_per_sample * (*info)->config.channels;
+  start /= (*info)->planes;
+
+  for (int i=0; i<(*info)->planes; i++)
+  {
+    memcpy((*info)->data[i]+start, buffer[i], bytes_to_copy);
+  }
+  (*info)->nb_samples += samples;
+
+  return true;
+}
+
+CSoundPacket *CActiveAESound::GetSound(bool orig)
+{
+  if (orig)
+    return m_orig_sound;
+  else
+    return m_dst_sound;
+}
+
+bool CActiveAESound::Prepare()
+{
+  unsigned int flags = READ_TRUNCATED | READ_CHUNKED;
+  m_pFile = new CFile();
+
+  if (!m_pFile->Open(m_filename, flags))
+  {
+    delete m_pFile;
+    m_pFile = NULL;
+    return false;
+  }
+  m_isSeekPosible = m_pFile->IoControl(IOCTRL_SEEK_POSSIBLE, NULL) != 0;
+  m_fileSize = m_pFile->GetLength();
+  return true;
+}
+
+void CActiveAESound::Finish()
+{
+  delete m_pFile;
+  m_pFile = NULL;
+}
+
+int CActiveAESound::GetChunkSize()
+{
+  return m_pFile->GetChunkSize();
+}
+
+int CActiveAESound::Read(void *h, uint8_t* buf, int size)
+{
+  CFile *pFile = static_cast<CActiveAESound*>(h)->m_pFile;
+  return pFile->Read(buf, size);
+}
+
+offset_t CActiveAESound::Seek(void *h, offset_t pos, int whence)
+{
+  CFile* pFile = static_cast<CActiveAESound*>(h)->m_pFile;
+  if(whence == AVSEEK_SIZE)
+    return pFile->GetLength();
+  else
+    return pFile->Seek(pos, whence & ~AVSEEK_FORCE);
+}
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.h
new file mode 100644
index 0000000..7cdf76c
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESound.h
@@ -0,0 +1,73 @@
+#pragma once
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "utils/StdString.h"
+#include "Interfaces/AESound.h"
+#include "ActiveAEResample.h"
+#include "filesystem/File.h"
+
+class DllAvUtil;
+
+namespace ActiveAE
+{
+
+class CActiveAESound : public IAESound
+{
+public:
+  CActiveAESound (const std::string &filename);
+  virtual ~CActiveAESound();
+
+  virtual void Play();
+  virtual void Stop();
+  virtual bool IsPlaying();
+
+  virtual void SetVolume(float volume) { m_volume = std::max(0.0f, std::min(1.0f, volume)); }
+  virtual float GetVolume() { return m_volume; }
+
+  uint8_t** InitSound(bool orig, SampleConfig config, int nb_samples);
+  bool StoreSound(bool orig, uint8_t **buffer, int samples, int linesize);
+  CSoundPacket *GetSound(bool orig);
+
+  bool IsConverted() { return m_isConverted; }
+  void SetConverted(bool state) { m_isConverted = state; }
+
+  bool Prepare();
+  void Finish();
+  int GetChunkSize();
+  int GetFileSize() { return m_fileSize; }
+  bool IsSeekPosible() { return m_isSeekPosible; }
+
+  static int Read(void *h, uint8_t* buf, int size);
+  static offset_t Seek(void *h, offset_t pos, int whence);
+
+protected:
+  std::string m_filename;
+  XFILE::CFile *m_pFile;
+  bool m_isSeekPosible;
+  int m_fileSize;
+  float m_volume;
+
+  CSoundPacket *m_orig_sound;
+  CSoundPacket *m_dst_sound;
+
+  bool m_isConverted;
+};
+}
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
new file mode 100644
index 0000000..e21b9d5
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.cpp
@@ -0,0 +1,357 @@
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "system.h"
+#include "threads/SingleLock.h"
+#include "utils/log.h"
+#include "utils/MathUtils.h"
+
+#include "AEFactory.h"
+#include "Utils/AEUtil.h"
+
+#include "ActiveAE.h"
+#include "ActiveAEStream.h"
+
+using namespace ActiveAE;
+
+/* typecast AE to CActiveAE */
+#define AE (*((CActiveAE*)CAEFactory::GetEngine()))
+
+
+CActiveAEStream::CActiveAEStream(AEAudioFormat *format)
+{
+  m_format = *format;
+  m_bufferedTime = 0;
+  m_currentBuffer = NULL;
+  m_drain = false;
+  m_paused = false;
+  m_rgain = 1.0;
+  m_volume = 1.0;
+  m_streamSpace = m_format.m_frameSize * m_format.m_frames;
+  m_streamDraining = false;
+  m_streamDrained = false;
+  m_streamFading = false;
+  m_streamFreeBuffers = 0;
+  m_streamIsBuffering = true;
+  m_streamSlave = NULL;
+}
+
+CActiveAEStream::~CActiveAEStream()
+{
+}
+
+void CActiveAEStream::IncFreeBuffers()
+{
+  CSingleLock lock(m_streamLock);
+  m_streamFreeBuffers++;
+}
+
+void CActiveAEStream::DecFreeBuffers()
+{
+  CSingleLock lock(m_streamLock);
+  m_streamFreeBuffers--;
+}
+
+void CActiveAEStream::ResetFreeBuffers()
+{
+  CSingleLock lock(m_streamLock);
+  m_streamFreeBuffers = 0;
+}
+
+unsigned int CActiveAEStream::GetSpace()
+{
+  CSingleLock lock(m_streamLock);
+  return m_streamFreeBuffers * m_streamSpace;
+}
+
+unsigned int CActiveAEStream::AddData(void *data, unsigned int size)
+{
+  Message *msg;
+  unsigned int copied = 0;
+  int bytesToCopy = size;
+  while(copied < size)
+  {
+    if (m_currentBuffer)
+    {
+      int start = m_currentBuffer->pkt->nb_samples *
+                  m_currentBuffer->pkt->bytes_per_sample *
+                  m_currentBuffer->pkt->config.channels /
+                  m_currentBuffer->pkt->planes;
+
+      int freeSamples = m_currentBuffer->pkt->max_nb_samples - m_currentBuffer->pkt->nb_samples;
+      int space =  freeSamples * m_format.m_frameSize;
+      int bytes = std::min(bytesToCopy, space);
+      int samples = bytes / m_currentBuffer->pkt->bytes_per_sample / m_currentBuffer->pkt->config.channels;
+      //TODO: handle planar formats
+      memcpy(m_currentBuffer->pkt->data[0] + start, (uint8_t*)data+copied, bytes);
+      {
+        CSingleLock lock(*m_statsLock);
+        m_currentBuffer->pkt->nb_samples += samples;
+        m_bufferedTime += (double)samples / m_currentBuffer->pkt->config.sample_rate;
+      }
+      copied += bytes;
+      bytesToCopy -= bytes;
+      if (m_currentBuffer->pkt->nb_samples == m_currentBuffer->pkt->max_nb_samples)
+      {
+        MsgStreamSample msgData;
+        msgData.buffer = m_currentBuffer;
+        msgData.stream = this;
+        m_streamPort->SendOutMessage(CActiveAEDataProtocol::STREAMSAMPLE, &msgData, sizeof(MsgStreamSample));
+        m_currentBuffer = NULL;
+      }
+      continue;
+    }
+    else if (m_streamPort->ReceiveInMessage(&msg))
+    {
+      if (msg->signal == CActiveAEDataProtocol::STREAMBUFFER)
+      {
+        m_currentBuffer = *((CSampleBuffer**)msg->data);
+        msg->Release();
+        DecFreeBuffers();
+        continue;
+      }
+      else
+      {
+        CLog::Log(LOGERROR, "CActiveAEStream::AddData - unknown signal");
+        msg->Release();
+        break;
+      }
+    }
+    if (!m_inMsgEvent.WaitMSec(200))
+      break;
+  }
+  return copied;
+}
+
+double CActiveAEStream::GetDelay()
+{
+  return AE.GetDelay(this);
+}
+
+bool CActiveAEStream::IsBuffering()
+{
+  CSingleLock lock(m_streamLock);
+  return m_streamIsBuffering;
+}
+
+double CActiveAEStream::GetCacheTime()
+{
+  return AE.GetCacheTime(this);
+}
+
+double CActiveAEStream::GetCacheTotal()
+{
+  return AE.GetCacheTotal(this);
+}
+
+void CActiveAEStream::Pause()
+{
+  AE.PauseStream(this, true);
+}
+
+void CActiveAEStream::Resume()
+{
+  AE.PauseStream(this, false);
+}
+
+void CActiveAEStream::Drain(bool wait)
+{
+  Message *msg;
+  CActiveAEStream *stream = this;
+
+  m_streamDraining = true;
+  m_streamDrained = false;
+
+  Message *reply;
+  if (m_streamPort->SendOutMessageSync(CActiveAEDataProtocol::DRAINSTREAM,
+                                       &reply,2000,
+                                       &stream, sizeof(CActiveAEStream*)))
+  {
+    bool success = reply->signal == CActiveAEDataProtocol::ACC ? true : false;
+    reply->Release();
+    if (!success)
+    {
+      CLog::Log(LOGERROR, "CActiveAEStream::Drain - no acc");
+    }
+  }
+
+  if (m_currentBuffer)
+  {
+    MsgStreamSample msgData;
+    msgData.buffer = m_currentBuffer;
+    msgData.stream = this;
+    m_streamPort->SendOutMessage(CActiveAEDataProtocol::STREAMSAMPLE, &msgData, sizeof(MsgStreamSample));
+    m_currentBuffer = NULL;
+  }
+
+  XbmcThreads::EndTime timer(2000);
+  while (!timer.IsTimePast())
+  {
+    if (m_streamPort->ReceiveInMessage(&msg))
+    {
+      if (msg->signal == CActiveAEDataProtocol::STREAMBUFFER)
+      {
+        MsgStreamSample msgData;
+        msgData.stream = this;
+        msgData.buffer = *((CSampleBuffer**)msg->data);
+        msg->Reply(CActiveAEDataProtocol::STREAMSAMPLE, &msgData, sizeof(MsgStreamSample));
+        DecFreeBuffers();
+        continue;
+      }
+      else if (msg->signal == CActiveAEDataProtocol::STREAMDRAINED)
+      {
+        msg->Release();
+        return;
+      }
+    }
+    else if (!wait)
+      return;
+
+    m_inMsgEvent.WaitMSec(timer.MillisLeft());
+  }
+  CLog::Log(LOGERROR, "CActiveAEStream::Drain - timeout out");
+}
+
+bool CActiveAEStream::IsDraining()
+{
+  CSingleLock lock(m_streamLock);
+  return m_streamDraining;
+}
+
+bool CActiveAEStream::IsDrained()
+{
+  CSingleLock lock(m_streamLock);
+  return m_streamDrained;
+}
+
+void CActiveAEStream::Flush()
+{
+  if (m_currentBuffer)
+  {
+    MsgStreamSample msgData;
+    m_currentBuffer->pkt->nb_samples = 0;
+    msgData.buffer = m_currentBuffer;
+    msgData.stream = this;
+    m_streamPort->SendOutMessage(CActiveAEDataProtocol::STREAMSAMPLE, &msgData, sizeof(MsgStreamSample));
+    m_currentBuffer = NULL;
+  }
+  AE.FlushStream(this);
+  ResetFreeBuffers();
+}
+
+float CActiveAEStream::GetAmplification()
+{
+  return m_streamAmplify;
+}
+
+void CActiveAEStream::SetAmplification(float amplify)
+{
+  m_streamAmplify = amplify;
+  AE.SetStreamAmplification(this, m_streamAmplify);
+}
+
+float CActiveAEStream::GetReplayGain()
+{
+  return m_streamRgain;
+}
+
+void CActiveAEStream::SetReplayGain(float factor)
+{
+  m_streamRgain = std::max( 0.0f, factor);
+  AE.SetStreamReplaygain(this, m_streamRgain);
+}
+
+float CActiveAEStream::GetVolume()
+{
+  return m_streamVolume;
+}
+
+void CActiveAEStream::SetVolume(float volume)
+{
+  m_streamVolume = std::max( 0.0f, std::min(1.0f, volume));
+  AE.SetStreamVolume(this, m_streamVolume);
+}
+
+double CActiveAEStream::GetResampleRatio()
+{
+  return m_streamResampleRatio;
+}
+
+bool CActiveAEStream::SetResampleRatio(double ratio)
+{
+  m_streamResampleRatio = ratio;
+  AE.SetStreamResampleRatio(this, m_streamResampleRatio);
+  return true;
+}
+
+void CActiveAEStream::FadeVolume(float from, float target, unsigned int time)
+{
+  if (time == 0)
+    return;
+
+  m_streamFading = true;
+  AE.SetStreamFade(this, from, target, time);
+}
+
+bool CActiveAEStream::IsFading()
+{
+  CSingleLock lock(m_streamLock);
+  return m_streamFading;
+}
+
+const unsigned int CActiveAEStream::GetFrameSize() const
+{
+  return m_format.m_frameSize;
+}
+
+const unsigned int CActiveAEStream::GetChannelCount() const
+{
+  return m_format.m_channelLayout.Count();
+}
+
+const unsigned int CActiveAEStream::GetSampleRate() const
+{
+  return m_format.m_sampleRate;
+}
+
+const unsigned int CActiveAEStream::GetEncodedSampleRate() const
+{
+  return m_format.m_encodedRate;
+}
+
+const enum AEDataFormat CActiveAEStream::GetDataFormat() const
+{
+  return m_format.m_dataFormat;
+}
+
+void CActiveAEStream::RegisterAudioCallback(IAudioCallback* pCallback)
+{
+}
+
+void CActiveAEStream::UnRegisterAudioCallback()
+{
+}
+
+void CActiveAEStream::RegisterSlave(IAEStream *slave)
+{
+  CSingleLock lock(m_streamLock);
+  m_streamSlave = slave;
+}
+
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h
new file mode 100644
index 0000000..b18d0f5
--- /dev/null
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEStream.h
@@ -0,0 +1,115 @@
+#pragma once
+/*
+ *      Copyright (C) 2010-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "AEAudioFormat.h"
+#include "Interfaces/AEStream.h"
+#include "Utils/AELimiter.h"
+
+namespace ActiveAE
+{
+
+class CActiveAEStream : public IAEStream
+{
+protected:
+  friend class CActiveAE;
+  friend class CEngineStats;
+  CActiveAEStream(AEAudioFormat *format);
+  virtual ~CActiveAEStream();
+  void FadingFinished();
+  void IncFreeBuffers();
+  void DecFreeBuffers();
+  void ResetFreeBuffers();
+
+public:
+  virtual unsigned int GetSpace();
+  virtual unsigned int AddData(void *data, unsigned int size);
+  virtual double GetDelay();
+  virtual bool IsBuffering();
+  virtual double GetCacheTime();
+  virtual double GetCacheTotal();
+
+  virtual void Pause();
+  virtual void Resume();
+  virtual void Drain(bool wait);
+  virtual bool IsDraining();
+  virtual bool IsDrained();
+  virtual void Flush();
+
+  virtual float GetVolume();
+  virtual float GetReplayGain();
+  virtual float GetAmplification();
+  virtual void SetVolume(float volume);
+  virtual void SetReplayGain(float factor);
+  virtual void SetAmplification(float amplify);
+
+  virtual const unsigned int GetFrameSize() const;
+  virtual const unsigned int GetChannelCount() const;
+  
+  virtual const unsigned int GetSampleRate() const ;
+  virtual const unsigned int GetEncodedSampleRate() const;
+  virtual const enum AEDataFormat GetDataFormat() const;
+  
+  virtual double GetResampleRatio();
+  virtual bool SetResampleRatio(double ratio);
+  virtual void RegisterAudioCallback(IAudioCallback* pCallback);
+  virtual void UnRegisterAudioCallback();
+  virtual void FadeVolume(float from, float to, unsigned int time);
+  virtual bool IsFading();
+  virtual void RegisterSlave(IAEStream *stream);
+
+protected:
+
+  AEAudioFormat m_format;
+  float m_streamVolume;
+  float m_streamRgain;
+  float m_streamAmplify;
+  double m_streamResampleRatio;
+  unsigned int m_streamSpace;
+  bool m_streamDraining;
+  bool m_streamDrained;
+  bool m_streamFading;
+  int m_streamFreeBuffers;
+  bool m_streamIsBuffering;
+  IAEStream *m_streamSlave;
+  CCriticalSection m_streamLock;
+
+  // only accessed by engine
+  CActiveAEBufferPool *m_inputBuffers;
+  CActiveAEBufferPoolResample *m_resampleBuffers;
+  std::deque<CSampleBuffer*> m_processingSamples;
+  CSampleBuffer *m_currentBuffer;
+  CActiveAEDataProtocol *m_streamPort;
+  CEvent m_inMsgEvent;
+  CCriticalSection *m_statsLock;
+  bool m_drain;
+  bool m_paused;
+  bool m_started;
+  CAELimiter m_limiter;
+  float m_volume;
+  float m_rgain;
+  float m_bufferedTime;
+  int m_fadingSamples;
+  float m_fadingBase;
+  float m_fadingTarget;
+  int m_fadingTime;
+};
+}
+
diff --git a/xbmc/cores/AudioEngine/Makefile.in b/xbmc/cores/AudioEngine/Makefile.in
index 833dfab..2e1a83d 100644
--- a/xbmc/cores/AudioEngine/Makefile.in
+++ b/xbmc/cores/AudioEngine/Makefile.in
@@ -43,6 +43,13 @@ SRCS += Engines/SoftAE/SoftAE.cpp
 SRCS += Engines/SoftAE/SoftAEStream.cpp
 SRCS += Engines/SoftAE/SoftAESound.cpp
 
+SRCS += Engines/ActiveAE/ActiveAE.cpp
+SRCS += Engines/ActiveAE/ActiveAESink.cpp
+SRCS += Engines/ActiveAE/ActiveAEStream.cpp
+SRCS += Engines/ActiveAE/ActiveAESound.cpp
+SRCS += Engines/ActiveAE/ActiveAEResample.cpp
+SRCS += Engines/ActiveAE/ActiveAEBuffer.cpp
+
 ifeq (@USE_ANDROID@,1)
 SRCS += Sinks/AESinkAUDIOTRACK.cpp
 else
diff --git a/xbmc/utils/ActorProtocol.cpp b/xbmc/utils/ActorProtocol.cpp
new file mode 100644
index 0000000..cf4c26f
--- /dev/null
+++ b/xbmc/utils/ActorProtocol.cpp
@@ -0,0 +1,253 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "ActorProtocol.h"
+
+using namespace Actor;
+
+void Message::Release()
+{
+  bool skip;
+  origin->Lock();
+  skip = isSync ? !isSyncFini : false;
+  isSyncFini = true;
+  origin->Unlock();
+
+  if (skip)
+    return;
+
+  // free data buffer
+  if (data != buffer)
+    delete [] data;
+
+  // delete event in case of sync message
+  if (event)
+    delete event;
+
+  origin->ReturnMessage(this);
+}
+
+bool Message::Reply(int sig, void *data /* = NULL*/, int size /* = 0 */)
+{
+  if (!isSync)
+  {
+    if (isOut)
+      return origin->SendInMessage(sig, data, size);
+    else
+      return origin->SendOutMessage(sig, data, size);
+  }
+
+  origin->Lock();
+
+  if (!isSyncTimeout)
+  {
+    Message *msg = origin->GetMessage();
+    msg->signal = sig;
+    msg->isOut = !isOut;
+    replyMessage = msg;
+    if (data)
+    {
+      if (size > MSG_INTERNAL_BUFFER_SIZE)
+        msg->data = new uint8_t[size];
+      else
+        msg->data = msg->buffer;
+      memcpy(msg->data, data, size);
+    }
+  }
+
+  origin->Unlock();
+
+  if (event)
+    event->Set();
+
+  return true;
+}
+
+Protocol::~Protocol()
+{
+  Message *msg;
+  Purge();
+  while (!freeMessageQueue.empty())
+  {
+    msg = freeMessageQueue.front();
+    freeMessageQueue.pop();
+    delete msg;
+  }
+}
+
+Message *Protocol::GetMessage()
+{
+  Message *msg;
+
+  CSingleLock lock(criticalSection);
+
+  if (!freeMessageQueue.empty())
+  {
+    msg = freeMessageQueue.front();
+    freeMessageQueue.pop();
+  }
+  else
+    msg = new Message();
+
+  msg->isSync = false;
+  msg->isSyncFini = false;
+  msg->isSyncTimeout = false;
+  msg->event = NULL;
+  msg->data = NULL;
+  msg->payloadSize = 0;
+  msg->replyMessage = NULL;
+  msg->origin = this;
+
+  return msg;
+}
+
+void Protocol::ReturnMessage(Message *msg)
+{
+  CSingleLock lock(criticalSection);
+
+  freeMessageQueue.push(msg);
+}
+
+bool Protocol::SendOutMessage(int signal, void *data /* = NULL */, int size /* = 0 */, Message *outMsg /* = NULL */)
+{
+  Message *msg;
+  if (outMsg)
+    msg = outMsg;
+  else
+    msg = GetMessage();
+
+  msg->signal = signal;
+  msg->isOut = true;
+
+  if (data)
+  {
+    if (size > MSG_INTERNAL_BUFFER_SIZE)
+      msg->data = new uint8_t[size];
+    else
+      msg->data = msg->buffer;
+    memcpy(msg->data, data, size);
+  }
+
+  { CSingleLock lock(criticalSection);
+    outMessages.push(msg);
+  }
+  containerOutEvent->Set();
+
+  return true;
+}
+
+bool Protocol::SendInMessage(int signal, void *data /* = NULL */, int size /* = 0 */, Message *outMsg /* = NULL */)
+{
+  Message *msg;
+  if (outMsg)
+    msg = outMsg;
+  else
+    msg = GetMessage();
+
+  msg->signal = signal;
+  msg->isOut = false;
+
+  if (data)
+  {
+    if (size > MSG_INTERNAL_BUFFER_SIZE)
+      msg->data = new uint8_t[size];
+    else
+      msg->data = msg->buffer;
+    memcpy(msg->data, data, size);
+  }
+
+  { CSingleLock lock(criticalSection);
+    inMessages.push(msg);
+  }
+  containerInEvent->Set();
+
+  return true;
+}
+
+
+bool Protocol::SendOutMessageSync(int signal, Message **retMsg, int timeout, void *data /* = NULL */, int size /* = 0 */)
+{
+  Message *msg = GetMessage();
+  msg->isOut = true;
+  msg->isSync = true;
+  msg->event = new CEvent;
+  msg->event->Reset();
+  SendOutMessage(signal, data, size, msg);
+
+  if (!msg->event->WaitMSec(timeout))
+  {
+    msg->origin->Lock();
+    if (msg->replyMessage)
+      *retMsg = msg->replyMessage;
+    else
+    {
+      *retMsg = NULL;
+      msg->isSyncTimeout = true;
+    }
+    msg->origin->Unlock();
+  }
+  else
+    *retMsg = msg->replyMessage;
+
+  msg->Release();
+
+  if (*retMsg)
+    return true;
+  else
+    return false;
+}
+
+bool Protocol::ReceiveOutMessage(Message **msg)
+{
+  CSingleLock lock(criticalSection);
+
+  if (outMessages.empty() || outDefered)
+    return false;
+
+  *msg = outMessages.front();
+  outMessages.pop();
+
+  return true;
+}
+
+bool Protocol::ReceiveInMessage(Message **msg)
+{
+  CSingleLock lock(criticalSection);
+
+  if (inMessages.empty() || inDefered)
+    return false;
+
+  *msg = inMessages.front();
+  inMessages.pop();
+
+  return true;
+}
+
+
+void Protocol::Purge()
+{
+  Message *msg;
+
+  while (ReceiveInMessage(&msg))
+    msg->Release();
+
+  while (ReceiveOutMessage(&msg))
+    msg->Release();
+}
diff --git a/xbmc/utils/ActorProtocol.h b/xbmc/utils/ActorProtocol.h
new file mode 100644
index 0000000..8ef3359
--- /dev/null
+++ b/xbmc/utils/ActorProtocol.h
@@ -0,0 +1,87 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#pragma once
+
+#include "threads/Thread.h"
+#include "utils/log.h"
+#include <queue>
+#include "memory.h"
+
+#define MSG_INTERNAL_BUFFER_SIZE 32
+
+namespace Actor
+{
+
+class Protocol;
+
+class Message
+{
+  friend class Protocol;
+public:
+  int signal;
+  bool isSync;
+  bool isSyncFini;
+  bool isOut;
+  bool isSyncTimeout;
+  int payloadSize;
+  uint8_t buffer[MSG_INTERNAL_BUFFER_SIZE];
+  uint8_t *data;
+  Message *replyMessage;
+  Protocol *origin;
+  CEvent *event;
+
+  void Release();
+  bool Reply(int sig, void *data = NULL, int size = 0);
+
+private:
+  Message() {isSync = false; data = NULL; event = NULL; replyMessage = NULL;};
+};
+
+class Protocol
+{
+public:
+  Protocol(std::string name, CEvent* inEvent, CEvent *outEvent)
+    : portName(name), inDefered(false), outDefered(false) {containerInEvent = inEvent; containerOutEvent = outEvent;};
+  virtual ~Protocol();
+  Message *GetMessage();
+  void ReturnMessage(Message *msg);
+  bool SendOutMessage(int signal, void *data = NULL, int size = 0, Message *outMsg = NULL);
+  bool SendInMessage(int signal, void *data = NULL, int size = 0, Message *outMsg = NULL);
+  bool SendOutMessageSync(int signal, Message **retMsg, int timeout, void *data = NULL, int size = 0);
+  bool ReceiveOutMessage(Message **msg);
+  bool ReceiveInMessage(Message **msg);
+  void Purge();
+  void DeferIn(bool value) {inDefered = value;};
+  void DeferOut(bool value) {outDefered = value;};
+  void Lock() {criticalSection.lock();};
+  void Unlock() {criticalSection.unlock();};
+  std::string portName;
+
+protected:
+  CEvent *containerInEvent, *containerOutEvent;
+  CCriticalSection criticalSection;
+  std::queue<Message*> outMessages;
+  std::queue<Message*> inMessages;
+  std::queue<Message*> freeMessageQueue;
+  bool inDefered, outDefered;
+};
+
+}
diff --git a/xbmc/utils/Makefile.in b/xbmc/utils/Makefile.in
index 694a9bd..ca49be2 100644
--- a/xbmc/utils/Makefile.in
+++ b/xbmc/utils/Makefile.in
@@ -70,6 +70,7 @@ SRCS += Vector.cpp
 SRCS += Weather.cpp
 SRCS += XBMCTinyXML.cpp
 SRCS += XMLUtils.cpp
+SRCS += ActorProtocol.cpp 
 
 ifeq (@USE_OPENGLES@,1)
 SRCS += AMLUtils.cpp
-- 
1.8.1.6


From 5e22d771079269b28d443a869cf9024bf7cfb9c0 Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Sat, 8 Jun 2013 09:39:38 +0200
Subject: [PATCH 013/123] ActiveAE: Make Factory aware of environment, change
 global namespace

---
 xbmc/cores/AudioEngine/AEFactory.cpp | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/AudioEngine/AEFactory.cpp b/xbmc/cores/AudioEngine/AEFactory.cpp
index 4f9f566..5adda5f 100644
--- a/xbmc/cores/AudioEngine/AEFactory.cpp
+++ b/xbmc/cores/AudioEngine/AEFactory.cpp
@@ -28,7 +28,6 @@
 #else
   #include "Engines/SoftAE/SoftAE.h"
   #include "Engines/ActiveAE/ActiveAE.h"
-  using namespace ActiveAE;
 #endif
 
 #if defined(HAS_PULSEAUDIO)
@@ -69,6 +68,8 @@ bool CAEFactory::LoadEngine()
     #endif
     if (!loaded && engine == "SOFT" )
       loaded = CAEFactory::LoadEngine(AE_ENGINE_SOFT);
+    if (!loaded && engine == "ACTIVE")
+      loaded = CAEFactory::LoadEngine(AE_ENGINE_ACTIVE);
   }
 #endif
 
@@ -101,7 +102,7 @@ bool CAEFactory::LoadEngine(enum AEEngine engine)
     case AE_ENGINE_COREAUDIO: AE = new CCoreAudioAE(); break;
 #else
     case AE_ENGINE_SOFT     : AE = new CSoftAE(); break;
-    case AE_ENGINE_ACTIVE   : AE = new CActiveAE(); break;
+    case AE_ENGINE_ACTIVE   : AE = new ActiveAE::CActiveAE(); break;
 #endif
 #if defined(HAS_PULSEAUDIO)
     case AE_ENGINE_PULSE    : AE = new CPulseAE(); break;
-- 
1.8.1.6


From 89bb54f049db842565fe68698fd8aacc896be229 Mon Sep 17 00:00:00 2001
From: unknown <fernetmenta@online.de>
Date: Thu, 11 Jul 2013 18:33:34 +0200
Subject: [PATCH 015/123] AE: allow Windows to use ActiveAE via env

---
 xbmc/cores/AudioEngine/AEFactory.cpp | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/xbmc/cores/AudioEngine/AEFactory.cpp b/xbmc/cores/AudioEngine/AEFactory.cpp
index 5adda5f..d5517f3 100644
--- a/xbmc/cores/AudioEngine/AEFactory.cpp
+++ b/xbmc/cores/AudioEngine/AEFactory.cpp
@@ -73,6 +73,20 @@ bool CAEFactory::LoadEngine()
   }
 #endif
 
+#if defined(TARGET_WINDOWS)
+  std::string engine;
+  if (getenv("AE_ENGINE"))
+  {
+    engine = (std::string)getenv("AE_ENGINE");
+    std::transform(engine.begin(), engine.end(), engine.begin(), ::toupper);
+
+    if (!loaded && engine == "SOFT" )
+      loaded = CAEFactory::LoadEngine(AE_ENGINE_SOFT);
+    if (!loaded && engine == "ACTIVE")
+      loaded = CAEFactory::LoadEngine(AE_ENGINE_ACTIVE);
+  }
+#endif
+
 #if defined(HAS_PULSEAUDIO)
   if (!loaded)
     loaded = CAEFactory::LoadEngine(AE_ENGINE_PULSE);
-- 
1.8.1.6


From 795bc8558b82484598f4e304a0b0681eaa0b7ec5 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 14 Jul 2013 17:28:13 +0200
Subject: [PATCH 016/123] ActiveAE: convert BE/LE to NE if possible

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
index 252f431..0e003bd 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
@@ -648,6 +648,18 @@ void CActiveAESink::OpenSink()
       return;
     }
 
+#ifdef WORDS_BIGENDIAN
+    if (m_sinkFormat.m_dataFormat == AE_FMT_S16BE)
+      m_sinkFormat.m_dataFormat = AE_FMT_S16NE;
+    else if (m_sinkFormat.m_dataFormat == AE_FMT_S32BE)
+      m_sinkFormat.m_dataFormat = AE_FMT_S32NE;
+#else
+    if (m_sinkFormat.m_dataFormat == AE_FMT_S16LE)
+      m_sinkFormat.m_dataFormat = AE_FMT_S16NE;
+    else if (m_sinkFormat.m_dataFormat == AE_FMT_S32LE)
+      m_sinkFormat.m_dataFormat = AE_FMT_S32NE;
+#endif
+
     CLog::Log(LOGDEBUG, "CActiveAE::OpenSink - %s Initialized:", m_sink->GetName());
     CLog::Log(LOGDEBUG, "  Output Device : %s", m_deviceFriendlyName.c_str());
     CLog::Log(LOGDEBUG, "  Sample Rate   : %d", m_sinkFormat.m_sampleRate);
-- 
1.8.1.6


From d3462ff7d97c254cc3f5378421e1507d4a19a29f Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 14 Jul 2013 17:48:23 +0200
Subject: [PATCH 017/123] ActiveAE: always request float on sink if not raw

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index dc79da7..c1ec6e5 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -1087,6 +1087,7 @@ void CActiveAE::ApplySettingsToFormat(AEAudioFormat &format, AudioSettings &sett
   }
   else
   {
+    format.m_dataFormat = AE_FMT_FLOAT;
     if ((format.m_channelLayout.Count() > 2) || settings.stereoupmix)
     {
       switch (settings.channels)
-- 
1.8.1.6


From 91ab13397e29e13fef220b3b8334f6062b73f63d Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 14 Jul 2013 18:34:47 +0200
Subject: [PATCH 018/123] ActiveAE: set volume on sink if supported

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp     |  8 +++++++-
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h       |  1 +
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp | 14 ++++++++++++++
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h   |  3 +++
 4 files changed, 25 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
index c1ec6e5..a692d2b 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.cpp
@@ -146,6 +146,7 @@ bool CEngineStats::IsSuspended()
   m_encoder = NULL;
   m_audioCallback = NULL;
   m_vizInitialized = false;
+  m_sinkHasVolume = false;
 }
 
 CActiveAE::~CActiveAE()
@@ -217,6 +218,8 @@ void CActiveAE::StateMachine(int signal, Protocol *port, Message *msg)
           return;
         case CActiveAEControlProtocol::VOLUME:
           m_volume = *(float*)msg->data;
+          if (m_sinkHasVolume)
+            m_sink.m_controlPort.SendOutMessage(CSinkControlProtocol::VOLUME, &m_volume, sizeof(float));
           return;
         case CActiveAEControlProtocol::MUTE:
           m_muted = *(bool*)msg->data;
@@ -752,6 +755,7 @@ void CActiveAE::Configure()
     m_settings.driver = driver;
     initSink = true;
     m_stats.Reset(m_sinkFormat.m_sampleRate);
+    m_sink.m_controlPort.SendOutMessage(CSinkControlProtocol::VOLUME, &m_volume, sizeof(float));
   }
 
   if (m_silenceBuffers)
@@ -1181,6 +1185,7 @@ void CActiveAE::InitSink()
     {
       m_sinkFormat = *data;
     }
+    m_sinkHasVolume = m_sink.HasVolume();
     reply->Release();
   }
   else
@@ -1461,7 +1466,8 @@ bool CActiveAE::RunStages()
       {
         // mix gui sounds
         MixSounds(*(out->pkt));
-        Deamplify(*(out->pkt));
+        if (!m_sinkHasVolume)
+          Deamplify(*(out->pkt));
 
         // viz
         {
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
index 30da1ac..40a2870 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAE.h
@@ -314,6 +314,7 @@ class CActiveAE : public IAE, private CThread
 
   float m_volume;
   bool m_muted;
+  bool m_sinkHasVolume;
 
   // viz
   IAudioCallback *m_audioCallback;
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
index 0e003bd..2088cb6 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
@@ -39,6 +39,7 @@
   m_sink = NULL;
   m_stats = NULL;
   m_convertBuffer = NULL;
+  m_volume = 0.0;
 }
 
 void CActiveAESink::Start()
@@ -88,6 +89,13 @@ bool CActiveAESink::IsCompatible(const AEAudioFormat format, const std::string &
   return m_sink->IsCompatible(format, device);
 }
 
+bool CActiveAESink::HasVolume()
+{
+  if (!m_sink)
+    return false;
+  return m_sink->HasVolume();
+}
+
 enum SINK_STATES
 {
   S_TOP = 0,                      // 0
@@ -232,6 +240,10 @@ void CActiveAESink::StateMachine(int signal, Protocol *port, Message *msg)
             m_extTimeout = 0;
           }
           return;
+        case CSinkControlProtocol::VOLUME:
+          m_volume = *(float*)msg->data;
+          m_sink->SetVolume(m_volume);
+          return;
         default:
           break;
         }
@@ -648,6 +660,8 @@ void CActiveAESink::OpenSink()
       return;
     }
 
+    m_sink->SetVolume(m_volume);
+
 #ifdef WORDS_BIGENDIAN
     if (m_sinkFormat.m_dataFormat == AE_FMT_S16BE)
       m_sinkFormat.m_dataFormat = AE_FMT_S16NE;
diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h
index ae19f38..d36555d 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.h
@@ -49,6 +49,7 @@ class CSinkControlProtocol : public Protocol
     CONFIGURE,
     UNCONFIGURE,
     SILENCEMODE,
+    VOLUME,
     TIMEOUT,
   };
   enum InSignal
@@ -85,6 +86,7 @@ class CActiveAESink : private CThread
   void Start();
   void Dispose();
   bool IsCompatible(const AEAudioFormat format, const std::string &device);
+  bool HasVolume();
   CSinkControlProtocol m_controlPort;
   CSinkDataProtocol m_dataPort;
 
@@ -128,6 +130,7 @@ class CActiveAESink : private CThread
   IAESink *m_sink;
   AEAudioFormat m_sinkFormat, m_requestedFormat;
   CEngineStats *m_stats;
+  float m_volume;
 };
 
 }
-- 
1.8.1.6


From 7b58c9ca0373097b89339304035a4a5edb05c1fe Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Sun, 14 Jul 2013 15:42:25 +0200
Subject: [PATCH 019/123] ActiveAE: Remove special case - not needed anymore
 after: 37b8fb75af29c071a47d1557fe7dfff0b0812dc4

---
 xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp | 11 ++---------
 1 file changed, 2 insertions(+), 9 deletions(-)

diff --git a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
index 2088cb6..7812c02 100644
--- a/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
+++ b/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAESink.cpp
@@ -826,14 +826,7 @@ void CActiveAESink::GenerateNoise()
     noise[i] = (float) sqrt( -2.0f * log( R1 )) * cos( 2.0f * PI * R2 ) * 0.00001;
   }
 
-  if (m_sinkFormat.m_dataFormat != AE_FMT_FLOAT)
-  {
-    CAEConvert::AEConvertFrFn convertFn = CAEConvert::FrFloat(m_sinkFormat.m_dataFormat);
-    convertFn(noise, nb_floats, m_sampleOfNoise.pkt->data[0]);
-  }
-  else
-  {
-    memcpy(m_sampleOfNoise.pkt->data[0], noise, nb_floats*sizeof(float));
-  }
+  CAEConvert::AEConvertFrFn convertFn = CAEConvert::FrFloat(m_sinkFormat.m_dataFormat);
+  convertFn(noise, nb_floats, m_sampleOfNoise.pkt->data[0]);
   delete [] noise;
 }
-- 
1.8.1.6


From e7a30953e4fab54b252fb66f9d48720bf31abe1e Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 30 May 2013 10:56:06 +0200
Subject: [PATCH 020/123] renderer: use fence for determination when a buffer
 is ready for reuse

---
 xbmc/cores/VideoRenderers/BaseRenderer.h      |  1 +
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp | 32 +++++++++++++++++++++++++++
 xbmc/cores/VideoRenderers/LinuxRendererGL.h   |  2 ++
 xbmc/cores/VideoRenderers/RenderManager.cpp   |  7 +++++-
 4 files changed, 41 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.h b/xbmc/cores/VideoRenderers/BaseRenderer.h
index 7e503c5..fe1f577 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.h
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.h
@@ -92,6 +92,7 @@ class CBaseRenderer
   virtual unsigned int GetMaxBufferSize() { return 0; }
   virtual void         SetBufferSize(int numBuffers) { }
   virtual void         ReleaseBuffer(int idx) { }
+  virtual bool         IsProcessed(int idx) { return true; }
 
   virtual bool Supports(ERENDERFEATURE feature) { return false; }
 
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index 32b8d22..95e6716 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -128,6 +128,7 @@
   memset(&image , 0, sizeof(image));
   memset(&pbo   , 0, sizeof(pbo));
   flipindex = 0;
+  fence = None;
 #ifdef HAVE_LIBVDPAU
   vdpau = NULL;
 #endif
@@ -138,6 +139,8 @@
 
 CLinuxRendererGL::YUVBUFFER::~YUVBUFFER()
 {
+  if(fence)
+    glDeleteSync(fence);
 #ifdef HAVE_LIBVA
   delete &vaapi;
 #endif
@@ -1205,6 +1208,15 @@ void CLinuxRendererGL::Render(DWORD flags, int renderBuffer)
     RenderSoftware(renderBuffer, m_currentField);
     VerifyGLState();
   }
+
+  // set fence in order to determine when buffer is ready for reuse
+  // this is the case when the gl has finished processing
+  if(m_buffers[renderBuffer].fence)
+  {
+    glDeleteSync(m_buffers[renderBuffer].fence);
+    m_buffers[renderBuffer].fence = None;
+  }
+  m_buffers[renderBuffer].fence = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
 }
 
 void CLinuxRendererGL::RenderSinglePass(int index, int field)
@@ -3395,6 +3407,26 @@ unsigned int CLinuxRendererGL::GetProcessorSize()
     return 0;
 }
 
+bool CLinuxRendererGL::IsProcessed(int idx)
+{
+  YUVBUFFER &buf = m_buffers[idx];
+  if(buf.fence)
+  {
+    GLint state;
+    GLsizei length;
+    glGetSynciv(buf.fence, GL_SYNC_STATUS, 1, &length, &state);
+    if(state == GL_SIGNALED)
+    {
+      glDeleteSync(buf.fence);
+      buf.fence = None;
+      return true;
+    }
+    else
+      return false;
+  }
+  return true;
+}
+
 #ifdef HAVE_LIBVDPAU
 void CLinuxRendererGL::AddProcessor(CVDPAU* vdpau, int index)
 {
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.h b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
index 96b752b..e239b92 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
@@ -141,6 +141,7 @@ class CLinuxRendererGL : public CBaseRenderer
   virtual void         SetBufferSize(int numBuffers) { m_NumYV12Buffers = numBuffers; }
   virtual unsigned int GetMaxBufferSize() { return NUM_BUFFERS; }
   virtual unsigned int GetProcessorSize();
+  virtual bool         IsProcessed(int idx);
 
 #ifdef HAVE_LIBVDPAU
   virtual void         AddProcessor(CVDPAU* vdpau, int index);
@@ -278,6 +279,7 @@ class CLinuxRendererGL : public CBaseRenderer
     YV12Image image;
     unsigned  flipindex; /* used to decide if this has been uploaded */
     GLuint    pbo[MAX_PLANES];
+    GLsync    fence;
 
 #ifdef HAVE_LIBVDPAU
     CVDPAU*   vdpau;
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 28201a2..595ed8b 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -374,11 +374,16 @@ void CXBMCRenderManager::FrameMove()
     /* release all previous */
     for(std::deque<int>::iterator it = m_discard.begin(); it != m_discard.end(); )
     {
-      // TODO check for fence
+      if (!m_pRenderer->IsProcessed(*it))
+      {
+        ++it;
+        continue;
+      }
       m_pRenderer->ReleaseBuffer(*it);
       m_overlays.Release(*it);
       m_free.push_back(*it);
       it = m_discard.erase(it);
+      m_presentevent.notifyAll();
     }
   }
 }
-- 
1.8.1.6


From be9fc8089a3ab1a44e6d2ec3cc2cd222f20987c6 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 28 May 2012 10:34:39 +0200
Subject: [PATCH 021/123] videoplayer: adapt lateness detection and dropping to
 buffering

---
 xbmc/cores/VideoRenderers/RenderManager.cpp        |  16 +-
 xbmc/cores/VideoRenderers/RenderManager.h          |  12 +-
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodec.h      |  15 +-
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp        |  31 ++++
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.h          |   7 +
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp            | 194 +++++++++++++++++----
 xbmc/cores/dvdplayer/DVDPlayerVideo.h              |  23 +++
 7 files changed, 260 insertions(+), 38 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 595ed8b..44124a3 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -299,6 +299,8 @@ bool CXBMCRenderManager::Configure(unsigned int width, unsigned int height, unsi
     m_bIsStarted = true;
     m_bReconfigured = true;
     m_presentstep = PRESENT_IDLE;
+    m_presentpts = DVD_NOPTS_VALUE;
+    m_sleeptime = 1.0;
     m_presentevent.notifyAll();
 
     m_firstFlipPage = false;  // tempfix
@@ -645,7 +647,7 @@ void CXBMCRenderManager::SetViewMode(int iViewMode)
     m_pRenderer->SetViewMode(iViewMode);
 }
 
-void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0LL*/, int source /*= -1*/, EFIELDSYNC sync /*= FS_NONE*/)
+void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0LL*/, double pts /* = 0 */, int source /*= -1*/, EFIELDSYNC sync /*= FS_NONE*/)
 {
   { CSharedLock lock(m_sharedSection);
 
@@ -713,6 +715,7 @@ void CXBMCRenderManager::FlipPage(volatile bool& bStop, double timestamp /* = 0L
     m.timestamp     = timestamp;
     m.presentfield  = sync;
     m.presentmethod = presentmethod;
+    m.pts           = pts;
     requeue(m_queued, m_free);
 
     /* signal to any waiters to check state */
@@ -1071,6 +1074,8 @@ void CXBMCRenderManager::PrepareNextRender()
     m_discard.push_back(m_presentsource);
     m_presentsource = idx;
     m_queued.pop_front();
+    m_sleeptime = m_Queue[idx].timestamp - clocktime;
+    m_presentpts = m_Queue[idx].pts;
     m_presentevent.notifyAll();
   }
 }
@@ -1087,3 +1092,12 @@ void CXBMCRenderManager::DiscardBuffer()
     m_presentstep   = PRESENT_IDLE;
   m_presentevent.notifyAll();
 }
+
+bool CXBMCRenderManager::GetStats(double &sleeptime, double &pts, int &bufferLevel)
+{
+  CSingleLock lock(m_presentlock);
+  sleeptime = m_sleeptime;
+  pts = m_presentpts;
+  bufferLevel = m_queued.size() + m_discard.size();
+  return true;
+}
diff --git a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
index 764ba07..1d9116e 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.h
+++ b/xbmc/cores/VideoRenderers/RenderManager.h
@@ -97,10 +97,11 @@ class CXBMCRenderManager
    *
    * @param bStop reference to stop flag of calling thread
    * @param timestamp of frame delivered with AddVideoPicture
+   * @param pts used for lateness detection
    * @param source depreciated
    * @param sync signals frame, top, or bottom field
    */
-  void FlipPage(volatile bool& bStop, double timestamp = 0.0, int source = -1, EFIELDSYNC sync = FS_NONE);
+  void FlipPage(volatile bool& bStop, double timestamp = 0.0, double pts = 0.0, int source = -1, EFIELDSYNC sync = FS_NONE);
   unsigned int PreInit();
   void UnInit();
   bool Flush();
@@ -175,6 +176,12 @@ class CXBMCRenderManager
   int WaitForBuffer(volatile bool& bStop, int timeout = 100);
 
   /**
+   * Can be called by player for lateness detection. This is done best by
+   * looking at the end of the queue.
+   */
+  bool GetStats(double &sleeptime, double &pts, int &bufferLevel);
+
+  /**
    * Video player call this on flush in oder to discard any queued frames
    */
   void DiscardBuffer();
@@ -221,6 +228,7 @@ class CXBMCRenderManager
 
   struct SPresent
   {
+    double         pts;
     double         timestamp;
     EFIELDSYNC     presentfield;
     EPRESENTMETHOD presentmethod;
@@ -232,6 +240,8 @@ class CXBMCRenderManager
 
   ERenderFormat   m_format;
 
+  double     m_sleeptime;
+  double     m_presentpts;
   double     m_presentcorr;
   double     m_presenterr;
   double     m_errorbuff[ERRORBUFFSIZE];
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
index 5704704..ee943a0 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -109,6 +109,10 @@ struct DVDVideoUserData
 #define DVP_FLAG_NOSKIP             0x00000010 // indicate this picture should never be dropped
 #define DVP_FLAG_DROPPED            0x00000020 // indicate that this picture has been dropped in decoder stage, will have no data
 
+#define DVP_FLAG_DROPDEINT          0x00000040 // indicate that this picture was requested to have been dropped in deint stage
+#define DVP_FLAG_NO_POSTPROC        0x00000100
+#define DVP_FLAG_DRAIN              0x00000200
+
 // DVP_FLAG 0x00000100 - 0x00000f00 is in use by libmpeg2!
 
 #define DVP_QSCALE_UNKNOWN          0
@@ -126,6 +130,9 @@ struct DVDVideoUserData
 #define VC_PICTURE  0x00000004  // the decoder got a picture, call Decode(NULL, 0) again to parse the rest of the data
 #define VC_USERDATA 0x00000008  // the decoder found some userdata,  call Decode(NULL, 0) again to parse the rest of the data
 #define VC_FLUSHED  0x00000010  // the decoder lost it's state, we need to restart decoding again
+#define VC_DROPPED  0x00000020  // needed to identify if a picture was dropped
+#define VC_HURRY    0x00000040
+
 class CDVDVideoCodec
 {
 public:
@@ -243,10 +250,16 @@ class CDVDVideoCodec
     return 0;
   }
 
-
   /**
    * Number of references to old pictures that are allowed to
    * be retained when calling decode on the next demux packet
    */
   virtual unsigned GetAllowedReferences() { return 0; }
+
+  virtual bool GetPts(double &pts, int &skippedDeint, int &interlaced)
+  {
+    return false;
+  }
+
+  virtual void SetCodecControl(int flags) {}
 };
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index 0591b1f..f789785 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -163,6 +163,7 @@ enum PixelFormat CDVDVideoCodecFFmpeg::GetFormat( struct AVCodecContext * avctx
   m_iLastKeyframe = 0;
   m_dts = DVD_NOPTS_VALUE;
   m_started = false;
+  m_decoderPts = DVD_NOPTS_VALUE;
 }
 
 CDVDVideoCodecFFmpeg::~CDVDVideoCodecFFmpeg()
@@ -340,6 +341,14 @@ void CDVDVideoCodecFFmpeg::SetDropState(bool bDrop)
 {
   if( m_pCodecContext )
   {
+    if (bDrop && m_pHardware && m_pHardware->CanSkipDeint())
+    {
+      m_requestSkipDeint = true;
+      bDrop = false;
+    }
+    else
+      m_requestSkipDeint = false;
+
     // i don't know exactly how high this should be set
     // couldn't find any good docs on it. think it varies
     // from codec to codec on what it does
@@ -541,6 +550,7 @@ int CDVDVideoCodecFFmpeg::Decode(uint8_t* pData, int iSize, double dts, double p
 void CDVDVideoCodecFFmpeg::Reset()
 {
   m_started = false;
+  m_decoderPts = DVD_NOPTS_VALUE;
   m_iLastKeyframe = m_pCodecContext->has_b_frames;
   m_dllAvCodec.avcodec_flush_buffers(m_pCodecContext);
 
@@ -643,6 +653,22 @@ bool CDVDVideoCodecFFmpeg::GetPictureCommon(DVDVideoPicture* pDvdVideoPicture)
   else
     pDvdVideoPicture->pts = DVD_NOPTS_VALUE;
 
+  if (pDvdVideoPicture->pts != DVD_NOPTS_VALUE)
+    m_decoderPts = pDvdVideoPicture->pts;
+  else
+    m_decoderPts = m_dts;
+
+  if (m_requestSkipDeint)
+  {
+    pDvdVideoPicture->iFlags |= DVP_FLAG_DROPDEINT;
+    m_skippedDeint = 1;
+  }
+  else
+    m_skippedDeint = 0;
+
+  m_requestSkipDeint = false;
+  pDvdVideoPicture->iFlags |= m_codecControlFlags;
+
   if(!m_started)
     pDvdVideoPicture->iFlags |= DVP_FLAG_DROPPED;
 
@@ -880,3 +906,8 @@ unsigned CDVDVideoCodecFFmpeg::GetAllowedReferences()
   else
     return 0;
 }
+
+void CDVDVideoCodecFFmpeg::SetCodecControl(int flags)
+{
+  m_codecControlFlags = flags;
+}
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
index fe6bbaa..c7ae207 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
@@ -46,6 +46,7 @@ class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
     virtual int  Check     (AVCodecContext* avctx) = 0;
     virtual void Reset     () {}
     virtual unsigned GetAllowedReferences() { return 0; }
+    virtual bool CanSkipDeint() {return false; }
     virtual const std::string Name() = 0;
     virtual CCriticalSection* Section() { return NULL; }
   };
@@ -63,6 +64,8 @@ class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
   virtual const char* GetName() { return m_name.c_str(); }; // m_name is never changed after open
   virtual unsigned GetConvergeCount();
   virtual unsigned GetAllowedReferences();
+  virtual bool GetPts(double &pts, int &skippedDeint, int &interlaced) {pts=m_decoderPts; skippedDeint=m_skippedDeint; if (m_pFrame) interlaced = m_pFrame->interlaced_frame; return true;}
+  virtual void SetCodecControl(int flags);
 
   bool               IsHardwareAllowed()                     { return !m_bSoftware; }
   IHardwareDecoder * GetHardware()                           { return m_pHardware; };
@@ -124,4 +127,8 @@ class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
   double m_dts;
   bool   m_started;
   std::vector<PixelFormat> m_formats;
+  double m_decoderPts, m_decoderInterval;
+  int    m_skippedDeint;
+  bool   m_requestSkipDeint;
+  int    m_codecControlFlags;
 };
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 749195f..4c1e9dd 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -322,8 +322,10 @@ void CDVDPlayerVideo::Process()
 
   int iDropped = 0; //frames dropped in a row
   bool bRequestDrop = false;
+  int iDropDirective;
 
   m_videoStats.Start();
+  m_droppingStats.Reset();
 
   while (!m_bStop)
   {
@@ -433,6 +435,7 @@ void CDVDPlayerVideo::Process()
       picture.iFlags &= ~DVP_FLAG_ALLOCATED;
       m_packets.clear();
       m_started = false;
+      m_droppingStats.Reset();
     }
     else if (pMsg->IsType(CDVDMsg::GENERAL_FLUSH)) // private message sent by (CDVDPlayerVideo::Flush())
     {
@@ -445,6 +448,7 @@ void CDVDPlayerVideo::Process()
       //we need to recalculate the framerate
       //TODO: this needs to be set on a streamchange instead
       ResetFrameRateCalc();
+      m_droppingStats.Reset();
 
       m_stalled = true;
       m_started = false;
@@ -462,8 +466,10 @@ void CDVDPlayerVideo::Process()
       m_speed = static_cast<CDVDMsgInt*>(pMsg)->m_value;
       if(m_speed == DVD_PLAYSPEED_PAUSE)
         m_iNrOfPicturesNotToSkip = 0;
+
       if (m_pVideoCodec)
         m_pVideoCodec->SetSpeed(m_speed);
+      m_droppingStats.Reset();
     }
     else if (pMsg->IsType(CDVDMsg::PLAYER_STARTED))
     {
@@ -509,6 +515,28 @@ void CDVDPlayerVideo::Process()
         m_iNrOfPicturesNotToSkip = 1;
       }
 
+      bRequestDrop = false;
+      iDropDirective = CalcDropRequirement(pts);
+      if (iDropDirective & EOS_VERYLATE)
+      {
+        if (m_bAllowDrop)
+        {
+          m_pullupCorrection.Flush();
+          bRequestDrop = true;
+        }
+      }
+      int codecControl = 0;
+      if (iDropDirective & EOS_BUFFER_LEVEL)
+        codecControl |= DVP_FLAG_DRAIN;
+      if (m_speed > DVD_PLAYSPEED_NORMAL)
+        codecControl |= DVP_FLAG_NO_POSTPROC;
+      m_pVideoCodec->SetCodecControl(codecControl);
+      if (iDropDirective & EOS_DROPPED)
+      {
+        m_iDroppedFrames++;
+        iDropped++;
+      }
+
       if (m_messageQueue.GetDataSize() == 0
       ||  m_speed < 0)
       {
@@ -561,15 +589,8 @@ void CDVDPlayerVideo::Process()
       }
 
       m_videoStats.AddSampleBytes(pPacket->iSize);
-      // assume decoder dropped a picture if it didn't give us any
-      // picture from a demux packet, this should be reasonable
-      // for libavformat as a demuxer as it normally packetizes
-      // pictures when they come from demuxer
-      if(bRequestDrop && !bPacketDrop && (iDecoderState & VC_BUFFER) && !(iDecoderState & VC_PICTURE))
-      {
-        m_iDroppedFrames++;
-        iDropped++;
-      }
+
+      bRequestDrop = false;
 
       // loop while no error
       while (!m_bStop)
@@ -1207,33 +1228,12 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
   m_FlipTimeStamp += max(0.0, iSleepTime);
   m_FlipTimeStamp += iFrameDuration;
 
-  if (iSleepTime <= 0 && m_speed)
-    m_iLateFrames++;
-  else
-    m_iLateFrames = 0;
-
-  // ask decoder to drop frames next round, as we are very late
-  if(m_iLateFrames > 10)
+  if ((pPicture->iFlags & DVP_FLAG_DROPPED))
   {
-    if (!(pPicture->iFlags & DVP_FLAG_NOSKIP))
-    {
-      //if we're calculating the framerate,
-      //don't drop frames until we've calculated a stable framerate
-      if (m_bAllowDrop || m_speed != DVD_PLAYSPEED_NORMAL)
-      {
-        result |= EOS_VERYLATE;
-        m_pullupCorrection.Flush(); //dropped frames mess up the pattern, so just flush it
-      }
-      m_iDroppedRequest++;
-    }
-  }
-  else
-  {
-    m_iDroppedRequest = 0;
-  }
-
-  if( (pPicture->iFlags & DVP_FLAG_DROPPED) )
+    m_droppingStats.AddOutputDropGain(pts, 1/m_fFrameRate);
+    CLog::Log(LOGDEBUG,"%s - dropped in output", __FUNCTION__);
     return result | EOS_DROPPED;
+  }
 
   // set fieldsync if picture is interlaced
   EFIELDSYNC mDisplayField = FS_NONE;
@@ -1266,7 +1266,7 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
   if (index < 0)
     return EOS_DROPPED;
 
-  g_renderManager.FlipPage(CThread::m_bStop, (iCurrentClock + iSleepTime) / DVD_TIME_BASE, -1, mDisplayField);
+  g_renderManager.FlipPage(CThread::m_bStop, (iCurrentClock + iSleepTime) / DVD_TIME_BASE, pts, -1, mDisplayField);
 
   return result;
 #else
@@ -1566,3 +1566,127 @@ void CDVDPlayerVideo::CalcFrameRate()
     m_iFrameRateCount = 0;
   }
 }
+
+int CDVDPlayerVideo::CalcDropRequirement(double pts)
+{
+  int result = 0;
+  double iSleepTime;
+  double iDecoderPts, iRenderPts;
+  double iInterval;
+  int    interlaced;
+  double iGain;
+  double iLateness;
+  bool   bNewFrame;
+  int    iSkippedDeint = 0;
+  int    iBufferLevel;
+
+  // get decoder stats
+  if (!m_pVideoCodec->GetPts(iDecoderPts, iSkippedDeint, interlaced))
+    iDecoderPts = pts;
+  if (iDecoderPts == DVD_NOPTS_VALUE)
+    iDecoderPts = pts;
+
+  // get render stats
+  g_renderManager.GetStats(iSleepTime, iRenderPts, iBufferLevel);
+
+  if (iBufferLevel < 0)
+    result |= EOS_BUFFER_LEVEL;
+  else if (iBufferLevel < 2)
+  {
+    result |= EOS_BUFFER_LEVEL;
+    CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - hurry: %d", iBufferLevel);
+  }
+
+  bNewFrame = iDecoderPts != m_droppingStats.m_lastDecoderPts;
+
+  if (interlaced)
+    iInterval = 2/m_fFrameRate*(double)DVD_TIME_BASE;
+  else
+    iInterval = 1/m_fFrameRate*(double)DVD_TIME_BASE;
+
+  if (m_droppingStats.m_lastDecoderPts > 0
+      && bNewFrame
+      && m_bAllowDrop
+      && m_droppingStats.m_dropRequests > 0)
+  {
+    iGain = (iDecoderPts - m_droppingStats.m_lastDecoderPts - iInterval)/(double)DVD_TIME_BASE;
+    if (iSkippedDeint)
+    {
+      CDroppingStats::CGain gain;
+      gain.gain = 1/m_fFrameRate;
+      gain.pts = iDecoderPts;
+      m_droppingStats.m_gain.push_back(gain);
+      m_droppingStats.m_totalGain += gain.gain;
+      result |= EOS_DROPPED;
+      m_droppingStats.m_dropRequests = 0;
+      CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - dropped de-interlacing cycle, Sleeptime: %f, Bufferlevel: %d", iSleepTime, iBufferLevel);
+    }
+    else if (iGain > 1/m_fFrameRate)
+    {
+      CDroppingStats::CGain gain;
+      gain.gain = iGain;
+      gain.pts = iDecoderPts;
+      m_droppingStats.m_gain.push_back(gain);
+      m_droppingStats.m_totalGain += iGain;
+      result |= EOS_DROPPED;
+      m_droppingStats.m_dropRequests = 0;
+      CLog::Log(LOGDEBUG,"CDVDPlayerVideo::CalcDropRequirement - dropped in decoder, Sleeptime: %f, Bufferlevel: %d, Gain: %f", iSleepTime, iBufferLevel, iGain);
+    }
+  }
+  m_droppingStats.m_lastDecoderPts = iDecoderPts;
+
+  // subtract gains
+  while (!m_droppingStats.m_gain.empty() &&
+         iRenderPts >= m_droppingStats.m_gain.front().pts)
+  {
+    m_droppingStats.m_totalGain -= m_droppingStats.m_gain.front().gain;
+    m_droppingStats.m_gain.pop_front();
+  }
+
+  // calculate lateness
+  iLateness = iSleepTime + m_droppingStats.m_totalGain;
+  if (iLateness < 0 && m_speed)
+  {
+    if (bNewFrame)
+      m_droppingStats.m_lateFrames++;
+
+    // if lateness is smaller than frametime, we observe this state
+    // for 10 cycles
+    if (m_droppingStats.m_lateFrames > 10 || iLateness < -2/m_fFrameRate)
+    {
+      // is frame allowed to skip
+      if (m_iNrOfPicturesNotToSkip <= 0)
+      {
+        result |= EOS_VERYLATE;
+        if (bNewFrame)
+          m_droppingStats.m_dropRequests++;
+      }
+    }
+  }
+  else
+  {
+    m_droppingStats.m_dropRequests = 0;
+    m_droppingStats.m_lateFrames = 0;
+  }
+  m_droppingStats.m_lastRenderPts = iRenderPts;
+  return result;
+}
+
+void CDroppingStats::Reset()
+{
+  m_gain.clear();
+  m_totalGain = 0;
+  m_lastDecoderPts = 0;
+  m_lastRenderPts = 0;
+  m_lateFrames = 0;
+  m_dropRequests = 0;
+}
+
+void CDroppingStats::AddOutputDropGain(double pts, double frametime)
+{
+  CDroppingStats::CGain gain;
+  gain.gain = frametime;
+  gain.pts = pts;
+  m_gain.push_back(gain);
+  m_totalGain += frametime;
+}
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.h b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
index 5f763c0..9be23fb 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
@@ -36,6 +36,25 @@
 
 #define VIDEO_PICTURE_QUEUE_SIZE 1
 
+class CDroppingStats
+{
+public:
+  void Reset();
+  void AddOutputDropGain(double pts, double frametime);
+  struct CGain
+  {
+    double gain;
+    double pts;
+  };
+  std::deque<CGain> m_gain;
+  double m_totalGain;
+  double m_lastDecoderPts;
+  double m_lastRenderPts;
+  unsigned int m_lateFrames;
+  unsigned int m_dropRequests;
+};
+
+
 class CDVDPlayerVideo : public CThread
 {
 public:
@@ -103,6 +122,7 @@ class CDVDPlayerVideo : public CThread
 #define EOS_ABORT 1
 #define EOS_DROPPED 2
 #define EOS_VERYLATE 4
+#define EOS_BUFFER_LEVEL 8
 
   void AutoCrop(DVDVideoPicture* pPicture);
   void AutoCrop(DVDVideoPicture *pPicture, RECT &crop);
@@ -128,6 +148,7 @@ class CDVDPlayerVideo : public CThread
 
   void   ResetFrameRateCalc();
   void   CalcFrameRate();
+  int    CalcDropRequirement(double pts);
 
   double m_fFrameRate;       //framerate of the video currently playing
   bool   m_bCalcFrameRate;  //if we should calculate the framerate from the timestamps
@@ -180,5 +201,7 @@ class CDVDPlayerVideo : public CThread
   CPullupCorrection m_pullupCorrection;
 
   std::list<DVDMessageListItem> m_packets;
+
+  CDroppingStats m_droppingStats;
 };
 
-- 
1.8.1.6


From 4b56e80e90f4d673cbca7fa91e740216444d6586 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 2 Sep 2012 16:05:21 +0200
Subject: [PATCH 022/123] video player: present correct pts to user for a/v
 sync (after buffering in renderer)

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 25 +++++++++++++++++++++++++
 xbmc/cores/dvdplayer/DVDPlayerVideo.h   |  2 +-
 2 files changed, 26 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 4c1e9dd..ba99804 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1486,6 +1486,22 @@ void CDVDPlayerVideo::ResetFrameRateCalc()
                         g_advancedSettings.m_videoFpsDetect == 0;
 }
 
+double CDVDPlayerVideo::GetCurrentPts()
+{
+  double iSleepTime, iRenderPts;
+  int iBufferLevel;
+
+  // get render stats
+  g_renderManager.GetStats(iSleepTime, iRenderPts, iBufferLevel);
+
+  if( m_stalled )
+    iRenderPts = DVD_NOPTS_VALUE;
+  else
+    iRenderPts = iRenderPts - max(0.0, iSleepTime);
+
+  return iRenderPts;
+}
+
 #define MAXFRAMERATEDIFF   0.01
 #define MAXFRAMESERR    1000
 
@@ -1604,6 +1620,15 @@ int CDVDPlayerVideo::CalcDropRequirement(double pts)
   else
     iInterval = 1/m_fFrameRate*(double)DVD_TIME_BASE;
 
+
+  m_FlipTimeStamp = m_pClock->GetAbsoluteClock() + max(0.0, iSleepTime) + iInterval;
+
+  if( m_stalled )
+    m_iCurrentPts = DVD_NOPTS_VALUE;
+  else
+    m_iCurrentPts = iRenderPts - max(0.0, iSleepTime);
+
+
   if (m_droppingStats.m_lastDecoderPts > 0
       && bNewFrame
       && m_bAllowDrop
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.h b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
index 9be23fb..3c3e007 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
@@ -100,7 +100,7 @@ class CDVDPlayerVideo : public CThread
 
   bool InitializedOutputDevice();
 
-  double GetCurrentPts()                           { return m_iCurrentPts; }
+  double GetCurrentPts();
   int    GetPullupCorrection()                     { return m_pullupCorrection.GetPatternLength(); }
 
   double GetOutputDelay(); /* returns the expected delay, from that a packet is put in queue */
-- 
1.8.1.6


From 3be868f44191d3437f2ccf053e2c964ed5b3ffd4 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sat, 16 Feb 2013 18:25:53 +0100
Subject: [PATCH 023/123] videoplayer: some rework and documentation

---
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodec.h      | 29 ++++++++++++++++++++--
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp        | 11 ++++++++
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.h          |  2 +-
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp            |  2 +-
 4 files changed, 40 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
index ee943a0..7abbd7e 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -131,7 +131,6 @@ struct DVDVideoUserData
 #define VC_USERDATA 0x00000008  // the decoder found some userdata,  call Decode(NULL, 0) again to parse the rest of the data
 #define VC_FLUSHED  0x00000010  // the decoder lost it's state, we need to restart decoding again
 #define VC_DROPPED  0x00000020  // needed to identify if a picture was dropped
-#define VC_HURRY    0x00000040
 
 class CDVDVideoCodec
 {
@@ -256,10 +255,36 @@ class CDVDVideoCodec
    */
   virtual unsigned GetAllowedReferences() { return 0; }
 
-  virtual bool GetPts(double &pts, int &skippedDeint, int &interlaced)
+  /**
+   * For calculation of dropping requirements player asks for some information.
+   *
+   * - pts : right after decoder, used to detect gaps (dropped frames in decoder)
+   * - skippedDeint : indicates if decoder has just skipped a deinterlacing cycle
+   *   instead of dropping a full frame
+   * - interlaced : when detecting gaps in pts, player needs to know whether
+   *   it's interlaced or not
+   *
+   * If codec does not implement this method, pts of decoded frame at input
+   * video player is used. In case coded does post-proc and de-interlacing there
+   * may be quite some frames queued up between exit decoder and entry player.
+   */
+  virtual bool GetCodecStats(double &pts, int &skippedDeint, int &interlaced)
   {
     return false;
   }
 
+  /**
+   * Codec can be informed by player with the following flags:
+   *
+   * DVP_FLAG_NO_POSTPROC : if speed is not normal the codec can switch off
+   *                        postprocessing and de-interlacing
+   *
+   * DVP_FLAG_DRAIN : codecs may do postprocessing and de-interlacing.
+   *                  If video buffers in RenderManager are about to run dry,
+   *                  this is signaled to codec. Codec can wait for post-proc
+   *                  to be finished instead of returning empty and getting another
+   *                  packet.
+   *
+   */
   virtual void SetCodecControl(int flags) {}
 };
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index f789785..43c133c 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -907,6 +907,17 @@ unsigned CDVDVideoCodecFFmpeg::GetAllowedReferences()
     return 0;
 }
 
+bool CDVDVideoCodecFFmpeg::GetCodecStats(double &pts, int &skippedDeint, int &interlaced)
+{
+  pts = m_decoderPts;
+  skippedDeint = m_skippedDeint;
+  if (m_pFrame)
+    interlaced = m_pFrame->interlaced_frame;
+  else
+    interlaced = 0;
+  return true;
+}
+
 void CDVDVideoCodecFFmpeg::SetCodecControl(int flags)
 {
   m_codecControlFlags = flags;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
index c7ae207..81b9af9 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
@@ -64,7 +64,7 @@ class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
   virtual const char* GetName() { return m_name.c_str(); }; // m_name is never changed after open
   virtual unsigned GetConvergeCount();
   virtual unsigned GetAllowedReferences();
-  virtual bool GetPts(double &pts, int &skippedDeint, int &interlaced) {pts=m_decoderPts; skippedDeint=m_skippedDeint; if (m_pFrame) interlaced = m_pFrame->interlaced_frame; return true;}
+  virtual bool GetCodecStats(double &pts, int &skippedDeint, int &interlaced);
   virtual void SetCodecControl(int flags);
 
   bool               IsHardwareAllowed()                     { return !m_bSoftware; }
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index ba99804..56b32b9 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1597,7 +1597,7 @@ int CDVDPlayerVideo::CalcDropRequirement(double pts)
   int    iBufferLevel;
 
   // get decoder stats
-  if (!m_pVideoCodec->GetPts(iDecoderPts, iSkippedDeint, interlaced))
+  if (!m_pVideoCodec->GetCodecStats(iDecoderPts, iSkippedDeint, interlaced))
     iDecoderPts = pts;
   if (iDecoderPts == DVD_NOPTS_VALUE)
     iDecoderPts = pts;
-- 
1.8.1.6


From 4dd137d05f8e2fe7f36736395a9650139b7f21cb Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sat, 7 Apr 2012 09:19:00 +0200
Subject: [PATCH 024/123] vdpau: redesign

---
 language/English/strings.po                        |   12 +-
 system/settings/settings.xml                       |   10 +
 system/shaders/yuv2rgb_basic.glsl                  |   12 +
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp      |  200 +-
 xbmc/cores/VideoRenderers/LinuxRendererGL.h        |   13 +-
 xbmc/cores/VideoRenderers/RenderFormats.h          |    1 +
 xbmc/cores/VideoRenderers/RenderManager.cpp        |    3 +-
 xbmc/cores/VideoRenderers/RenderManager.h          |    2 +-
 .../VideoRenderers/VideoShaders/YUV2RGBShader.cpp  |    2 +
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodec.h      |    4 +-
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp        |    6 +-
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.h          |    1 -
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp     | 3843 ++++++++++++++------
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h       |  675 +++-
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp            |    1 +
 xbmc/settings/AdvancedSettings.cpp                 |    8 +-
 xbmc/settings/AdvancedSettings.h                   |    4 +-
 xbmc/utils/ActorProtocol.cpp                       |    4 +
 xbmc/utils/ActorProtocol.h                         |    4 +
 xbmc/video/dialogs/GUIDialogVideoSettings.cpp      |    2 +-
 xbmc/windowing/X11/WinSystemX11.h                  |    1 +
 21 files changed, 3578 insertions(+), 1230 deletions(-)

diff --git a/language/English/strings.po b/language/English/strings.po
index bb2272d..f2a0572 100644
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -5767,7 +5767,15 @@ msgctxt "#13435"
 msgid "Enable HQ Scalers for scalings above"
 msgstr ""
 
-#empty strings from id 13436 to 13499
+msgctxt "#13436"
+msgid "Allow Vdpau OpenGL interop"
+msgstr ""
+
+msgctxt "#13437"
+msgid "Allow Vdpau OpenGL interop YUV"
+msgstr ""
+
+#empty strings from id 13438 to 13499
 
 #: system/settings/settings.xml
 msgctxt "#13500"
@@ -6842,7 +6850,7 @@ msgid "Software Blend"
 msgstr ""
 
 msgctxt "#16325"
-msgid "Auto - ION Optimized"
+msgid "VDPAU - Bob"
 msgstr ""
 
 #empty strings from id 16326 to 16399
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index 6e32551..15e9a75 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -375,6 +375,16 @@
           <level>2</level>
           <default>true</default>
         </setting>
+          <setting id="videoplayer.usevdpaumixer" type="boolean" label="13436" help="">
+          <visible>HAVE_LIBVDPAU</visible>
+          <level>2</level>
+          <default>true</default>
+          <control>
+            <dependencies>
+              <dependency type="enable" setting="videoplayer.usevdpau" operator="is">true</dependency> <!-- USE VDPAU -->
+            </dependencies>
+          </control>
+        </setting>
         <setting id="videoplayer.usevaapi" type="boolean" label="13426" help="36156">
           <visible>HAVE_LIBVA</visible>
           <level>2</level>
diff --git a/system/shaders/yuv2rgb_basic.glsl b/system/shaders/yuv2rgb_basic.glsl
index c8c8a2e..0799a4b 100644
--- a/system/shaders/yuv2rgb_basic.glsl
+++ b/system/shaders/yuv2rgb_basic.glsl
@@ -70,6 +70,18 @@ void main()
   rgb.a = gl_Color.a;
   gl_FragColor = rgb;
 
+#elif defined(XBMC_VDPAU_NV12)
+
+  vec4 yuv, rgb;
+  yuv.rgba = vec4( texture2D(m_sampY, stretch(m_cordY)).r
+                 , texture2D(m_sampU, stretch(m_cordU)).r
+                 , texture2D(m_sampV, stretch(m_cordV)).g
+                 , 1.0 );
+
+  rgb   = m_yuvmat * yuv;
+  rgb.a = gl_Color.a;
+  gl_FragColor = rgb;
+
 #elif defined(XBMC_YUY2) || defined(XBMC_UYVY)
 
 #if(XBMC_texture_rectangle)
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index 95e6716..88c7e5f 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -679,6 +679,18 @@ void CLinuxRendererGL::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
     glDisable(GL_POLYGON_STIPPLE);
 
   }
+  else if(m_format == RENDER_FMT_VDPAU_420
+      && !(flags & RENDER_FLAG_BOTH))
+  {
+    glDisable(GL_BLEND);
+    glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
+    Render(flags | RENDER_FLAG_TOP, index);
+
+    glEnable(GL_BLEND);
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+    glColor4f(1.0f, 1.0f, 1.0f, 128 / 255.0f);
+    Render(flags | RENDER_FLAG_BOT , index);
+  }
   else
     Render(flags, index);
 
@@ -759,11 +771,6 @@ void CLinuxRendererGL::FlipPage(int source)
 
   m_buffers[m_iYV12RenderBuffer].flipindex = ++m_flipindex;
 
-#ifdef HAVE_LIBVDPAU  
-  if((m_renderMethod & RENDER_VDPAU) && m_buffers[m_iYV12RenderBuffer].vdpau)
-    m_buffers[m_iYV12RenderBuffer].vdpau->Present();
-#endif
-
   return;
 }
 
@@ -1090,6 +1097,12 @@ void CLinuxRendererGL::LoadShaders(int field)
     m_textureCreate = &CLinuxRendererGL::CreateVDPAUTexture;
     m_textureDelete = &CLinuxRendererGL::DeleteVDPAUTexture;
   }
+  else if (m_format == RENDER_FMT_VDPAU_420)
+  {
+    m_textureUpload = &CLinuxRendererGL::UploadVDPAUTexture420;
+    m_textureCreate = &CLinuxRendererGL::CreateVDPAUTexture420;
+    m_textureDelete = &CLinuxRendererGL::DeleteVDPAUTexture420;
+  }
   else if (m_format == RENDER_FMT_VAAPI)
   {
     m_textureUpload = &CLinuxRendererGL::UploadVAAPITexture;
@@ -1165,7 +1178,10 @@ void CLinuxRendererGL::Render(DWORD flags, int renderBuffer)
     m_currentField = FIELD_FULL;
 
   // call texture load function
+  m_skipRender = false;
   (this->*m_textureUpload)(renderBuffer);
+  if (m_skipRender)
+    return;
 
   if (m_renderMethod & RENDER_GLSL)
   {
@@ -1540,17 +1556,12 @@ void CLinuxRendererGL::RenderFromFBO()
 void CLinuxRendererGL::RenderVDPAU(int index, int field)
 {
 #ifdef HAVE_LIBVDPAU
-  YUVPLANE &plane = m_buffers[index].fields[field][0];
-  CVDPAU   *vdpau = m_buffers[m_iYV12RenderBuffer].vdpau;
-
-  if (!vdpau)
-    return;
+  YUVPLANE &plane = m_buffers[index].fields[0][1];
 
   glEnable(m_textureTarget);
   glActiveTextureARB(GL_TEXTURE0);
-  glBindTexture(m_textureTarget, plane.id);
 
-  vdpau->BindPixmap();
+  glBindTexture(m_textureTarget, plane.id);
 
   // Try some clamping or wrapping
   glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
@@ -1608,8 +1619,6 @@ void CLinuxRendererGL::RenderVDPAU(int index, int field)
   if (m_pVideoFilterShader)
     m_pVideoFilterShader->Disable();
 
-  vdpau->ReleasePixmap();
-
   glBindTexture (m_textureTarget, 0);
   glDisable(m_textureTarget);
 #endif
@@ -2286,12 +2295,14 @@ void CLinuxRendererGL::DeleteVDPAUTexture(int index)
 {
 #ifdef HAVE_LIBVDPAU
   YUVPLANE &plane = m_buffers[index].fields[0][0];
+  YUVFIELDS &fields = m_buffers[index].fields;
 
   SAFE_RELEASE(m_buffers[index].vdpau);
 
   if(plane.id && glIsTexture(plane.id))
     glDeleteTextures(1, &plane.id);
   plane.id = 0;
+  fields[0][1].id = 0;
 #endif
 }
 
@@ -2324,10 +2335,147 @@ bool CLinuxRendererGL::CreateVDPAUTexture(int index)
 void CLinuxRendererGL::UploadVDPAUTexture(int index)
 {
 #ifdef HAVE_LIBVDPAU
-  glPixelStorei(GL_UNPACK_ALIGNMENT,1); //what's this for?
+  VDPAU::CVdpauRenderPicture *vdpau = m_buffers[index].vdpau;
+
+  unsigned int flipindex = m_buffers[index].flipindex;
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE &plane = fields[0][0];
+
+  if (!vdpau || !vdpau->valid)
+  {
+    m_skipRender = true;
+    return;
+  }
+
+  fields[0][1].id = vdpau->texture[0];
+
+#endif
+}
+
+void CLinuxRendererGL::DeleteVDPAUTexture420(int index)
+{
+#ifdef HAVE_LIBVDPAU
+  YUVPLANE &plane = m_buffers[index].fields[0][0];
+  YUVFIELDS &fields = m_buffers[index].fields;
+
+  SAFE_RELEASE(m_buffers[index].vdpau);
+
+  if(plane.id && glIsTexture(plane.id))
+    glDeleteTextures(1, &plane.id);
+  plane.id = 0;
+  fields[1][0].id = 0;
+  fields[1][1].id = 0;
+  fields[2][0].id = 0;
+  fields[2][1].id = 0;
+
+#endif
+}
+
+bool CLinuxRendererGL::CreateVDPAUTexture420(int index)
+{
+#ifdef HAVE_LIBVDPAU
+  YV12Image &im     = m_buffers[index].image;
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE &plane = fields[0][0];
+  GLuint    *pbo    = m_buffers[index].pbo;
+
+  DeleteVDPAUTexture420(index);
+
+  memset(&im    , 0, sizeof(im));
+  memset(&fields, 0, sizeof(fields));
+
+  im.cshift_x = 1;
+  im.cshift_y = 1;
+
+  im.plane[0] = NULL;
+  im.plane[1] = NULL;
+  im.plane[2] = NULL;
+
+  for(int p = 0;p<3;p++)
+  {
+    pbo[p] = None;
+  }
+
+  glEnable(m_textureTarget);
+  glGenTextures(1, &plane.id);
+  glDisable(m_textureTarget);
+
 #endif
+  return true;
 }
 
+void CLinuxRendererGL::UploadVDPAUTexture420(int index)
+{
+#ifdef HAVE_LIBVDPAU
+  VDPAU::CVdpauRenderPicture *vdpau = m_buffers[index].vdpau;
+  YV12Image &im = m_buffers[index].image;
+
+  unsigned int flipindex = m_buffers[index].flipindex;
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE &plane = fields[0][0];
+
+  if (!vdpau || !vdpau->valid)
+  {
+    m_skipRender = true;
+    return;
+  }
+
+  im.height = vdpau->texHeight;
+  im.width  = vdpau->texWidth;
+
+  // YUV
+  for (int f = FIELD_FULL; f<=FIELD_BOT ; f++)
+  {
+    int fieldshift = (f==FIELD_FULL) ? 0 : 1;
+    YUVPLANES &planes = fields[f];
+
+    planes[0].texwidth  = im.width;
+    planes[0].texheight = im.height >> fieldshift;
+
+    planes[1].texwidth  = planes[0].texwidth  >> im.cshift_x;
+    planes[1].texheight = planes[0].texheight >> im.cshift_y;
+    planes[2].texwidth  = planes[1].texwidth;
+    planes[2].texheight = planes[1].texheight;
+
+    for (int p = 0; p < 3; p++)
+    {
+      planes[p].pixpertex_x = 1;
+      planes[p].pixpertex_y = 1;
+    }
+  }
+  // crop
+//  m_sourceRect.x1 += vdpau->crop.x1;
+//  m_sourceRect.x2 -= vdpau->crop.x2;
+//  m_sourceRect.y1 += vdpau->crop.y1;
+//  m_sourceRect.y2 -= vdpau->crop.y2;
+
+  // set textures
+  fields[1][0].id = vdpau->texture[0];
+  fields[1][1].id = vdpau->texture[2];
+  fields[2][0].id = vdpau->texture[1];
+  fields[2][1].id = vdpau->texture[3];
+
+  glEnable(m_textureTarget);
+  for (int f = 1; f < 3; f++)
+  {
+    for (int p=0;p<2;p++)
+    {
+      glBindTexture(m_textureTarget,fields[f][p].id);
+      glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+      glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+
+      glBindTexture(m_textureTarget,0);
+      VerifyGLState();
+    }
+    fields[f][2].id = fields[f][1].id;
+  }
+  CalculateTextureSourceRects(index, 3);
+  glDisable(m_textureTarget);
+
+#endif
+}
 
 void CLinuxRendererGL::DeleteVAAPITexture(int index)
 {
@@ -3250,12 +3398,13 @@ bool CLinuxRendererGL::Supports(EINTERLACEMETHOD method)
   if(method == VS_INTERLACEMETHOD_AUTO)
     return true;
 
-  if(m_renderMethod & RENDER_VDPAU)
+  if(m_renderMethod & RENDER_VDPAU ||
+      m_format == RENDER_FMT_VDPAU_420)
   {
 #ifdef HAVE_LIBVDPAU
-    CVDPAU *vdpau = m_buffers[m_iYV12RenderBuffer].vdpau;
-    if(vdpau)
-      return vdpau->Supports(method);
+    VDPAU::CVdpauRenderPicture *vdpauPic = m_buffers[m_iYV12RenderBuffer].vdpau;
+    if(vdpauPic && vdpauPic->vdpau)
+      return vdpauPic->vdpau->Supports(method);
 #endif
     return false;
   }
@@ -3348,14 +3497,7 @@ EINTERLACEMETHOD CLinuxRendererGL::AutoInterlaceMethod()
     return VS_INTERLACEMETHOD_NONE;
 
   if(m_renderMethod & RENDER_VDPAU)
-  {
-#ifdef HAVE_LIBVDPAU
-    CVDPAU *vdpau = m_buffers[m_iYV12RenderBuffer].vdpau;
-    if(vdpau)
-      return vdpau->AutoInterlaceMethod();
-#endif
     return VS_INTERLACEMETHOD_NONE;
-  }
 
   if(Supports(VS_INTERLACEMETHOD_RENDER_BOB))
     return VS_INTERLACEMETHOD_RENDER_BOB;
@@ -3400,6 +3542,7 @@ void CLinuxRendererGL::UnBindPbo(YUVBUFFER& buff)
 unsigned int CLinuxRendererGL::GetProcessorSize()
 {
   if(m_format == RENDER_FMT_VDPAU
+  || m_format == RENDER_FMT_VDPAU_420
   || m_format == RENDER_FMT_VAAPI
   || m_format == RENDER_FMT_CVBREF)
     return 1;
@@ -3428,11 +3571,12 @@ bool CLinuxRendererGL::IsProcessed(int idx)
 }
 
 #ifdef HAVE_LIBVDPAU
-void CLinuxRendererGL::AddProcessor(CVDPAU* vdpau, int index)
+void CLinuxRendererGL::AddProcessor(VDPAU::CVdpauRenderPicture *vdpau, int index)
 {
   YUVBUFFER &buf = m_buffers[index];
+  VDPAU::CVdpauRenderPicture *pic = vdpau->Acquire();
   SAFE_RELEASE(buf.vdpau);
-  buf.vdpau = (CVDPAU*)vdpau->Acquire();
+  buf.vdpau = pic;
 }
 #endif
 
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.h b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
index e239b92..d72eb64 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
@@ -39,12 +39,11 @@
 
 class CRenderCapture;
 
-class CVDPAU;
 class CBaseTexture;
 namespace Shaders { class BaseYUV2RGBShader; }
 namespace Shaders { class BaseVideoFilterShader; }
 namespace VAAPI   { struct CHolder; }
-
+namespace VDPAU   { class CVdpauRenderPicture; }
 
 #undef ALIGN
 #define ALIGN(value, alignment) (((value)+((alignment)-1))&~((alignment)-1))
@@ -144,7 +143,7 @@ class CLinuxRendererGL : public CBaseRenderer
   virtual bool         IsProcessed(int idx);
 
 #ifdef HAVE_LIBVDPAU
-  virtual void         AddProcessor(CVDPAU* vdpau, int index);
+  virtual void         AddProcessor(VDPAU::CVdpauRenderPicture* vdpau, int index);
 #endif
 #ifdef HAVE_LIBVA
   virtual void         AddProcessor(VAAPI::CHolder& holder, int index);
@@ -195,6 +194,10 @@ class CLinuxRendererGL : public CBaseRenderer
   void DeleteVDPAUTexture(int index);
   bool CreateVDPAUTexture(int index);
 
+  void UploadVDPAUTexture420(int index);
+  void DeleteVDPAUTexture420(int index);
+  bool CreateVDPAUTexture420(int index);
+
   void UploadVAAPITexture(int index);
   void DeleteVAAPITexture(int index);
   bool CreateVAAPITexture(int index);
@@ -221,6 +224,7 @@ class CLinuxRendererGL : public CBaseRenderer
   void RenderSinglePass(int renderBuffer, int field); // single pass glsl renderer
   void RenderSoftware(int renderBuffer, int field);   // single pass s/w yuv2rgb renderer
   void RenderVDPAU(int renderBuffer, int field);      // render using vdpau hardware
+  void RenderVDPAUYV12(int renderBuffer, int field);      // render using vdpau hardware
   void RenderVAAPI(int renderBuffer, int field);      // render using vdpau hardware
 
   struct
@@ -282,7 +286,7 @@ class CLinuxRendererGL : public CBaseRenderer
     GLsync    fence;
 
 #ifdef HAVE_LIBVDPAU
-    CVDPAU*   vdpau;
+    VDPAU::CVdpauRenderPicture *vdpau;
 #endif
 #ifdef HAVE_LIBVA
     VAAPI::CHolder& vaapi;
@@ -326,6 +330,7 @@ class CLinuxRendererGL : public CBaseRenderer
   bool  m_nonLinStretch;
   bool  m_nonLinStretchGui;
   float m_pixelRatio;
+  bool  m_skipRender;
 };
 
 
diff --git a/xbmc/cores/VideoRenderers/RenderFormats.h b/xbmc/cores/VideoRenderers/RenderFormats.h
index 4e8d7e9..6ed62be 100644
--- a/xbmc/cores/VideoRenderers/RenderFormats.h
+++ b/xbmc/cores/VideoRenderers/RenderFormats.h
@@ -26,6 +26,7 @@ enum ERenderFormat {
   RENDER_FMT_YUV420P10,
   RENDER_FMT_YUV420P16,
   RENDER_FMT_VDPAU,
+  RENDER_FMT_VDPAU_420,
   RENDER_FMT_NV12,
   RENDER_FMT_UYVY422,
   RENDER_FMT_YUYV422,
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index 44124a3..a59ee4d 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -925,7 +925,8 @@ int CXBMCRenderManager::AddVideoPicture(DVDVideoPicture& pic)
     CDVDCodecUtils::CopyDXVA2Picture(&image, &pic);
   }
 #ifdef HAVE_LIBVDPAU
-  else if(pic.format == RENDER_FMT_VDPAU)
+  else if(pic.format == RENDER_FMT_VDPAU
+       || pic.format == RENDER_FMT_VDPAU_420)
     m_pRenderer->AddProcessor(pic.vdpau, index);
 #endif
 #ifdef HAVE_LIBOPENMAX
diff --git a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
index 1d9116e..7a3a530 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.h
+++ b/xbmc/cores/VideoRenderers/RenderManager.h
@@ -35,7 +35,7 @@
 
 namespace DXVA { class CProcessor; }
 namespace VAAPI { class CSurfaceHolder; }
-class CVDPAU;
+namespace VDPAU { class CVdpauRenderPicture; }
 struct DVDVideoPicture;
 
 #define ERRORBUFFSIZE 30
diff --git a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
index 5b58f61..95f4a1e 100644
--- a/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
+++ b/xbmc/cores/VideoRenderers/VideoShaders/YUV2RGBShader.cpp
@@ -214,6 +214,8 @@ static void CalculateYUVMatrixGL(GLfloat      res[4][4]
     m_defines += "#define XBMC_YUY2\n";
   else if (m_format == RENDER_FMT_UYVY422)
     m_defines += "#define XBMC_UYVY\n";
+  else if (RENDER_FMT_VDPAU_420)
+    m_defines += "#define XBMC_VDPAU_NV12\n";
   else
     CLog::Log(LOGERROR, "GL: BaseYUV2RGBGLSLShader - unsupported format %d", m_format);
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
index 7abbd7e..13a2648 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -34,7 +34,7 @@
 
 namespace DXVA { class CSurfaceContext; }
 namespace VAAPI { struct CHolder; }
-class CVDPAU;
+namespace VDPAU { class CVdpauRenderPicture; }
 class COpenMax;
 class COpenMaxVideo;
 struct OpenMaxVideoBuffer;
@@ -55,7 +55,7 @@ struct DVDVideoPicture
       DXVA::CSurfaceContext* context;
     };
     struct {
-      CVDPAU* vdpau;
+      VDPAU::CVdpauRenderPicture* vdpau;
     };
     struct {
       VAAPI::CHolder* vaapi;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index 43c133c..ec93844 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -75,11 +75,11 @@ enum PixelFormat CDVDVideoCodecFFmpeg::GetFormat( struct AVCodecContext * avctx
   while(*cur != PIX_FMT_NONE)
   {
 #ifdef HAVE_LIBVDPAU
-    if(CVDPAU::IsVDPAUFormat(*cur) && CSettings::Get().GetBool("videoplayer.usevdpau"))
+    if(VDPAU::CDecoder::IsVDPAUFormat(*cur) && CSettings::Get().GetBool("videoplayer.usevdpau"))
     {
       CLog::Log(LOGNOTICE,"CDVDVideoCodecFFmpeg::GetFormat - Creating VDPAU(%ix%i)", avctx->width, avctx->height);
-      CVDPAU* vdp = new CVDPAU();
-      if(vdp->Open(avctx, *cur))
+      VDPAU::CDecoder* vdp = new VDPAU::CDecoder();
+      if(vdp->Open(avctx, *cur, ctx->m_uSurfacesCount))
       {
         ctx->SetHardware(vdp);
         return *cur;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
index 81b9af9..fd8b863 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.h
@@ -29,7 +29,6 @@
 #include "DllAvFilter.h"
 #include "DllPostProc.h"
 
-class CVDPAU;
 class CCriticalSection;
 
 class CDVDVideoCodecFFmpeg : public CDVDVideoCodec
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 4e00208..89ac10e 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -33,11 +33,16 @@
 #include "settings/MediaSettings.h"
 #include "Application.h"
 #include "utils/MathUtils.h"
+#include "utils/TimeUtils.h"
 #include "DVDCodecs/DVDCodecUtils.h"
+#include "cores/VideoRenderers/RenderFlags.h"
+
+using namespace VDPAU;
+#define NUM_RENDER_PICS 9
 
 #define ARSIZE(x) (sizeof(x) / sizeof((x)[0]))
 
-CVDPAU::Desc decoder_profiles[] = {
+CDecoder::Desc decoder_profiles[] = {
 {"MPEG1",        VDP_DECODER_PROFILE_MPEG1},
 {"MPEG2_SIMPLE", VDP_DECODER_PROFILE_MPEG2_SIMPLE},
 {"MPEG2_MAIN",   VDP_DECODER_PROFILE_MPEG2_MAIN},
@@ -51,14 +56,16 @@
 {"MPEG4_PART2_ASP", VDP_DECODER_PROFILE_MPEG4_PART2_ASP},
 #endif
 };
-const size_t decoder_profile_count = sizeof(decoder_profiles)/sizeof(CVDPAU::Desc);
+const size_t decoder_profile_count = sizeof(decoder_profiles)/sizeof(CDecoder::Desc);
 
-static float studioCSC[3][4] =
-{
-    { 1.0f,        0.0f, 1.57480000f,-0.78740000f},
-    { 1.0f,-0.18737736f,-0.46813736f, 0.32775736f},
-    { 1.0f, 1.85556000f,        0.0f,-0.92780000f}
-};
+//static float studioCSC[3][4] =
+//{
+//    { 1.0f,        0.0f, 1.57480000f,-0.78740000f},
+//    { 1.0f,-0.18737736f,-0.46813736f, 0.32775736f},
+//    { 1.0f, 1.85556000f,        0.0f,-0.92780000f}
+//};
+static float studioCSCKCoeffs601[3] = {0.299, 0.587, 0.114};  //BT601 {Kr, Kg, Kb}
+static float studioCSCKCoeffs709[3] = {0.2126, 0.7152, 0.0722};  //BT709 {Kr, Kg, Kb}
 
 static struct SInterlaceMapping
 {
@@ -69,114 +76,30 @@
 , {VS_INTERLACEMETHOD_VDPAU_TEMPORAL_HALF        , VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL}
 , {VS_INTERLACEMETHOD_VDPAU_TEMPORAL_SPATIAL     , VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL_SPATIAL}
 , {VS_INTERLACEMETHOD_VDPAU_TEMPORAL_SPATIAL_HALF, VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL_SPATIAL}
-, {VS_INTERLACEMETHOD_VDPAU_INVERSE_TELECINE     , VDP_VIDEO_MIXER_FEATURE_INVERSE_TELECINE} 
+, {VS_INTERLACEMETHOD_VDPAU_INVERSE_TELECINE     , VDP_VIDEO_MIXER_FEATURE_INVERSE_TELECINE}
 , {VS_INTERLACEMETHOD_NONE                       , (VdpVideoMixerFeature)-1}
 };
 
 //since libvdpau 0.4, vdp_device_create_x11() installs a callback on the Display*,
 //if we unload libvdpau with dlclose(), we segfault on XCloseDisplay,
 //so we just keep a static handle to libvdpau around
-void* CVDPAU::dl_handle;
+void* CDecoder::dl_handle;
+
+//-----------------------------------------------------------------------------
+// CVDPAU
+//-----------------------------------------------------------------------------
 
-CVDPAU::CVDPAU()
+CDecoder::CDecoder() : m_vdpauOutput(&m_inMsgEvent)
 {
-  glXBindTexImageEXT = NULL;
-  glXReleaseTexImageEXT = NULL;
-  vdp_device = VDP_INVALID_HANDLE;
-  surfaceNum      = presentSurfaceNum = 0;
-  picAge.b_age    = picAge.ip_age[0] = picAge.ip_age[1] = 256*256*256*64;
-  vdpauConfigured = false;
-  m_DisplayState = VDPAU_OPEN;
-  m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME;
-  m_mixerstep  = 0;
+  m_vdpauConfig.vdpDevice = VDP_INVALID_HANDLE;
+  m_vdpauConfig.videoSurfaces = &m_videoSurfaces;
+  m_vdpauConfig.videoSurfaceSec = &m_videoSurfaceSec;
 
-  m_glPixmap = 0;
-  m_Pixmap = 0;
-  if (!glXBindTexImageEXT)
-    glXBindTexImageEXT    = (PFNGLXBINDTEXIMAGEEXTPROC)glXGetProcAddress((GLubyte *) "glXBindTexImageEXT");
-  if (!glXReleaseTexImageEXT)
-    glXReleaseTexImageEXT = (PFNGLXRELEASETEXIMAGEEXTPROC)glXGetProcAddress((GLubyte *) "glXReleaseTexImageEXT");
+  m_vdpauConfigured = false;
+  m_DisplayState = VDPAU_OPEN;
+}
 
-  totalAvailableOutputSurfaces = 0;
-  outputSurface = presentSurface = VDP_INVALID_HANDLE;
-  vdp_flip_target = VDP_INVALID_HANDLE;
-  vdp_flip_queue = VDP_INVALID_HANDLE;
-  vid_width = vid_height = OutWidth = OutHeight = 0;
-  surface_width = surface_height = 0;
-  
-  memset(&decoder, 0, sizeof(decoder));
-  memset(&outRect, 0, sizeof(outRect));
-  memset(&outRectVid, 0, sizeof(outRectVid));
-
-  m_Display = NULL;
-
-  tmpBrightness  = 0;
-  tmpContrast    = 0;
-  tmpDeintMode   = 0;
-  tmpDeintGUI    = 0;
-  tmpDeint       = 0;
-  max_references = 0;
-
-  for (int i = 0; i < NUM_OUTPUT_SURFACES; i++)
-    outputSurfaces[i] = VDP_INVALID_HANDLE;
-
-  videoMixer = VDP_INVALID_HANDLE;
-  m_BlackBar = NULL;
-
-  memset(m_features, 0, sizeof(m_features));
-  m_feature_count = 0;
-  m_vdpauOutputMethod = OUTPUT_NONE;
-
-  upScale = g_advancedSettings.m_videoVDPAUScaling;
-
-  vdp_video_mixer_set_attribute_values = NULL;
-  vdp_generate_csc_matrix = NULL;
-  vdp_presentation_queue_target_destroy = NULL;
-  vdp_presentation_queue_create = NULL;
-  vdp_presentation_queue_destroy = NULL;
-  vdp_presentation_queue_display = NULL;
-  vdp_presentation_queue_block_until_surface_idle = NULL;
-  vdp_presentation_queue_target_create_x11 = NULL;
-  vdp_presentation_queue_query_surface_status = NULL;
-  vdp_presentation_queue_get_time = NULL;
-  vdp_get_error_string = NULL;
-  vdp_decoder_create = NULL;
-  vdp_decoder_destroy = NULL;
-  vdp_decoder_render = NULL;
-  vdp_decoder_query_caps = NULL;
-  vdp_preemption_callback_register = NULL;
-  dl_vdp_device_create_x11 = NULL;
-  dl_vdp_get_proc_address = NULL;
-  dl_vdp_preemption_callback_register = NULL;
-  past[0] = NULL;
-  past[1] = NULL;
-  current = NULL;
-  future = NULL;
-  tmpNoiseReduction = 0.0f;
-  tmpSharpness = 0.0f;
-  vdp_get_proc_address = NULL;
-  vdp_device_destroy = NULL;
-  vdp_video_surface_create = NULL;
-  vdp_video_surface_destroy = NULL;
-  vdp_video_surface_put_bits_y_cb_cr = NULL;
-  vdp_video_surface_get_bits_y_cb_cr = NULL;
-  vdp_output_surface_put_bits_y_cb_cr = NULL;
-  vdp_output_surface_put_bits_native = NULL;
-  vdp_output_surface_create = NULL;
-  vdp_output_surface_destroy = NULL;
-  vdp_output_surface_get_bits_native = NULL;
-  vdp_output_surface_render_output_surface = NULL;
-  vdp_output_surface_put_bits_indexed = NULL;
-  vdp_video_mixer_create = NULL;
-  vdp_video_mixer_set_feature_enables = NULL;
-  vdp_video_mixer_query_parameter_support = NULL;
-  vdp_video_mixer_query_feature_support = NULL;
-  vdp_video_mixer_destroy = NULL;
-  vdp_video_mixer_render = NULL;
-  m_hwContext.bitstream_buffers_allocated = 0;
-}
-
-bool CVDPAU::Open(AVCodecContext* avctx, const enum PixelFormat, unsigned int surfaces)
+bool CDecoder::Open(AVCodecContext* avctx, const enum PixelFormat, unsigned int surfaces)
 {
   if(avctx->coded_width  == 0
   || avctx->coded_height == 0)
@@ -184,6 +107,8 @@ bool CVDPAU::Open(AVCodecContext* avctx, const enum PixelFormat, unsigned int su
     CLog::Log(LOGWARNING,"(VDPAU) no width/height available, can't init");
     return false;
   }
+  m_vdpauConfig.numRenderBuffers = surfaces;
+  m_decoderThread = CThread::GetCurrentThreadId();
 
   if ((avctx->codec_id == AV_CODEC_ID_MPEG4) && !g_advancedSettings.m_videoAllowMpeg4VDPAU)
     return false;
@@ -198,8 +123,6 @@ bool CVDPAU::Open(AVCodecContext* avctx, const enum PixelFormat, unsigned int su
         error = "dlerror() returned NULL";
 
       CLog::Log(LOGNOTICE,"(VDPAU) Unable to get handle to libvdpau: %s", error);
-      //g_application.m_guiDialogKaiToast.QueueNotification(CGUIDialogKaiToast::Error, "VDPAU", error, 10000);
-
       return false;
     }
   }
@@ -208,8 +131,9 @@ bool CVDPAU::Open(AVCodecContext* avctx, const enum PixelFormat, unsigned int su
     return false;
 
   InitVDPAUProcs();
+  m_presentPicture = 0;
 
-  if (vdp_device != VDP_INVALID_HANDLE)
+  if (m_vdpauConfig.vdpDevice != VDP_INVALID_HANDLE)
   {
     SpewHardwareAvailable();
 
@@ -227,28 +151,26 @@ bool CVDPAU::Open(AVCodecContext* avctx, const enum PixelFormat, unsigned int su
    
       /* attempt to create a decoder with this width/height, some sizes are not supported by hw */
       VdpStatus vdp_st;
-      vdp_st = vdp_decoder_create(vdp_device, profile, avctx->coded_width, avctx->coded_height, 5, &decoder);
+      vdp_st = m_vdpauConfig.vdpProcs.vdp_decoder_create(m_vdpauConfig.vdpDevice, profile, avctx->coded_width, avctx->coded_height, 5, &m_vdpauConfig.vdpDecoder);
 
       if(vdp_st != VDP_STATUS_OK)
       {
-        CLog::Log(LOGERROR, " (VDPAU) Error: %s(%d) checking for decoder support\n", vdp_get_error_string(vdp_st), vdp_st);
+        CLog::Log(LOGERROR, " (VDPAU) Error: %s(%d) checking for decoder support\n", m_vdpauConfig.vdpProcs.vdp_get_error_string(vdp_st), vdp_st);
         FiniVDPAUProcs();
         return false;
       }
 
-      vdp_decoder_destroy(decoder);
+      m_vdpauConfig.vdpProcs.vdp_decoder_destroy(m_vdpauConfig.vdpDecoder);
       CheckStatus(vdp_st, __LINE__);
     }
 
-    InitCSCMatrix(avctx->coded_height);
-
     /* finally setup ffmpeg */
     memset(&m_hwContext, 0, sizeof(AVVDPAUContext));
-    m_hwContext.render = CVDPAU::Render;
+    m_hwContext.render = CDecoder::Render;
     m_hwContext.bitstream_buffers_allocated = 0;
-    avctx->get_buffer      = CVDPAU::FFGetBuffer;
-    avctx->release_buffer  = CVDPAU::FFReleaseBuffer;
-    avctx->draw_horiz_band = CVDPAU::FFDrawSlice;
+    avctx->get_buffer      = CDecoder::FFGetBuffer;
+    avctx->release_buffer  = CDecoder::FFReleaseBuffer;
+    avctx->draw_horiz_band = CDecoder::FFDrawSlice;
     avctx->slice_flags=SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
     avctx->hwaccel_context = &m_hwContext;
     avctx->thread_count    = 1;
@@ -259,17 +181,20 @@ bool CVDPAU::Open(AVCodecContext* avctx, const enum PixelFormat, unsigned int su
   return false;
 }
 
-CVDPAU::~CVDPAU()
+CDecoder::~CDecoder()
 {
   Close();
 }
 
-void CVDPAU::Close()
+void CDecoder::Close()
 {
   CLog::Log(LOGNOTICE, " (VDPAU) %s", __FUNCTION__);
 
+  CSingleLock lock(m_DecoderSection);
+
   FiniVDPAUOutput();
   FiniVDPAUProcs();
+  m_vdpauOutput.Dispose();
 
   while (!m_videoSurfaces.empty())
   {
@@ -287,191 +212,120 @@ void CVDPAU::Close()
   }
 
   g_Windowing.Unregister(this);
+
+  if (m_hwContext.bitstream_buffers_allocated)
+  {
+    m_dllAvUtil.av_freep(&m_hwContext.bitstream_buffers);
+  }
+
   m_dllAvUtil.Unload();
 }
 
-bool CVDPAU::MakePixmapGL()
+long CDecoder::Release()
 {
-  int num=0;
-  int fbConfigIndex = 0;
-
-  int doubleVisAttributes[] = {
-    GLX_RENDER_TYPE, GLX_RGBA_BIT,
-    GLX_RED_SIZE, 8,
-    GLX_GREEN_SIZE, 8,
-    GLX_BLUE_SIZE, 8,
-    GLX_ALPHA_SIZE, 8,
-    GLX_DEPTH_SIZE, 8,
-    GLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT,
-    GLX_BIND_TO_TEXTURE_RGBA_EXT, True,
-    GLX_DOUBLEBUFFER, True,
-    GLX_Y_INVERTED_EXT, True,
-    GLX_X_RENDERABLE, True,
-    None
-  };
-
-  int pixmapAttribs[] = {
-    GLX_TEXTURE_TARGET_EXT, GLX_TEXTURE_2D_EXT,
-    GLX_TEXTURE_FORMAT_EXT, GLX_TEXTURE_FORMAT_RGBA_EXT,
-    None
-  };
-
-  GLXFBConfig *fbConfigs;
-  fbConfigs = glXChooseFBConfig(m_Display, DefaultScreen(m_Display), doubleVisAttributes, &num);
-  if (fbConfigs==NULL)
+  // check if we should do some pre-cleanup here
+  // a second decoder might need resources
+  if (m_vdpauConfigured == true)
   {
-    CLog::Log(LOGERROR, "GLX Error: MakePixmap: No compatible framebuffers found");
-    return false;
-  }
-  CLog::Log(LOGDEBUG, "Found %d fbconfigs.", num);
-  fbConfigIndex = 0;
-  CLog::Log(LOGDEBUG, "Using fbconfig index %d.", fbConfigIndex);
+    CSingleLock lock(m_DecoderSection);
+    CLog::Log(LOGNOTICE,"CVDPAU::Release pre-cleanup");
 
-  m_glPixmap = glXCreatePixmap(m_Display, fbConfigs[fbConfigIndex], m_Pixmap, pixmapAttribs);
+    Message *reply;
+    if (m_vdpauOutput.m_controlPort.SendOutMessageSync(COutputControlProtocol::PRECLEANUP,
+                                                   &reply,
+                                                   2000))
+    {
+      bool success = reply->signal == COutputControlProtocol::ACC ? true : false;
+      reply->Release();
+      if (!success)
+      {
+        CLog::Log(LOGERROR, "VDPAU::%s - pre-cleanup returned error", __FUNCTION__);
+        m_DisplayState = VDPAU_ERROR;
+      }
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "VDPAU::%s - pre-cleanup timed out", __FUNCTION__);
+      m_DisplayState = VDPAU_ERROR;
+    }
 
-  if (!m_glPixmap)
-  {
-    CLog::Log(LOGINFO, "GLX Error: Could not create Pixmap");
-    XFree(fbConfigs);
-    return false;
+    for(unsigned int i = 0; i < m_videoSurfaces.size(); ++i)
+    {
+      vdpau_render_state *render = m_videoSurfaces[i];
+      if (render->surface != VDP_INVALID_HANDLE && !(render->state & FF_VDPAU_STATE_USED_FOR_RENDER))
+      {
+        m_vdpauConfig.vdpProcs.vdp_video_surface_destroy(render->surface);
+        render->surface = VDP_INVALID_HANDLE;
+      }
+    }
   }
-  XFree(fbConfigs);
+  IHardwareDecoder::Release();
+}
 
-  return true;
+long CDecoder::ReleasePicReference()
+{
+  return IHardwareDecoder::Release();
 }
 
-bool CVDPAU::MakePixmap(int width, int height)
+void CDecoder::SetWidthHeight(int width, int height)
 {
+  m_vdpauConfig.upscale = g_advancedSettings.m_videoVDPAUScaling;
+
   //pick the smallest dimensions, so we downscale with vdpau and upscale with opengl when appropriate
   //this requires the least amount of gpu memory bandwidth
-  if (g_graphicsContext.GetWidth() < width || g_graphicsContext.GetHeight() < height || upScale)
+  if (g_graphicsContext.GetWidth() < width || g_graphicsContext.GetHeight() < height || m_vdpauConfig.upscale >= 0)
   {
     //scale width to desktop size if the aspect ratio is the same or bigger than the desktop
     if ((double)height * g_graphicsContext.GetWidth() / width <= (double)g_graphicsContext.GetHeight())
     {
-      OutWidth = g_graphicsContext.GetWidth();
-      OutHeight = MathUtils::round_int((double)height * g_graphicsContext.GetWidth() / width);
+      m_vdpauConfig.outWidth = g_graphicsContext.GetWidth();
+      m_vdpauConfig.outHeight = MathUtils::round_int((double)height * g_graphicsContext.GetWidth() / width);
     }
     else //scale height to the desktop size if the aspect ratio is smaller than the desktop
     {
-      OutHeight = g_graphicsContext.GetHeight();
-      OutWidth = MathUtils::round_int((double)width * g_graphicsContext.GetHeight() / height);
+      m_vdpauConfig.outHeight = g_graphicsContext.GetHeight();
+      m_vdpauConfig.outWidth = MathUtils::round_int((double)width * g_graphicsContext.GetHeight() / height);
     }
   }
   else
   { //let opengl scale
-    OutWidth = width;
-    OutHeight = height;
-  }
-
-  CLog::Log(LOGNOTICE,"Creating %ix%i pixmap", OutWidth, OutHeight);
-
-    // Get our window attribs.
-  XWindowAttributes wndattribs;
-  XGetWindowAttributes(m_Display, DefaultRootWindow(m_Display), &wndattribs); // returns a status but I don't know what success is
-
-  m_Pixmap = XCreatePixmap(m_Display,
-                           DefaultRootWindow(m_Display),
-                           OutWidth,
-                           OutHeight,
-                           wndattribs.depth);
-  if (!m_Pixmap)
-  {
-    CLog::Log(LOGERROR, "GLX Error: MakePixmap: Unable to create XPixmap");
-    return false;
-  }
-
-  XGCValues values = {};
-  GC xgc;
-  values.foreground = BlackPixel (m_Display, DefaultScreen (m_Display));
-  xgc = XCreateGC(m_Display, m_Pixmap, GCForeground, &values);
-  XFillRectangle(m_Display, m_Pixmap, xgc, 0, 0, OutWidth, OutHeight);
-  XFreeGC(m_Display, xgc);
-
-  if(!MakePixmapGL())
-    return false;
-
-  return true;
-}
-
-void CVDPAU::BindPixmap()
-{
-  CSharedLock lock(m_DecoderSection);
-
-  { CSharedLock dLock(m_DisplaySection);
-    if (m_DisplayState != VDPAU_OPEN)
-      return;
-  }
-
-  if (m_glPixmap)
-  {
-    if(presentSurface != VDP_INVALID_HANDLE)
-    {
-      VdpPresentationQueueStatus status;
-      VdpTime time;
-      VdpStatus vdp_st;
-      vdp_st = vdp_presentation_queue_query_surface_status(
-                    vdp_flip_queue, presentSurface, &status, &time);
-      CheckStatus(vdp_st, __LINE__);
-      while(status != VDP_PRESENTATION_QUEUE_STATUS_VISIBLE && vdp_st == VDP_STATUS_OK)
-      {
-        Sleep(1);
-        vdp_st = vdp_presentation_queue_query_surface_status(
-                      vdp_flip_queue, presentSurface, &status, &time);
-        CheckStatus(vdp_st, __LINE__);
-      }
-    }
-    
-    glXBindTexImageEXT(m_Display, m_glPixmap, GLX_FRONT_LEFT_EXT, NULL);
-  }
-  else CLog::Log(LOGERROR,"(VDPAU) BindPixmap called without valid pixmap");
-}
-
-void CVDPAU::ReleasePixmap()
-{
-  CSharedLock lock(m_DecoderSection);
-
-  { CSharedLock dLock(m_DisplaySection);
-    if (m_DisplayState != VDPAU_OPEN)
-      return;
-  }
-
-  if (m_glPixmap)
-  {
-    glXReleaseTexImageEXT(m_Display, m_glPixmap, GLX_FRONT_LEFT_EXT);
+    m_vdpauConfig.outWidth = width;
+    m_vdpauConfig.outHeight = height;
   }
-  else CLog::Log(LOGERROR,"(VDPAU) ReleasePixmap called without valid pixmap");
+  CLog::Log(LOGDEBUG, "CVDPAU::SetWidthHeight Setting OutWidth: %i OutHeight: %i", m_vdpauConfig.outWidth, m_vdpauConfig.outHeight);
 }
 
-void CVDPAU::OnLostDevice()
+void CDecoder::OnLostDevice()
 {
   CLog::Log(LOGNOTICE,"CVDPAU::OnLostDevice event");
 
-  CExclusiveLock lock(m_DecoderSection);
+  CSingleLock lock(m_DecoderSection);
   FiniVDPAUOutput();
   FiniVDPAUProcs();
 
   m_DisplayState = VDPAU_LOST;
+  lock.Leave();
   m_DisplayEvent.Reset();
 }
 
-void CVDPAU::OnResetDevice()
+void CDecoder::OnResetDevice()
 {
   CLog::Log(LOGNOTICE,"CVDPAU::OnResetDevice event");
 
-  CExclusiveLock lock(m_DisplaySection);
+  CSingleLock lock(m_DecoderSection);
   if (m_DisplayState == VDPAU_LOST)
   {
     m_DisplayState = VDPAU_RESET;
+    lock.Leave();
     m_DisplayEvent.Set();
   }
 }
 
-int CVDPAU::Check(AVCodecContext* avctx)
+int CDecoder::Check(AVCodecContext* avctx)
 {
   EDisplayState state;
 
-  { CSharedLock lock(m_DisplaySection);
+  { CSingleLock lock(m_DecoderSection);
     state = m_DisplayState;
   }
 
@@ -485,16 +339,13 @@ int CVDPAU::Check(AVCodecContext* avctx)
     }
     else
     {
-      CSharedLock lock(m_DisplaySection);
+      CSingleLock lock(m_DecoderSection);
       state = m_DisplayState;
     }
   }
   if (state == VDPAU_RESET || state == VDPAU_ERROR)
   {
-    CLog::Log(LOGNOTICE,"Attempting recovery");
-
-    CSingleLock gLock(g_graphicsContext);
-    CExclusiveLock lock(m_DecoderSection);
+    CSingleLock lock(m_DecoderSection);
 
     FiniVDPAUOutput();
     FiniVDPAUProcs();
@@ -509,7 +360,7 @@ int CVDPAU::Check(AVCodecContext* avctx)
   return 0;
 }
 
-bool CVDPAU::IsVDPAUFormat(PixelFormat format)
+bool CDecoder::IsVDPAUFormat(PixelFormat format)
 {
   if (format == AV_PIX_FMT_VDPAU)
     return true;
@@ -517,90 +368,28 @@ bool CVDPAU::IsVDPAUFormat(PixelFormat format)
     return false;
 }
 
-void CVDPAU::CheckFeatures()
-{
-  if (videoMixer == VDP_INVALID_HANDLE)
-  {
-    CLog::Log(LOGNOTICE, " (VDPAU) Creating the video mixer");
-    // Creation of VideoMixer.
-    VdpVideoMixerParameter parameters[] = {
-      VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_WIDTH,
-      VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_HEIGHT,
-      VDP_VIDEO_MIXER_PARAMETER_CHROMA_TYPE
-    };
-
-    void const * parameter_values[] = {
-      &surface_width,
-      &surface_height,
-      &vdp_chroma_type
-    };
-
-    tmpBrightness = 0;
-    tmpContrast = 0;
-    tmpNoiseReduction = 0;
-    tmpSharpness = 0;
-
-    VdpStatus vdp_st = vdp_video_mixer_create(vdp_device,
-                                    m_feature_count,
-                                    m_features,
-                                    ARSIZE(parameters),
-                                    parameters,
-                                    parameter_values,
-                                    &videoMixer);
-    CheckStatus(vdp_st, __LINE__);
-
-    SetHWUpscaling();
-  }
-
-  if (tmpBrightness != CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness ||
-      tmpContrast   != CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast)
-  {
-    SetColor();
-    tmpBrightness = CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness;
-    tmpContrast = CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast;
-  }
-  if (tmpNoiseReduction != CMediaSettings::Get().GetCurrentVideoSettings().m_NoiseReduction)
-  {
-    tmpNoiseReduction = CMediaSettings::Get().GetCurrentVideoSettings().m_NoiseReduction;
-    SetNoiseReduction();
-  }
-  if (tmpSharpness != CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness)
-  {
-    tmpSharpness = CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness;
-    SetSharpness();
-  }
-  if (  tmpDeintMode != CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode ||
-        tmpDeintGUI  != CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod ||
-       (tmpDeintGUI == VS_INTERLACEMETHOD_AUTO && tmpDeint != AutoInterlaceMethod()))
-  {
-    tmpDeintMode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
-    tmpDeintGUI  = CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod;
-    if (tmpDeintGUI == VS_INTERLACEMETHOD_AUTO)
-      tmpDeint = AutoInterlaceMethod();
-    else
-      tmpDeint = tmpDeintGUI;
-
-    SetDeinterlacing();
-  }
-}
-
-bool CVDPAU::Supports(VdpVideoMixerFeature feature)
+bool CDecoder::Supports(VdpVideoMixerFeature feature)
 {
-  for(int i = 0; i < m_feature_count; i++)
+  for(int i = 0; i < m_vdpauConfig.featureCount; i++)
   {
-    if(m_features[i] == feature)
+    if(m_vdpauConfig.vdpFeatures[i] == feature)
       return true;
   }
   return false;
 }
 
-bool CVDPAU::Supports(EINTERLACEMETHOD method)
+bool CDecoder::Supports(EINTERLACEMETHOD method)
 {
   if(method == VS_INTERLACEMETHOD_VDPAU_BOB
-  || method == VS_INTERLACEMETHOD_AUTO
-  || method == VS_INTERLACEMETHOD_AUTO_ION)
+  || method == VS_INTERLACEMETHOD_AUTO)
     return true;
 
+  if (CSettings::Get().GetBool("videoplayer.usevdpauinteropyuv"))
+  {
+    if (method == VS_INTERLACEMETHOD_RENDER_BOB)
+      return true;
+  }
+
   for(SInterlaceMapping* p = g_interlace_mapping; p->method != VS_INTERLACEMETHOD_NONE; p++)
   {
     if(p->method == method)
@@ -609,162 +398,12 @@ bool CVDPAU::Supports(EINTERLACEMETHOD method)
   return false;
 }
 
-EINTERLACEMETHOD CVDPAU::AutoInterlaceMethod()
-{
-  return VS_INTERLACEMETHOD_VDPAU_TEMPORAL;
-}
-
-void CVDPAU::SetColor()
-{
-  VdpStatus vdp_st;
-
-  if (tmpBrightness != CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness)
-    m_Procamp.brightness = (float)((CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness)-50) / 100;
-  if (tmpContrast != CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast)
-    m_Procamp.contrast = (float)((CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast)+50) / 100;
-
-  if(vid_height >= 600 || vid_width > 1024)
-    vdp_st = vdp_generate_csc_matrix(&m_Procamp, VDP_COLOR_STANDARD_ITUR_BT_709, &m_CSCMatrix);
-  else
-    vdp_st = vdp_generate_csc_matrix(&m_Procamp, VDP_COLOR_STANDARD_ITUR_BT_601, &m_CSCMatrix);
-
-  VdpVideoMixerAttribute attributes[] = { VDP_VIDEO_MIXER_ATTRIBUTE_CSC_MATRIX };
-  if (CSettings::Get().GetBool("videoscreen.limitedrange"))
-  {
-    void const * pm_CSCMatix[] = { &studioCSC };
-    vdp_st = vdp_video_mixer_set_attribute_values(videoMixer, ARSIZE(attributes), attributes, pm_CSCMatix);
-  }
-  else
-  {
-    void const * pm_CSCMatix[] = { &m_CSCMatrix };
-    vdp_st = vdp_video_mixer_set_attribute_values(videoMixer, ARSIZE(attributes), attributes, pm_CSCMatix);
-  }
-  CheckStatus(vdp_st, __LINE__);
-}
-
-void CVDPAU::SetNoiseReduction()
-{
-  if(!Supports(VDP_VIDEO_MIXER_FEATURE_NOISE_REDUCTION))
-    return;
-
-  VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_NOISE_REDUCTION };
-  VdpVideoMixerAttribute attributes[] = { VDP_VIDEO_MIXER_ATTRIBUTE_NOISE_REDUCTION_LEVEL };
-  VdpStatus vdp_st;
-
-  if (!CMediaSettings::Get().GetCurrentVideoSettings().m_NoiseReduction)
-  {
-    VdpBool enabled[]= {0};
-    vdp_st = vdp_video_mixer_set_feature_enables(videoMixer, ARSIZE(feature), feature, enabled);
-    CheckStatus(vdp_st, __LINE__);
-    return;
-  }
-  VdpBool enabled[]={1};
-  vdp_st = vdp_video_mixer_set_feature_enables(videoMixer, ARSIZE(feature), feature, enabled);
-  CheckStatus(vdp_st, __LINE__);
-  void* nr[] = { &CMediaSettings::Get().GetCurrentVideoSettings().m_NoiseReduction };
-  CLog::Log(LOGNOTICE,"Setting Noise Reduction to %f",CMediaSettings::Get().GetCurrentVideoSettings().m_NoiseReduction);
-  vdp_st = vdp_video_mixer_set_attribute_values(videoMixer, ARSIZE(attributes), attributes, nr);
-  CheckStatus(vdp_st, __LINE__);
-}
-
-void CVDPAU::SetSharpness()
-{
-  if(!Supports(VDP_VIDEO_MIXER_FEATURE_SHARPNESS))
-    return;
-  
-  VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_SHARPNESS };
-  VdpVideoMixerAttribute attributes[] = { VDP_VIDEO_MIXER_ATTRIBUTE_SHARPNESS_LEVEL };
-  VdpStatus vdp_st;
-
-  if (!CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness)
-  {
-    VdpBool enabled[]={0};
-    vdp_st = vdp_video_mixer_set_feature_enables(videoMixer, ARSIZE(feature), feature, enabled);
-    CheckStatus(vdp_st, __LINE__);
-    return;
-  }
-  VdpBool enabled[]={1};
-  vdp_st = vdp_video_mixer_set_feature_enables(videoMixer, ARSIZE(feature), feature, enabled);
-  CheckStatus(vdp_st, __LINE__);
-  void* sh[] = { &CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness };
-  CLog::Log(LOGNOTICE,"Setting Sharpness to %f",CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness);
-  vdp_st = vdp_video_mixer_set_attribute_values(videoMixer, ARSIZE(attributes), attributes, sh);
-  CheckStatus(vdp_st, __LINE__);
-}
-
-void CVDPAU::SetHWUpscaling()
-{
-#ifdef VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L1
-  if(!Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L1) || !upScale)
-    return;
-
-  VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L1 };
-  VdpStatus vdp_st;
-  VdpBool enabled[]={1};
-  vdp_st = vdp_video_mixer_set_feature_enables(videoMixer, ARSIZE(feature), feature, enabled);
-  CheckStatus(vdp_st, __LINE__);
-#endif
-}
-
-void CVDPAU::SetDeinterlacing()
+EINTERLACEMETHOD CDecoder::AutoInterlaceMethod()
 {
-  VdpStatus vdp_st;
-  EDEINTERLACEMODE   mode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
-  EINTERLACEMETHOD method = CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod;
-  if (method == VS_INTERLACEMETHOD_AUTO)
-    method = AutoInterlaceMethod();
-
-  VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL,
-                                     VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL_SPATIAL,
-                                     VDP_VIDEO_MIXER_FEATURE_INVERSE_TELECINE };
-  if (mode == VS_DEINTERLACEMODE_OFF)
-  {
-    VdpBool enabled[]={0,0,0};
-    vdp_st = vdp_video_mixer_set_feature_enables(videoMixer, ARSIZE(feature), feature, enabled);
-  }
-  else
-  {
-    if (method == VS_INTERLACEMETHOD_AUTO_ION)
-    {
-      if (vid_height <= 576)
-      {
-        VdpBool enabled[]={1,1,0};
-        vdp_st = vdp_video_mixer_set_feature_enables(videoMixer, ARSIZE(feature), feature, enabled);
-      }
-      else if (vid_height > 576)
-      {
-        VdpBool enabled[]={1,0,0};
-        vdp_st = vdp_video_mixer_set_feature_enables(videoMixer, ARSIZE(feature), feature, enabled);
-      }
-    }
-    else if (method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL
-         ||  method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_HALF)
-    {
-      VdpBool enabled[]={1,0,0};
-      vdp_st = vdp_video_mixer_set_feature_enables(videoMixer, ARSIZE(feature), feature, enabled);
-    }
-    else if (method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_SPATIAL
-         ||  method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_SPATIAL_HALF)
-    {
-      VdpBool enabled[]={1,1,0};
-      vdp_st = vdp_video_mixer_set_feature_enables(videoMixer, ARSIZE(feature), feature, enabled);
-    }
-    else if (method == VS_INTERLACEMETHOD_VDPAU_INVERSE_TELECINE)
-    {
-      VdpBool enabled[]={1,0,1};
-      vdp_st = vdp_video_mixer_set_feature_enables(videoMixer, ARSIZE(feature), feature, enabled);
-    }
-    else
-    {
-      VdpBool enabled[]={0,0,0};
-      vdp_st = vdp_video_mixer_set_feature_enables(videoMixer, ARSIZE(feature), feature, enabled);
-    }
-  }
-
-  CheckStatus(vdp_st, __LINE__);
+  return VS_INTERLACEMETHOD_RENDER_BOB;
 }
 
-void CVDPAU::InitVDPAUProcs()
+void CDecoder::InitVDPAUProcs()
 {
   char* error;
 
@@ -774,151 +413,115 @@ void CVDPAU::InitVDPAUProcs()
   if (error)
   {
     CLog::Log(LOGERROR,"(VDPAU) - %s in %s",error,__FUNCTION__);
-    vdp_device = VDP_INVALID_HANDLE;
-
-    //g_application.m_guiDialogKaiToast.QueueNotification(CGUIDialogKaiToast::Error, "VDPAU", error, 10000);
-
+    m_vdpauConfig.vdpDevice = VDP_INVALID_HANDLE;
     return;
   }
 
   if (dl_vdp_device_create_x11)
   {
-    CSingleLock lock(g_graphicsContext);
-    m_Display = g_Windowing.GetDisplay();
-  }
-  else
-  {
-    CLog::Log(LOGERROR,"(VDPAU) - Unable to get dl_vdp_device_create_x11 in %s", __FUNCTION__);
-    vdp_device = VDP_INVALID_HANDLE;
-    return;
+    m_Display = XOpenDisplay(NULL);
   }
 
-  int mScreen = DefaultScreen(m_Display);
+  int mScreen = g_Windowing.GetCurrentScreen();
   VdpStatus vdp_st;
 
   // Create Device
-  // tested on 64bit Ubuntu 11.10 and it deadlocked without this
-  XLockDisplay(m_Display);
   vdp_st = dl_vdp_device_create_x11(m_Display, //x_display,
                                  mScreen, //x_screen,
-                                 &vdp_device,
-                                 &vdp_get_proc_address);
-  XUnlockDisplay(m_Display);
+                                 &m_vdpauConfig.vdpDevice,
+                                 &m_vdpauConfig.vdpProcs.vdp_get_proc_address);
 
-  CLog::Log(LOGNOTICE,"vdp_device = 0x%08x vdp_st = 0x%08x",vdp_device,vdp_st);
+  CLog::Log(LOGNOTICE,"vdp_device = 0x%08x vdp_st = 0x%08x",m_vdpauConfig.vdpDevice,vdp_st);
   if (vdp_st != VDP_STATUS_OK)
   {
     CLog::Log(LOGERROR,"(VDPAU) unable to init VDPAU - vdp_st = 0x%x.  Falling back.",vdp_st);
-    vdp_device = VDP_INVALID_HANDLE;
+    m_vdpauConfig.vdpDevice = VDP_INVALID_HANDLE;
     return;
   }
 
 #define VDP_PROC(id, proc) \
   do { \
-    vdp_st = vdp_get_proc_address(vdp_device, id, (void**)&proc); \
+    vdp_st = m_vdpauConfig.vdpProcs.vdp_get_proc_address(m_vdpauConfig.vdpDevice, id, (void**)&proc); \
     CheckStatus(vdp_st, __LINE__); \
   } while(0);
 
-  VDP_PROC(VDP_FUNC_ID_GET_ERROR_STRING                    , vdp_get_error_string);
-  VDP_PROC(VDP_FUNC_ID_DEVICE_DESTROY                      , vdp_device_destroy);
-  VDP_PROC(VDP_FUNC_ID_GENERATE_CSC_MATRIX                 , vdp_generate_csc_matrix);
-  VDP_PROC(VDP_FUNC_ID_VIDEO_SURFACE_CREATE                , vdp_video_surface_create);
-  VDP_PROC(VDP_FUNC_ID_VIDEO_SURFACE_DESTROY               , vdp_video_surface_destroy);
-  VDP_PROC(VDP_FUNC_ID_VIDEO_SURFACE_PUT_BITS_Y_CB_CR      , vdp_video_surface_put_bits_y_cb_cr);
-  VDP_PROC(VDP_FUNC_ID_VIDEO_SURFACE_GET_BITS_Y_CB_CR      , vdp_video_surface_get_bits_y_cb_cr);
-  VDP_PROC(VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_Y_CB_CR     , vdp_output_surface_put_bits_y_cb_cr);
-  VDP_PROC(VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_NATIVE      , vdp_output_surface_put_bits_native);
-  VDP_PROC(VDP_FUNC_ID_OUTPUT_SURFACE_CREATE               , vdp_output_surface_create);
-  VDP_PROC(VDP_FUNC_ID_OUTPUT_SURFACE_DESTROY              , vdp_output_surface_destroy);
-  VDP_PROC(VDP_FUNC_ID_OUTPUT_SURFACE_GET_BITS_NATIVE      , vdp_output_surface_get_bits_native);
-  VDP_PROC(VDP_FUNC_ID_OUTPUT_SURFACE_RENDER_OUTPUT_SURFACE, vdp_output_surface_render_output_surface);
-  VDP_PROC(VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_INDEXED     , vdp_output_surface_put_bits_indexed);  
-  VDP_PROC(VDP_FUNC_ID_VIDEO_MIXER_CREATE                  , vdp_video_mixer_create);
-  VDP_PROC(VDP_FUNC_ID_VIDEO_MIXER_SET_FEATURE_ENABLES     , vdp_video_mixer_set_feature_enables);
-  VDP_PROC(VDP_FUNC_ID_VIDEO_MIXER_DESTROY                 , vdp_video_mixer_destroy);
-  VDP_PROC(VDP_FUNC_ID_VIDEO_MIXER_RENDER                  , vdp_video_mixer_render);
-  VDP_PROC(VDP_FUNC_ID_VIDEO_MIXER_SET_ATTRIBUTE_VALUES    , vdp_video_mixer_set_attribute_values);
-  VDP_PROC(VDP_FUNC_ID_VIDEO_MIXER_QUERY_PARAMETER_SUPPORT , vdp_video_mixer_query_parameter_support);
-  VDP_PROC(VDP_FUNC_ID_VIDEO_MIXER_QUERY_FEATURE_SUPPORT   , vdp_video_mixer_query_feature_support);
-  VDP_PROC(VDP_FUNC_ID_DECODER_CREATE                      , vdp_decoder_create);
-  VDP_PROC(VDP_FUNC_ID_DECODER_DESTROY                     , vdp_decoder_destroy);
-  VDP_PROC(VDP_FUNC_ID_DECODER_RENDER                      , vdp_decoder_render);
-  VDP_PROC(VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES          , vdp_decoder_query_caps);
-  VDP_PROC(VDP_FUNC_ID_PREEMPTION_CALLBACK_REGISTER        , vdp_preemption_callback_register);
-  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_TARGET_DESTROY          , vdp_presentation_queue_target_destroy);
-  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_CREATE                  , vdp_presentation_queue_create);
-  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_DESTROY                 , vdp_presentation_queue_destroy);
-  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_DISPLAY                 , vdp_presentation_queue_display);
-  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_BLOCK_UNTIL_SURFACE_IDLE, vdp_presentation_queue_block_until_surface_idle);
-  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_TARGET_CREATE_X11       , vdp_presentation_queue_target_create_x11);
-  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_QUERY_SURFACE_STATUS    , vdp_presentation_queue_query_surface_status);
-  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_GET_TIME                , vdp_presentation_queue_get_time);
-  
+  VDP_PROC(VDP_FUNC_ID_GET_ERROR_STRING                    , m_vdpauConfig.vdpProcs.vdp_get_error_string);
+  VDP_PROC(VDP_FUNC_ID_DEVICE_DESTROY                      , m_vdpauConfig.vdpProcs.vdp_device_destroy);
+  VDP_PROC(VDP_FUNC_ID_GENERATE_CSC_MATRIX                 , m_vdpauConfig.vdpProcs.vdp_generate_csc_matrix);
+  VDP_PROC(VDP_FUNC_ID_VIDEO_SURFACE_CREATE                , m_vdpauConfig.vdpProcs.vdp_video_surface_create);
+  VDP_PROC(VDP_FUNC_ID_VIDEO_SURFACE_DESTROY               , m_vdpauConfig.vdpProcs.vdp_video_surface_destroy);
+  VDP_PROC(VDP_FUNC_ID_VIDEO_SURFACE_PUT_BITS_Y_CB_CR      , m_vdpauConfig.vdpProcs.vdp_video_surface_put_bits_y_cb_cr);
+  VDP_PROC(VDP_FUNC_ID_VIDEO_SURFACE_GET_BITS_Y_CB_CR      , m_vdpauConfig.vdpProcs.vdp_video_surface_get_bits_y_cb_cr);
+  VDP_PROC(VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_Y_CB_CR     , m_vdpauConfig.vdpProcs.vdp_output_surface_put_bits_y_cb_cr);
+  VDP_PROC(VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_NATIVE      , m_vdpauConfig.vdpProcs.vdp_output_surface_put_bits_native);
+  VDP_PROC(VDP_FUNC_ID_OUTPUT_SURFACE_CREATE               , m_vdpauConfig.vdpProcs.vdp_output_surface_create);
+  VDP_PROC(VDP_FUNC_ID_OUTPUT_SURFACE_DESTROY              , m_vdpauConfig.vdpProcs.vdp_output_surface_destroy);
+  VDP_PROC(VDP_FUNC_ID_OUTPUT_SURFACE_GET_BITS_NATIVE      , m_vdpauConfig.vdpProcs.vdp_output_surface_get_bits_native);
+  VDP_PROC(VDP_FUNC_ID_OUTPUT_SURFACE_RENDER_OUTPUT_SURFACE, m_vdpauConfig.vdpProcs.vdp_output_surface_render_output_surface);
+  VDP_PROC(VDP_FUNC_ID_OUTPUT_SURFACE_PUT_BITS_INDEXED     , m_vdpauConfig.vdpProcs.vdp_output_surface_put_bits_indexed);
+  VDP_PROC(VDP_FUNC_ID_VIDEO_MIXER_CREATE                  , m_vdpauConfig.vdpProcs.vdp_video_mixer_create);
+  VDP_PROC(VDP_FUNC_ID_VIDEO_MIXER_SET_FEATURE_ENABLES     , m_vdpauConfig.vdpProcs.vdp_video_mixer_set_feature_enables);
+  VDP_PROC(VDP_FUNC_ID_VIDEO_MIXER_DESTROY                 , m_vdpauConfig.vdpProcs.vdp_video_mixer_destroy);
+  VDP_PROC(VDP_FUNC_ID_VIDEO_MIXER_RENDER                  , m_vdpauConfig.vdpProcs.vdp_video_mixer_render);
+  VDP_PROC(VDP_FUNC_ID_VIDEO_MIXER_SET_ATTRIBUTE_VALUES    , m_vdpauConfig.vdpProcs.vdp_video_mixer_set_attribute_values);
+  VDP_PROC(VDP_FUNC_ID_VIDEO_MIXER_QUERY_PARAMETER_SUPPORT , m_vdpauConfig.vdpProcs.vdp_video_mixer_query_parameter_support);
+  VDP_PROC(VDP_FUNC_ID_VIDEO_MIXER_QUERY_FEATURE_SUPPORT   , m_vdpauConfig.vdpProcs.vdp_video_mixer_query_feature_support);
+  VDP_PROC(VDP_FUNC_ID_DECODER_CREATE                      , m_vdpauConfig.vdpProcs.vdp_decoder_create);
+  VDP_PROC(VDP_FUNC_ID_DECODER_DESTROY                     , m_vdpauConfig.vdpProcs.vdp_decoder_destroy);
+  VDP_PROC(VDP_FUNC_ID_DECODER_RENDER                      , m_vdpauConfig.vdpProcs.vdp_decoder_render);
+  VDP_PROC(VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES          , m_vdpauConfig.vdpProcs.vdp_decoder_query_caps);
+  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_TARGET_DESTROY          , m_vdpauConfig.vdpProcs.vdp_presentation_queue_target_destroy);
+  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_CREATE                  , m_vdpauConfig.vdpProcs.vdp_presentation_queue_create);
+  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_DESTROY                 , m_vdpauConfig.vdpProcs.vdp_presentation_queue_destroy);
+  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_DISPLAY                 , m_vdpauConfig.vdpProcs.vdp_presentation_queue_display);
+  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_BLOCK_UNTIL_SURFACE_IDLE, m_vdpauConfig.vdpProcs.vdp_presentation_queue_block_until_surface_idle);
+  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_TARGET_CREATE_X11       , m_vdpauConfig.vdpProcs.vdp_presentation_queue_target_create_x11);
+  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_QUERY_SURFACE_STATUS    , m_vdpauConfig.vdpProcs.vdp_presentation_queue_query_surface_status);
+  VDP_PROC(VDP_FUNC_ID_PRESENTATION_QUEUE_GET_TIME                , m_vdpauConfig.vdpProcs.vdp_presentation_queue_get_time);
+
 #undef VDP_PROC
 
   // set all vdpau resources to invalid
-  vdp_flip_target = VDP_INVALID_HANDLE;
-  vdp_flip_queue = VDP_INVALID_HANDLE;
-  videoMixer = VDP_INVALID_HANDLE;
-  totalAvailableOutputSurfaces = 0;
-  presentSurface = VDP_INVALID_HANDLE;
-  outputSurface = VDP_INVALID_HANDLE;
-  for (int i = 0; i < NUM_OUTPUT_SURFACES; i++)
-    outputSurfaces[i] = VDP_INVALID_HANDLE;
-
-  m_vdpauOutputMethod = OUTPUT_NONE;
-
-  CExclusiveLock lock(m_DisplaySection);
   m_DisplayState = VDPAU_OPEN;
-  vdpauConfigured = false;
+  m_vdpauConfigured = false;
 }
 
-void CVDPAU::FiniVDPAUProcs()
+void CDecoder::FiniVDPAUProcs()
 {
-  if (vdp_device == VDP_INVALID_HANDLE) return;
+  if (m_vdpauConfig.vdpDevice == VDP_INVALID_HANDLE) return;
 
   VdpStatus vdp_st;
-  vdp_st = vdp_device_destroy(vdp_device);
+  vdp_st = m_vdpauConfig.vdpProcs.vdp_device_destroy(m_vdpauConfig.vdpDevice);
   CheckStatus(vdp_st, __LINE__);
-  vdp_device = VDP_INVALID_HANDLE;
-  vdpauConfigured = false;
+  m_vdpauConfig.vdpDevice = VDP_INVALID_HANDLE;
 }
 
-void CVDPAU::InitCSCMatrix(int Height)
+void CDecoder::FiniVDPAUOutput()
 {
-  VdpStatus vdp_st;
-  m_Procamp.struct_version = VDP_PROCAMP_VERSION;
-  m_Procamp.brightness     = 0.0;
-  m_Procamp.contrast       = 1.0;
-  m_Procamp.saturation     = 1.0;
-  m_Procamp.hue            = 0;
-  vdp_st = vdp_generate_csc_matrix(&m_Procamp,
-                                   (Height < 720)? VDP_COLOR_STANDARD_ITUR_BT_601 : VDP_COLOR_STANDARD_ITUR_BT_709,
-                                   &m_CSCMatrix);
-  CheckStatus(vdp_st, __LINE__);
-}
-
-void CVDPAU::FiniVDPAUOutput()
-{
-  FiniOutputMethod();
-
-  if (vdp_device == VDP_INVALID_HANDLE || !vdpauConfigured) return;
+  if (m_vdpauConfig.vdpDevice == VDP_INVALID_HANDLE || !m_vdpauConfigured) return;
 
   CLog::Log(LOGNOTICE, " (VDPAU) %s", __FUNCTION__);
 
+  // uninit output
+  m_vdpauOutput.Dispose();
+  m_vdpauConfigured = false;
+
   VdpStatus vdp_st;
 
-  vdp_st = vdp_decoder_destroy(decoder);
+  vdp_st = m_vdpauConfig.vdpProcs.vdp_decoder_destroy(m_vdpauConfig.vdpDecoder);
   if (CheckStatus(vdp_st, __LINE__))
     return;
-  decoder = VDP_INVALID_HANDLE;
+  m_vdpauConfig.vdpDecoder = VDP_INVALID_HANDLE;
+
+  CSingleLock lock(m_videoSurfaceSec);
+  CLog::Log(LOGDEBUG, "CVDPAU::FiniVDPAUOutput destroying %d video surfaces", (int)m_videoSurfaces.size());
 
-  for (unsigned int i = 0; i < m_videoSurfaces.size(); ++i)
+  for(unsigned int i = 0; i < m_videoSurfaces.size(); ++i)
   {
     vdpau_render_state *render = m_videoSurfaces[i];
     if (render->surface != VDP_INVALID_HANDLE)
     {
-      vdp_st = vdp_video_surface_destroy(render->surface);
+      vdp_st = m_vdpauConfig.vdpProcs.vdp_video_surface_destroy(render->surface);
       render->surface = VDP_INVALID_HANDLE;
     }
     if (CheckStatus(vdp_st, __LINE__))
@@ -926,10 +529,9 @@ void CVDPAU::FiniVDPAUOutput()
   }
 }
 
-
-void CVDPAU::ReadFormatOf( AVCodecID codec
-                         , VdpDecoderProfile &vdp_decoder_profile
-                         , VdpChromaType     &vdp_chroma_type)
+void CDecoder::ReadFormatOf( AVCodecID codec
+                           , VdpDecoderProfile &vdp_decoder_profile
+                           , VdpChromaType     &vdp_chroma_type)
 {
   switch (codec)
   {
@@ -941,7 +543,7 @@ void CVDPAU::ReadFormatOf( AVCodecID codec
       vdp_decoder_profile = VDP_DECODER_PROFILE_MPEG2_MAIN;
       vdp_chroma_type     = VDP_CHROMA_TYPE_420;
       break;
-    case  AV_CODEC_ID_H264:
+    case AV_CODEC_ID_H264:
       vdp_decoder_profile = VDP_DECODER_PROFILE_H264_HIGH;
       vdp_chroma_type     = VDP_CHROMA_TYPE_420;
       break;
@@ -953,12 +555,10 @@ void CVDPAU::ReadFormatOf( AVCodecID codec
       vdp_decoder_profile = VDP_DECODER_PROFILE_VC1_ADVANCED;
       vdp_chroma_type     = VDP_CHROMA_TYPE_420;
       break;
-#if (defined VDP_DECODER_PROFILE_MPEG4_PART2_ASP)
     case AV_CODEC_ID_MPEG4:
       vdp_decoder_profile = VDP_DECODER_PROFILE_MPEG4_PART2_ASP;
       vdp_chroma_type     = VDP_CHROMA_TYPE_420;
       break;
-#endif
     default:
       vdp_decoder_profile = 0;
       vdp_chroma_type     = 0;
@@ -966,170 +566,78 @@ void CVDPAU::ReadFormatOf( AVCodecID codec
   }
 }
 
-
-bool CVDPAU::ConfigVDPAU(AVCodecContext* avctx, int ref_frames)
+bool CDecoder::ConfigVDPAU(AVCodecContext* avctx, int ref_frames)
 {
   FiniVDPAUOutput();
 
   VdpStatus vdp_st;
   VdpDecoderProfile vdp_decoder_profile;
-  vid_width = avctx->width;
-  vid_height = avctx->height;
-  surface_width = avctx->coded_width;
-  surface_height = avctx->coded_height;
 
-  past[1] = past[0] = current = future = NULL;
-  CLog::Log(LOGNOTICE, " (VDPAU) screenWidth:%i vidWidth:%i surfaceWidth:%i",OutWidth,vid_width,surface_width);
-  CLog::Log(LOGNOTICE, " (VDPAU) screenHeight:%i vidHeight:%i surfaceHeight:%i",OutHeight,vid_height,surface_height);
-  ReadFormatOf(avctx->codec_id, vdp_decoder_profile, vdp_chroma_type);
+  m_vdpauConfig.vidWidth = avctx->width;
+  m_vdpauConfig.vidHeight = avctx->height;
+  m_vdpauConfig.surfaceWidth = avctx->coded_width;
+  m_vdpauConfig.surfaceHeight = avctx->coded_height;
+
+  SetWidthHeight(avctx->width,avctx->height);
+
+  CLog::Log(LOGNOTICE, " (VDPAU) screenWidth:%i vidWidth:%i surfaceWidth:%i",m_vdpauConfig.outWidth,m_vdpauConfig.vidWidth,m_vdpauConfig.surfaceWidth);
+  CLog::Log(LOGNOTICE, " (VDPAU) screenHeight:%i vidHeight:%i surfaceHeight:%i",m_vdpauConfig.outHeight,m_vdpauConfig.vidHeight,m_vdpauConfig.surfaceHeight);
+
+  ReadFormatOf(avctx->codec_id, vdp_decoder_profile, m_vdpauConfig.vdpChromaType);
 
   if(avctx->codec_id == AV_CODEC_ID_H264)
   {
-     max_references = ref_frames;
-     if (max_references > 16) max_references = 16;
-     if (max_references < 5)  max_references = 5;
+    m_vdpauConfig.maxReferences = ref_frames;
+    if (m_vdpauConfig.maxReferences > 16) m_vdpauConfig.maxReferences = 16;
+    if (m_vdpauConfig.maxReferences < 5)  m_vdpauConfig.maxReferences = 5;
   }
   else
-    max_references = 2;
+    m_vdpauConfig.maxReferences = 2;
 
-  vdp_st = vdp_decoder_create(vdp_device,
+  vdp_st = m_vdpauConfig.vdpProcs.vdp_decoder_create(m_vdpauConfig.vdpDevice,
                               vdp_decoder_profile,
-                              surface_width,
-                              surface_height,
-                              max_references,
-                              &decoder);
-  if (CheckStatus(vdp_st, __LINE__))
-    return false;
-
-  m_vdpauOutputMethod = OUTPUT_NONE;
-
-  vdpauConfigured = true;
-  return true;
-}
-
-bool CVDPAU::ConfigOutputMethod(AVCodecContext *avctx, AVFrame *pFrame)
-{
-  VdpStatus vdp_st;
-
-  if (m_vdpauOutputMethod == OUTPUT_PIXMAP)
-    return true;
-
-  FiniOutputMethod();
-
-  MakePixmap(avctx->width,avctx->height);
-
-  vdp_st = vdp_presentation_queue_target_create_x11(vdp_device,
-                                                    m_Pixmap, //x_window,
-                                                    &vdp_flip_target);
-  if (CheckStatus(vdp_st, __LINE__))
-    return false;
-
-  vdp_st = vdp_presentation_queue_create(vdp_device,
-                                         vdp_flip_target,
-                                         &vdp_flip_queue);
+                              m_vdpauConfig.surfaceWidth,
+                              m_vdpauConfig.surfaceHeight,
+                              m_vdpauConfig.maxReferences,
+                              &m_vdpauConfig.vdpDecoder);
   if (CheckStatus(vdp_st, __LINE__))
     return false;
 
-  totalAvailableOutputSurfaces = 0;
-
-  int tmpMaxOutputSurfaces = NUM_OUTPUT_SURFACES;
-  if (vid_width == FULLHD_WIDTH)
-    tmpMaxOutputSurfaces = NUM_OUTPUT_SURFACES_FOR_FULLHD;
-
-  // Creation of outputSurfaces
-  for (int i = 0; i < NUM_OUTPUT_SURFACES && i < tmpMaxOutputSurfaces; i++)
-  {
-    vdp_st = vdp_output_surface_create(vdp_device,
-                                       VDP_RGBA_FORMAT_B8G8R8A8,
-                                       OutWidth,
-                                       OutHeight,
-                                       &outputSurfaces[i]);
-    if (CheckStatus(vdp_st, __LINE__))
+  // initialize output
+  CSingleLock lock(g_graphicsContext);
+  m_vdpauConfig.stats = &m_bufferStats;
+  m_vdpauConfig.vdpau = this;
+  m_bufferStats.Reset();
+  m_vdpauOutput.Start();
+  Message *reply;
+  if (m_vdpauOutput.m_controlPort.SendOutMessageSync(COutputControlProtocol::INIT,
+                                                 &reply,
+                                                 2000,
+                                                 &m_vdpauConfig,
+                                                 sizeof(m_vdpauConfig)))
+  {
+    bool success = reply->signal == COutputControlProtocol::ACC ? true : false;
+    reply->Release();
+    if (!success)
+    {
+      CLog::Log(LOGERROR, "VDPAU::%s - vdpau output returned error", __FUNCTION__);
+      m_vdpauOutput.Dispose();
       return false;
-    totalAvailableOutputSurfaces++;
-  }
-  CLog::Log(LOGNOTICE, " (VDPAU) Total Output Surfaces Available: %i of a max (tmp: %i const: %i)",
-                       totalAvailableOutputSurfaces,
-                       tmpMaxOutputSurfaces,
-                       NUM_OUTPUT_SURFACES);
-
-  // create 3 pitches of black lines needed for clipping top
-  // and bottom lines when de-interlacing
-  m_BlackBar = new uint32_t[3*OutWidth];
-  memset(m_BlackBar, 0, 3*OutWidth*sizeof(uint32_t));
-
-  surfaceNum = presentSurfaceNum = 0;
-  outputSurface = presentSurface = VDP_INVALID_HANDLE;
-  videoMixer = VDP_INVALID_HANDLE;
-
-  m_vdpauOutputMethod = OUTPUT_PIXMAP;
-
-  return true;
-}
-
-bool CVDPAU::FiniOutputMethod()
-{
-  VdpStatus vdp_st;
-
-  if (vdp_flip_queue != VDP_INVALID_HANDLE)
-  {
-    vdp_st = vdp_presentation_queue_destroy(vdp_flip_queue);
-    vdp_flip_queue = VDP_INVALID_HANDLE;
-    CheckStatus(vdp_st, __LINE__);
-  }
-
-  if (vdp_flip_target != VDP_INVALID_HANDLE)
-  {
-    vdp_st = vdp_presentation_queue_target_destroy(vdp_flip_target);
-    vdp_flip_target = VDP_INVALID_HANDLE;
-    CheckStatus(vdp_st, __LINE__);
-  }
-
-  if (m_glPixmap)
-  {
-    CLog::Log(LOGDEBUG, "GLX: Destroying glPixmap");
-    glXDestroyPixmap(m_Display, m_glPixmap);
-    m_glPixmap = None;
-  }
-
-  if (m_Pixmap)
-  {
-    CLog::Log(LOGDEBUG, "GLX: Destroying XPixmap");
-    XFreePixmap(m_Display, m_Pixmap);
-    m_Pixmap = None;
-  }
-
-  outputSurface = presentSurface = VDP_INVALID_HANDLE;
-
-  for (int i = 0; i < totalAvailableOutputSurfaces; i++)
-  {
-    if (outputSurfaces[i] == VDP_INVALID_HANDLE)
-       continue;
-    vdp_st = vdp_output_surface_destroy(outputSurfaces[i]);
-    outputSurfaces[i] = VDP_INVALID_HANDLE;
-    CheckStatus(vdp_st, __LINE__);
-  }
-
-  if (videoMixer != VDP_INVALID_HANDLE)
-  {
-    vdp_st = vdp_video_mixer_destroy(videoMixer);
-    videoMixer = VDP_INVALID_HANDLE;
-    CheckStatus(vdp_st, __LINE__);
+    }
   }
-
-  if (m_BlackBar)
+  else
   {
-    delete [] m_BlackBar;
-    m_BlackBar = NULL;
+    CLog::Log(LOGERROR, "VDPAU::%s - failed to init output", __FUNCTION__);
+    m_vdpauOutput.Dispose();
+    return false;
   }
 
-  while (!m_DVDVideoPics.empty())
-    m_DVDVideoPics.pop();
-
+  m_inMsgEvent.Reset();
+  m_vdpauConfigured = true;
   return true;
 }
 
-void CVDPAU::SpewHardwareAvailable()  //Copyright (c) 2008 Wladimir J. van der Laan  -- VDPInfo
+void CDecoder::SpewHardwareAvailable()  //CopyrighVDPAUt (c) 2008 Wladimir J. van der Laan  -- VDPInfo
 {
   VdpStatus rv;
   CLog::Log(LOGNOTICE,"VDPAU Decoder capabilities:");
@@ -1139,7 +647,7 @@ void CVDPAU::SpewHardwareAvailable()  //Copyright (c) 2008 Wladimir J. van der L
   {
     VdpBool is_supported = false;
     uint32_t max_level, max_macroblocks, max_width, max_height;
-    rv = vdp_decoder_query_caps(vdp_device, decoder_profiles[x].id,
+    rv = m_vdpauConfig.vdpProcs.vdp_decoder_query_caps(m_vdpauConfig.vdpDevice, decoder_profiles[x].id,
                                 &is_supported, &max_level, &max_macroblocks, &max_width, &max_height);
     if(rv == VDP_STATUS_OK && is_supported)
     {
@@ -1148,13 +656,13 @@ void CVDPAU::SpewHardwareAvailable()  //Copyright (c) 2008 Wladimir J. van der L
     }
   }
   CLog::Log(LOGNOTICE,"------------------------------------");
-  m_feature_count = 0;
+  m_vdpauConfig.featureCount = 0;
 #define CHECK_SUPPORT(feature)  \
   do { \
     VdpBool supported; \
-    if(vdp_video_mixer_query_feature_support(vdp_device, feature, &supported) == VDP_STATUS_OK && supported) { \
+    if(m_vdpauConfig.vdpProcs.vdp_video_mixer_query_feature_support(m_vdpauConfig.vdpDevice, feature, &supported) == VDP_STATUS_OK && supported) { \
       CLog::Log(LOGNOTICE, "Mixer feature: "#feature);  \
-      m_features[m_feature_count++] = feature; \
+      m_vdpauConfig.vdpFeatures[m_vdpauConfig.featureCount++] = feature; \
     } \
   } while(false)
 
@@ -1178,7 +686,7 @@ void CVDPAU::SpewHardwareAvailable()  //Copyright (c) 2008 Wladimir J. van der L
 
 }
 
-bool CVDPAU::IsSurfaceValid(vdpau_render_state *render)
+bool CDecoder::IsSurfaceValid(vdpau_render_state *render)
 {
   // find render state in queue
   bool found(false);
@@ -1205,34 +713,33 @@ bool CVDPAU::IsSurfaceValid(vdpau_render_state *render)
   return true;
 }
 
-int CVDPAU::FFGetBuffer(AVCodecContext *avctx, AVFrame *pic)
+int CDecoder::FFGetBuffer(AVCodecContext *avctx, AVFrame *pic)
 {
   //CLog::Log(LOGNOTICE,"%s",__FUNCTION__);
   CDVDVideoCodecFFmpeg* ctx        = (CDVDVideoCodecFFmpeg*)avctx->opaque;
-  CVDPAU*               vdp        = (CVDPAU*)ctx->GetHardware();
-  struct pictureAge*    pA         = &vdp->picAge;
+  CDecoder*             vdp        = (CDecoder*)ctx->GetHardware();
 
   // while we are waiting to recover we can't do anything
-  CSharedLock lock(vdp->m_DecoderSection);
+  CSingleLock lock(vdp->m_DecoderSection);
 
-  { CSharedLock dLock(vdp->m_DisplaySection);
-    if(vdp->m_DisplayState != VDPAU_OPEN)
-    {
-      CLog::Log(LOGWARNING, "CVDPAU::FFGetBuffer - returning due to awaiting recovery");
-      return -1;
-    }
+  if(vdp->m_DisplayState != VDPAU_OPEN)
+  {
+    CLog::Log(LOGWARNING, "CVDPAU::FFGetBuffer - returning due to awaiting recovery");
+    return -1;
   }
 
   vdpau_render_state * render = NULL;
 
   // find unused surface
-  for(unsigned int i = 0; i < vdp->m_videoSurfaces.size(); i++)
-  {
-    if(!(vdp->m_videoSurfaces[i]->state & (FF_VDPAU_STATE_USED_FOR_REFERENCE | FF_VDPAU_STATE_USED_FOR_RENDER)))
+  { CSingleLock lock(vdp->m_videoSurfaceSec);
+    for(unsigned int i = 0; i < vdp->m_videoSurfaces.size(); i++)
     {
-      render = vdp->m_videoSurfaces[i];
-      render->state = 0;
-      break;
+      if(!(vdp->m_videoSurfaces[i]->state & (FF_VDPAU_STATE_USED_FOR_REFERENCE | FF_VDPAU_STATE_USED_FOR_RENDER)))
+      {
+        render = vdp->m_videoSurfaces[i];
+        render->state = 0;
+        break;
+      }
     }
   }
 
@@ -1241,21 +748,22 @@ int CVDPAU::FFGetBuffer(AVCodecContext *avctx, AVFrame *pic)
   {
     // create a new surface
     VdpDecoderProfile profile;
-    ReadFormatOf(avctx->codec_id, profile, vdp->vdp_chroma_type);
+    ReadFormatOf(avctx->codec_id, profile, vdp->m_vdpauConfig.vdpChromaType);
     render = (vdpau_render_state*)calloc(sizeof(vdpau_render_state), 1);
     if (render == NULL)
     {
       CLog::Log(LOGWARNING, "CVDPAU::FFGetBuffer - calloc failed");
       return -1;
     }
+    CSingleLock lock(vdp->m_videoSurfaceSec);
     render->surface = VDP_INVALID_HANDLE;
     vdp->m_videoSurfaces.push_back(render);
   }
 
   if (render->surface == VDP_INVALID_HANDLE)
   {
-    vdp_st = vdp->vdp_video_surface_create(vdp->vdp_device,
-                                         vdp->vdp_chroma_type,
+    vdp_st = vdp->m_vdpauConfig.vdpProcs.vdp_video_surface_create(vdp->m_vdpauConfig.vdpDevice,
+                                         vdp->m_vdpauConfig.vdpChromaType,
                                          avctx->coded_width,
                                          avctx->coded_height,
                                          &render->surface);
@@ -1277,18 +785,6 @@ int CVDPAU::FFGetBuffer(AVCodecContext *avctx, AVFrame *pic)
 
   pic->linesize[0] = pic->linesize[1] =  pic->linesize[2] = 0;
 
-  if(pic->reference)
-  {
-    pA->ip_age[0]= pA->ip_age[1]+1;
-    pA->ip_age[1]= 1;
-    pA->b_age++;
-  }
-  else
-  {
-    pA->ip_age[0]++;
-    pA->ip_age[1]++;
-    pA->b_age = 1;
-  }
   pic->type= FF_BUFFER_TYPE_USER;
 
   render->state |= FF_VDPAU_STATE_USED_FOR_REFERENCE;
@@ -1296,15 +792,16 @@ int CVDPAU::FFGetBuffer(AVCodecContext *avctx, AVFrame *pic)
   return 0;
 }
 
-void CVDPAU::FFReleaseBuffer(AVCodecContext *avctx, AVFrame *pic)
+void CDecoder::FFReleaseBuffer(AVCodecContext *avctx, AVFrame *pic)
 {
   //CLog::Log(LOGNOTICE,"%s",__FUNCTION__);
   CDVDVideoCodecFFmpeg* ctx        = (CDVDVideoCodecFFmpeg*)avctx->opaque;
-  CVDPAU*               vdp        = (CVDPAU*)ctx->GetHardware();
+  CDecoder*             vdp        = (CDecoder*)ctx->GetHardware();
+
   vdpau_render_state  * render;
   unsigned int i;
 
-  CSharedLock lock(vdp->m_DecoderSection);
+  CSingleLock lock(vdp->m_DecoderSection);
 
   render=(vdpau_render_state*)pic->data[0];
   if(!render)
@@ -1313,6 +810,8 @@ void CVDPAU::FFReleaseBuffer(AVCodecContext *avctx, AVFrame *pic)
     return;
   }
 
+  CSingleLock vLock(vdp->m_videoSurfaceSec);
+  render->state &= ~FF_VDPAU_STATE_USED_FOR_REFERENCE;
   for(i=0; i<4; i++)
     pic->data[i]= NULL;
 
@@ -1326,29 +825,26 @@ void CVDPAU::FFReleaseBuffer(AVCodecContext *avctx, AVFrame *pic)
   render->state &= ~FF_VDPAU_STATE_USED_FOR_REFERENCE;
 }
 
-VdpStatus CVDPAU::Render(VdpDecoder decoder, VdpVideoSurface target,
-                         VdpPictureInfo const *picture_info,
-                         uint32_t bitstream_buffer_count,
-                         VdpBitstreamBuffer const * bitstream_buffers)
+VdpStatus CDecoder::Render( VdpDecoder decoder, VdpVideoSurface target,
+                            VdpPictureInfo const *picture_info,
+                            uint32_t bitstream_buffer_count,
+                            VdpBitstreamBuffer const * bitstream_buffers)
 {
   return VDP_STATUS_OK;
 }
 
-void CVDPAU::FFDrawSlice(struct AVCodecContext *s,
+void CDecoder::FFDrawSlice(struct AVCodecContext *s,
                                            const AVFrame *src, int offset[4],
                                            int y, int type, int height)
 {
   CDVDVideoCodecFFmpeg* ctx = (CDVDVideoCodecFFmpeg*)s->opaque;
-  CVDPAU*               vdp = (CVDPAU*)ctx->GetHardware();
+  CDecoder*               vdp = (CDecoder*)ctx->GetHardware();
 
   // while we are waiting to recover we can't do anything
-  CSharedLock lock(vdp->m_DecoderSection);
-
-  { CSharedLock dLock(vdp->m_DisplaySection);
-    if(vdp->m_DisplayState != VDPAU_OPEN)
-      return;
-  }
+  CSingleLock lock(vdp->m_DecoderSection);
 
+  if(vdp->m_DisplayState != VDPAU_OPEN)
+    return;
 
   if(src->linesize[0] || src->linesize[1] || src->linesize[2]
   || offset[0] || offset[1] || offset[2])
@@ -1378,67 +874,50 @@ void CVDPAU::FFDrawSlice(struct AVCodecContext *s,
   if(s->codec_id == AV_CODEC_ID_H264)
     max_refs = vdp->m_hwContext.info.h264.num_ref_frames;
 
-  if(vdp->decoder == VDP_INVALID_HANDLE
-  || vdp->vdpauConfigured == false
-  || vdp->max_references < max_refs)
+  if(vdp->m_vdpauConfig.vdpDecoder == VDP_INVALID_HANDLE
+  || vdp->m_vdpauConfigured == false
+  || vdp->m_vdpauConfig.maxReferences < max_refs)
   {
     if(!vdp->ConfigVDPAU(s, max_refs))
       return;
   }
 
-  vdp_st = vdp->vdp_decoder_render(vdp->decoder,
+  uint64_t startTime = CurrentHostCounter();
+  uint16_t decoded, processed, rend;
+  vdp->m_bufferStats.Get(decoded, processed, rend);
+  vdp_st = vdp->m_vdpauConfig.vdpProcs.vdp_decoder_render(vdp->m_vdpauConfig.vdpDecoder,
                                    render->surface,
                                    (VdpPictureInfo const *)&(vdp->m_hwContext.info),
                                    vdp->m_hwContext.bitstream_buffers_used,
                                    vdp->m_hwContext.bitstream_buffers);
   vdp->CheckStatus(vdp_st, __LINE__);
+  uint64_t diff = CurrentHostCounter() - startTime;
+  if (diff*1000/CurrentHostFrequency() > 30)
+    CLog::Log(LOGWARNING,"CVDPAU::DrawSlice - VdpDecoderRender long decoding: %d ms, dec: %d, proc: %d, rend: %d", (int)((diff*1000)/CurrentHostFrequency()), decoded, processed, rend);
+
 }
 
-int CVDPAU::Decode(AVCodecContext *avctx, AVFrame *pFrame)
-{
-  //CLog::Log(LOGNOTICE,"%s",__FUNCTION__);
-  VdpStatus vdp_st;
-  VdpTime time;
 
+int CDecoder::Decode(AVCodecContext *avctx, AVFrame *pFrame)
+{
   int result = Check(avctx);
   if (result)
     return result;
 
-  CSharedLock lock(m_DecoderSection);
+  CSingleLock lock(m_DecoderSection);
 
-  if (!vdpauConfigured)
+  if (!m_vdpauConfigured)
     return VC_ERROR;
 
-  // configure vdpau output
-  if (!ConfigOutputMethod(avctx, pFrame))
-    return VC_FLUSHED;
-
-  outputSurface = outputSurfaces[surfaceNum];
-
-  CheckFeatures();
-
-  if (( (int)outRectVid.x1 != OutWidth ) ||
-      ( (int)outRectVid.y1 != OutHeight ))
-  {
-    outRectVid.x0 = 0;
-    outRectVid.y0 = 0;
-    outRectVid.x1 = OutWidth;
-    outRectVid.y1 = OutHeight;
-  }
-
-  EDEINTERLACEMODE   mode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
-  EINTERLACEMETHOD method = CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod;
-  if (method == VS_INTERLACEMETHOD_AUTO)
-    method = AutoInterlaceMethod();
-
   if(pFrame)
   { // we have a new frame from decoder
 
-    vdpau_render_state * render = (vdpau_render_state*)pFrame->data[2];
-    if(!render) // old style ffmpeg gave data on plane 0
-      render = (vdpau_render_state*)pFrame->data[0];
+    vdpau_render_state * render = (vdpau_render_state*)pFrame->data[0];
     if(!render)
+    {
+      CLog::Log(LOGERROR, "CVDPAU::Decode: no valid frame");
       return VC_ERROR;
+    }
 
     // ffmpeg vc-1 decoder does not flush, make sure the data buffer is still valid
     if (!IsSurfaceValid(render))
@@ -1447,258 +926,166 @@ int CVDPAU::Decode(AVCodecContext *avctx, AVFrame *pFrame)
       return VC_BUFFER;
     }
 
+    CSingleLock lock(m_videoSurfaceSec);
     render->state |= FF_VDPAU_STATE_USED_FOR_RENDER;
+    lock.Leave();
 
-    ClearUsedForRender(&past[0]);
-    past[0] = past[1];
-    past[1] = current;
-    current = future;
-    future = render;
+    // send frame to output for processing
+    CVdpauDecodedPicture pic;
+    memset(&pic.DVDPic, 0, sizeof(pic.DVDPic));
+    ((CDVDVideoCodecFFmpeg*)avctx->opaque)->GetPictureCommon(&pic.DVDPic);
+    pic.render = render;
+    m_bufferStats.IncDecoded();
+    m_vdpauOutput.m_dataPort.SendOutMessage(COutputDataProtocol::NEWFRAME, &pic, sizeof(pic));
 
-    DVDVideoPicture DVDPic;
-    memset(&DVDPic, 0, sizeof(DVDVideoPicture));
-    ((CDVDVideoCodecFFmpeg*)avctx->opaque)->GetPictureCommon(&DVDPic);
-    m_DVDVideoPics.push(DVDPic);
+    m_codecControl = pic.DVDPic.iFlags & (DVP_FLAG_DRAIN | DVP_FLAG_NO_POSTPROC);
+  }
 
-    int pics = m_DVDVideoPics.size();
-    if (pics < 2)
-        return VC_BUFFER;
-    else if (pics > 2)
+  int retval = 0;
+  uint16_t decoded, processed, render;
+  Message *msg;
+  while (m_vdpauOutput.m_controlPort.ReceiveInMessage(&msg))
+  {
+    if (msg->signal == COutputControlProtocol::ERROR)
     {
-      // this should not normally happen
-      CLog::Log(LOGERROR, "CVDPAU::Decode - invalid number of pictures in queue");
-      while (pics-- != 2)
-        m_DVDVideoPics.pop();
+      m_DisplayState = VDPAU_ERROR;
+      retval |= VC_ERROR;
     }
+    msg->Release();
+  }
+
+  m_bufferStats.Get(decoded, processed, render);
 
-    if (mode == VS_DEINTERLACEMODE_FORCE
-    || (mode == VS_DEINTERLACEMODE_AUTO && m_DVDVideoPics.front().iFlags & DVP_FLAG_INTERLACED))
+  uint64_t startTime = CurrentHostCounter();
+  while (!retval)
+  {
+    if (m_vdpauOutput.m_dataPort.ReceiveInMessage(&msg))
     {
-      if((method == VS_INTERLACEMETHOD_AUTO_ION
-      ||  method == VS_INTERLACEMETHOD_VDPAU_BOB
-      ||  method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL
-      ||  method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_HALF
-      ||  method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_SPATIAL
-      ||  method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_SPATIAL_HALF
-      ||  method == VS_INTERLACEMETHOD_VDPAU_INVERSE_TELECINE ))
+      if (msg->signal == COutputDataProtocol::PICTURE)
       {
-        if((method == VS_INTERLACEMETHOD_AUTO_ION && vid_height > 576)
-        || method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_HALF
-        || method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_SPATIAL_HALF
-        || avctx->skip_frame == AVDISCARD_NONREF)
-          m_mixerstep = 0;
-        else
-          m_mixerstep = 1;
-
-        if(m_DVDVideoPics.front().iFlags & DVP_FLAG_TOP_FIELD_FIRST)
-          m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_TOP_FIELD;
-        else
-          m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_BOTTOM_FIELD;
+        if (m_presentPicture)
+        {
+          m_presentPicture->ReturnUnused();
+          m_presentPicture = 0;
+        }
+
+        m_presentPicture = *(CVdpauRenderPicture**)msg->data;
+        m_presentPicture->vdpau = this;
+        m_bufferStats.DecRender();
+        m_bufferStats.Get(decoded, processed, render);
+        retval |= VC_PICTURE;
+        msg->Release();
+        break;
+      }
+      msg->Release();
+    }
+    else if (m_vdpauOutput.m_controlPort.ReceiveInMessage(&msg))
+    {
+      if (msg->signal == COutputControlProtocol::STATS)
+      {
+        m_bufferStats.Get(decoded, processed, render);
       }
       else
       {
-        m_mixerstep  = 0;
-        m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME;
+        m_DisplayState = VDPAU_ERROR;
+        retval |= VC_ERROR;
       }
+      msg->Release();
     }
-    else
+
+    if ((m_codecControl & DVP_FLAG_DRAIN))
     {
-      m_mixerstep  = 0;
-      m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME;
+      if (decoded + processed + render < 4)
+      {
+        retval |= VC_BUFFER;
+      }
     }
-
-  }
-  else if(m_mixerstep == 1)
-  { // no new frame given, output second field of old frame
-
-    if(avctx->skip_frame == AVDISCARD_NONREF)
+    else
     {
-      ClearUsedForRender(&past[1]);
-      m_DVDVideoPics.pop();
-      return VC_BUFFER;
+      if (decoded < 4 && (processed + render) < 3)
+      {
+        retval |= VC_BUFFER;
+      }
     }
 
-    m_mixerstep = 2;
-    if(m_mixerfield == VDP_VIDEO_MIXER_PICTURE_STRUCTURE_TOP_FIELD)
-      m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_BOTTOM_FIELD;
-    else
-      m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_TOP_FIELD;
+    if (!retval && !m_inMsgEvent.WaitMSec(2000))
+      break;
   }
-  else
+  uint64_t diff = CurrentHostCounter() - startTime;
+  if (retval & VC_PICTURE)
   {
-    CLog::Log(LOGERROR, "CVDPAU::Decode - invalid mixer state reached");
-    return VC_BUFFER;
+    m_bufferStats.SetParams(diff, m_codecControl);
   }
+  if (diff*1000/CurrentHostFrequency() > 50)
+    CLog::Log(LOGDEBUG,"CVDPAU::Decode long wait: %d", (int)((diff*1000)/CurrentHostFrequency()));
 
-  VdpVideoSurface past_surfaces[2] = { VDP_INVALID_HANDLE, VDP_INVALID_HANDLE };
-  VdpVideoSurface futu_surfaces[1] = { VDP_INVALID_HANDLE };
-
-  if(m_mixerfield == VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME)
+  if (!retval)
   {
-    if (past[0])
-      past_surfaces[1] = past[0]->surface;
-    if (past[1])
-      past_surfaces[0] = past[1]->surface;
-    futu_surfaces[0] = future->surface;
+    CLog::Log(LOGERROR, "VDPAU::%s - timed out waiting for output message", __FUNCTION__);
+    m_DisplayState = VDPAU_ERROR;
+    retval |= VC_ERROR;
   }
-  else
-  {
-    if(m_mixerstep == 1)
-    { // first field
-      if (past[1])
-      {
-        past_surfaces[1] = past[1]->surface;
-        past_surfaces[0] = past[1]->surface;
-      }
-      futu_surfaces[0] = current->surface;
-    }
-    else
-    { // second field
-      if (past[1])
-        past_surfaces[1] = past[1]->surface;
-      past_surfaces[0] = current->surface;
-      futu_surfaces[0] = future->surface;
-    }
-  }
-
-  vdp_presentation_queue_block_until_surface_idle(vdp_flip_queue,outputSurface,&time);
-
-  VdpRect sourceRect = {0,0,vid_width, vid_height};
-
-  vdp_st = vdp_video_mixer_render(videoMixer,
-                                  VDP_INVALID_HANDLE,
-                                  0, 
-                                  m_mixerfield,
-                                  2,
-                                  past_surfaces,
-                                  current->surface,
-                                  1,
-                                  futu_surfaces,
-                                  &sourceRect,
-                                  outputSurface,
-                                  &(outRectVid),
-                                  &(outRectVid),
-                                  0,
-                                  NULL);
-  CheckStatus(vdp_st, __LINE__);
 
-  surfaceNum++;
-  if (surfaceNum >= totalAvailableOutputSurfaces) surfaceNum = 0;
+  return retval;
+}
 
-  if(m_mixerfield == VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME)
-  {
-    ClearUsedForRender(&past[0]);
-    return VC_BUFFER | VC_PICTURE;
-  }
-  else
-  {
-    // in order to clip top and bottom lines when de-interlacing
-    // we black those lines as a work around for not working
-    // background colour using the mixer
-    // pixel perfect is preferred over overscanning or zooming
+bool CDecoder::GetPicture(AVCodecContext* avctx, AVFrame* frame, DVDVideoPicture* picture)
+{
+  CSingleLock lock(m_DecoderSection);
 
-    VdpRect clipRect = outRectVid;
-    clipRect.y1 = clipRect.y0 + 2;
-    uint32_t *data[] = {m_BlackBar};
-    uint32_t pitches[] = {outRectVid.x1};
-    vdp_st = vdp_output_surface_put_bits_native(outputSurface,
-                                        (void**)data,
-                                        pitches,
-                                        &clipRect);
-    CheckStatus(vdp_st, __LINE__);
+  if (m_DisplayState != VDPAU_OPEN)
+    return false;
 
-    clipRect = outRectVid;
-    clipRect.y0 = clipRect.y1 - 2;
-    vdp_st = vdp_output_surface_put_bits_native(outputSurface,
-                                        (void**)data,
-                                        pitches,
-                                        &clipRect);
-    CheckStatus(vdp_st, __LINE__);
+  *picture = m_presentPicture->DVDPic;
+  picture->vdpau = m_presentPicture;
 
-    if(m_mixerstep == 1)
-      return VC_PICTURE;
-    else
-    {
-      ClearUsedForRender(&past[1]);
-      return VC_BUFFER | VC_PICTURE;
-    }
-  }
+  return true;
 }
 
-bool CVDPAU::GetPicture(AVCodecContext* avctx, AVFrame* frame, DVDVideoPicture* picture)
+void CDecoder::Reset()
 {
-  CSharedLock lock(m_DecoderSection);
-
-  { CSharedLock dLock(m_DisplaySection);
-    if (m_DisplayState != VDPAU_OPEN)
-      return false;
-  }
+  CSingleLock lock(m_DecoderSection);
 
-  *picture = m_DVDVideoPics.front();
-  // if this is the first field of an interlaced frame, we'll need
-  // this same picture for the second field later
-  if (m_mixerstep != 1)
-    m_DVDVideoPics.pop();
-
-  picture->format = RENDER_FMT_VDPAU;
-  picture->iFlags &= DVP_FLAG_DROPPED;
-  picture->iWidth = OutWidth;
-  picture->iHeight = OutHeight;
-  picture->vdpau = this;
+  if (!m_vdpauConfigured)
+    return;
 
-  if(m_mixerstep)
+  Message *reply;
+  if (m_vdpauOutput.m_controlPort.SendOutMessageSync(COutputControlProtocol::FLUSH,
+                                                 &reply,
+                                                 2000))
   {
-    picture->iRepeatPicture = -0.5;
-    if(m_mixerstep > 1)
+    bool success = reply->signal == COutputControlProtocol::ACC ? true : false;
+    reply->Release();
+    if (!success)
     {
-      picture->dts = DVD_NOPTS_VALUE;
-      picture->pts = DVD_NOPTS_VALUE;
+      CLog::Log(LOGERROR, "VDPAU::%s - flush returned error", __FUNCTION__);
+      m_DisplayState = VDPAU_ERROR;
     }
+    else
+      m_bufferStats.Reset();
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "VDPAU::%s - flush timed out", __FUNCTION__);
+    m_DisplayState = VDPAU_ERROR;
   }
-  return true;
 }
 
-void CVDPAU::Reset()
+bool CDecoder::CanSkipDeint()
 {
-  // invalidate surfaces and picture queue when seeking
-  ClearUsedForRender(&past[0]);
-  ClearUsedForRender(&past[1]);
-  ClearUsedForRender(&current);
-  ClearUsedForRender(&future);
-
-  while (!m_DVDVideoPics.empty())
-    m_DVDVideoPics.pop();
+  return m_bufferStats.CanSkipDeint();
 }
 
-void CVDPAU::Present()
+void CDecoder::ReturnRenderPicture(CVdpauRenderPicture *renderPic)
 {
-  //CLog::Log(LOGNOTICE,"%s",__FUNCTION__);
-  VdpStatus vdp_st;
-
-  CSharedLock lock(m_DecoderSection);
-
-  { CSharedLock dLock(m_DisplaySection);
-    if (m_DisplayState != VDPAU_OPEN)
-      return;
-  }
-
-  presentSurface = outputSurface;
-
-  vdp_st = vdp_presentation_queue_display(vdp_flip_queue,
-                                          presentSurface,
-                                          0,
-                                          0,
-                                          0);
-  CheckStatus(vdp_st, __LINE__);
+  m_vdpauOutput.m_dataPort.SendOutMessage(COutputDataProtocol::RETURNPIC, &renderPic, sizeof(renderPic));
 }
 
-bool CVDPAU::CheckStatus(VdpStatus vdp_st, int line)
+bool CDecoder::CheckStatus(VdpStatus vdp_st, int line)
 {
   if (vdp_st != VDP_STATUS_OK)
   {
-    CLog::Log(LOGERROR, " (VDPAU) Error: %s(%d) at %s:%d\n", vdp_get_error_string(vdp_st), vdp_st, __FILE__, line);
-
-    CExclusiveLock lock(m_DisplaySection);
+    CLog::Log(LOGERROR, " (VDPAU) Error: %s(%d) at %s:%d\n", m_vdpauConfig.vdpProcs.vdp_get_error_string(vdp_st), vdp_st, __FILE__, line);
 
     if(m_DisplayState == VDPAU_OPEN)
     {
@@ -1716,4 +1103,2424 @@ bool CVDPAU::CheckStatus(VdpStatus vdp_st, int line)
   return false;
 }
 
+//-----------------------------------------------------------------------------
+// RenderPicture
+//-----------------------------------------------------------------------------
+
+CVdpauRenderPicture* CVdpauRenderPicture::Acquire()
+{
+  CSingleLock lock(*renderPicSection);
+
+  if (refCount == 0)
+    vdpau->Acquire();
+
+  refCount++;
+  return this;
+}
+
+long CVdpauRenderPicture::Release()
+{
+  CSingleLock lock(*renderPicSection);
+
+  refCount--;
+  if (refCount > 0)
+    return refCount;
+
+  lock.Leave();
+  vdpau->ReturnRenderPicture(this);
+  vdpau->ReleasePicReference();
+
+  return refCount;
+}
+
+void CVdpauRenderPicture::ReturnUnused()
+{
+  { CSingleLock lock(*renderPicSection);
+    if (refCount > 0)
+      return;
+  }
+  if (vdpau)
+    vdpau->ReturnRenderPicture(this);
+}
+//-----------------------------------------------------------------------------
+// Mixer
+//-----------------------------------------------------------------------------
+CMixer::CMixer(CEvent *inMsgEvent) :
+  CThread("Vdpau Mixer Thread"),
+  m_controlPort("ControlPort", inMsgEvent, &m_outMsgEvent),
+  m_dataPort("DataPort", inMsgEvent, &m_outMsgEvent)
+{
+  m_inMsgEvent = inMsgEvent;
+}
+
+CMixer::~CMixer()
+{
+  Dispose();
+}
+
+void CMixer::Start()
+{
+  Create();
+}
+
+void CMixer::Dispose()
+{
+  m_bStop = true;
+  m_outMsgEvent.Set();
+  StopThread();
+
+  m_controlPort.Purge();
+  m_dataPort.Purge();
+}
+
+void CMixer::OnStartup()
+{
+  CLog::Log(LOGNOTICE, "CMixer::OnStartup: Output Thread created");
+}
+
+void CMixer::OnExit()
+{
+  CLog::Log(LOGNOTICE, "CMixer::OnExit: Output Thread terminated");
+}
+
+enum MIXER_STATES
+{
+  M_TOP = 0,                      // 0
+  M_TOP_ERROR,                    // 1
+  M_TOP_UNCONFIGURED,             // 2
+  M_TOP_CONFIGURED,               // 3
+  M_TOP_CONFIGURED_WAIT1,         // 4
+  M_TOP_CONFIGURED_STEP1,         // 5
+  M_TOP_CONFIGURED_WAIT2,         // 6
+  M_TOP_CONFIGURED_STEP2,         // 7
+};
+
+int MIXER_parentStates[] = {
+    -1,
+    0, //TOP_ERROR
+    0, //TOP_UNCONFIGURED
+    0, //TOP_CONFIGURED
+    3, //TOP_CONFIGURED_WAIT1
+    3, //TOP_CONFIGURED_STEP1
+    3, //TOP_CONFIGURED_WAIT2
+    3, //TOP_CONFIGURED_STEP2
+};
+
+void CMixer::StateMachine(int signal, Protocol *port, Message *msg)
+{
+  for (int state = m_state; ; state = MIXER_parentStates[state])
+  {
+    switch (state)
+    {
+    case M_TOP: // TOP
+      if (port == &m_controlPort)
+      {
+        switch (signal)
+        {
+        case CMixerControlProtocol::FLUSH:
+          Flush();
+          msg->Reply(CMixerControlProtocol::ACC);
+          return;
+        default:
+          break;
+        }
+      }
+      {
+        std::string portName = port == NULL ? "timer" : port->portName;
+        CLog::Log(LOGWARNING, "CMixer::%s - signal: %d form port: %s not handled for state: %d", __FUNCTION__, signal, portName.c_str(), m_state);
+      }
+      return;
+
+    case M_TOP_ERROR: // TOP
+      break;
+
+    case M_TOP_UNCONFIGURED:
+      if (port == &m_controlPort)
+      {
+        switch (signal)
+        {
+        case CMixerControlProtocol::INIT:
+          CVdpauConfig *data;
+          data = (CVdpauConfig*)msg->data;
+          if (data)
+          {
+            m_config = *data;
+          }
+          Init();
+          if (!m_vdpError)
+          {
+            m_state = M_TOP_CONFIGURED_WAIT1;
+            msg->Reply(CMixerControlProtocol::ACC);
+          }
+          else
+          {
+            msg->Reply(CMixerControlProtocol::ERROR);
+          }
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case M_TOP_CONFIGURED:
+      if (port == &m_dataPort)
+      {
+        switch (signal)
+        {
+        case CMixerDataProtocol::FRAME:
+          CVdpauDecodedPicture *frame;
+          frame = (CVdpauDecodedPicture*)msg->data;
+          if (frame)
+          {
+            m_decodedPics.push(*frame);
+          }
+          m_extTimeout = 0;
+          return;
+        case CMixerDataProtocol::BUFFER:
+          VdpOutputSurface *surf;
+          surf = (VdpOutputSurface*)msg->data;
+          if (surf)
+          {
+            m_outputSurfaces.push(*surf);
+          }
+          m_extTimeout = 0;
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case M_TOP_CONFIGURED_WAIT1:
+      if (port == NULL) // timeout
+      {
+        switch (signal)
+        {
+        case CMixerControlProtocol::TIMEOUT:
+          if (!m_decodedPics.empty() && !m_outputSurfaces.empty())
+          {
+            m_state = M_TOP_CONFIGURED_STEP1;
+            m_bStateMachineSelfTrigger = true;
+          }
+          else
+          {
+//            if (m_extTimeout != 0)
+//            {
+//              SetPostProcFeatures(false);
+//              CLog::Log(LOGWARNING,"CVDPAU::Mixer timeout - decoded: %d, outputSurf: %d", (int)m_decodedPics.size(), (int)m_outputSurfaces.size());
+//            }
+            m_extTimeout = 100;
+          }
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case M_TOP_CONFIGURED_STEP1:
+      if (port == NULL) // timeout
+      {
+        switch (signal)
+        {
+        case CMixerControlProtocol::TIMEOUT:
+          m_mixerInput.push_front(m_decodedPics.front());
+          m_decodedPics.pop();
+          if (m_mixerInput.size() < 2)
+          {
+            m_state = M_TOP_CONFIGURED_WAIT1;
+            m_extTimeout = 0;
+            return;
+          }
+          InitCycle();
+          ProcessPicture();
+          if (m_vdpError)
+          {
+            m_state = M_TOP_CONFIGURED_WAIT1;
+            m_extTimeout = 1000;
+            return;
+          }
+          if (m_processPicture.DVDPic.format != RENDER_FMT_VDPAU_420)
+            m_outputSurfaces.pop();
+          m_config.stats->IncProcessed();
+          m_config.stats->DecDecoded();
+          m_dataPort.SendInMessage(CMixerDataProtocol::PICTURE,&m_processPicture,sizeof(m_processPicture));
+          if (m_mixersteps > 1)
+          {
+            m_state = M_TOP_CONFIGURED_WAIT2;
+            m_extTimeout = 0;
+          }
+          else
+          {
+            FiniCycle();
+            m_state = M_TOP_CONFIGURED_WAIT1;
+            m_extTimeout = 0;
+          }
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case M_TOP_CONFIGURED_WAIT2:
+      if (port == NULL) // timeout
+      {
+        switch (signal)
+        {
+        case CMixerControlProtocol::TIMEOUT:
+          if (!m_outputSurfaces.empty())
+          {
+            m_state = M_TOP_CONFIGURED_STEP2;
+            m_bStateMachineSelfTrigger = true;
+          }
+          else
+          {
+//            if (m_extTimeout != 0)
+//            {
+//              SetPostProcFeatures(false);
+//              CLog::Log(LOGNOTICE,"---mixer wait2 decoded: %d, outputSurf: %d", (int)m_decodedPics.size(), (int)m_outputSurfaces.size());
+//            }
+            m_extTimeout = 100;
+          }
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case M_TOP_CONFIGURED_STEP2:
+       if (port == NULL) // timeout
+       {
+         switch (signal)
+         {
+         case CMixerControlProtocol::TIMEOUT:
+           m_processPicture.outputSurface = m_outputSurfaces.front();
+           m_mixerstep = 1;
+           ProcessPicture();
+           if (m_vdpError)
+           {
+             m_state = M_TOP_CONFIGURED_WAIT1;
+             m_extTimeout = 1000;
+             return;
+           }
+           if (m_processPicture.DVDPic.format != RENDER_FMT_VDPAU_420)
+             m_outputSurfaces.pop();
+           m_config.stats->IncProcessed();
+           m_dataPort.SendInMessage(CMixerDataProtocol::PICTURE,&m_processPicture,sizeof(m_processPicture));
+           FiniCycle();
+           m_state = M_TOP_CONFIGURED_WAIT1;
+           m_extTimeout = 0;
+           return;
+         default:
+           break;
+         }
+       }
+       break;
+
+    default: // we are in no state, should not happen
+      CLog::Log(LOGERROR, "CMixer::%s - no valid state: %d", __FUNCTION__, m_state);
+      return;
+    }
+  } // for
+}
+
+void CMixer::Process()
+{
+  Message *msg;
+  Protocol *port;
+  bool gotMsg;
+
+  m_state = M_TOP_UNCONFIGURED;
+  m_extTimeout = 1000;
+  m_bStateMachineSelfTrigger = false;
+
+  while (!m_bStop)
+  {
+    gotMsg = false;
+
+    if (m_bStateMachineSelfTrigger)
+    {
+      m_bStateMachineSelfTrigger = false;
+      // self trigger state machine
+      StateMachine(msg->signal, port, msg);
+      if (!m_bStateMachineSelfTrigger)
+      {
+        msg->Release();
+        msg = NULL;
+      }
+      continue;
+    }
+    // check control port
+    else if (m_controlPort.ReceiveOutMessage(&msg))
+    {
+      gotMsg = true;
+      port = &m_controlPort;
+    }
+    // check data port
+    else if (m_dataPort.ReceiveOutMessage(&msg))
+    {
+      gotMsg = true;
+      port = &m_dataPort;
+    }
+
+    if (gotMsg)
+    {
+      StateMachine(msg->signal, port, msg);
+      if (!m_bStateMachineSelfTrigger)
+      {
+        msg->Release();
+        msg = NULL;
+      }
+      continue;
+    }
+
+    // wait for message
+    else if (m_outMsgEvent.WaitMSec(m_extTimeout))
+    {
+      continue;
+    }
+    // time out
+    else
+    {
+      msg = m_controlPort.GetMessage();
+      msg->signal = CMixerControlProtocol::TIMEOUT;
+      port = 0;
+      // signal timeout to state machine
+      StateMachine(msg->signal, port, msg);
+      if (!m_bStateMachineSelfTrigger)
+      {
+        msg->Release();
+        msg = NULL;
+      }
+    }
+  }
+  Uninit();
+}
+
+void CMixer::CreateVdpauMixer()
+{
+  CLog::Log(LOGNOTICE, " (VDPAU) Creating the video mixer");
+
+  InitCSCMatrix(m_config.vidWidth);
+
+  VdpVideoMixerParameter parameters[] = {
+    VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_WIDTH,
+    VDP_VIDEO_MIXER_PARAMETER_VIDEO_SURFACE_HEIGHT,
+    VDP_VIDEO_MIXER_PARAMETER_CHROMA_TYPE};
+
+  void const * parameter_values[] = {
+    &m_config.surfaceWidth,
+    &m_config.surfaceHeight,
+    &m_config.vdpChromaType};
+
+  VdpStatus vdp_st = VDP_STATUS_ERROR;
+  vdp_st = m_config.vdpProcs.vdp_video_mixer_create(m_config.vdpDevice,
+                                m_config.featureCount,
+                                m_config.vdpFeatures,
+                                ARSIZE(parameters),
+                                parameters,
+                                parameter_values,
+                                &m_videoMixer);
+  CheckStatus(vdp_st, __LINE__);
+
+  // create 3 pitches of black lines needed for clipping top
+  // and bottom lines when de-interlacing
+  m_BlackBar = new uint32_t[3*m_config.outWidth];
+  memset(m_BlackBar, 0, 3*m_config.outWidth*sizeof(uint32_t));
+
+}
+
+void CMixer::InitCSCMatrix(int Width)
+{
+  VdpStatus vdp_st;
+  m_Procamp.struct_version = VDP_PROCAMP_VERSION;
+  m_Procamp.brightness     = 0.0;
+  m_Procamp.contrast       = 1.0;
+  m_Procamp.saturation     = 1.0;
+  m_Procamp.hue            = 0;
+  vdp_st = m_config.vdpProcs.vdp_generate_csc_matrix(&m_Procamp,
+                                   (Width < 1000)? VDP_COLOR_STANDARD_ITUR_BT_601 : VDP_COLOR_STANDARD_ITUR_BT_709,
+                                   &m_CSCMatrix);
+  CheckStatus(vdp_st, __LINE__);
+}
+
+void CMixer::CheckFeatures()
+{
+  if (m_Upscale != m_config.upscale)
+  {
+    SetHWUpscaling();
+    m_Upscale = m_config.upscale;
+  }
+  if (m_Brightness != CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness ||
+      m_Contrast   != CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast)
+  {
+    SetColor();
+    m_Brightness = CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness;
+    m_Contrast = CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast;
+  }
+  if (m_NoiseReduction != CMediaSettings::Get().GetCurrentVideoSettings().m_NoiseReduction)
+  {
+    m_NoiseReduction = CMediaSettings::Get().GetCurrentVideoSettings().m_NoiseReduction;
+    SetNoiseReduction();
+  }
+  if (m_Sharpness != CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness)
+  {
+    m_Sharpness = CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness;
+    SetSharpness();
+  }
+  if (m_DeintMode != CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode ||
+      m_Deint     != CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod)
+  {
+    m_DeintMode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+    m_Deint     = CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod;
+    SetDeinterlacing();
+  }
+}
+
+void CMixer::SetPostProcFeatures(bool postProcEnabled)
+{
+  if (m_PostProc != postProcEnabled)
+  {
+    if (postProcEnabled)
+    {
+      SetNoiseReduction();
+      SetSharpness();
+      SetDeinterlacing();
+      SetHWUpscaling();
+    }
+    else
+      PostProcOff();
+    m_PostProc = postProcEnabled;
+  }
+}
+
+void CMixer::PostProcOff()
+{
+  VdpStatus vdp_st;
+
+  if (m_videoMixer == VDP_INVALID_HANDLE)
+    return;
+
+  VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL,
+                                     VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL_SPATIAL,
+                                     VDP_VIDEO_MIXER_FEATURE_INVERSE_TELECINE};
+
+  VdpBool enabled[]={0,0,0};
+  vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+  CheckStatus(vdp_st, __LINE__);
+
+  if(m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_NOISE_REDUCTION))
+  {
+    VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_NOISE_REDUCTION};
+
+    VdpBool enabled[]={0};
+    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+    CheckStatus(vdp_st, __LINE__);
+  }
+
+  if(m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_SHARPNESS))
+  {
+    VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_SHARPNESS};
+
+    VdpBool enabled[]={0};
+    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+    CheckStatus(vdp_st, __LINE__);
+  }
+
+  DisableHQScaling();
+}
+
+
+bool CMixer::GenerateStudioCSCMatrix(VdpColorStandard colorStandard, VdpCSCMatrix &studioCSCMatrix)
+{
+   // instead use studioCSCKCoeffs601[3], studioCSCKCoeffs709[3] to generate float[3][4] matrix (float studioCSC[3][4])
+   // m00 = mRY = red: luma factor (contrast factor) (1.0)
+   // m10 = mGY = green: luma factor (contrast factor) (1.0)
+   // m20 = mBY = blue: luma factor (contrast factor) (1.0)
+   //
+   // m01 = mRB = red: blue color diff coeff (0.0)
+   // m11 = mGB = green: blue color diff coeff (-2Kb(1-Kb)/(Kg))
+   // m21 = mBB = blue: blue color diff coeff ((1-Kb)/0.5)
+   //
+   // m02 = mRR = red: red color diff coeff ((1-Kr)/0.5)
+   // m12 = mGR = green: red color diff coeff (-2Kr(1-Kr)/(Kg))
+   // m22 = mBR = blue: red color diff coeff (0.0)
+   //
+   // m03 = mRC = red: colour zero offset (brightness factor) (-(1-Kr)/0.5 * (128/255))
+   // m13 = mGC = green: colour zero offset (brightness factor) ((256/255) * (Kb(1-Kb) + Kr(1-Kr)) / Kg)
+   // m23 = mBC = blue: colour zero offset (brightness factor) (-(1-Kb)/0.5 * (128/255))
+
+   // columns
+   int Y = 0;
+   int Cb = 1;
+   int Cr = 2;
+   int C = 3;
+   // rows
+   int R = 0;
+   int G = 1;
+   int B = 2;
+   // colour standard coefficients for red, geen, blue
+   double Kr, Kg, Kb;
+   // colour diff zero position (use standard 8-bit coding precision)
+   double CDZ = 128; //256*0.5
+   // range excursion (use standard 8-bit coding precision)
+   double EXC = 255; //256-1
+
+   if (colorStandard == VDP_COLOR_STANDARD_ITUR_BT_601)
+   {
+      Kr = studioCSCKCoeffs601[0];
+      Kg = studioCSCKCoeffs601[1];
+      Kb = studioCSCKCoeffs601[2];
+   }
+   else // assume VDP_COLOR_STANDARD_ITUR_BT_709
+   {
+      Kr = studioCSCKCoeffs709[0];
+      Kg = studioCSCKCoeffs709[1];
+      Kb = studioCSCKCoeffs709[2];
+   }
+   // we keep luma unscaled to retain the levels present in source so that 16-235 luma is converted to RGB 16-235
+   studioCSCMatrix[R][Y] = 1.0;
+   studioCSCMatrix[G][Y] = 1.0;
+   studioCSCMatrix[B][Y] = 1.0;
+
+   studioCSCMatrix[R][Cb] = 0.0;
+   studioCSCMatrix[G][Cb] = (double)-2 * Kb * (1 - Kb) / Kg;
+   studioCSCMatrix[B][Cb] = (double)(1 - Kb) / 0.5;
+
+   studioCSCMatrix[R][Cr] = (double)(1 - Kr) / 0.5;
+   studioCSCMatrix[G][Cr] = (double)-2 * Kr * (1 - Kr) / Kg;
+   studioCSCMatrix[B][Cr] = 0.0;
+
+   studioCSCMatrix[R][C] = (double)-1 * studioCSCMatrix[R][Cr] * CDZ/EXC;
+   studioCSCMatrix[G][C] = (double)-1 * (studioCSCMatrix[G][Cb] + studioCSCMatrix[G][Cr]) * CDZ/EXC;
+   studioCSCMatrix[B][C] = (double)-1 * studioCSCMatrix[B][Cb] * CDZ/EXC;
+
+   return true;
+}
+
+void CMixer::SetColor()
+{
+  VdpStatus vdp_st;
+
+  if (m_Brightness != CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness)
+    m_Procamp.brightness = (float)((CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness)-50) / 100;
+  if (m_Contrast != CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast)
+    m_Procamp.contrast = (float)((CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast)+50) / 100;
+
+  VdpColorStandard colorStandard;
+//  if(vid_height >= 600 || vid_width > 1024)
+  if(m_config.surfaceWidth > 1000)
+    colorStandard = VDP_COLOR_STANDARD_ITUR_BT_709;
+    //vdp_st = vdp_generate_csc_matrix(&m_Procamp, VDP_COLOR_STANDARD_ITUR_BT_709, &m_CSCMatrix);
+  else
+    colorStandard = VDP_COLOR_STANDARD_ITUR_BT_601;
+    //vdp_st = vdp_generate_csc_matrix(&m_Procamp, VDP_COLOR_STANDARD_ITUR_BT_601, &m_CSCMatrix);
+
+  VdpVideoMixerAttribute attributes[] = { VDP_VIDEO_MIXER_ATTRIBUTE_CSC_MATRIX };
+  if (CSettings::Get().GetBool("videoscreen.limitedrange"))
+  {
+    float studioCSC[3][4];
+    GenerateStudioCSCMatrix(colorStandard, studioCSC);
+    void const * pm_CSCMatix[] = { &studioCSC };
+    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_attribute_values(m_videoMixer, ARSIZE(attributes), attributes, pm_CSCMatix);
+  }
+  else
+  {
+    vdp_st = m_config.vdpProcs.vdp_generate_csc_matrix(&m_Procamp, colorStandard, &m_CSCMatrix);
+    void const * pm_CSCMatix[] = { &m_CSCMatrix };
+    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_attribute_values(m_videoMixer, ARSIZE(attributes), attributes, pm_CSCMatix);
+  }
+  CheckStatus(vdp_st, __LINE__);
+}
+
+void CMixer::SetNoiseReduction()
+{
+  if(!m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_NOISE_REDUCTION))
+    return;
+
+  VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_NOISE_REDUCTION };
+  VdpVideoMixerAttribute attributes[] = { VDP_VIDEO_MIXER_ATTRIBUTE_NOISE_REDUCTION_LEVEL };
+  VdpStatus vdp_st;
+
+  if (!CMediaSettings::Get().GetCurrentVideoSettings().m_NoiseReduction)
+  {
+    VdpBool enabled[]= {0};
+    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+    CheckStatus(vdp_st, __LINE__);
+    return;
+  }
+  VdpBool enabled[]={1};
+  vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+  CheckStatus(vdp_st, __LINE__);
+  void* nr[] = { &CMediaSettings::Get().GetCurrentVideoSettings().m_NoiseReduction };
+  CLog::Log(LOGNOTICE,"Setting Noise Reduction to %f",CMediaSettings::Get().GetCurrentVideoSettings().m_NoiseReduction);
+  vdp_st = m_config.vdpProcs.vdp_video_mixer_set_attribute_values(m_videoMixer, ARSIZE(attributes), attributes, nr);
+  CheckStatus(vdp_st, __LINE__);
+}
+
+void CMixer::SetSharpness()
+{
+  if(!m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_SHARPNESS))
+    return;
+
+  VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_SHARPNESS };
+  VdpVideoMixerAttribute attributes[] = { VDP_VIDEO_MIXER_ATTRIBUTE_SHARPNESS_LEVEL };
+  VdpStatus vdp_st;
+
+  if (!CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness)
+  {
+    VdpBool enabled[]={0};
+    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+    CheckStatus(vdp_st, __LINE__);
+    return;
+  }
+  VdpBool enabled[]={1};
+  vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+  CheckStatus(vdp_st, __LINE__);
+  void* sh[] = { &CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness };
+  CLog::Log(LOGNOTICE,"Setting Sharpness to %f",CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness);
+  vdp_st = m_config.vdpProcs.vdp_video_mixer_set_attribute_values(m_videoMixer, ARSIZE(attributes), attributes, sh);
+  CheckStatus(vdp_st, __LINE__);
+}
+
+EINTERLACEMETHOD CMixer::GetDeinterlacingMethod(bool log /* = false */)
+{
+  EINTERLACEMETHOD method = CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod;
+  if (method == VS_INTERLACEMETHOD_AUTO)
+  {
+    int deint = -1;
+//    if (m_config.outHeight >= 720)
+//      deint = g_advancedSettings.m_videoVDPAUdeintHD;
+//    else
+//      deint = g_advancedSettings.m_videoVDPAUdeintSD;
+
+    if (deint != -1)
+    {
+      if (m_config.vdpau->Supports(EINTERLACEMETHOD(deint)))
+      {
+        method = EINTERLACEMETHOD(deint);
+        if (log)
+          CLog::Log(LOGNOTICE, "CVDPAU::GetDeinterlacingMethod: set de-interlacing to %d",  deint);
+      }
+      else
+      {
+        if (log)
+          CLog::Log(LOGWARNING, "CVDPAU::GetDeinterlacingMethod: method for de-interlacing (advanced settings) not supported");
+      }
+    }
+  }
+  return method;
+}
+
+void CMixer::SetDeinterlacing()
+{
+  VdpStatus vdp_st;
+
+  if (m_videoMixer == VDP_INVALID_HANDLE)
+    return;
+
+  EDEINTERLACEMODE   mode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+  EINTERLACEMETHOD method = GetDeinterlacingMethod(true);
+
+  VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL,
+                                     VDP_VIDEO_MIXER_FEATURE_DEINTERLACE_TEMPORAL_SPATIAL,
+                                     VDP_VIDEO_MIXER_FEATURE_INVERSE_TELECINE };
+
+  if (mode == VS_DEINTERLACEMODE_OFF)
+  {
+    VdpBool enabled[] = {0,0,0};
+    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+  }
+  else
+  {
+    if (method == VS_INTERLACEMETHOD_AUTO)
+    {
+      VdpBool enabled[] = {1,0,0};
+      if (g_advancedSettings.m_videoVDPAUtelecine)
+        enabled[2] = 1;
+      vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+    }
+    else if (method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL
+         ||  method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_HALF)
+    {
+      VdpBool enabled[] = {1,0,0};
+      if (g_advancedSettings.m_videoVDPAUtelecine)
+        enabled[2] = 1;
+      vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+    }
+    else if (method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_SPATIAL
+         ||  method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_SPATIAL_HALF)
+    {
+      VdpBool enabled[] = {1,1,0};
+      if (g_advancedSettings.m_videoVDPAUtelecine)
+        enabled[2] = 1;
+      vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+    }
+    else
+    {
+      VdpBool enabled[]={0,0,0};
+      vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+    }
+  }
+  CheckStatus(vdp_st, __LINE__);
+
+  SetDeintSkipChroma();
+
+  m_config.useInteropYuv = CSettings::Get().GetBool("videoplayer.usevdpauinteropyuv");
+}
+
+void CMixer::SetDeintSkipChroma()
+{
+  VdpVideoMixerAttribute attribute[] = { VDP_VIDEO_MIXER_ATTRIBUTE_SKIP_CHROMA_DEINTERLACE};
+  VdpStatus vdp_st;
+
+  uint8_t val;
+  if (g_advancedSettings.m_videoVDPAUdeintSkipChromaHD && m_config.outHeight >= 720)
+    val = 1;
+  else
+    val = 0;
+
+  void const *values[]={&val};
+  vdp_st = m_config.vdpProcs.vdp_video_mixer_set_attribute_values(m_videoMixer, ARSIZE(attribute), attribute, values);
+
+  CheckStatus(vdp_st, __LINE__);
+}
+
+void CMixer::SetHWUpscaling()
+{
+#ifdef VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L1
+
+  VdpStatus vdp_st;
+  VdpBool enabled[]={1};
+  switch (m_config.upscale)
+  {
+    case 9:
+       if (m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L9))
+       {
+          VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L9 };
+          vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+          break;
+       }
+    case 8:
+       if (m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L8))
+       {
+          VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L8 };
+          vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+          break;
+       }
+    case 7:
+       if (m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L7))
+       {
+          VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L7 };
+          vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+          break;
+       }
+    case 6:
+       if (m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L6))
+       {
+          VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L6 };
+          vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+          break;
+       }
+    case 5:
+       if (m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L5))
+       {
+          VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L5 };
+          vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+          break;
+       }
+    case 4:
+       if (m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L4))
+       {
+          VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L4 };
+          vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+          break;
+       }
+    case 3:
+       if (m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L3))
+       {
+          VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L3 };
+          vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+          break;
+       }
+    case 2:
+       if (m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L2))
+       {
+          VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L2 };
+          vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+          break;
+       }
+    case 1:
+       if (m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L1))
+       {
+          VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L1 };
+          vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+          break;
+       }
+    default:
+       DisableHQScaling();
+       return;
+  }
+  CheckStatus(vdp_st, __LINE__);
+#endif
+}
+
+void CMixer::DisableHQScaling()
+{
+  VdpStatus vdp_st;
+
+  if (m_videoMixer == VDP_INVALID_HANDLE)
+    return;
+
+  if(m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L1))
+  {
+    VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L1 };
+    VdpBool enabled[]={0};
+    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+    CheckStatus(vdp_st, __LINE__);
+  }
+
+  if(m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L2))
+  {
+    VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L2 };
+    VdpBool enabled[]={0};
+    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+    CheckStatus(vdp_st, __LINE__);
+  }
+
+  if(m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L3))
+  {
+    VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L3 };
+    VdpBool enabled[]={0};
+    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+    CheckStatus(vdp_st, __LINE__);
+  }
+
+  if(m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L4))
+  {
+    VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L4 };
+    VdpBool enabled[]={0};
+    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+    CheckStatus(vdp_st, __LINE__);
+  }
+
+  if(m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L5))
+  {
+    VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L5 };
+    VdpBool enabled[]={0};
+    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+    CheckStatus(vdp_st, __LINE__);
+  }
+
+  if(m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L6))
+  {
+    VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L6 };
+    VdpBool enabled[]={0};
+    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+    CheckStatus(vdp_st, __LINE__);
+  }
+
+  if(m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L7))
+  {
+    VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L7 };
+    VdpBool enabled[]={0};
+    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+    CheckStatus(vdp_st, __LINE__);
+  }
+
+  if(m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L8))
+  {
+    VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L8 };
+    VdpBool enabled[]={0};
+    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+    CheckStatus(vdp_st, __LINE__);
+  }
+
+  if(m_config.vdpau->Supports(VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L9))
+  {
+    VdpVideoMixerFeature feature[] = { VDP_VIDEO_MIXER_FEATURE_HIGH_QUALITY_SCALING_L9 };
+    VdpBool enabled[]={0};
+    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_feature_enables(m_videoMixer, ARSIZE(feature), feature, enabled);
+    CheckStatus(vdp_st, __LINE__);
+  }
+}
+
+
+void CMixer::Init()
+{
+  m_Brightness = 0.0;
+  m_Contrast = 0.0;
+  m_NoiseReduction = 0.0;
+  m_Sharpness = 0.0;
+  m_DeintMode = 0;
+  m_Deint = 0;
+  m_PostProc = false;
+  m_vdpError = false;
+
+  m_config.upscale = g_advancedSettings.m_videoVDPAUScaling;
+  m_config.useInteropYuv = CSettings::Get().GetBool("videoplayer.usevdpauinteropyuv");
+
+  CreateVdpauMixer();
+}
+
+void CMixer::Uninit()
+{
+  Flush();
+  while (!m_outputSurfaces.empty())
+  {
+    m_outputSurfaces.pop();
+  }
+  m_config.vdpProcs.vdp_video_mixer_destroy(m_videoMixer);
+
+  delete [] m_BlackBar;
+}
+
+void CMixer::Flush()
+{
+  while (!m_mixerInput.empty())
+  {
+    CVdpauDecodedPicture pic = m_mixerInput.back();
+    m_mixerInput.pop_back();
+    CSingleLock lock(*m_config.videoSurfaceSec);
+    if (pic.render)
+      pic.render->state &= ~FF_VDPAU_STATE_USED_FOR_RENDER;
+  }
+  while (!m_decodedPics.empty())
+  {
+    CVdpauDecodedPicture pic = m_decodedPics.front();
+    m_decodedPics.pop();
+    CSingleLock lock(*m_config.videoSurfaceSec);
+    if (pic.render)
+      pic.render->state &= ~FF_VDPAU_STATE_USED_FOR_RENDER;
+  }
+  Message *msg;
+  while (m_dataPort.ReceiveOutMessage(&msg))
+  {
+    if (msg->signal == CMixerDataProtocol::FRAME)
+    {
+      CVdpauDecodedPicture pic = *(CVdpauDecodedPicture*)msg->data;
+      CSingleLock lock(*m_config.videoSurfaceSec);
+      if (pic.render)
+        pic.render->state &= ~FF_VDPAU_STATE_USED_FOR_RENDER;
+    }
+    else if (msg->signal == CMixerDataProtocol::BUFFER)
+    {
+      VdpOutputSurface *surf;
+      surf = (VdpOutputSurface*)msg->data;
+      m_outputSurfaces.push(*surf);
+    }
+    msg->Release();
+  }
+}
+
+void CMixer::InitCycle()
+{
+  CheckFeatures();
+  uint64_t latency;
+  int flags;
+  m_config.stats->GetParams(latency, flags);
+  latency = (latency*1000)/CurrentHostFrequency();
+  if (flags & DVP_FLAG_NO_POSTPROC)
+    SetPostProcFeatures(false);
+  else
+    SetPostProcFeatures(true);
+
+  m_config.stats->SetCanSkipDeint(false);
+
+  EDEINTERLACEMODE   mode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+  EINTERLACEMETHOD method = GetDeinterlacingMethod();
+  bool interlaced = m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_INTERLACED;
+
+  if (mode == VS_DEINTERLACEMODE_FORCE ||
+     (mode == VS_DEINTERLACEMODE_AUTO && interlaced))
+  {
+    if((method == VS_INTERLACEMETHOD_AUTO && interlaced)
+      ||  method == VS_INTERLACEMETHOD_VDPAU_BOB
+      ||  method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL
+      ||  method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_HALF
+      ||  method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_SPATIAL
+      ||  method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_SPATIAL_HALF
+      ||  method == VS_INTERLACEMETHOD_VDPAU_INVERSE_TELECINE )
+    {
+      if(method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_HALF
+        || method == VS_INTERLACEMETHOD_VDPAU_TEMPORAL_SPATIAL_HALF
+        || !g_graphicsContext.IsFullScreenVideo())
+        m_mixersteps = 1;
+      else
+      {
+        m_mixersteps = 2;
+        m_config.stats->SetCanSkipDeint(true);
+      }
+
+      if (m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_DROPDEINT)
+      {
+        m_mixersteps = 1;
+      }
+
+      if(m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_TOP_FIELD_FIRST)
+        m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_TOP_FIELD;
+      else
+        m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_BOTTOM_FIELD;
+
+      m_mixerInput[1].DVDPic.format = RENDER_FMT_VDPAU;
+      m_mixerInput[1].DVDPic.iFlags &= ~(DVP_FLAG_TOP_FIELD_FIRST |
+                                        DVP_FLAG_REPEAT_TOP_FIELD |
+                                        DVP_FLAG_INTERLACED);
+      m_config.useInteropYuv = false;
+    }
+    else if (method == VS_INTERLACEMETHOD_RENDER_BOB && m_config.useInteropYuv)
+    {
+      m_mixersteps = 1;
+      m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME;
+      m_mixerInput[1].DVDPic.format = RENDER_FMT_VDPAU_420;
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "CMixer::%s - interlace method not supported", __FUNCTION__);
+      m_mixersteps = 1;
+      m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME;
+      m_mixerInput[1].DVDPic.format = RENDER_FMT_VDPAU;
+      m_mixerInput[1].DVDPic.iFlags &= ~(DVP_FLAG_TOP_FIELD_FIRST |
+                                        DVP_FLAG_REPEAT_TOP_FIELD |
+                                        DVP_FLAG_INTERLACED);
+    }
+  }
+  else
+  {
+    m_mixersteps = 1;
+    m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME;
+
+    if (m_config.useInteropYuv)
+      m_mixerInput[1].DVDPic.format = RENDER_FMT_VDPAU_420;
+    else
+    {
+      m_mixerInput[1].DVDPic.format = RENDER_FMT_VDPAU;
+      m_mixerInput[1].DVDPic.iFlags &= ~(DVP_FLAG_TOP_FIELD_FIRST |
+                                        DVP_FLAG_REPEAT_TOP_FIELD |
+                                        DVP_FLAG_INTERLACED);
+    }
+  }
+  m_mixerstep = 0;
+
+  if (m_mixerInput[1].DVDPic.format == RENDER_FMT_VDPAU)
+  {
+    m_processPicture.outputSurface = m_outputSurfaces.front();
+    m_mixerInput[1].DVDPic.iWidth = m_config.outWidth;
+    m_mixerInput[1].DVDPic.iHeight = m_config.outHeight;
+  }
+  else
+  {
+    m_mixerInput[1].DVDPic.iWidth = m_config.vidWidth;
+    m_mixerInput[1].DVDPic.iHeight = m_config.vidHeight;
+  }
+
+  m_processPicture.DVDPic = m_mixerInput[1].DVDPic;
+  m_processPicture.render = m_mixerInput[1].render;
+}
+
+void CMixer::FiniCycle()
+{
+  while (m_mixerInput.size() > 3)
+  {
+    CVdpauDecodedPicture &tmp = m_mixerInput.back();
+    if (tmp.render && m_processPicture.DVDPic.format != RENDER_FMT_VDPAU_420)
+    {
+      CSingleLock lock(*m_config.videoSurfaceSec);
+      tmp.render->state &= ~FF_VDPAU_STATE_USED_FOR_RENDER;
+    }
+    m_mixerInput.pop_back();
+//    m_config.stats->DecDecoded();
+  }
+}
+
+void CMixer::ProcessPicture()
+{
+  if (m_processPicture.DVDPic.format == RENDER_FMT_VDPAU_420)
+    return;
+
+  VdpStatus vdp_st;
+
+  if (m_mixerstep == 1)
+  {
+    if(m_mixerfield == VDP_VIDEO_MIXER_PICTURE_STRUCTURE_TOP_FIELD)
+      m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_BOTTOM_FIELD;
+    else
+      m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_TOP_FIELD;
+  }
+
+  VdpVideoSurface past_surfaces[4] = { VDP_INVALID_HANDLE, VDP_INVALID_HANDLE, VDP_INVALID_HANDLE, VDP_INVALID_HANDLE };
+  VdpVideoSurface futu_surfaces[2] = { VDP_INVALID_HANDLE, VDP_INVALID_HANDLE };
+  uint32_t pastCount = 4;
+  uint32_t futuCount = 2;
+
+  if(m_mixerfield == VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME)
+  {
+    // use only 2 past 1 future for progressive/weave
+    // (only used for postproc anyway eg noise reduction)
+    if (m_mixerInput.size() > 3)
+      past_surfaces[1] = m_mixerInput[3].render->surface;
+    if (m_mixerInput.size() > 2)
+      past_surfaces[0] = m_mixerInput[2].render->surface;
+    futu_surfaces[0] = m_mixerInput[0].render->surface;
+    pastCount = 2;
+    futuCount = 1;
+  }
+  else
+  {
+    if(m_mixerstep == 0)
+    { // first field
+      if (m_mixerInput.size() > 3)
+      {
+        past_surfaces[3] = m_mixerInput[3].render->surface;
+        past_surfaces[2] = m_mixerInput[3].render->surface;
+      }
+      if (m_mixerInput.size() > 2)
+      {
+        past_surfaces[1] = m_mixerInput[2].render->surface;
+        past_surfaces[0] = m_mixerInput[2].render->surface;
+      }
+      futu_surfaces[0] = m_mixerInput[1].render->surface;
+      futu_surfaces[1] = m_mixerInput[0].render->surface;;
+    }
+    else
+    { // second field
+      if (m_mixerInput.size() > 3)
+      {
+        past_surfaces[3] = m_mixerInput[3].render->surface;
+      }
+      if (m_mixerInput.size() > 2)
+      {
+        past_surfaces[2] = m_mixerInput[2].render->surface;
+        past_surfaces[1] = m_mixerInput[2].render->surface;
+      }
+      past_surfaces[0] = m_mixerInput[1].render->surface;
+      futu_surfaces[0] = m_mixerInput[1].render->surface;
+      futu_surfaces[1] = m_mixerInput[1].render->surface;
+
+      m_processPicture.DVDPic.pts = DVD_NOPTS_VALUE;
+      m_processPicture.DVDPic.dts = DVD_NOPTS_VALUE;
+    }
+    m_processPicture.DVDPic.iRepeatPicture = 0.0;
+  } // interlaced
+
+  VdpRect sourceRect;
+  sourceRect.x0 = 0;
+  sourceRect.y0 = 0;
+  sourceRect.x1 = m_config.vidWidth;
+  sourceRect.y1 = m_config.vidHeight;
+
+  VdpRect destRect;
+  destRect.x0 = 0;
+  destRect.y0 = 0;
+  destRect.x1 = m_config.outWidth;
+  destRect.y1 = m_config.outHeight;
+
+  // start vdpau video mixer
+  vdp_st = m_config.vdpProcs.vdp_video_mixer_render(m_videoMixer,
+                                VDP_INVALID_HANDLE,
+                                0,
+                                m_mixerfield,
+                                pastCount,
+                                past_surfaces,
+                                m_mixerInput[1].render->surface,
+                                futuCount,
+                                futu_surfaces,
+                                &sourceRect,
+                                m_processPicture.outputSurface,
+                                &destRect,
+                                &destRect,
+                                0,
+                                NULL);
+  CheckStatus(vdp_st, __LINE__);
+
+  if (m_mixerfield != VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME)
+  {
+    // in order to clip top and bottom lines when de-interlacing
+    // we black those lines as a work around for not working
+    // background colour using the mixer
+    // pixel perfect is preferred over overscanning or zooming
+
+    VdpRect clipRect = destRect;
+    clipRect.y1 = clipRect.y0 + 2;
+    uint32_t *data[] = {m_BlackBar};
+    uint32_t pitches[] = {destRect.x1};
+    vdp_st = m_config.vdpProcs.vdp_output_surface_put_bits_native(m_processPicture.outputSurface,
+                                            (void**)data,
+                                            pitches,
+                                            &clipRect);
+    CheckStatus(vdp_st, __LINE__);
+
+    clipRect = destRect;
+    clipRect.y0 = clipRect.y1 - 2;
+    vdp_st = m_config.vdpProcs.vdp_output_surface_put_bits_native(m_processPicture.outputSurface,
+                                            (void**)data,
+                                            pitches,
+                                            &clipRect);
+    CheckStatus(vdp_st, __LINE__);
+  }
+}
+
+
+bool CMixer::CheckStatus(VdpStatus vdp_st, int line)
+{
+  if (vdp_st != VDP_STATUS_OK)
+  {
+    CLog::Log(LOGERROR, " (VDPAU) Error: %s(%d) at %s:%d\n", m_config.vdpProcs.vdp_get_error_string(vdp_st), vdp_st, __FILE__, line);
+    m_vdpError = true;
+    return true;
+  }
+  return false;
+}
+
+//-----------------------------------------------------------------------------
+// Output
+//-----------------------------------------------------------------------------
+COutput::COutput(CEvent *inMsgEvent) :
+  CThread("Vdpau Output Thread"),
+  m_controlPort("OutputControlPort", inMsgEvent, &m_outMsgEvent),
+  m_dataPort("OutputDataPort", inMsgEvent, &m_outMsgEvent),
+  m_mixer(&m_outMsgEvent)
+{
+  m_inMsgEvent = inMsgEvent;
+
+  CVdpauRenderPicture pic;
+  pic.renderPicSection = &m_bufferPool.renderPicSec;
+  pic.refCount = 0;
+  for (unsigned int i = 0; i < NUM_RENDER_PICS; i++)
+  {
+    m_bufferPool.allRenderPics.push_back(pic);
+  }
+  for (unsigned int i = 0; i < m_bufferPool.allRenderPics.size(); ++i)
+  {
+    m_bufferPool.freeRenderPics.push_back(&m_bufferPool.allRenderPics[i]);
+  }
+}
+
+void COutput::Start()
+{
+  Create();
+}
+
+COutput::~COutput()
+{
+  Dispose();
+
+  m_bufferPool.freeRenderPics.clear();
+  m_bufferPool.usedRenderPics.clear();
+  m_bufferPool.allRenderPics.clear();
+}
+
+void COutput::Dispose()
+{
+  CSingleLock lock(g_graphicsContext);
+  m_bStop = true;
+  m_outMsgEvent.Set();
+  StopThread();
+  m_controlPort.Purge();
+  m_dataPort.Purge();
+}
+
+void COutput::OnStartup()
+{
+  CLog::Log(LOGNOTICE, "COutput::OnStartup: Output Thread created");
+}
+
+void COutput::OnExit()
+{
+  CLog::Log(LOGNOTICE, "COutput::OnExit: Output Thread terminated");
+}
+
+enum OUTPUT_STATES
+{
+  O_TOP = 0,                      // 0
+  O_TOP_ERROR,                    // 1
+  O_TOP_UNCONFIGURED,             // 2
+  O_TOP_CONFIGURED,               // 3
+  O_TOP_CONFIGURED_IDLE,          // 4
+  O_TOP_CONFIGURED_WORK,          // 5
+};
+
+int VDPAU_OUTPUT_parentStates[] = {
+    -1,
+    0, //TOP_ERROR
+    0, //TOP_UNCONFIGURED
+    0, //TOP_CONFIGURED
+    3, //TOP_CONFIGURED_IDLE
+    3, //TOP_CONFIGURED_WORK
+};
+
+void COutput::StateMachine(int signal, Protocol *port, Message *msg)
+{
+  for (int state = m_state; ; state = VDPAU_OUTPUT_parentStates[state])
+  {
+    switch (state)
+    {
+    case O_TOP: // TOP
+      if (port == &m_controlPort)
+      {
+        switch (signal)
+        {
+        case COutputControlProtocol::FLUSH:
+          msg->Reply(COutputControlProtocol::ACC);
+          return;
+        case COutputControlProtocol::PRECLEANUP:
+          msg->Reply(COutputControlProtocol::ACC);
+          return;
+        default:
+          break;
+        }
+      }
+      else if (port == &m_dataPort)
+      {
+        switch (signal)
+        {
+        case COutputDataProtocol::RETURNPIC:
+          CVdpauRenderPicture *pic;
+          pic = *((CVdpauRenderPicture**)msg->data);
+          ProcessReturnPicture(pic);
+          return;
+        default:
+          break;
+        }
+      }
+      {
+        std::string portName = port == NULL ? "timer" : port->portName;
+        CLog::Log(LOGWARNING, "COutput::%s - signal: %d form port: %s not handled for state: %d", __FUNCTION__, signal, portName.c_str(), m_state);
+      }
+      return;
+
+    case O_TOP_ERROR:
+      break;
+
+    case O_TOP_UNCONFIGURED:
+      if (port == &m_controlPort)
+      {
+        switch (signal)
+        {
+        case COutputControlProtocol::INIT:
+          CVdpauConfig *data;
+          data = (CVdpauConfig*)msg->data;
+          if (data)
+          {
+            m_config = *data;
+          }
+          Init();
+          Message *reply;
+          if (m_mixer.m_controlPort.SendOutMessageSync(CMixerControlProtocol::INIT,
+                                     &reply, 1000, &m_config, sizeof(m_config)))
+          {
+            if (reply->signal != CMixerControlProtocol::ACC)
+              m_vdpError = true;
+            reply->Release();
+          }
+
+          // set initial number of
+          m_bufferPool.numOutputSurfaces = 4;
+          EnsureBufferPool();
+          if (!m_vdpError)
+          {
+            m_state = O_TOP_CONFIGURED_IDLE;
+            msg->Reply(COutputControlProtocol::ACC);
+          }
+          else
+          {
+            m_state = O_TOP_ERROR;
+            msg->Reply(COutputControlProtocol::ERROR);
+          }
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case O_TOP_CONFIGURED:
+      if (port == &m_controlPort)
+      {
+        switch (signal)
+        {
+        case COutputControlProtocol::FLUSH:
+          Flush();
+          msg->Reply(COutputControlProtocol::ACC);
+          return;
+        case COutputControlProtocol::PRECLEANUP:
+          Flush();
+          msg->Reply(COutputControlProtocol::ACC);
+          return;
+        default:
+          break;
+        }
+      }
+      else if (port == &m_dataPort)
+      {
+        switch (signal)
+        {
+        case COutputDataProtocol::NEWFRAME:
+          CVdpauDecodedPicture *frame;
+          frame = (CVdpauDecodedPicture*)msg->data;
+          if (frame)
+          {
+            m_mixer.m_dataPort.SendOutMessage(CMixerDataProtocol::FRAME,
+                                               frame,sizeof(CVdpauDecodedPicture));
+          }
+          return;
+        case COutputDataProtocol::RETURNPIC:
+          CVdpauRenderPicture *pic;
+          pic = *((CVdpauRenderPicture**)msg->data);
+          ProcessReturnPicture(pic);
+          m_controlPort.SendInMessage(COutputControlProtocol::STATS);
+          m_state = O_TOP_CONFIGURED_WORK;
+          m_extTimeout = 0;
+          return;
+        default:
+          break;
+        }
+      }
+      else if (port == &m_mixer.m_dataPort)
+      {
+        switch (signal)
+        {
+        case CMixerDataProtocol::PICTURE:
+          CVdpauProcessedPicture *pic;
+          pic = (CVdpauProcessedPicture*)msg->data;
+          m_bufferPool.processedPics.push(*pic);
+          m_state = O_TOP_CONFIGURED_WORK;
+          m_extTimeout = 0;
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case O_TOP_CONFIGURED_IDLE:
+      if (port == NULL) // timeout
+      {
+        switch (signal)
+        {
+        case COutputControlProtocol::TIMEOUT:
+//          uint16_t decoded, processed, render;
+//          m_config.stats->Get(decoded, processed, render);
+//          CLog::Log(LOGDEBUG, "CVDPAU::COutput - timeout idle: decoded: %d, proc: %d, render: %d", decoded, processed, render);
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case O_TOP_CONFIGURED_WORK:
+      if (port == NULL) // timeout
+      {
+        switch (signal)
+        {
+        case COutputControlProtocol::TIMEOUT:
+          if (HasWork())
+          {
+            CVdpauRenderPicture *pic;
+            pic = ProcessMixerPicture();
+            if (pic)
+            {
+              m_config.stats->DecProcessed();
+              m_config.stats->IncRender();
+              m_dataPort.SendInMessage(COutputDataProtocol::PICTURE, &pic, sizeof(pic));
+            }
+            m_extTimeout = 1;
+          }
+          else
+          {
+            m_state = O_TOP_CONFIGURED_IDLE;
+            m_extTimeout = 100;
+          }
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    default: // we are in no state, should not happen
+      CLog::Log(LOGERROR, "COutput::%s - no valid state: %d", __FUNCTION__, m_state);
+      return;
+    }
+  } // for
+}
+
+void COutput::Process()
+{
+  Message *msg;
+  Protocol *port;
+  bool gotMsg;
+
+  m_state = O_TOP_UNCONFIGURED;
+  m_extTimeout = 1000;
+  m_bStateMachineSelfTrigger = false;
+
+  while (!m_bStop)
+  {
+    gotMsg = false;
+
+    if (m_bStateMachineSelfTrigger)
+    {
+      m_bStateMachineSelfTrigger = false;
+      // self trigger state machine
+      StateMachine(msg->signal, port, msg);
+      if (!m_bStateMachineSelfTrigger)
+      {
+        msg->Release();
+        msg = NULL;
+      }
+      continue;
+    }
+    // check control port
+    else if (m_controlPort.ReceiveOutMessage(&msg))
+    {
+      gotMsg = true;
+      port = &m_controlPort;
+    }
+    // check data port
+    else if (m_dataPort.ReceiveOutMessage(&msg))
+    {
+      gotMsg = true;
+      port = &m_dataPort;
+    }
+    // check mixer data port
+    else if (m_mixer.m_dataPort.ReceiveInMessage(&msg))
+    {
+      gotMsg = true;
+      port = &m_mixer.m_dataPort;
+    }
+    if (gotMsg)
+    {
+      StateMachine(msg->signal, port, msg);
+      if (!m_bStateMachineSelfTrigger)
+      {
+        msg->Release();
+        msg = NULL;
+      }
+      continue;
+    }
+
+    // wait for message
+    else if (m_outMsgEvent.WaitMSec(m_extTimeout))
+    {
+      continue;
+    }
+    // time out
+    else
+    {
+      msg = m_controlPort.GetMessage();
+      msg->signal = COutputControlProtocol::TIMEOUT;
+      port = 0;
+      // signal timeout to state machine
+      StateMachine(msg->signal, port, msg);
+      if (!m_bStateMachineSelfTrigger)
+      {
+        msg->Release();
+        msg = NULL;
+      }
+    }
+  }
+  Flush();
+  Uninit();
+}
+
+bool COutput::Init()
+{
+  if (!CreateGlxContext())
+    return false;
+
+  if (!GLInit())
+    return false;
+
+  m_mixer.Start();
+  m_vdpError = false;
+
+  return true;
+}
+
+bool COutput::Uninit()
+{
+  m_mixer.Dispose();
+  GLUnmapSurfaces();
+  GLUnbindPixmaps();
+  ReleaseBufferPool();
+  DestroyGlxContext();
+  return true;
+}
+
+void COutput::Flush()
+{
+  Message *reply;
+  if (m_mixer.m_controlPort.SendOutMessageSync(CMixerControlProtocol::FLUSH,
+                                                 &reply,
+                                                 2000))
+  {
+    reply->Release();
+  }
+  else
+    CLog::Log(LOGERROR, "Coutput::%s - failed to flush mixer", __FUNCTION__);
+
+  Message *msg;
+  while (m_mixer.m_dataPort.ReceiveInMessage(&msg))
+  {
+    if (msg->signal == CMixerDataProtocol::PICTURE)
+    {
+      CVdpauProcessedPicture pic = *(CVdpauProcessedPicture*)msg->data;
+      if (pic.DVDPic.format == RENDER_FMT_VDPAU_420)
+      {
+        CSingleLock lock(*m_config.videoSurfaceSec);
+        if (pic.render)
+          pic.render->state &= ~FF_VDPAU_STATE_USED_FOR_RENDER;
+      }
+    }
+    msg->Release();
+  }
+
+  while (m_dataPort.ReceiveOutMessage(&msg))
+  {
+    if (msg->signal == COutputDataProtocol::NEWFRAME)
+    {
+      CVdpauDecodedPicture pic = *(CVdpauDecodedPicture*)msg->data;
+      CSingleLock lock(*m_config.videoSurfaceSec);
+      if (pic.render)
+        pic.render->state &= ~FF_VDPAU_STATE_USED_FOR_RENDER;
+    }
+    else if (msg->signal == COutputDataProtocol::RETURNPIC)
+    {
+      CVdpauRenderPicture *pic;
+      pic = *((CVdpauRenderPicture**)msg->data);
+      ProcessReturnPicture(pic);
+    }
+    msg->Release();
+  }
+
+  while (m_dataPort.ReceiveInMessage(&msg))
+  {
+    if (msg->signal == COutputDataProtocol::PICTURE)
+    {
+      CVdpauRenderPicture *pic;
+      pic = *((CVdpauRenderPicture**)msg->data);
+      ProcessReturnPicture(pic);
+    }
+  }
+
+  // reset used render flag which was cleared on mixer flush
+  std::deque<CVdpauRenderPicture*>::iterator it;
+  for (it = m_bufferPool.usedRenderPics.begin(); it != m_bufferPool.usedRenderPics.end(); ++it)
+  {
+    if ((*it)->DVDPic.format == RENDER_FMT_VDPAU_420)
+    {
+      std::map<VdpVideoSurface, VdpauBufferPool::GLVideoSurface>::iterator it2;
+      it2 = m_bufferPool.glVideoSurfaceMap.find((*it)->sourceIdx);
+      if (it2 == m_bufferPool.glVideoSurfaceMap.end())
+      {
+        CLog::Log(LOGDEBUG, "COutput::Flush - gl surface not found");
+        continue;
+      }
+      vdpau_render_state *render = it2->second.sourceVuv;
+      if (render)
+        render->state |= FF_VDPAU_STATE_USED_FOR_RENDER;
+    }
+  }
+}
+
+bool COutput::HasWork()
+{
+  if (m_config.usePixmaps)
+  {
+    if (!m_bufferPool.processedPics.empty() && FindFreePixmap() >= 0)
+      return true;
+    if (!m_bufferPool.notVisiblePixmaps.empty() && !m_bufferPool.freeRenderPics.empty())
+      return true;
+    return false;
+  }
+  else
+  {
+    if (!m_bufferPool.processedPics.empty() && !m_bufferPool.freeRenderPics.empty())
+      return true;
+    return false;
+  }
+}
+
+CVdpauRenderPicture* COutput::ProcessMixerPicture()
+{
+  CVdpauRenderPicture *retPic = 0;
+
+  if (m_config.usePixmaps)
+  {
+    if (!m_bufferPool.processedPics.empty() && FindFreePixmap() >= 0)
+    {
+      unsigned int i = FindFreePixmap();
+      VdpauBufferPool::Pixmaps *pixmap = &m_bufferPool.pixmaps[i];
+      pixmap->used = true;
+      CVdpauProcessedPicture pic = m_bufferPool.processedPics.front();
+      m_bufferPool.processedPics.pop();
+      pixmap->surface = pic.outputSurface;
+      pixmap->DVDPic = pic.DVDPic;
+      pixmap->id = i;
+      m_bufferPool.notVisiblePixmaps.push_back(pixmap);
+      VdpStatus vdp_st;
+      m_config.vdpProcs.vdp_presentation_queue_display(pixmap->vdp_flip_queue,
+                                                       pixmap->surface,0,0,0);
+    }
+    if (!m_bufferPool.notVisiblePixmaps.empty() && !m_bufferPool.freeRenderPics.empty())
+    {
+      VdpStatus vdp_st;
+      VdpTime time;
+      VdpPresentationQueueStatus status;
+      VdpauBufferPool::Pixmaps *pixmap = m_bufferPool.notVisiblePixmaps.front();
+      vdp_st = m_config.vdpProcs.vdp_presentation_queue_query_surface_status(
+                        pixmap->vdp_flip_queue, pixmap->surface, &status, &time);
+
+      if (vdp_st == VDP_STATUS_OK && status == VDP_PRESENTATION_QUEUE_STATUS_VISIBLE)
+      {
+        retPic = m_bufferPool.freeRenderPics.front();
+        m_bufferPool.freeRenderPics.pop_front();
+        m_bufferPool.usedRenderPics.push_back(retPic);
+        retPic->sourceIdx = pixmap->id;
+        retPic->DVDPic = pixmap->DVDPic;
+        retPic->valid = true;
+        retPic->texture[0] = pixmap->texture;
+        retPic->crop = CRect(0,0,0,0);
+        m_bufferPool.notVisiblePixmaps.pop_front();
+        m_mixer.m_dataPort.SendOutMessage(CMixerDataProtocol::BUFFER, &pixmap->surface, sizeof(pixmap->surface));
+      }
+    }
+  } // pixmap
+  else if (!m_bufferPool.processedPics.empty() && !m_bufferPool.freeRenderPics.empty())
+  {
+    retPic = m_bufferPool.freeRenderPics.front();
+    m_bufferPool.freeRenderPics.pop_front();
+    m_bufferPool.usedRenderPics.push_back(retPic);
+    CVdpauProcessedPicture procPic = m_bufferPool.processedPics.front();
+    m_bufferPool.processedPics.pop();
+
+    retPic->DVDPic = procPic.DVDPic;
+    retPic->valid = true;
+    if (retPic->DVDPic.format == RENDER_FMT_VDPAU)
+    {
+      m_config.useInteropYuv = false;
+      m_bufferPool.numOutputSurfaces = NUM_RENDER_PICS;
+      EnsureBufferPool();
+      GLMapSurfaces();
+      retPic->sourceIdx = procPic.outputSurface;
+      retPic->texture[0] = m_bufferPool.glOutputSurfaceMap[procPic.outputSurface].texture[0];
+      retPic->crop = CRect(0,0,0,0);
+    }
+    else
+    {
+      m_config.useInteropYuv = true;
+      GLMapSurfaces();
+      retPic->sourceIdx = procPic.render->surface;
+      for (unsigned int i=0; i<4; ++i)
+        retPic->texture[i] = m_bufferPool.glVideoSurfaceMap[procPic.render->surface].texture[i];
+      retPic->texWidth = m_config.surfaceWidth;
+      retPic->texHeight = m_config.surfaceHeight;
+      retPic->crop.x1 = 0;
+      retPic->crop.y1 = 0;
+      retPic->crop.x2 = m_config.surfaceWidth - m_config.vidWidth;
+      retPic->crop.y2 = m_config.surfaceHeight - m_config.vidHeight;
+    }
+  }
+  return retPic;
+}
+
+void COutput::ProcessReturnPicture(CVdpauRenderPicture *pic)
+{
+  std::deque<CVdpauRenderPicture*>::iterator it;
+  it = std::find(m_bufferPool.usedRenderPics.begin(), m_bufferPool.usedRenderPics.end(), pic);
+  if (it == m_bufferPool.usedRenderPics.end())
+  {
+    CLog::Log(LOGWARNING, "COutput::ProcessReturnPicture - pic not found");
+    return;
+  }
+  m_bufferPool.usedRenderPics.erase(it);
+  m_bufferPool.freeRenderPics.push_back(pic);
+  if (!pic->valid)
+  {
+    CLog::Log(LOGDEBUG, "COutput::%s - return of invalid render pic", __FUNCTION__);
+    return;
+  }
+
+  if (m_config.usePixmaps)
+  {
+    m_bufferPool.pixmaps[pic->sourceIdx].used = false;
+    return;
+  }
+  else if (pic->DVDPic.format == RENDER_FMT_VDPAU_420)
+  {
+    std::map<VdpVideoSurface, VdpauBufferPool::GLVideoSurface>::iterator it;
+    it = m_bufferPool.glVideoSurfaceMap.find(pic->sourceIdx);
+    if (it == m_bufferPool.glVideoSurfaceMap.end())
+    {
+      CLog::Log(LOGDEBUG, "COutput::ProcessReturnPicture - gl surface not found");
+      return;
+    }
+    vdpau_render_state *render = it->second.sourceVuv;
+    CSingleLock lock(*m_config.videoSurfaceSec);
+    render->state &= ~FF_VDPAU_STATE_USED_FOR_RENDER;
+  }
+  else if (pic->DVDPic.format == RENDER_FMT_VDPAU)
+  {
+    std::map<VdpOutputSurface, VdpauBufferPool::GLVideoSurface>::iterator it;
+    it = m_bufferPool.glOutputSurfaceMap.find(pic->sourceIdx);
+    if (it == m_bufferPool.glOutputSurfaceMap.end())
+    {
+      CLog::Log(LOGDEBUG, "COutput::ProcessReturnPicture - gl surface not found");
+      return;
+    }
+    VdpOutputSurface outSurf = it->second.sourceRgb;
+    m_mixer.m_dataPort.SendOutMessage(CMixerDataProtocol::BUFFER, &outSurf, sizeof(outSurf));
+  }
+}
+
+int COutput::FindFreePixmap()
+{
+  // find free pixmap
+  unsigned int i;
+  for (i = 0; i < m_bufferPool.pixmaps.size(); ++i)
+  {
+    if (!m_bufferPool.pixmaps[i].used)
+      break;
+  }
+  if (i == m_bufferPool.pixmaps.size())
+    return -1;
+  else
+    return i;
+}
+
+bool COutput::EnsureBufferPool()
+{
+  VdpStatus vdp_st;
+
+  // Creation of outputSurfaces
+  VdpOutputSurface outputSurface;
+  for (int i = m_bufferPool.outputSurfaces.size(); i < m_bufferPool.numOutputSurfaces; i++)
+  {
+    vdp_st = m_config.vdpProcs.vdp_output_surface_create(m_config.vdpDevice,
+                                      VDP_RGBA_FORMAT_B8G8R8A8,
+                                      m_config.outWidth,
+                                      m_config.outHeight,
+                                      &outputSurface);
+    if (CheckStatus(vdp_st, __LINE__))
+      return false;
+    m_bufferPool.outputSurfaces.push_back(outputSurface);
+
+    m_mixer.m_dataPort.SendOutMessage(CMixerDataProtocol::BUFFER,
+                                      &outputSurface,
+                                      sizeof(VdpOutputSurface));
+    CLog::Log(LOGNOTICE, "VDPAU::COutput::InitBufferPool - Output Surface created");
+  }
+
+
+  if (m_config.usePixmaps && m_bufferPool.pixmaps.empty())
+  {
+    // create pixmpas
+    VdpauBufferPool::Pixmaps pixmap;
+    int numPixmaps = NUM_RENDER_PICS;
+    for (unsigned int i = 0; i < numPixmaps; i++)
+    {
+      pixmap.pixmap = None;
+      pixmap.glPixmap = None;
+      pixmap.vdp_flip_queue = VDP_INVALID_HANDLE;
+      pixmap.vdp_flip_target = VDP_INVALID_HANDLE;
+      MakePixmap(pixmap);
+      glXMakeCurrent(m_Display, None, NULL);
+      vdp_st = m_config.vdpProcs.vdp_presentation_queue_target_create_x11(m_config.vdpDevice,
+                                             pixmap.pixmap, //x_window,
+                                             &pixmap.vdp_flip_target);
+
+      CheckStatus(vdp_st, __LINE__);
+
+      vdp_st = m_config.vdpProcs.vdp_presentation_queue_create(m_config.vdpDevice,
+                                            pixmap.vdp_flip_target,
+                                            &pixmap.vdp_flip_queue);
+      CheckStatus(vdp_st, __LINE__);
+      glXMakeCurrent(m_Display, m_glPixmap, m_glContext);
+
+      pixmap.id = i;
+      pixmap.used = false;
+      m_bufferPool.pixmaps.push_back(pixmap);
+    }
+    GLBindPixmaps();
+  }
+
+  return true;
+}
+
+void COutput::ReleaseBufferPool()
+{
+  VdpStatus vdp_st;
+
+  CSingleLock lock(m_bufferPool.renderPicSec);
+
+  if (m_config.usePixmaps)
+  {
+    for (unsigned int i = 0; i < m_bufferPool.pixmaps.size(); ++i)
+    {
+      if (m_bufferPool.pixmaps[i].vdp_flip_queue != VDP_INVALID_HANDLE)
+      {
+        vdp_st = m_config.vdpProcs.vdp_presentation_queue_destroy(m_bufferPool.pixmaps[i].vdp_flip_queue);
+        CheckStatus(vdp_st, __LINE__);
+      }
+      if (m_bufferPool.pixmaps[i].vdp_flip_target != VDP_INVALID_HANDLE)
+      {
+        vdp_st = m_config.vdpProcs.vdp_presentation_queue_target_destroy(m_bufferPool.pixmaps[i].vdp_flip_target);
+        CheckStatus(vdp_st, __LINE__);
+      }
+      if (m_bufferPool.pixmaps[i].glPixmap)
+      {
+        glXDestroyPixmap(m_Display, m_bufferPool.pixmaps[i].glPixmap);
+      }
+      if (m_bufferPool.pixmaps[i].pixmap)
+      {
+        XFreePixmap(m_Display, m_bufferPool.pixmaps[i].pixmap);
+      }
+    }
+    m_bufferPool.pixmaps.clear();
+  }
+
+  // release all output surfaces
+  for (unsigned int i = 0; i < m_bufferPool.outputSurfaces.size(); ++i)
+  {
+    if (m_bufferPool.outputSurfaces[i] == VDP_INVALID_HANDLE)
+      continue;
+    vdp_st = m_config.vdpProcs.vdp_output_surface_destroy(m_bufferPool.outputSurfaces[i]);
+    CheckStatus(vdp_st, __LINE__);
+  }
+  m_bufferPool.outputSurfaces.clear();
+
+  // invalidate all used render pictures
+  for (unsigned int i = 0; i < m_bufferPool.usedRenderPics.size(); ++i)
+  {
+    m_bufferPool.usedRenderPics[i]->valid = false;
+  }
+}
+
+void COutput::InitMixer()
+{
+  for (unsigned int i = 0; i < m_bufferPool.outputSurfaces.size(); ++i)
+  {
+    m_mixer.m_dataPort.SendOutMessage(CMixerDataProtocol::BUFFER,
+                                      &m_bufferPool.outputSurfaces[i],
+                                      sizeof(VdpOutputSurface));
+  }
+}
+
+bool COutput::MakePixmap(VdpauBufferPool::Pixmaps &pixmap)
+{
+  CLog::Log(LOGNOTICE,"Creating %ix%i pixmap", m_config.outWidth, m_config.outHeight);
+
+    // Get our window attribs.
+  XWindowAttributes wndattribs;
+  XGetWindowAttributes(m_Display, g_Windowing.GetWindow(), &wndattribs);
+
+  pixmap.pixmap = XCreatePixmap(m_Display,
+                           g_Windowing.GetWindow(),
+                           m_config.outWidth,
+                           m_config.outHeight,
+                           wndattribs.depth);
+  if (!pixmap.pixmap)
+  {
+    CLog::Log(LOGERROR, "VDPAU::COUtput::MakePixmap - GLX Error: MakePixmap: Unable to create XPixmap");
+    return false;
+  }
+
+//  XGCValues values = {};
+//  GC xgc;
+//  values.foreground = BlackPixel (m_Display, DefaultScreen (m_Display));
+//  xgc = XCreateGC(m_Display, pixmap.pixmap, GCForeground, &values);
+//  XFillRectangle(m_Display, pixmap.pixmap, xgc, 0, 0, m_config.outWidth, m_config.outHeight);
+//  XFreeGC(m_Display, xgc);
+
+  if(!MakePixmapGL(pixmap))
+    return false;
+
+  return true;
+}
+
+bool COutput::MakePixmapGL(VdpauBufferPool::Pixmaps &pixmap)
+{
+  int num=0;
+  int fbConfigIndex = 0;
+
+  int doubleVisAttributes[] = {
+    GLX_RENDER_TYPE, GLX_RGBA_BIT,
+    GLX_RED_SIZE, 8,
+    GLX_GREEN_SIZE, 8,
+    GLX_BLUE_SIZE, 8,
+    GLX_ALPHA_SIZE, 8,
+    GLX_DEPTH_SIZE, 8,
+    GLX_DRAWABLE_TYPE, GLX_PIXMAP_BIT,
+    GLX_BIND_TO_TEXTURE_RGBA_EXT, True,
+    GLX_DOUBLEBUFFER, False,
+    GLX_Y_INVERTED_EXT, True,
+    GLX_X_RENDERABLE, True,
+    None
+  };
+
+  int pixmapAttribs[] = {
+    GLX_TEXTURE_TARGET_EXT, GLX_TEXTURE_2D_EXT,
+    GLX_TEXTURE_FORMAT_EXT, GLX_TEXTURE_FORMAT_RGBA_EXT,
+    None
+  };
+
+  GLXFBConfig *fbConfigs;
+  fbConfigs = glXChooseFBConfig(m_Display, g_Windowing.GetCurrentScreen(), doubleVisAttributes, &num);
+  if (fbConfigs==NULL)
+  {
+    CLog::Log(LOGERROR, "VDPAU::COutput::MakPixmapGL - No compatible framebuffers found");
+    return false;
+  }
+  fbConfigIndex = 0;
+
+  pixmap.glPixmap = glXCreatePixmap(m_Display, fbConfigs[fbConfigIndex], pixmap.pixmap, pixmapAttribs);
+
+  if (!pixmap.glPixmap)
+  {
+    CLog::Log(LOGERROR, "VDPAU::COutput::MakPixmapGL - Could not create Pixmap");
+    XFree(fbConfigs);
+    return false;
+  }
+  XFree(fbConfigs);
+  return true;
+}
+
+bool COutput::GLInit()
+{
+  glXBindTexImageEXT = NULL;
+  glXReleaseTexImageEXT = NULL;
+#ifdef GL_NV_vdpau_interop
+  glVDPAUInitNV = NULL;
+  glVDPAUFiniNV = NULL;
+  glVDPAURegisterOutputSurfaceNV = NULL;
+  glVDPAURegisterVideoSurfaceNV = NULL;
+  glVDPAUIsSurfaceNV = NULL;
+  glVDPAUUnregisterSurfaceNV = NULL;
+  glVDPAUSurfaceAccessNV = NULL;
+  glVDPAUMapSurfacesNV = NULL;
+  glVDPAUUnmapSurfacesNV = NULL;
+  glVDPAUGetSurfaceivNV = NULL;
+#endif
+
+  m_config.usePixmaps = !CSettings::Get().GetBool("videoplayer.usevdpauinterop");
+
+#ifdef GL_NV_vdpau_interop
+  if (glewIsSupported("GL_NV_vdpau_interop"))
+  {
+    if (!glVDPAUInitNV)
+      glVDPAUInitNV    = (PFNGLVDPAUINITNVPROC)glXGetProcAddress((GLubyte *) "glVDPAUInitNV");
+    if (!glVDPAUFiniNV)
+      glVDPAUFiniNV = (PFNGLVDPAUFININVPROC)glXGetProcAddress((GLubyte *) "glVDPAUFiniNV");
+    if (!glVDPAURegisterOutputSurfaceNV)
+      glVDPAURegisterOutputSurfaceNV    = (PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC)glXGetProcAddress((GLubyte *) "glVDPAURegisterOutputSurfaceNV");
+    if (!glVDPAURegisterVideoSurfaceNV)
+      glVDPAURegisterVideoSurfaceNV    = (PFNGLVDPAUREGISTERVIDEOSURFACENVPROC)glXGetProcAddress((GLubyte *) "glVDPAURegisterVideoSurfaceNV");
+    if (!glVDPAUIsSurfaceNV)
+      glVDPAUIsSurfaceNV    = (PFNGLVDPAUISSURFACENVPROC)glXGetProcAddress((GLubyte *) "glVDPAUIsSurfaceNV");
+    if (!glVDPAUUnregisterSurfaceNV)
+      glVDPAUUnregisterSurfaceNV = (PFNGLVDPAUUNREGISTERSURFACENVPROC)glXGetProcAddress((GLubyte *) "glVDPAUUnregisterSurfaceNV");
+    if (!glVDPAUSurfaceAccessNV)
+      glVDPAUSurfaceAccessNV    = (PFNGLVDPAUSURFACEACCESSNVPROC)glXGetProcAddress((GLubyte *) "glVDPAUSurfaceAccessNV");
+    if (!glVDPAUMapSurfacesNV)
+      glVDPAUMapSurfacesNV = (PFNGLVDPAUMAPSURFACESNVPROC)glXGetProcAddress((GLubyte *) "glVDPAUMapSurfacesNV");
+    if (!glVDPAUUnmapSurfacesNV)
+      glVDPAUUnmapSurfacesNV = (PFNGLVDPAUUNMAPSURFACESNVPROC)glXGetProcAddress((GLubyte *) "glVDPAUUnmapSurfacesNV");
+    if (!glVDPAUGetSurfaceivNV)
+      glVDPAUGetSurfaceivNV = (PFNGLVDPAUGETSURFACEIVNVPROC)glXGetProcAddress((GLubyte *) "glVDPAUGetSurfaceivNV");
+
+    CLog::Log(LOGNOTICE, "VDPAU::COutput GL interop supported");
+  }
+  else
+#endif
+  {
+    m_config.usePixmaps = true;
+    CSettings::Get().SetBool("videoplayer.usevdpauinterop",false);
+    CSettings::Get().SetBool("videoplayer.usevdpauinteropyuv",false);
+  }
+  if (!glXBindTexImageEXT)
+    glXBindTexImageEXT    = (PFNGLXBINDTEXIMAGEEXTPROC)glXGetProcAddress((GLubyte *) "glXBindTexImageEXT");
+  if (!glXReleaseTexImageEXT)
+    glXReleaseTexImageEXT = (PFNGLXRELEASETEXIMAGEEXTPROC)glXGetProcAddress((GLubyte *) "glXReleaseTexImageEXT");
+
+#ifdef GL_NV_vdpau_interop
+  if (!m_config.usePixmaps)
+  {
+    while (glGetError() != GL_NO_ERROR);
+    glVDPAUInitNV(reinterpret_cast<void*>(m_config.vdpDevice), reinterpret_cast<void*>(m_config.vdpProcs.vdp_get_proc_address));
+    if (glGetError() != GL_NO_ERROR)
+    {
+      CLog::Log(LOGERROR, "VDPAU::COutput - GLInitInterop glVDPAUInitNV failed");
+      m_vdpError = true;
+      return false;
+    }
+    CLog::Log(LOGNOTICE, "VDPAU::COutput: vdpau gl interop initialized");
+  }
+#endif
+  return true;
+}
+
+void COutput::GLMapSurfaces()
+{
+#ifdef GL_NV_vdpau_interop
+  if (m_config.usePixmaps)
+    return;
+
+  if (m_config.useInteropYuv)
+  {
+    VdpauBufferPool::GLVideoSurface glSurface;
+    if (m_config.videoSurfaces->size() != m_bufferPool.glVideoSurfaceMap.size())
+    {
+      CSingleLock lock(*m_config.videoSurfaceSec);
+      for (int i = 0; i < m_config.videoSurfaces->size(); i++)
+      {
+        if ((*m_config.videoSurfaces)[i]->surface == VDP_INVALID_HANDLE)
+          continue;
+
+        if (m_bufferPool.glVideoSurfaceMap.find((*m_config.videoSurfaces)[i]->surface) == m_bufferPool.glVideoSurfaceMap.end())
+        {
+          glSurface.sourceVuv = (*m_config.videoSurfaces)[i];
+          while (glGetError() != GL_NO_ERROR) ;
+          glGenTextures(4, glSurface.texture);
+          if (glGetError() != GL_NO_ERROR)
+          {
+             CLog::Log(LOGERROR, "VDPAU::COutput error creating texture");
+             m_vdpError = true;
+          }
+          glSurface.glVdpauSurface = glVDPAURegisterVideoSurfaceNV(reinterpret_cast<void*>((*m_config.videoSurfaces)[i]->surface),
+                                                    GL_TEXTURE_2D, 4, glSurface.texture);
+
+          if (glGetError() != GL_NO_ERROR)
+          {
+            CLog::Log(LOGERROR, "VDPAU::COutput error register video surface");
+            m_vdpError = true;
+          }
+          glVDPAUSurfaceAccessNV(glSurface.glVdpauSurface, GL_READ_ONLY);
+          if (glGetError() != GL_NO_ERROR)
+          {
+            CLog::Log(LOGERROR, "VDPAU::COutput error setting access");
+            m_vdpError = true;
+          }
+          glVDPAUMapSurfacesNV(1, &glSurface.glVdpauSurface);
+          if (glGetError() != GL_NO_ERROR)
+          {
+            CLog::Log(LOGERROR, "VDPAU::COutput error mapping surface");
+            m_vdpError = true;
+          }
+          m_bufferPool.glVideoSurfaceMap[(*m_config.videoSurfaces)[i]->surface] = glSurface;
+          if (m_vdpError)
+            return;
+          CLog::Log(LOGNOTICE, "VDPAU::COutput registered surface");
+        }
+      }
+    }
+  }
+  else
+  {
+    if (m_bufferPool.glOutputSurfaceMap.size() != m_bufferPool.numOutputSurfaces)
+    {
+      VdpauBufferPool::GLVideoSurface glSurface;
+      for (int i=m_bufferPool.glOutputSurfaceMap.size(); i<m_bufferPool.outputSurfaces.size(); i++)
+      {
+        glSurface.sourceRgb = m_bufferPool.outputSurfaces[i];
+        glGenTextures(1, glSurface.texture);
+        glSurface.glVdpauSurface = glVDPAURegisterOutputSurfaceNV(reinterpret_cast<void*>(m_bufferPool.outputSurfaces[i]),
+                                               GL_TEXTURE_2D, 1, glSurface.texture);
+        if (glGetError() != GL_NO_ERROR)
+        {
+          CLog::Log(LOGERROR, "VDPAU::COutput error register output surface");
+          m_vdpError = true;
+        }
+        glVDPAUSurfaceAccessNV(glSurface.glVdpauSurface, GL_READ_ONLY);
+        if (glGetError() != GL_NO_ERROR)
+        {
+          CLog::Log(LOGERROR, "VDPAU::COutput error setting access");
+          m_vdpError = true;
+        }
+        glVDPAUMapSurfacesNV(1, &glSurface.glVdpauSurface);
+        if (glGetError() != GL_NO_ERROR)
+        {
+          CLog::Log(LOGERROR, "VDPAU::COutput error mapping surface");
+          m_vdpError = true;
+        }
+        m_bufferPool.glOutputSurfaceMap[m_bufferPool.outputSurfaces[i]] = glSurface;
+        if (m_vdpError)
+          return;
+      }
+      CLog::Log(LOGNOTICE, "VDPAU::COutput registered output surfaces");
+    }
+  }
+#endif
+}
+
+void COutput::GLUnmapSurfaces()
+{
+#ifdef GL_NV_vdpau_interop
+  if (m_config.usePixmaps)
+    return;
+
+  { CSingleLock lock(*m_config.videoSurfaceSec);
+    std::map<VdpVideoSurface, VdpauBufferPool::GLVideoSurface>::iterator it;
+    for (it = m_bufferPool.glVideoSurfaceMap.begin(); it != m_bufferPool.glVideoSurfaceMap.end(); ++it)
+    {
+      glVDPAUUnregisterSurfaceNV(it->second.glVdpauSurface);
+      glDeleteTextures(4, it->second.texture);
+    }
+    m_bufferPool.glVideoSurfaceMap.clear();
+  }
+
+  std::map<VdpOutputSurface, VdpauBufferPool::GLVideoSurface>::iterator it;
+  for (it = m_bufferPool.glOutputSurfaceMap.begin(); it != m_bufferPool.glOutputSurfaceMap.end(); ++it)
+  {
+    glVDPAUUnregisterSurfaceNV(it->second.glVdpauSurface);
+    glDeleteTextures(1, it->second.texture);
+  }
+  m_bufferPool.glOutputSurfaceMap.clear();
+
+  glVDPAUFiniNV();
+
+  CLog::Log(LOGNOTICE, "VDPAU::COutput: vdpau gl interop finished");
+
+#endif
+}
+
+void COutput::GLBindPixmaps()
+{
+  if (!m_config.usePixmaps)
+    return;
+
+  for (unsigned int i = 0; i < m_bufferPool.pixmaps.size(); i++)
+  {
+    // create texture
+    glGenTextures(1, &m_bufferPool.pixmaps[i].texture);
+
+    //bind texture
+    glBindTexture(GL_TEXTURE_2D, m_bufferPool.pixmaps[i].texture);
+
+    // bind pixmap
+    glXBindTexImageEXT(m_Display, m_bufferPool.pixmaps[i].glPixmap, GLX_FRONT_LEFT_EXT, NULL);
+
+    glBindTexture(GL_TEXTURE_2D, 0);
+  }
+
+  CLog::Log(LOGNOTICE, "VDPAU::COutput: bound pixmaps");
+}
+
+void COutput::GLUnbindPixmaps()
+{
+  if (!m_config.usePixmaps)
+    return;
+
+  for (unsigned int i = 0; i < m_bufferPool.pixmaps.size(); i++)
+  {
+    // create texture
+    if (!glIsTexture(m_bufferPool.pixmaps[i].texture))
+      continue;
+
+    //bind texture
+    glBindTexture(GL_TEXTURE_2D, m_bufferPool.pixmaps[i].texture);
+
+    // release pixmap
+    glXReleaseTexImageEXT(m_Display, m_bufferPool.pixmaps[i].glPixmap, GLX_FRONT_LEFT_EXT);
+
+    glBindTexture(GL_TEXTURE_2D, 0);
+
+    glDeleteTextures(1, &m_bufferPool.pixmaps[i].texture);
+  }
+  CLog::Log(LOGNOTICE, "VDPAU::COutput: unbound pixmaps");
+}
+
+bool COutput::CheckStatus(VdpStatus vdp_st, int line)
+{
+  if (vdp_st != VDP_STATUS_OK)
+  {
+    CLog::Log(LOGERROR, " (VDPAU) Error: %s(%d) at %s:%d\n", m_config.vdpProcs.vdp_get_error_string(vdp_st), vdp_st, __FILE__, line);
+    m_vdpError = true;
+    return true;
+  }
+  return false;
+}
+
+bool COutput::CreateGlxContext()
+{
+  GLXContext   glContext;
+  Window       window;
+
+  m_Display = g_Windowing.GetDisplay();
+  glContext = g_Windowing.GetGlxContext();
+  m_Window = g_Windowing.GetWindow();
+
+  // Get our window attribs.
+  XWindowAttributes wndattribs;
+  XGetWindowAttributes(m_Display, m_Window, &wndattribs);
+
+  // Get visual Info
+  XVisualInfo visInfo;
+  visInfo.visualid = wndattribs.visual->visualid;
+  int nvisuals = 0;
+  XVisualInfo* visuals = XGetVisualInfo(m_Display, VisualIDMask, &visInfo, &nvisuals);
+  if (nvisuals != 1)
+  {
+    CLog::Log(LOGERROR, "VDPAU::COutput::CreateGlxContext - could not find visual");
+    return false;
+  }
+  visInfo = visuals[0];
+  XFree(visuals);
+
+  m_pixmap = XCreatePixmap(m_Display,
+                           m_Window,
+                           192,
+                           108,
+                           visInfo.depth);
+  if (!m_pixmap)
+  {
+    CLog::Log(LOGERROR, "VDPAU::COutput::CreateGlxContext - Unable to create XPixmap");
+    return false;
+  }
+
+  // create gl pixmap
+  m_glPixmap = glXCreateGLXPixmap(m_Display, &visInfo, m_pixmap);
+
+  if (!m_glPixmap)
+  {
+    CLog::Log(LOGINFO, "VDPAU::COutput::CreateGlxContext - Could not create glPixmap");
+    return false;
+  }
+
+  m_glContext = glXCreateContext(m_Display, &visInfo, glContext, True);
+
+  if (!glXMakeCurrent(m_Display, m_glPixmap, m_glContext))
+  {
+    CLog::Log(LOGINFO, "VDPAU::COutput::CreateGlxContext - Could not make Pixmap current");
+    return false;
+  }
+
+  CLog::Log(LOGNOTICE, "VDPAU::COutput::CreateGlxContext - created context");
+  return true;
+}
+
+bool COutput::DestroyGlxContext()
+{
+  if (m_glContext)
+  {
+    glXMakeCurrent(m_Display, None, NULL);
+    glXDestroyContext(m_Display, m_glContext);
+  }
+  m_glContext = 0;
+
+  if (m_glPixmap)
+    glXDestroyPixmap(m_Display, m_glPixmap);
+  m_glPixmap = 0;
+
+  if (m_pixmap)
+    XFreePixmap(m_Display, m_pixmap);
+  m_pixmap = 0;
+
+  return true;
+}
+
 #endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
index 87e8797..5bee48b 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
@@ -1,5 +1,3 @@
-
-#pragma once
 /*
  *      Copyright (C) 2005-2013 Team XBMC
  *      http://www.xbmc.org
@@ -20,9 +18,32 @@
  *
  */
 
+/**
+ * design goals:
+ * - improve performance
+ *   max out hw resources: e.g. make 1080p60 play on ION2
+ *   allow advanced de-interlacing on ION
+ *
+ * - add vdpau/opengl interop
+ *
+ * - remove tight dependency to render thread
+ *   prior design needed to hijack render thread in order to do
+ *   gl interop functions. In particular this was a problem for
+ *   init and clear down. Introduction of GL_NV_vdpau_interop
+ *   increased the need to be independent from render thread
+ *
+ * - move to an actor based design in order to reduce the number
+ *   of locks needed.
+ */
+
+#pragma once
+
 #include "system_gl.h"
 
-#include <queue>
+#include "DllAvUtil.h"
+#include "DVDVideoCodec.h"
+#include "DVDVideoCodecFFmpeg.h"
+#include "libavcodec/vdpau.h"
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
 #define GLX_GLXEXT_PROTOTYPES
@@ -37,124 +58,31 @@
 #include "settings/VideoSettings.h"
 #include "guilib/DispResource.h"
 #include "threads/Event.h"
-namespace Surface { class CSurface; }
-
-#define NUM_OUTPUT_SURFACES                4
-#define NUM_VIDEO_SURFACES_MPEG2           10  // (1 frame being decoded, 2 reference)
-#define NUM_VIDEO_SURFACES_H264            32 // (1 frame being decoded, up to 16 references)
-#define NUM_VIDEO_SURFACES_VC1             10  // (same as MPEG-2)
-#define NUM_OUTPUT_SURFACES_FOR_FULLHD     2
-#define FULLHD_WIDTH                       1920
-
-class CVDPAU
- : public CDVDVideoCodecFFmpeg::IHardwareDecoder
- , public IDispResource
-{
-public:
-
-  struct pictureAge
-  {
-    int b_age;
-    int ip_age[2];
-  };
-
-  struct Desc
-  {
-    const char *name;
-    uint32_t id;
-    uint32_t aux; /* optional extra parameter... */
-  };
-
-  CVDPAU();
-  virtual ~CVDPAU();
-  
-  virtual bool Open      (AVCodecContext* avctx, const enum PixelFormat, unsigned int surfaces = 0);
-  virtual int  Decode    (AVCodecContext* avctx, AVFrame* frame);
-  virtual bool GetPicture(AVCodecContext* avctx, AVFrame* frame, DVDVideoPicture* picture);
-  virtual void Reset();
-  virtual void Close();
-
-  virtual int  Check(AVCodecContext* avctx);
-
-  virtual const std::string Name() { return "vdpau"; }
-
-  virtual unsigned GetAllowedReferences() { return 2; /* this is a lie, we can only do one, but we block on decode to get the surface */ }
-
-  bool MakePixmap(int width, int height);
-  bool MakePixmapGL();
-
-  void ReleasePixmap();
-  void BindPixmap();
-
-  PFNGLXBINDTEXIMAGEEXTPROC    glXBindTexImageEXT;
-  PFNGLXRELEASETEXIMAGEEXTPROC glXReleaseTexImageEXT;
-  GLXPixmap  m_glPixmap;
-  Pixmap  m_Pixmap;
-
-  static void             FFReleaseBuffer(AVCodecContext *avctx, AVFrame *pic);
-  static void             FFDrawSlice(struct AVCodecContext *s,
-                               const AVFrame *src, int offset[4],
-                               int y, int type, int height);
-  static int              FFGetBuffer(AVCodecContext *avctx, AVFrame *pic);
-  static VdpStatus        Render(VdpDecoder decoder, VdpVideoSurface target,
-                                 VdpPictureInfo const *picture_info,
-                                 uint32_t bitstream_buffer_count,
-                                 VdpBitstreamBuffer const * bitstream_buffers);
-
-  void Present();
-  bool ConfigVDPAU(AVCodecContext *avctx, int ref_frames);
-  void SpewHardwareAvailable();
-  void InitCSCMatrix(int Height);
-  bool CheckStatus(VdpStatus vdp_st, int line);
-  bool IsSurfaceValid(vdpau_render_state *render);
-
-  void CheckFeatures();
-  void SetColor();
-  void SetNoiseReduction();
-  void SetSharpness();
-  void SetDeinterlacing();
-  void SetHWUpscaling();
+#include "threads/Thread.h"
+#include "utils/ActorProtocol.h"
 
-  pictureAge picAge;
-  vdpau_render_state *past[2], *current, *future;
-  int        tmpDeintMode, tmpDeintGUI, tmpDeint;
-  float      tmpNoiseReduction, tmpSharpness;
-  float      tmpBrightness, tmpContrast;
-  int        OutWidth, OutHeight;
-  bool       upScale;
-  std::queue<DVDVideoPicture> m_DVDVideoPics;
+using namespace Actor;
 
-  static inline void ClearUsedForRender(vdpau_render_state **st)
-  {
-    if (*st) {
-      (*st)->state &= ~FF_VDPAU_STATE_USED_FOR_RENDER;
-      *st = NULL;
-    }
-  }
 
-  VdpProcamp    m_Procamp;
-  VdpCSCMatrix  m_CSCMatrix;
-  VdpDevice     HasDevice() { return vdp_device != VDP_INVALID_HANDLE; };
-  VdpChromaType vdp_chroma_type;
+#define FULLHD_WIDTH                       1920
+#define MAX_PIC_Q_LENGTH                   20 //for non-interop_yuv this controls the max length of the decoded pic to render completion Q
 
+namespace VDPAU
+{
 
-  //  protected:
-  void      InitVDPAUProcs();
-  void      FiniVDPAUProcs();
-  void      FiniVDPAUOutput();
-  bool      ConfigOutputMethod(AVCodecContext *avctx, AVFrame *pFrame);
-  bool      FiniOutputMethod();
+/**
+ * VDPAU interface to driver
+ */
 
-  VdpDevice                            vdp_device;
-  VdpGetProcAddress *                  vdp_get_proc_address;
-  VdpPresentationQueueTarget           vdp_flip_target;
-  VdpPresentationQueue                 vdp_flip_queue;
-  VdpDeviceDestroy *                   vdp_device_destroy;
+struct VDPAU_procs
+{
+  VdpGetProcAddress *                   vdp_get_proc_address;
+  VdpDeviceDestroy *                    vdp_device_destroy;
 
-  VdpVideoSurfaceCreate *              vdp_video_surface_create;
-  VdpVideoSurfaceDestroy *             vdp_video_surface_destroy;
-  VdpVideoSurfacePutBitsYCbCr *        vdp_video_surface_put_bits_y_cb_cr;
-  VdpVideoSurfaceGetBitsYCbCr *        vdp_video_surface_get_bits_y_cb_cr;
+  VdpVideoSurfaceCreate *               vdp_video_surface_create;
+  VdpVideoSurfaceDestroy *              vdp_video_surface_destroy;
+  VdpVideoSurfacePutBitsYCbCr *         vdp_video_surface_put_bits_y_cb_cr;
+  VdpVideoSurfaceGetBitsYCbCr *         vdp_video_surface_get_bits_y_cb_cr;
 
   VdpOutputSurfacePutBitsYCbCr *        vdp_output_surface_put_bits_y_cb_cr;
   VdpOutputSurfacePutBitsNative *       vdp_output_surface_put_bits_native;
@@ -164,15 +92,15 @@ class CVDPAU
   VdpOutputSurfaceRenderOutputSurface * vdp_output_surface_render_output_surface;
   VdpOutputSurfacePutBitsIndexed *      vdp_output_surface_put_bits_indexed;
 
-  VdpVideoMixerCreate *                vdp_video_mixer_create;
-  VdpVideoMixerSetFeatureEnables *     vdp_video_mixer_set_feature_enables;
-  VdpVideoMixerQueryParameterSupport * vdp_video_mixer_query_parameter_support;
-  VdpVideoMixerQueryFeatureSupport *   vdp_video_mixer_query_feature_support;
-  VdpVideoMixerDestroy *               vdp_video_mixer_destroy;
-  VdpVideoMixerRender *                vdp_video_mixer_render;
-  VdpVideoMixerSetAttributeValues *    vdp_video_mixer_set_attribute_values;
+  VdpVideoMixerCreate *                 vdp_video_mixer_create;
+  VdpVideoMixerSetFeatureEnables *      vdp_video_mixer_set_feature_enables;
+  VdpVideoMixerQueryParameterSupport *  vdp_video_mixer_query_parameter_support;
+  VdpVideoMixerQueryFeatureSupport *    vdp_video_mixer_query_feature_support;
+  VdpVideoMixerDestroy *                vdp_video_mixer_destroy;
+  VdpVideoMixerRender *                 vdp_video_mixer_render;
+  VdpVideoMixerSetAttributeValues *     vdp_video_mixer_set_attribute_values;
 
-  VdpGenerateCSCMatrix *               vdp_generate_csc_matrix;
+  VdpGenerateCSCMatrix *                vdp_generate_csc_matrix;
 
   VdpPresentationQueueTargetDestroy *         vdp_presentation_queue_target_destroy;
   VdpPresentationQueueCreate *                vdp_presentation_queue_create;
@@ -185,65 +113,464 @@ class CVDPAU
 
   VdpGetErrorString *                         vdp_get_error_string;
 
-  VdpDecoderCreate *            vdp_decoder_create;
-  VdpDecoderDestroy *           vdp_decoder_destroy;
-  VdpDecoderRender *            vdp_decoder_render;
-  VdpDecoderQueryCapabilities * vdp_decoder_query_caps;
+  VdpDecoderCreate *             vdp_decoder_create;
+  VdpDecoderDestroy *            vdp_decoder_destroy;
+  VdpDecoderRender *             vdp_decoder_render;
+  VdpDecoderQueryCapabilities *  vdp_decoder_query_caps;
 
   VdpPreemptionCallbackRegister * vdp_preemption_callback_register;
 
-  VdpOutputSurface  outputSurfaces[NUM_OUTPUT_SURFACES];
-  VdpOutputSurface  outputSurface;
-  VdpOutputSurface  presentSurface;
+};
+
+//-----------------------------------------------------------------------------
+// VDPAU data structs
+//-----------------------------------------------------------------------------
 
-  VdpDecoder    decoder;
-  VdpVideoMixer videoMixer;
-  VdpRect       outRect;
-  VdpRect       outRectVid;
+class CDecoder;
 
-  static void* dl_handle;
-  VdpStatus (*dl_vdp_device_create_x11)(Display* display, int screen, VdpDevice* device, VdpGetProcAddress **get_proc_address);
-  VdpStatus (*dl_vdp_get_proc_address)(VdpDevice device, VdpFuncId function_id, void** function_pointer);
-  VdpStatus (*dl_vdp_preemption_callback_register)(VdpDevice device, VdpPreemptionCallback callback, void* context);
+/**
+ * Buffer statistics used to control number of frames in queue
+ */
 
-  int      surfaceNum;
-  int      presentSurfaceNum;
-  int      totalAvailableOutputSurfaces;
-  uint32_t vid_width, vid_height;
-  int      surface_width, surface_height;
-  uint32_t max_references;
-  Display* m_Display;
-  bool     vdpauConfigured;
-  uint32_t *m_BlackBar;
+class CVdpauBufferStats
+{
+public:
+  uint16_t decodedPics;
+  uint16_t processedPics;
+  uint16_t renderPics;
+  uint64_t latency;         // time decoder has waited for a frame, ideally there is no latency
+  int playSpeed;
+  bool canSkipDeint;
+  int processCmd;
+
+  void IncDecoded() { CSingleLock l(m_sec); decodedPics++;}
+  void DecDecoded() { CSingleLock l(m_sec); decodedPics--;}
+  void IncProcessed() { CSingleLock l(m_sec); processedPics++;}
+  void DecProcessed() { CSingleLock l(m_sec); processedPics--;}
+  void IncRender() { CSingleLock l(m_sec); renderPics++;}
+  void DecRender() { CSingleLock l(m_sec); renderPics--;}
+  void Reset() { CSingleLock l(m_sec); decodedPics=0; processedPics=0;renderPics=0;latency=0;}
+  void Get(uint16_t &decoded, uint16_t &processed, uint16_t &render) {CSingleLock l(m_sec); decoded = decodedPics, processed=processedPics, render=renderPics;}
+  void SetParams(uint64_t time, int speed) { CSingleLock l(m_sec); latency = time; playSpeed = speed; }
+  void GetParams(uint64_t &lat, int &speed) { CSingleLock l(m_sec); lat = latency; speed = playSpeed; }
+  void SetCmd(int cmd) { CSingleLock l(m_sec); processCmd = cmd; }
+  void GetCmd(int &cmd) { CSingleLock l(m_sec); cmd = processCmd; processCmd = 0; }
+  void SetCanSkipDeint(bool canSkip) { CSingleLock l(m_sec); canSkipDeint = canSkip; }
+  bool CanSkipDeint() { CSingleLock l(m_sec); if (canSkipDeint) return true; else return false;}
+private:
+  CCriticalSection m_sec;
+};
+
+/**
+ *  CVdpauConfig holds all configuration parameters needed by vdpau
+ *  The structure is sent to the internal classes CMixer and COutput
+ *  for init.
+ */
 
+struct CVdpauConfig
+{
+  int surfaceWidth;
+  int surfaceHeight;
+  int vidWidth;
+  int vidHeight;
+  int outWidth;
+  int outHeight;
+  VDPAU_procs vdpProcs;
+  VdpDevice vdpDevice;
+  VdpDecoder vdpDecoder;
+  VdpChromaType vdpChromaType;
+  CVdpauBufferStats *stats;
+  CDecoder *vdpau;
+  int featureCount;
+  int upscale;
+  VdpVideoMixerFeature vdpFeatures[14];
+  std::vector<vdpau_render_state*> *videoSurfaces;
+  CCriticalSection *videoSurfaceSec;
+  bool usePixmaps;
+  int numRenderBuffers;
+  uint32_t maxReferences;
+  bool useInteropYuv;
+};
+
+/**
+ * Holds a decoded frame
+ * Input to COutput for further processing
+ */
+struct CVdpauDecodedPicture
+{
+  DVDVideoPicture DVDPic;
+  vdpau_render_state *render;
+};
+
+/**
+ * Frame after having been processed by vdpau mixer
+ */
+struct CVdpauProcessedPicture
+{
+  DVDVideoPicture DVDPic;
+  vdpau_render_state *render;
+  VdpOutputSurface outputSurface;
+};
+
+/**
+ * Ready to render textures
+ * Sent from COutput back to CDecoder
+ * Objects are referenced by DVDVideoPicture and are sent
+ * to renderer
+ */
+class CVdpauRenderPicture
+{
+  friend class CDecoder;
+  friend class COutput;
+public:
+  DVDVideoPicture DVDPic;
+  int texWidth, texHeight;
+  CRect crop;
+  GLuint texture[4];
+  uint32_t sourceIdx;
+  bool valid;
+  CDecoder *vdpau;
+  CVdpauRenderPicture* Acquire();
+  long Release();
+private:
+  void ReturnUnused();
+  int refCount;
+  CCriticalSection *renderPicSection;
+};
+
+//-----------------------------------------------------------------------------
+// Mixer
+//-----------------------------------------------------------------------------
+
+class CMixerControlProtocol : public Protocol
+{
+public:
+  CMixerControlProtocol(std::string name, CEvent* inEvent, CEvent *outEvent) : Protocol(name, inEvent, outEvent) {};
+  enum OutSignal
+  {
+    INIT = 0,
+    FLUSH,
+    TIMEOUT,
+  };
+  enum InSignal
+  {
+    ACC,
+    ERROR,
+  };
+};
+
+class CMixerDataProtocol : public Protocol
+{
+public:
+  CMixerDataProtocol(std::string name, CEvent* inEvent, CEvent *outEvent) : Protocol(name, inEvent, outEvent) {};
+  enum OutSignal
+  {
+    FRAME,
+    BUFFER,
+  };
+  enum InSignal
+  {
+    PICTURE,
+  };
+};
 
+/**
+ * Embeds the vdpau video mixer
+ * Embedded by COutput class, gets decoded frames from COutput, processes
+ * them in mixer ands sends processed frames back to COutput
+ */
+class CMixer : private CThread
+{
+public:
+  CMixer(CEvent *inMsgEvent);
+  virtual ~CMixer();
+  void Start();
+  void Dispose();
+  CMixerControlProtocol m_controlPort;
+  CMixerDataProtocol m_dataPort;
+protected:
+  void OnStartup();
+  void OnExit();
+  void Process();
+  void StateMachine(int signal, Protocol *port, Message *msg);
+  void Init();
+  void Uninit();
+  void Flush();
+  void CreateVdpauMixer();
+  void ProcessPicture();
+  void InitCycle();
+  void FiniCycle();
+  void CheckFeatures();
+  void SetPostProcFeatures(bool postProcEnabled);
+  void PostProcOff();
+  void InitCSCMatrix(int Width);
+  bool GenerateStudioCSCMatrix(VdpColorStandard colorStandard, VdpCSCMatrix &studioCSCMatrix);
+  void SetColor();
+  void SetNoiseReduction();
+  void SetSharpness();
+  void SetDeintSkipChroma();
+  void SetDeinterlacing();
+  void SetHWUpscaling();
+  void DisableHQScaling();
+  EINTERLACEMETHOD GetDeinterlacingMethod(bool log = false);
+  bool CheckStatus(VdpStatus vdp_st, int line);
+  CEvent m_outMsgEvent;
+  CEvent *m_inMsgEvent;
+  int m_state;
+  bool m_bStateMachineSelfTrigger;
+
+  // extended state variables for state machine
+  int m_extTimeout;
+  bool m_vdpError;
+  CVdpauConfig m_config;
+  VdpVideoMixer m_videoMixer;
+  VdpProcamp m_Procamp;
+  VdpCSCMatrix  m_CSCMatrix;
+  bool m_PostProc;
+  float m_Brightness;
+  float m_Contrast;
+  float m_NoiseReduction;
+  float m_Sharpness;
+  int m_DeintMode;
+  int m_Deint;
+  int m_Upscale;
+  uint32_t *m_BlackBar;
   VdpVideoMixerPictureStructure m_mixerfield;
-  int                           m_mixerstep;
+  int m_mixerstep;
+  int m_mixersteps;
+  CVdpauProcessedPicture m_processPicture;
+  std::queue<VdpOutputSurface> m_outputSurfaces;
+  std::queue<CVdpauDecodedPicture> m_decodedPics;
+  std::deque<CVdpauDecodedPicture> m_mixerInput;
+};
+
+//-----------------------------------------------------------------------------
+// Output
+//-----------------------------------------------------------------------------
+
+/**
+ * Buffer pool holds allocated vdpau and gl resources
+ * Embedded in COutput
+ */
+struct VdpauBufferPool
+{
+  struct Pixmaps
+  {
+    unsigned short id;
+    bool used;
+    DVDVideoPicture DVDPic;
+    GLuint texture;
+    Pixmap pixmap;
+    GLXPixmap  glPixmap;
+    VdpPresentationQueueTarget vdp_flip_target;
+    VdpPresentationQueue vdp_flip_queue;
+    VdpOutputSurface surface;
+  };
+  struct GLVideoSurface
+  {
+    GLuint texture[4];
+#ifdef GL_NV_vdpau_interop
+    GLvdpauSurfaceNV glVdpauSurface;
+#endif
+    vdpau_render_state *sourceVuv;
+    VdpOutputSurface sourceRgb;
+  };
+  unsigned short numOutputSurfaces;
+  std::vector<Pixmaps> pixmaps;
+  std::vector<VdpOutputSurface> outputSurfaces;
+  std::deque<Pixmaps*> notVisiblePixmaps;
+  std::vector<CVdpauRenderPicture> allRenderPics;
+  std::map<VdpVideoSurface, GLVideoSurface> glVideoSurfaceMap;
+  std::map<VdpOutputSurface, GLVideoSurface> glOutputSurfaceMap;
+  std::queue<CVdpauProcessedPicture> processedPics;
+  std::deque<CVdpauRenderPicture*> usedRenderPics;
+  std::deque<CVdpauRenderPicture*> freeRenderPics;
+  CCriticalSection renderPicSec;
+};
+
+class COutputControlProtocol : public Protocol
+{
+public:
+  COutputControlProtocol(std::string name, CEvent* inEvent, CEvent *outEvent) : Protocol(name, inEvent, outEvent) {};
+  enum OutSignal
+  {
+    INIT,
+    FLUSH,
+    PRECLEANUP,
+    TIMEOUT,
+  };
+  enum InSignal
+  {
+    ACC,
+    ERROR,
+    STATS,
+  };
+};
+
+class COutputDataProtocol : public Protocol
+{
+public:
+  COutputDataProtocol(std::string name, CEvent* inEvent, CEvent *outEvent) : Protocol(name, inEvent, outEvent) {};
+  enum OutSignal
+  {
+    NEWFRAME = 0,
+    RETURNPIC,
+  };
+  enum InSignal
+  {
+    PICTURE,
+  };
+};
+
+/**
+ * COutput is embedded in CDecoder and embeds CMixer
+ * The class has its own OpenGl context which is shared with render thread
+ * COuput generated ready to render textures and passes them back to
+ * CDecoder
+ */
+class COutput : private CThread
+{
+public:
+  COutput(CEvent *inMsgEvent);
+  virtual ~COutput();
+  void Start();
+  void Dispose();
+  COutputControlProtocol m_controlPort;
+  COutputDataProtocol m_dataPort;
+protected:
+  void OnStartup();
+  void OnExit();
+  void Process();
+  void StateMachine(int signal, Protocol *port, Message *msg);
+  bool HasWork();
+  CVdpauRenderPicture *ProcessMixerPicture();
+  void ProcessReturnPicture(CVdpauRenderPicture *pic);
+  int FindFreePixmap();
+  bool Init();
+  bool Uninit();
+  void Flush();
+  bool CreateGlxContext();
+  bool DestroyGlxContext();
+  bool EnsureBufferPool();
+  void ReleaseBufferPool();
+  void InitMixer();
+  bool GLInit();
+  void GLMapSurfaces();
+  void GLUnmapSurfaces();
+  void GLBindPixmaps();
+  void GLUnbindPixmaps();
+  bool MakePixmap(VdpauBufferPool::Pixmaps &pixmap);
+  bool MakePixmapGL(VdpauBufferPool::Pixmaps &pixmap);
+  bool CheckStatus(VdpStatus vdp_st, int line);
+  CEvent m_outMsgEvent;
+  CEvent *m_inMsgEvent;
+  int m_state;
+  bool m_bStateMachineSelfTrigger;
+
+  // extended state variables for state machine
+  int m_extTimeout;
+  bool m_vdpError;
+  CVdpauConfig m_config;
+  VdpauBufferPool m_bufferPool;
+  CMixer m_mixer;
+  Display *m_Display;
+  Window m_Window;
+  GLXContext m_glContext;
+  GLXWindow m_glWindow;
+  Pixmap    m_pixmap;
+  GLXPixmap m_glPixmap;
+
+  // gl functions
+  PFNGLXBINDTEXIMAGEEXTPROC    glXBindTexImageEXT;
+  PFNGLXRELEASETEXIMAGEEXTPROC glXReleaseTexImageEXT;
+#ifdef GL_NV_vdpau_interop
+  PFNGLVDPAUINITNVPROC glVDPAUInitNV;
+  PFNGLVDPAUFININVPROC glVDPAUFiniNV;
+  PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC glVDPAURegisterOutputSurfaceNV;
+  PFNGLVDPAUREGISTERVIDEOSURFACENVPROC glVDPAURegisterVideoSurfaceNV;
+  PFNGLVDPAUISSURFACENVPROC glVDPAUIsSurfaceNV;
+  PFNGLVDPAUUNREGISTERSURFACENVPROC glVDPAUUnregisterSurfaceNV;
+  PFNGLVDPAUSURFACEACCESSNVPROC glVDPAUSurfaceAccessNV;
+  PFNGLVDPAUMAPSURFACESNVPROC glVDPAUMapSurfacesNV;
+  PFNGLVDPAUUNMAPSURFACESNVPROC glVDPAUUnmapSurfacesNV;
+  PFNGLVDPAUGETSURFACEIVNVPROC glVDPAUGetSurfaceivNV;
+#endif
+};
+
+//-----------------------------------------------------------------------------
+// VDPAU decoder
+//-----------------------------------------------------------------------------
+
+/**
+ *  VDPAU main class
+ */
+class CDecoder
+ : public CDVDVideoCodecFFmpeg::IHardwareDecoder
+ , public IDispResource
+{
+   friend class CVdpauRenderPicture;
+
+public:
+
+  struct Desc
+  {
+    const char *name;
+    uint32_t id;
+    uint32_t aux; /* optional extra parameter... */
+  };
+
+  CDecoder();
+  virtual ~CDecoder();
+
+  virtual bool Open      (AVCodecContext* avctx, const enum PixelFormat, unsigned int surfaces = 0);
+  virtual int  Decode    (AVCodecContext* avctx, AVFrame* frame);
+  virtual bool GetPicture(AVCodecContext* avctx, AVFrame* frame, DVDVideoPicture* picture);
+  virtual void Reset();
+  virtual void Close();
+  virtual long Release();
+  virtual bool CanSkipDeint();
+  virtual unsigned GetAllowedReferences() { return 5; }
+
+  virtual int  Check(AVCodecContext* avctx);
+  virtual const std::string Name() { return "vdpau"; }
 
   bool Supports(VdpVideoMixerFeature feature);
   bool Supports(EINTERLACEMETHOD method);
   EINTERLACEMETHOD AutoInterlaceMethod();
+  static bool IsVDPAUFormat(PixelFormat fmt);
 
-  VdpVideoMixerFeature m_features[14];
-  int                  m_feature_count;
+  static void FFReleaseBuffer(AVCodecContext *avctx, AVFrame *pic);
+  static void FFDrawSlice(struct AVCodecContext *s,
+                          const AVFrame *src, int offset[4],
+                          int y, int type, int height);
+  static int FFGetBuffer(AVCodecContext *avctx, AVFrame *pic);
+  static VdpStatus Render( VdpDecoder decoder, VdpVideoSurface target,
+                           VdpPictureInfo const *picture_info,
+                           uint32_t bitstream_buffer_count,
+                           VdpBitstreamBuffer const * bitstream_buffers);
+
+  virtual void OnLostDevice();
+  virtual void OnResetDevice();
+
+protected:
+  void SetWidthHeight(int width, int height);
+  bool ConfigVDPAU(AVCodecContext *avctx, int ref_frames);
+  void SpewHardwareAvailable();
+  bool CheckStatus(VdpStatus vdp_st, int line);
+  bool IsSurfaceValid(vdpau_render_state *render);
+  void InitVDPAUProcs();
+  void FiniVDPAUProcs();
+  void FiniVDPAUOutput();
+  void ReturnRenderPicture(CVdpauRenderPicture *renderPic);
+  long ReleasePicReference();
 
-  static bool IsVDPAUFormat(PixelFormat fmt);
   static void ReadFormatOf( AVCodecID codec
                           , VdpDecoderProfile &decoder_profile
                           , VdpChromaType     &chroma_type);
 
-  std::vector<vdpau_render_state*> m_videoSurfaces;
-  AVVDPAUContext m_hwContext;
-  DllAvUtil   m_dllAvUtil;
-
-  enum VDPAUOutputMethod
-  {
-    OUTPUT_NONE,
-    OUTPUT_PIXMAP,
-    OUTPUT_GL_INTEROP_RGB,
-    OUTPUT_GL_INTEROP_YUV
-  };
-  VDPAUOutputMethod m_vdpauOutputMethod;
+  VdpStatus (*dl_vdp_device_create_x11)(Display* display, int screen, VdpDevice* device, VdpGetProcAddress **get_proc_address);
+  VdpStatus (*dl_vdp_get_proc_address)(VdpDevice device, VdpFuncId function_id, void** function_pointer);
+  VdpStatus (*dl_vdp_preemption_callback_register)(VdpDevice device, VdpPreemptionCallback callback, void* context);
 
   // OnLostDevice triggers transition from all states to LOST
   // internal errors trigger transition from OPEN to RESET
@@ -254,9 +581,25 @@ class CVDPAU
   , VDPAU_LOST
   , VDPAU_ERROR
   } m_DisplayState;
-  CSharedSection m_DecoderSection;
-  CSharedSection m_DisplaySection;
+  CCriticalSection m_DecoderSection;
   CEvent         m_DisplayEvent;
-  virtual void OnLostDevice();
-  virtual void OnResetDevice();
+
+  static void*  dl_handle;
+  DllAvUtil     m_dllAvUtil;
+  Display*      m_Display;
+  ThreadIdentifier m_decoderThread;
+  bool          m_vdpauConfigured;
+  CVdpauConfig  m_vdpauConfig;
+  std::vector<vdpau_render_state*> m_videoSurfaces;
+  AVVDPAUContext m_hwContext;
+  CCriticalSection m_videoSurfaceSec;
+
+  COutput       m_vdpauOutput;
+  CVdpauBufferStats m_bufferStats;
+  CEvent        m_inMsgEvent;
+  CVdpauRenderPicture *m_presentPicture;
+
+  int m_codecControl;
 };
+
+}
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 56b32b9..3c30d0b 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1009,6 +1009,7 @@ static std::string GetRenderFormatName(ERenderFormat format)
     case RENDER_FMT_UYVY422:   return "UYVY";
     case RENDER_FMT_YUYV422:   return "YUY2";
     case RENDER_FMT_VDPAU:     return "VDPAU";
+    case RENDER_FMT_VDPAU_420: return "VDPAU_420";
     case RENDER_FMT_DXVA:      return "DXVA";
     case RENDER_FMT_VAAPI:     return "VAAPI";
     case RENDER_FMT_OMXEGL:    return "OMXEGL";
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index de3a418..c156b90 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -161,7 +161,7 @@ void CAdvancedSettings::Initialize()
   m_videoIgnoreSecondsAtStart = 3*60;
   m_videoIgnorePercentAtEnd   = 8.0f;
   m_videoPlayCountMinimumPercent = 90.0f;
-  m_videoVDPAUScaling = false;
+  m_videoVDPAUScaling = -1;
   m_videoNonLinStretchRatio = 0.5f;
   m_videoEnableHighQualityHwScalers = false;
   m_videoAutoScaleMaxFps = 30.0f;
@@ -169,6 +169,8 @@ void CAdvancedSettings::Initialize()
   m_videoAllowMpeg4VAAPI = false;  
   m_videoDisableBackgroundDeinterlace = false;
   m_videoCaptureUseOcclusionQuery = -1; //-1 is auto detect
+  m_videoVDPAUtelecine = false;
+  m_videoVDPAUdeintSkipChromaHD = false;
   m_DXVACheckCompatibility = false;
   m_DXVACheckCompatibilityPresent = false;
   m_DXVAForceProcessorRenderer = true;
@@ -572,7 +574,7 @@ void CAdvancedSettings::ParseSettingsFile(const CStdString &file)
     XMLUtils::GetString(pElement,"cleandatetime", m_videoCleanDateTimeRegExp);
     XMLUtils::GetString(pElement,"ppffmpegdeinterlacing",m_videoPPFFmpegDeint);
     XMLUtils::GetString(pElement,"ppffmpegpostprocessing",m_videoPPFFmpegPostProc);
-    XMLUtils::GetBoolean(pElement,"vdpauscaling",m_videoVDPAUScaling);
+    XMLUtils::GetInt(pElement,"vdpauscaling",m_videoVDPAUScaling);
     XMLUtils::GetFloat(pElement, "nonlinearstretchratio", m_videoNonLinStretchRatio, 0.01f, 1.0f);
     XMLUtils::GetBoolean(pElement,"enablehighqualityhwscalers", m_videoEnableHighQualityHwScalers);
     XMLUtils::GetFloat(pElement,"autoscalemaxfps",m_videoAutoScaleMaxFps, 0.0f, 1000.0f);
@@ -581,6 +583,8 @@ void CAdvancedSettings::ParseSettingsFile(const CStdString &file)
     XMLUtils::GetBoolean(pElement,"allowmpeg4vaapi",m_videoAllowMpeg4VAAPI);    
     XMLUtils::GetBoolean(pElement, "disablebackgrounddeinterlace", m_videoDisableBackgroundDeinterlace);
     XMLUtils::GetInt(pElement, "useocclusionquery", m_videoCaptureUseOcclusionQuery, -1, 1);
+    XMLUtils::GetBoolean(pElement,"vdpauInvTelecine",m_videoVDPAUtelecine);
+    XMLUtils::GetBoolean(pElement,"vdpauHDdeintSkipChroma",m_videoVDPAUdeintSkipChromaHD);
 
     TiXmlElement* pAdjustRefreshrate = pElement->FirstChildElement("adjustrefreshrate");
     if (pAdjustRefreshrate)
diff --git a/xbmc/settings/AdvancedSettings.h b/xbmc/settings/AdvancedSettings.h
index 084fe8b..3a52878 100644
--- a/xbmc/settings/AdvancedSettings.h
+++ b/xbmc/settings/AdvancedSettings.h
@@ -147,6 +147,8 @@ class CAdvancedSettings : public ISettingCallback, public ISettingsHandler
     int m_videoPercentSeekBackwardBig;
     CStdString m_videoPPFFmpegDeint;
     CStdString m_videoPPFFmpegPostProc;
+    bool m_videoVDPAUtelecine;
+    bool m_videoVDPAUdeintSkipChromaHD;
     bool m_musicUseTimeSeeking;
     int m_musicTimeSeekForward;
     int m_musicTimeSeekBackward;
@@ -162,7 +164,7 @@ class CAdvancedSettings : public ISettingCallback, public ISettingsHandler
     CStdString m_audioHost;
     bool m_audioApplyDrc;
 
-    bool  m_videoVDPAUScaling;
+    int   m_videoVDPAUScaling;
     float m_videoNonLinStretchRatio;
     bool  m_videoEnableHighQualityHwScalers;
     float m_videoAutoScaleMaxFps;
diff --git a/xbmc/utils/ActorProtocol.cpp b/xbmc/utils/ActorProtocol.cpp
index cf4c26f..e3090c3 100644
--- a/xbmc/utils/ActorProtocol.cpp
+++ b/xbmc/utils/ActorProtocol.cpp
@@ -1,5 +1,9 @@
 /*
+<<<<<<< HEAD
  *      Copyright (C) 2005-2013 Team XBMC
+=======
+ *      Copyright (C) 2005-2012 Team XBMC
+>>>>>>> b5471a2... vdpau: redesign
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff --git a/xbmc/utils/ActorProtocol.h b/xbmc/utils/ActorProtocol.h
index 8ef3359..8c4038a 100644
--- a/xbmc/utils/ActorProtocol.h
+++ b/xbmc/utils/ActorProtocol.h
@@ -1,5 +1,9 @@
 /*
+<<<<<<< HEAD
  *      Copyright (C) 2005-2013 Team XBMC
+=======
+ *      Copyright (C) 2005-2012 Team XBMC
+>>>>>>> b5471a2... vdpau: redesign
  *      http://www.xbmc.org
  *
  *  This Program is free software; you can redistribute it and/or modify
diff --git a/xbmc/video/dialogs/GUIDialogVideoSettings.cpp b/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
index bd80082..27ed5ee 100644
--- a/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
+++ b/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
@@ -104,7 +104,7 @@ void CGUIDialogVideoSettings::CreateSettings()
     entries.push_back(make_pair(VS_INTERLACEMETHOD_INVERSE_TELECINE     , 16314));
     entries.push_back(make_pair(VS_INTERLACEMETHOD_VDPAU_TEMPORAL_SPATIAL     , 16311));
     entries.push_back(make_pair(VS_INTERLACEMETHOD_VDPAU_TEMPORAL             , 16310));
-    entries.push_back(make_pair(VS_INTERLACEMETHOD_VDPAU_BOB                  , 16021));
+    entries.push_back(make_pair(VS_INTERLACEMETHOD_VDPAU_BOB                  , 16325));
     entries.push_back(make_pair(VS_INTERLACEMETHOD_VDPAU_TEMPORAL_SPATIAL_HALF, 16318));
     entries.push_back(make_pair(VS_INTERLACEMETHOD_VDPAU_TEMPORAL_HALF        , 16317));
     entries.push_back(make_pair(VS_INTERLACEMETHOD_VDPAU_INVERSE_TELECINE     , 16314));
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index e425327..3dae22c 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -63,6 +63,7 @@ class CWinSystemX11 : public CWinSystemBase
   // Local to WinSystemX11 only
   Display*  GetDisplay() { return m_dpy; }
   GLXWindow GetWindow() { return m_glWindow; }
+  GLXContext GetGlxContext() { return m_glContext; }
 
 protected:
   bool RefreshGlxContext();
-- 
1.8.1.6


From 2c65b5bb8caabbe3ed88861ebda5a0392d06cd2e Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Wed, 12 Dec 2012 09:52:17 +0100
Subject: [PATCH 025/123] vdpau: make interop gl default and remove setting,
 rename and intvert interop yuv

---
 language/English/strings.po                    |  8 ++------
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 17 ++++++++++-------
 2 files changed, 12 insertions(+), 13 deletions(-)

diff --git a/language/English/strings.po b/language/English/strings.po
index f2a0572..eace353 100644
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -5768,14 +5768,10 @@ msgid "Enable HQ Scalers for scalings above"
 msgstr ""
 
 msgctxt "#13436"
-msgid "Allow Vdpau OpenGL interop"
+msgid "Prefer VDPAU Video Mixer"
 msgstr ""
 
-msgctxt "#13437"
-msgid "Allow Vdpau OpenGL interop YUV"
-msgstr ""
-
-#empty strings from id 13438 to 13499
+#empty strings from id 13437 to 13499
 
 #: system/settings/settings.xml
 msgctxt "#13500"
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 89ac10e..c4d1a53 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -384,12 +384,15 @@ bool CDecoder::Supports(EINTERLACEMETHOD method)
   || method == VS_INTERLACEMETHOD_AUTO)
     return true;
 
-  if (CSettings::Get().GetBool("videoplayer.usevdpauinteropyuv"))
+  if (!m_vdpauConfig.usePixmaps)
   {
     if (method == VS_INTERLACEMETHOD_RENDER_BOB)
       return true;
   }
 
+  if (method == VS_INTERLACEMETHOD_VDPAU_INVERSE_TELECINE)
+    return false;
+
   for(SInterlaceMapping* p = g_interlace_mapping; p->method != VS_INTERLACEMETHOD_NONE; p++)
   {
     if(p->method == method)
@@ -1869,7 +1872,7 @@ void CMixer::SetDeinterlacing()
 
   SetDeintSkipChroma();
 
-  m_config.useInteropYuv = CSettings::Get().GetBool("videoplayer.usevdpauinteropyuv");
+  m_config.useInteropYuv = !CSettings::Get().GetBool("videoplayer.usevdpaumixer");
 }
 
 void CMixer::SetDeintSkipChroma()
@@ -2061,7 +2064,7 @@ void CMixer::Init()
   m_vdpError = false;
 
   m_config.upscale = g_advancedSettings.m_videoVDPAUScaling;
-  m_config.useInteropYuv = CSettings::Get().GetBool("videoplayer.usevdpauinteropyuv");
+  m_config.useInteropYuv = !CSettings::Get().GetBool("videoplayer.usevdpaumixer");
 
   CreateVdpauMixer();
 }
@@ -2171,11 +2174,12 @@ void CMixer::InitCycle()
                                         DVP_FLAG_INTERLACED);
       m_config.useInteropYuv = false;
     }
-    else if (method == VS_INTERLACEMETHOD_RENDER_BOB && m_config.useInteropYuv)
+    else if (method == VS_INTERLACEMETHOD_RENDER_BOB)
     {
       m_mixersteps = 1;
       m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME;
       m_mixerInput[1].DVDPic.format = RENDER_FMT_VDPAU_420;
+      m_config.useInteropYuv = true;
     }
     else
     {
@@ -3207,7 +3211,7 @@ bool COutput::GLInit()
   glVDPAUGetSurfaceivNV = NULL;
 #endif
 
-  m_config.usePixmaps = !CSettings::Get().GetBool("videoplayer.usevdpauinterop");
+  m_config.usePixmaps = false;
 
 #ifdef GL_NV_vdpau_interop
   if (glewIsSupported("GL_NV_vdpau_interop"))
@@ -3239,8 +3243,7 @@ bool COutput::GLInit()
 #endif
   {
     m_config.usePixmaps = true;
-    CSettings::Get().SetBool("videoplayer.usevdpauinterop",false);
-    CSettings::Get().SetBool("videoplayer.usevdpauinteropyuv",false);
+    CSettings::Get().SetBool("videoplayer.usevdpaumixer",true);
   }
   if (!glXBindTexImageEXT)
     glXBindTexImageEXT    = (PFNGLXBINDTEXIMAGEEXTPROC)glXGetProcAddress((GLubyte *) "glXBindTexImageEXT");
-- 
1.8.1.6


From 5625fb3f23df0575518af5db59bc0ac6d0b204dc Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Wed, 12 Dec 2012 18:34:47 +0100
Subject: [PATCH 026/123] vdpau: drop studio level conversion

---
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp  |  4 +-
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 94 ++------------------------
 2 files changed, 6 insertions(+), 92 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index 88c7e5f..a904572 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -3314,7 +3314,7 @@ bool CLinuxRendererGL::Supports(ERENDERFEATURE feature)
 {
   if(feature == RENDERFEATURE_BRIGHTNESS)
   {
-    if ((m_renderMethod & RENDER_VDPAU) && !CSettings::Get().GetBool("videoscreen.limitedrange"))
+    if (m_renderMethod & RENDER_VDPAU)
       return true;
 
     if (m_renderMethod & RENDER_VAAPI)
@@ -3327,7 +3327,7 @@ bool CLinuxRendererGL::Supports(ERENDERFEATURE feature)
   
   if(feature == RENDERFEATURE_CONTRAST)
   {
-    if ((m_renderMethod & RENDER_VDPAU) && !CSettings::Get().GetBool("videoscreen.limitedrange"))
+    if (m_renderMethod & RENDER_VDPAU)
       return true;
 
     if (m_renderMethod & RENDER_VAAPI)
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index c4d1a53..399da83 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -58,15 +58,6 @@
 };
 const size_t decoder_profile_count = sizeof(decoder_profiles)/sizeof(CDecoder::Desc);
 
-//static float studioCSC[3][4] =
-//{
-//    { 1.0f,        0.0f, 1.57480000f,-0.78740000f},
-//    { 1.0f,-0.18737736f,-0.46813736f, 0.32775736f},
-//    { 1.0f, 1.85556000f,        0.0f,-0.92780000f}
-//};
-static float studioCSCKCoeffs601[3] = {0.299, 0.587, 0.114};  //BT601 {Kr, Kg, Kb}
-static float studioCSCKCoeffs709[3] = {0.2126, 0.7152, 0.0722};  //BT709 {Kr, Kg, Kb}
-
 static struct SInterlaceMapping
 {
   const EINTERLACEMETHOD     method;
@@ -1636,74 +1627,6 @@ void CMixer::PostProcOff()
   DisableHQScaling();
 }
 
-
-bool CMixer::GenerateStudioCSCMatrix(VdpColorStandard colorStandard, VdpCSCMatrix &studioCSCMatrix)
-{
-   // instead use studioCSCKCoeffs601[3], studioCSCKCoeffs709[3] to generate float[3][4] matrix (float studioCSC[3][4])
-   // m00 = mRY = red: luma factor (contrast factor) (1.0)
-   // m10 = mGY = green: luma factor (contrast factor) (1.0)
-   // m20 = mBY = blue: luma factor (contrast factor) (1.0)
-   //
-   // m01 = mRB = red: blue color diff coeff (0.0)
-   // m11 = mGB = green: blue color diff coeff (-2Kb(1-Kb)/(Kg))
-   // m21 = mBB = blue: blue color diff coeff ((1-Kb)/0.5)
-   //
-   // m02 = mRR = red: red color diff coeff ((1-Kr)/0.5)
-   // m12 = mGR = green: red color diff coeff (-2Kr(1-Kr)/(Kg))
-   // m22 = mBR = blue: red color diff coeff (0.0)
-   //
-   // m03 = mRC = red: colour zero offset (brightness factor) (-(1-Kr)/0.5 * (128/255))
-   // m13 = mGC = green: colour zero offset (brightness factor) ((256/255) * (Kb(1-Kb) + Kr(1-Kr)) / Kg)
-   // m23 = mBC = blue: colour zero offset (brightness factor) (-(1-Kb)/0.5 * (128/255))
-
-   // columns
-   int Y = 0;
-   int Cb = 1;
-   int Cr = 2;
-   int C = 3;
-   // rows
-   int R = 0;
-   int G = 1;
-   int B = 2;
-   // colour standard coefficients for red, geen, blue
-   double Kr, Kg, Kb;
-   // colour diff zero position (use standard 8-bit coding precision)
-   double CDZ = 128; //256*0.5
-   // range excursion (use standard 8-bit coding precision)
-   double EXC = 255; //256-1
-
-   if (colorStandard == VDP_COLOR_STANDARD_ITUR_BT_601)
-   {
-      Kr = studioCSCKCoeffs601[0];
-      Kg = studioCSCKCoeffs601[1];
-      Kb = studioCSCKCoeffs601[2];
-   }
-   else // assume VDP_COLOR_STANDARD_ITUR_BT_709
-   {
-      Kr = studioCSCKCoeffs709[0];
-      Kg = studioCSCKCoeffs709[1];
-      Kb = studioCSCKCoeffs709[2];
-   }
-   // we keep luma unscaled to retain the levels present in source so that 16-235 luma is converted to RGB 16-235
-   studioCSCMatrix[R][Y] = 1.0;
-   studioCSCMatrix[G][Y] = 1.0;
-   studioCSCMatrix[B][Y] = 1.0;
-
-   studioCSCMatrix[R][Cb] = 0.0;
-   studioCSCMatrix[G][Cb] = (double)-2 * Kb * (1 - Kb) / Kg;
-   studioCSCMatrix[B][Cb] = (double)(1 - Kb) / 0.5;
-
-   studioCSCMatrix[R][Cr] = (double)(1 - Kr) / 0.5;
-   studioCSCMatrix[G][Cr] = (double)-2 * Kr * (1 - Kr) / Kg;
-   studioCSCMatrix[B][Cr] = 0.0;
-
-   studioCSCMatrix[R][C] = (double)-1 * studioCSCMatrix[R][Cr] * CDZ/EXC;
-   studioCSCMatrix[G][C] = (double)-1 * (studioCSCMatrix[G][Cb] + studioCSCMatrix[G][Cr]) * CDZ/EXC;
-   studioCSCMatrix[B][C] = (double)-1 * studioCSCMatrix[B][Cb] * CDZ/EXC;
-
-   return true;
-}
-
 void CMixer::SetColor()
 {
   VdpStatus vdp_st;
@@ -1723,19 +1646,10 @@ void CMixer::SetColor()
     //vdp_st = vdp_generate_csc_matrix(&m_Procamp, VDP_COLOR_STANDARD_ITUR_BT_601, &m_CSCMatrix);
 
   VdpVideoMixerAttribute attributes[] = { VDP_VIDEO_MIXER_ATTRIBUTE_CSC_MATRIX };
-  if (CSettings::Get().GetBool("videoscreen.limitedrange"))
-  {
-    float studioCSC[3][4];
-    GenerateStudioCSCMatrix(colorStandard, studioCSC);
-    void const * pm_CSCMatix[] = { &studioCSC };
-    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_attribute_values(m_videoMixer, ARSIZE(attributes), attributes, pm_CSCMatix);
-  }
-  else
-  {
-    vdp_st = m_config.vdpProcs.vdp_generate_csc_matrix(&m_Procamp, colorStandard, &m_CSCMatrix);
-    void const * pm_CSCMatix[] = { &m_CSCMatrix };
-    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_attribute_values(m_videoMixer, ARSIZE(attributes), attributes, pm_CSCMatix);
-  }
+  vdp_st = m_config.vdpProcs.vdp_generate_csc_matrix(&m_Procamp, colorStandard, &m_CSCMatrix);
+  void const * pm_CSCMatix[] = { &m_CSCMatrix };
+  vdp_st = m_config.vdpProcs.vdp_video_mixer_set_attribute_values(m_videoMixer, ARSIZE(attributes), attributes, pm_CSCMatix);
+
   CheckStatus(vdp_st, __LINE__);
 }
 
-- 
1.8.1.6


From 335ae083e1dcc89cfaa8351b4ff3136b78c432be Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Wed, 12 Dec 2012 20:28:49 +0100
Subject: [PATCH 027/123] vdpau: observe ffmpeg tags for color space

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 38 ++++++++++++++++++--------
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h   |  1 +
 2 files changed, 27 insertions(+), 12 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 399da83..4b2b4e8 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -929,6 +929,7 @@ int CDecoder::Decode(AVCodecContext *avctx, AVFrame *pFrame)
     memset(&pic.DVDPic, 0, sizeof(pic.DVDPic));
     ((CDVDVideoCodecFFmpeg*)avctx->opaque)->GetPictureCommon(&pic.DVDPic);
     pic.render = render;
+    pic.DVDPic.color_matrix = avctx->colorspace;
     m_bufferStats.IncDecoded();
     m_vdpauOutput.m_dataPort.SendOutMessage(COutputDataProtocol::NEWFRAME, &pic, sizeof(pic));
 
@@ -1535,10 +1536,6 @@ void CMixer::InitCSCMatrix(int Width)
   m_Procamp.contrast       = 1.0;
   m_Procamp.saturation     = 1.0;
   m_Procamp.hue            = 0;
-  vdp_st = m_config.vdpProcs.vdp_generate_csc_matrix(&m_Procamp,
-                                   (Width < 1000)? VDP_COLOR_STANDARD_ITUR_BT_601 : VDP_COLOR_STANDARD_ITUR_BT_709,
-                                   &m_CSCMatrix);
-  CheckStatus(vdp_st, __LINE__);
 }
 
 void CMixer::CheckFeatures()
@@ -1549,11 +1546,13 @@ void CMixer::CheckFeatures()
     m_Upscale = m_config.upscale;
   }
   if (m_Brightness != CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness ||
-      m_Contrast   != CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast)
+      m_Contrast   != CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast ||
+      m_ColorMatrix != m_mixerInput[1].DVDPic.color_matrix)
   {
     SetColor();
     m_Brightness = CMediaSettings::Get().GetCurrentVideoSettings().m_Brightness;
     m_Contrast = CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast;
+    m_ColorMatrix = m_mixerInput[1].DVDPic.color_matrix;
   }
   if (m_NoiseReduction != CMediaSettings::Get().GetCurrentVideoSettings().m_NoiseReduction)
   {
@@ -1637,13 +1636,27 @@ void CMixer::SetColor()
     m_Procamp.contrast = (float)((CMediaSettings::Get().GetCurrentVideoSettings().m_Contrast)+50) / 100;
 
   VdpColorStandard colorStandard;
-//  if(vid_height >= 600 || vid_width > 1024)
-  if(m_config.surfaceWidth > 1000)
-    colorStandard = VDP_COLOR_STANDARD_ITUR_BT_709;
-    //vdp_st = vdp_generate_csc_matrix(&m_Procamp, VDP_COLOR_STANDARD_ITUR_BT_709, &m_CSCMatrix);
-  else
-    colorStandard = VDP_COLOR_STANDARD_ITUR_BT_601;
-    //vdp_st = vdp_generate_csc_matrix(&m_Procamp, VDP_COLOR_STANDARD_ITUR_BT_601, &m_CSCMatrix);
+  switch(m_mixerInput[1].DVDPic.color_matrix)
+  {
+    case AVCOL_SPC_BT709:
+      colorStandard = VDP_COLOR_STANDARD_ITUR_BT_709;
+      break;
+    case AVCOL_SPC_BT470BG:
+    case AVCOL_SPC_SMPTE170M:
+      colorStandard = VDP_COLOR_STANDARD_ITUR_BT_601;
+      break;
+    case AVCOL_SPC_SMPTE240M:
+      colorStandard = VDP_COLOR_STANDARD_SMPTE_240M;
+      break;
+    case AVCOL_SPC_FCC:
+    case AVCOL_SPC_UNSPECIFIED:
+    case AVCOL_SPC_RGB:
+    default:
+      if(m_config.surfaceWidth > 1000)
+        colorStandard = VDP_COLOR_STANDARD_ITUR_BT_709;
+      else
+        colorStandard = VDP_COLOR_STANDARD_ITUR_BT_601;
+  }
 
   VdpVideoMixerAttribute attributes[] = { VDP_VIDEO_MIXER_ATTRIBUTE_CSC_MATRIX };
   vdp_st = m_config.vdpProcs.vdp_generate_csc_matrix(&m_Procamp, colorStandard, &m_CSCMatrix);
@@ -1974,6 +1987,7 @@ void CMixer::Init()
   m_Sharpness = 0.0;
   m_DeintMode = 0;
   m_Deint = 0;
+  m_ColorMatrix = 0;
   m_PostProc = false;
   m_vdpError = false;
 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
index 5bee48b..ef99383 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
@@ -334,6 +334,7 @@ class CMixer : private CThread
   int m_DeintMode;
   int m_Deint;
   int m_Upscale;
+  unsigned int m_ColorMatrix       : 4;
   uint32_t *m_BlackBar;
   VdpVideoMixerPictureStructure m_mixerfield;
   int m_mixerstep;
-- 
1.8.1.6


From 28f7a60727380f8bef98393e8ed5162ecf4b20a0 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 27 Jan 2013 12:10:19 +0100
Subject: [PATCH 028/123] vdpau: switch off de-interlacing on ff

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 4b2b4e8..c56dc9c 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -2065,8 +2065,9 @@ void CMixer::InitCycle()
   EINTERLACEMETHOD method = GetDeinterlacingMethod();
   bool interlaced = m_mixerInput[1].DVDPic.iFlags & DVP_FLAG_INTERLACED;
 
-  if (mode == VS_DEINTERLACEMODE_FORCE ||
-     (mode == VS_DEINTERLACEMODE_AUTO && interlaced))
+  if (!(flags & DVP_FLAG_NO_POSTPROC) &&
+      (mode == VS_DEINTERLACEMODE_FORCE ||
+      (mode == VS_DEINTERLACEMODE_AUTO && interlaced)))
   {
     if((method == VS_INTERLACEMETHOD_AUTO && interlaced)
       ||  method == VS_INTERLACEMETHOD_VDPAU_BOB
-- 
1.8.1.6


From a04827ef0ca9a5a659ed2063d7076fb5db016134 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sat, 2 Feb 2013 13:17:09 +0100
Subject: [PATCH 029/123] vdpau: fix mp4 part2 decoding, activate by default

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 3 +--
 xbmc/settings/AdvancedSettings.cpp             | 2 +-
 2 files changed, 2 insertions(+), 3 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index c56dc9c..4ffeeb5 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -131,10 +131,9 @@ bool CDecoder::Open(AVCodecContext* avctx, const enum PixelFormat, unsigned int
     VdpDecoderProfile profile = 0;
     if(avctx->codec_id == AV_CODEC_ID_H264)
       profile = VDP_DECODER_PROFILE_H264_HIGH;
-#ifdef VDP_DECODER_PROFILE_MPEG4_PART2_ASP
     else if(avctx->codec_id == AV_CODEC_ID_MPEG4)
       profile = VDP_DECODER_PROFILE_MPEG4_PART2_ASP;
-#endif
+
     if(profile)
     {
       if (!CDVDCodecUtils::IsVP3CompatibleWidth(avctx->coded_width))
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index c156b90..bd08884 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -165,7 +165,7 @@ void CAdvancedSettings::Initialize()
   m_videoNonLinStretchRatio = 0.5f;
   m_videoEnableHighQualityHwScalers = false;
   m_videoAutoScaleMaxFps = 30.0f;
-  m_videoAllowMpeg4VDPAU = false;
+  m_videoAllowMpeg4VDPAU = true;
   m_videoAllowMpeg4VAAPI = false;  
   m_videoDisableBackgroundDeinterlace = false;
   m_videoCaptureUseOcclusionQuery = -1; //-1 is auto detect
-- 
1.8.1.6


From 29f7a999fbf40b3228553a655b9b5713cd572e66 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sat, 2 Mar 2013 15:19:19 +0100
Subject: [PATCH 030/123] vdpau: re-add limited range conversion

---
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp  |  4 +-
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 86 +++++++++++++++++++++++++-
 2 files changed, 85 insertions(+), 5 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index a904572..88c7e5f 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -3314,7 +3314,7 @@ bool CLinuxRendererGL::Supports(ERENDERFEATURE feature)
 {
   if(feature == RENDERFEATURE_BRIGHTNESS)
   {
-    if (m_renderMethod & RENDER_VDPAU)
+    if ((m_renderMethod & RENDER_VDPAU) && !CSettings::Get().GetBool("videoscreen.limitedrange"))
       return true;
 
     if (m_renderMethod & RENDER_VAAPI)
@@ -3327,7 +3327,7 @@ bool CLinuxRendererGL::Supports(ERENDERFEATURE feature)
   
   if(feature == RENDERFEATURE_CONTRAST)
   {
-    if (m_renderMethod & RENDER_VDPAU)
+    if ((m_renderMethod & RENDER_VDPAU) && !CSettings::Get().GetBool("videoscreen.limitedrange"))
       return true;
 
     if (m_renderMethod & RENDER_VAAPI)
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 4ffeeb5..f913a97 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -71,6 +71,9 @@
 , {VS_INTERLACEMETHOD_NONE                       , (VdpVideoMixerFeature)-1}
 };
 
+static float studioCSCKCoeffs601[3] = {0.299, 0.587, 0.114}; //BT601 {Kr, Kg, Kb}
+static float studioCSCKCoeffs709[3] = {0.2126, 0.7152, 0.0722}; //BT709 {Kr, Kg, Kb}
+
 //since libvdpau 0.4, vdp_device_create_x11() installs a callback on the Display*,
 //if we unload libvdpau with dlclose(), we segfault on XCloseDisplay,
 //so we just keep a static handle to libvdpau around
@@ -1625,6 +1628,73 @@ void CMixer::PostProcOff()
   DisableHQScaling();
 }
 
+bool CMixer::GenerateStudioCSCMatrix(VdpColorStandard colorStandard, VdpCSCMatrix &studioCSCMatrix)
+{
+   // instead use studioCSCKCoeffs601[3], studioCSCKCoeffs709[3] to generate float[3][4] matrix (float studioCSC[3][4])
+   // m00 = mRY = red: luma factor (contrast factor) (1.0)
+   // m10 = mGY = green: luma factor (contrast factor) (1.0)
+   // m20 = mBY = blue: luma factor (contrast factor) (1.0)
+   //
+   // m01 = mRB = red: blue color diff coeff (0.0)
+   // m11 = mGB = green: blue color diff coeff (-2Kb(1-Kb)/(Kg))
+   // m21 = mBB = blue: blue color diff coeff ((1-Kb)/0.5)
+   //
+   // m02 = mRR = red: red color diff coeff ((1-Kr)/0.5)
+   // m12 = mGR = green: red color diff coeff (-2Kr(1-Kr)/(Kg))
+   // m22 = mBR = blue: red color diff coeff (0.0)
+   //
+   // m03 = mRC = red: colour zero offset (brightness factor) (-(1-Kr)/0.5 * (128/255))
+   // m13 = mGC = green: colour zero offset (brightness factor) ((256/255) * (Kb(1-Kb) + Kr(1-Kr)) / Kg)
+   // m23 = mBC = blue: colour zero offset (brightness factor) (-(1-Kb)/0.5 * (128/255))
+
+   // columns
+   int Y = 0;
+   int Cb = 1;
+   int Cr = 2;
+   int C = 3;
+   // rows
+   int R = 0;
+   int G = 1;
+   int B = 2;
+   // colour standard coefficients for red, geen, blue
+   double Kr, Kg, Kb;
+   // colour diff zero position (use standard 8-bit coding precision)
+   double CDZ = 128; //256*0.5
+   // range excursion (use standard 8-bit coding precision)
+   double EXC = 255; //256-1
+
+   if (colorStandard == VDP_COLOR_STANDARD_ITUR_BT_601)
+   {
+      Kr = studioCSCKCoeffs601[0];
+      Kg = studioCSCKCoeffs601[1];
+      Kb = studioCSCKCoeffs601[2];
+   }
+   else // assume VDP_COLOR_STANDARD_ITUR_BT_709
+   {
+      Kr = studioCSCKCoeffs709[0];
+      Kg = studioCSCKCoeffs709[1];
+      Kb = studioCSCKCoeffs709[2];
+   }
+   // we keep luma unscaled to retain the levels present in source so that 16-235 luma is converted to RGB 16-235
+   studioCSCMatrix[R][Y] = 1.0;
+   studioCSCMatrix[G][Y] = 1.0;
+   studioCSCMatrix[B][Y] = 1.0;
+
+   studioCSCMatrix[R][Cb] = 0.0;
+   studioCSCMatrix[G][Cb] = (double)-2 * Kb * (1 - Kb) / Kg;
+   studioCSCMatrix[B][Cb] = (double)(1 - Kb) / 0.5;
+
+   studioCSCMatrix[R][Cr] = (double)(1 - Kr) / 0.5;
+   studioCSCMatrix[G][Cr] = (double)-2 * Kr * (1 - Kr) / Kg;
+   studioCSCMatrix[B][Cr] = 0.0;
+
+   studioCSCMatrix[R][C] = (double)-1 * studioCSCMatrix[R][Cr] * CDZ/EXC;
+   studioCSCMatrix[G][C] = (double)-1 * (studioCSCMatrix[G][Cb] + studioCSCMatrix[G][Cr]) * CDZ/EXC;
+   studioCSCMatrix[B][C] = (double)-1 * studioCSCMatrix[B][Cb] * CDZ/EXC;
+
+   return true;
+}
+
 void CMixer::SetColor()
 {
   VdpStatus vdp_st;
@@ -1658,9 +1728,19 @@ void CMixer::SetColor()
   }
 
   VdpVideoMixerAttribute attributes[] = { VDP_VIDEO_MIXER_ATTRIBUTE_CSC_MATRIX };
-  vdp_st = m_config.vdpProcs.vdp_generate_csc_matrix(&m_Procamp, colorStandard, &m_CSCMatrix);
-  void const * pm_CSCMatix[] = { &m_CSCMatrix };
-  vdp_st = m_config.vdpProcs.vdp_video_mixer_set_attribute_values(m_videoMixer, ARSIZE(attributes), attributes, pm_CSCMatix);
+  if (CSettings::Get().GetBool("videoscreen.limitedrange"))
+  {
+    float studioCSC[3][4];
+    GenerateStudioCSCMatrix(colorStandard, studioCSC);
+    void const * pm_CSCMatix[] = { &studioCSC };
+    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_attribute_values(m_videoMixer, ARSIZE(attributes), attributes, pm_CSCMatix);
+  }
+  else
+  {
+    vdp_st = m_config.vdpProcs.vdp_generate_csc_matrix(&m_Procamp, colorStandard, &m_CSCMatrix);
+    void const * pm_CSCMatix[] = { &m_CSCMatrix };
+    vdp_st = m_config.vdpProcs.vdp_video_mixer_set_attribute_values(m_videoMixer, ARSIZE(attributes), attributes, pm_CSCMatix);
+  }
 
   CheckStatus(vdp_st, __LINE__);
 }
-- 
1.8.1.6


From 1ec0508b83dde208260e6574139ea0d1e8ecfe01 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Tue, 25 Sep 2012 12:14:15 +0200
Subject: [PATCH 031/123] linuxrenderer: drop method RenderMultiPass

---
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp | 9 ++-------
 xbmc/cores/VideoRenderers/LinuxRendererGL.h   | 1 -
 2 files changed, 2 insertions(+), 8 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index 88c7e5f..3a2278d 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -1195,7 +1195,8 @@ void CLinuxRendererGL::Render(DWORD flags, int renderBuffer)
       break;
 
     case RQ_MULTIPASS:
-      RenderMultiPass(renderBuffer, m_currentField);
+      RenderToFBO(renderBuffer, m_currentField);
+      RenderFromFBO();
       VerifyGLState();
       break;
     }
@@ -1327,12 +1328,6 @@ void CLinuxRendererGL::RenderSinglePass(int index, int field)
   VerifyGLState();
 }
 
-void CLinuxRendererGL::RenderMultiPass(int index, int field)
-{
-  RenderToFBO(index, field);
-  RenderFromFBO();
-}
-
 void CLinuxRendererGL::RenderToFBO(int index, int field)
 {
   YUVPLANES &planes = m_buffers[index].fields[field];
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.h b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
index d72eb64..6b9046d 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
@@ -218,7 +218,6 @@ class CLinuxRendererGL : public CBaseRenderer
   void CalculateTextureSourceRects(int source, int num_planes);
 
   // renderers
-  void RenderMultiPass(int renderBuffer, int field);  // multi pass glsl renderer
   void RenderToFBO(int renderBuffer, int field);
   void RenderFromFBO();
   void RenderSinglePass(int renderBuffer, int field); // single pass glsl renderer
-- 
1.8.1.6


From 84d3b7a85900519c4ebc246db4e83cfaba4197b9 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Tue, 25 Sep 2012 13:20:47 +0200
Subject: [PATCH 032/123] linuxrenderer: implement progressive weave for vdpau

---
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp | 55 +++++++++++++++++++--------
 xbmc/cores/VideoRenderers/LinuxRendererGL.h   |  4 +-
 2 files changed, 41 insertions(+), 18 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index 3a2278d..3d9f22a 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -679,18 +679,6 @@ void CLinuxRendererGL::RenderUpdate(bool clear, DWORD flags, DWORD alpha)
     glDisable(GL_POLYGON_STIPPLE);
 
   }
-  else if(m_format == RENDER_FMT_VDPAU_420
-      && !(flags & RENDER_FLAG_BOTH))
-  {
-    glDisable(GL_BLEND);
-    glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
-    Render(flags | RENDER_FLAG_TOP, index);
-
-    glEnable(GL_BLEND);
-    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
-    glColor4f(1.0f, 1.0f, 1.0f, 128 / 255.0f);
-    Render(flags | RENDER_FLAG_BOT , index);
-  }
   else
     Render(flags, index);
 
@@ -1190,13 +1178,21 @@ void CLinuxRendererGL::Render(DWORD flags, int renderBuffer)
     {
     case RQ_LOW:
     case RQ_SINGLEPASS:
-      RenderSinglePass(renderBuffer, m_currentField);
+      if (m_format == RENDER_FMT_VDPAU_420 && m_currentField == FIELD_FULL)
+        RenderProgressiveWeave(renderBuffer, m_currentField);
+      else
+        RenderSinglePass(renderBuffer, m_currentField);
       VerifyGLState();
       break;
 
     case RQ_MULTIPASS:
-      RenderToFBO(renderBuffer, m_currentField);
-      RenderFromFBO();
+      if (m_format == RENDER_FMT_VDPAU_420 && m_currentField == FIELD_FULL)
+        RenderProgressiveWeave(renderBuffer, m_currentField);
+      else
+      {
+        RenderToFBO(renderBuffer, m_currentField);
+        RenderFromFBO();
+      }
       VerifyGLState();
       break;
     }
@@ -1328,7 +1324,7 @@ void CLinuxRendererGL::RenderSinglePass(int index, int field)
   VerifyGLState();
 }
 
-void CLinuxRendererGL::RenderToFBO(int index, int field)
+void CLinuxRendererGL::RenderToFBO(int index, int field, bool weave /*= false*/)
 {
   YUVPLANES &planes = m_buffers[index].fields[field];
 
@@ -1430,6 +1426,8 @@ void CLinuxRendererGL::RenderToFBO(int index, int field)
   }
   m_fbo.width  *= planes[0].pixpertex_x;
   m_fbo.height *= planes[0].pixpertex_y;
+  if (weave)
+    m_fbo.height *= 2;
 
   // 1st Pass to video frame size
   glBegin(GL_QUADS);
@@ -1548,6 +1546,31 @@ void CLinuxRendererGL::RenderFromFBO()
   VerifyGLState();
 }
 
+void CLinuxRendererGL::RenderProgressiveWeave(int index, int field)
+{
+  bool scaleUp = (int)m_sourceHeight < g_graphicsContext.GetHeight() || (int)m_sourceWidth < g_graphicsContext.GetWidth();
+
+  if (m_fbo.fbo.IsSupported() && (scaleUp || m_renderQuality == RQ_MULTIPASS))
+  {
+    glEnable(GL_POLYGON_STIPPLE);
+    glPolygonStipple(stipple_weave);
+    RenderToFBO(index, FIELD_TOP, true);
+    glPolygonStipple(stipple_weave+4);
+    RenderToFBO(index, FIELD_BOT, true);
+    glDisable(GL_POLYGON_STIPPLE);
+    RenderFromFBO();
+  }
+  else
+  {
+    glEnable(GL_POLYGON_STIPPLE);
+    glPolygonStipple(stipple_weave);
+    RenderSinglePass(index, FIELD_TOP);
+    glPolygonStipple(stipple_weave+4);
+    RenderSinglePass(index, FIELD_BOT);
+    glDisable(GL_POLYGON_STIPPLE);
+  }
+}
+
 void CLinuxRendererGL::RenderVDPAU(int index, int field)
 {
 #ifdef HAVE_LIBVDPAU
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.h b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
index 6b9046d..4494eca 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
@@ -218,12 +218,12 @@ class CLinuxRendererGL : public CBaseRenderer
   void CalculateTextureSourceRects(int source, int num_planes);
 
   // renderers
-  void RenderToFBO(int renderBuffer, int field);
+  void RenderToFBO(int renderBuffer, int field, bool weave = false);
   void RenderFromFBO();
   void RenderSinglePass(int renderBuffer, int field); // single pass glsl renderer
   void RenderSoftware(int renderBuffer, int field);   // single pass s/w yuv2rgb renderer
   void RenderVDPAU(int renderBuffer, int field);      // render using vdpau hardware
-  void RenderVDPAUYV12(int renderBuffer, int field);      // render using vdpau hardware
+  void RenderProgressiveWeave(int renderBuffer, int field); // render using vdpau hardware
   void RenderVAAPI(int renderBuffer, int field);      // render using vdpau hardware
 
   struct
-- 
1.8.1.6


From ec7254bd6dabe50dfaa382840b585004c1c8c883 Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Thu, 28 Mar 2013 10:38:37 +0100
Subject: [PATCH 033/123] VDPAU: silence compiler warnings

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 19 ++++++++-----------
 1 file changed, 8 insertions(+), 11 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index f913a97..e9ec3d2 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -252,7 +252,7 @@ long CDecoder::Release()
       }
     }
   }
-  IHardwareDecoder::Release();
+  return IHardwareDecoder::Release();
 }
 
 long CDecoder::ReleasePicReference()
@@ -1426,8 +1426,8 @@ void CMixer::StateMachine(int signal, Protocol *port, Message *msg)
 
 void CMixer::Process()
 {
-  Message *msg;
-  Protocol *port;
+  Message *msg = NULL;
+  Protocol *port = NULL;
   bool gotMsg;
 
   m_state = M_TOP_UNCONFIGURED;
@@ -1532,7 +1532,6 @@ void CMixer::CreateVdpauMixer()
 
 void CMixer::InitCSCMatrix(int Width)
 {
-  VdpStatus vdp_st;
   m_Procamp.struct_version = VDP_PROCAMP_VERSION;
   m_Procamp.brightness     = 0.0;
   m_Procamp.contrast       = 1.0;
@@ -2663,8 +2662,8 @@ void COutput::StateMachine(int signal, Protocol *port, Message *msg)
 
 void COutput::Process()
 {
-  Message *msg;
-  Protocol *port;
+  Message *msg = NULL;
+  Protocol *port = NULL;
   bool gotMsg;
 
   m_state = O_TOP_UNCONFIGURED;
@@ -2875,7 +2874,6 @@ CVdpauRenderPicture* COutput::ProcessMixerPicture()
       pixmap->DVDPic = pic.DVDPic;
       pixmap->id = i;
       m_bufferPool.notVisiblePixmaps.push_back(pixmap);
-      VdpStatus vdp_st;
       m_config.vdpProcs.vdp_presentation_queue_display(pixmap->vdp_flip_queue,
                                                        pixmap->surface,0,0,0);
     }
@@ -3033,7 +3031,7 @@ bool COutput::EnsureBufferPool()
   {
     // create pixmpas
     VdpauBufferPool::Pixmaps pixmap;
-    int numPixmaps = NUM_RENDER_PICS;
+    unsigned int numPixmaps = NUM_RENDER_PICS;
     for (unsigned int i = 0; i < numPixmaps; i++)
     {
       pixmap.pixmap = None;
@@ -3287,7 +3285,7 @@ void COutput::GLMapSurfaces()
     if (m_config.videoSurfaces->size() != m_bufferPool.glVideoSurfaceMap.size())
     {
       CSingleLock lock(*m_config.videoSurfaceSec);
-      for (int i = 0; i < m_config.videoSurfaces->size(); i++)
+      for (unsigned int i = 0; i < m_config.videoSurfaces->size(); i++)
       {
         if ((*m_config.videoSurfaces)[i]->surface == VDP_INVALID_HANDLE)
           continue;
@@ -3335,7 +3333,7 @@ void COutput::GLMapSurfaces()
     if (m_bufferPool.glOutputSurfaceMap.size() != m_bufferPool.numOutputSurfaces)
     {
       VdpauBufferPool::GLVideoSurface glSurface;
-      for (int i=m_bufferPool.glOutputSurfaceMap.size(); i<m_bufferPool.outputSurfaces.size(); i++)
+      for (unsigned int i = m_bufferPool.glOutputSurfaceMap.size(); i<m_bufferPool.outputSurfaces.size(); i++)
       {
         glSurface.sourceRgb = m_bufferPool.outputSurfaces[i];
         glGenTextures(1, glSurface.texture);
@@ -3459,7 +3457,6 @@ bool COutput::CheckStatus(VdpStatus vdp_st, int line)
 bool COutput::CreateGlxContext()
 {
   GLXContext   glContext;
-  Window       window;
 
   m_Display = g_Windowing.GetDisplay();
   glContext = g_Windowing.GetGlxContext();
-- 
1.8.1.6


From 3bc3adc2abf37a0edeb829c89559b71d314c40ca Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 25 Feb 2013 08:47:10 +0100
Subject: [PATCH 034/123] vdpau: release more resources on pre-cleanup

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 72 +++++++++++++++++++++++---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h   |  2 +
 2 files changed, 68 insertions(+), 6 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index e9ec3d2..9850cf0 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -1170,6 +1170,11 @@ void CMixer::Dispose()
   m_dataPort.Purge();
 }
 
+bool CMixer::IsActive()
+{
+  return IsRunning();
+}
+
 void CMixer::OnStartup()
 {
   CLog::Log(LOGNOTICE, "CMixer::OnStartup: Output Thread created");
@@ -2559,6 +2564,7 @@ void COutput::StateMachine(int signal, Protocol *port, Message *msg)
           return;
         case COutputControlProtocol::PRECLEANUP:
           Flush();
+          PreCleanup();
           msg->Reply(COutputControlProtocol::ACC);
           return;
         default:
@@ -2765,15 +2771,18 @@ bool COutput::Uninit()
 
 void COutput::Flush()
 {
-  Message *reply;
-  if (m_mixer.m_controlPort.SendOutMessageSync(CMixerControlProtocol::FLUSH,
+  if (m_mixer.IsActive())
+  {
+    Message *reply;
+    if (m_mixer.m_controlPort.SendOutMessageSync(CMixerControlProtocol::FLUSH,
                                                  &reply,
                                                  2000))
-  {
-    reply->Release();
+    {
+      reply->Release();
+    }
+    else
+      CLog::Log(LOGERROR, "Coutput::%s - failed to flush mixer", __FUNCTION__);
   }
-  else
-    CLog::Log(LOGERROR, "Coutput::%s - failed to flush mixer", __FUNCTION__);
 
   Message *msg;
   while (m_mixer.m_dataPort.ReceiveInMessage(&msg))
@@ -3111,6 +3120,57 @@ void COutput::ReleaseBufferPool()
   }
 }
 
+void COutput::PreCleanup()
+{
+
+  VdpStatus vdp_st;
+
+  m_mixer.Dispose();
+
+  CSingleLock lock(m_bufferPool.renderPicSec);
+  for (unsigned int i = 0; i < m_bufferPool.outputSurfaces.size(); ++i)
+  {
+    if (m_bufferPool.outputSurfaces[i] == VDP_INVALID_HANDLE)
+      continue;
+
+    // check if output surface is in use
+    bool used = false;
+    std::deque<CVdpauRenderPicture*>::iterator it;
+    for (it = m_bufferPool.usedRenderPics.begin(); it != m_bufferPool.usedRenderPics.end(); ++it)
+    {
+      if (((*it)->sourceIdx == m_bufferPool.outputSurfaces[i]) && (*it)->valid)
+      {
+        used = true;
+        break;
+      }
+    }
+    if (used)
+      continue;
+
+#ifdef GL_NV_vdpau_interop
+    // unmap surface
+    std::map<VdpOutputSurface, VdpauBufferPool::GLVideoSurface>::iterator it_map;
+    it_map = m_bufferPool.glOutputSurfaceMap.find(m_bufferPool.outputSurfaces[i]);
+    if (it_map == m_bufferPool.glOutputSurfaceMap.end())
+    {
+      CLog::Log(LOGERROR, "%s - could not find gl surface", __FUNCTION__);
+      continue;
+    }
+    glVDPAUUnregisterSurfaceNV(it_map->second.glVdpauSurface);
+    glDeleteTextures(1, it_map->second.texture);
+    m_bufferPool.glOutputSurfaceMap.erase(it_map);
+#endif
+
+    vdp_st = m_config.vdpProcs.vdp_output_surface_destroy(m_bufferPool.outputSurfaces[i]);
+    CheckStatus(vdp_st, __LINE__);
+
+    m_bufferPool.outputSurfaces[i] = VDP_INVALID_HANDLE;
+
+    CLog::Log(LOGDEBUG, "VDPAU::PreCleanup - released output surface");
+  }
+
+}
+
 void COutput::InitMixer()
 {
   for (unsigned int i = 0; i < m_bufferPool.outputSurfaces.size(); ++i)
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
index ef99383..39047b5 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.h
@@ -286,6 +286,7 @@ class CMixer : private CThread
   virtual ~CMixer();
   void Start();
   void Dispose();
+  bool IsActive();
   CMixerControlProtocol m_controlPort;
   CMixerDataProtocol m_dataPort;
 protected:
@@ -454,6 +455,7 @@ class COutput : private CThread
   bool DestroyGlxContext();
   bool EnsureBufferPool();
   void ReleaseBufferPool();
+  void PreCleanup();
   void InitMixer();
   bool GLInit();
   void GLMapSurfaces();
-- 
1.8.1.6


From d35ccb80581844bbca3333347f00e6fcb93a71d0 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Wed, 6 Mar 2013 07:35:10 +0100
Subject: [PATCH 035/123] vdpau: set deinterlacing method to auto, if default
 method not supported

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 9850cf0..0a6a1dc 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -2195,13 +2195,15 @@ void CMixer::InitCycle()
     }
     else
     {
-      CLog::Log(LOGERROR, "CMixer::%s - interlace method not supported", __FUNCTION__);
+      CLog::Log(LOGERROR, "CMixer::%s - interlace method: %d not supported, setting to AUTO", __FUNCTION__, method);
       m_mixersteps = 1;
       m_mixerfield = VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME;
       m_mixerInput[1].DVDPic.format = RENDER_FMT_VDPAU;
       m_mixerInput[1].DVDPic.iFlags &= ~(DVP_FLAG_TOP_FIELD_FIRST |
                                         DVP_FLAG_REPEAT_TOP_FIELD |
                                         DVP_FLAG_INTERLACED);
+
+      CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod = VS_INTERLACEMETHOD_AUTO;
     }
   }
   else
-- 
1.8.1.6


From c3e2ffae7ea03c7f97534d5232c7d85fa15e89fc Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 21 Apr 2013 09:19:34 +0200
Subject: [PATCH 036/123] vdpau: fix deadlock if decoder is closed while
 refresh rate changes

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 9 ++-------
 1 file changed, 2 insertions(+), 7 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 0a6a1dc..4b4b3c3 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -183,6 +183,8 @@ void CDecoder::Close()
 {
   CLog::Log(LOGNOTICE, " (VDPAU) %s", __FUNCTION__);
 
+  g_Windowing.Unregister(this);
+
   CSingleLock lock(m_DecoderSection);
 
   FiniVDPAUOutput();
@@ -204,13 +206,6 @@ void CDecoder::Close()
     m_dllAvUtil.av_freep(&m_hwContext.bitstream_buffers);
   }
 
-  g_Windowing.Unregister(this);
-
-  if (m_hwContext.bitstream_buffers_allocated)
-  {
-    m_dllAvUtil.av_freep(&m_hwContext.bitstream_buffers);
-  }
-
   m_dllAvUtil.Unload();
 }
 
-- 
1.8.1.6


From a8be3fdeb938bbaafb2ed203f3603df659fbeab2 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 1 Jun 2013 11:21:19 +0200
Subject: [PATCH 037/123] renderer: bump buffers to 5

---
 xbmc/cores/VideoRenderers/BaseRenderer.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/VideoRenderers/BaseRenderer.h b/xbmc/cores/VideoRenderers/BaseRenderer.h
index fe1f577..527ecf1 100644
--- a/xbmc/cores/VideoRenderers/BaseRenderer.h
+++ b/xbmc/cores/VideoRenderers/BaseRenderer.h
@@ -29,7 +29,7 @@
 
 #define MAX_PLANES 3
 #define MAX_FIELDS 3
-#define NUM_BUFFERS 3
+#define NUM_BUFFERS 5
 
 class CSetting;
 
-- 
1.8.1.6


From b0470afab151c7b6f40ef522a34971915eaf6a01 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 28 May 2012 10:41:31 +0200
Subject: [PATCH 038/123] videoplayer: update frametime, it might change due to
 fps detection

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 3c30d0b..347e888 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -707,6 +707,8 @@ void CDVDPlayerVideo::Process()
 
             int iResult = OutputPicture(&picture, pts);
 
+            frametime = (double)DVD_TIME_BASE/m_fFrameRate;
+
             if(m_started == false)
             {
               m_codecname = m_pVideoCodec->GetName();
-- 
1.8.1.6


From 3b2c4035e621d28160dc432159b61df047c6b879 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 28 May 2012 10:43:06 +0200
Subject: [PATCH 039/123] videoplayer: give streams with invalid fps a chance
 for fps detection

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 347e888..1a17145 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1529,7 +1529,7 @@ void CDVDPlayerVideo::CalcFrameRate()
   double frameduration = m_pullupCorrection.GetFrameDuration();
 
   if (frameduration == DVD_NOPTS_VALUE ||
-      (g_advancedSettings.m_videoFpsDetect == 1 && m_pullupCorrection.GetPatternLength() > 1))
+      (g_advancedSettings.m_videoFpsDetect == 1 && (m_pullupCorrection.GetPatternLength() > 1 && !m_bFpsInvalid)))
   {
     //reset the stored framerates if no good framerate was detected
     m_fStableFrameRate = 0.0;
-- 
1.8.1.6


From 122cde177d428fc91114be2fb57318a6aa69ba5b Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 28 May 2012 10:49:05 +0200
Subject: [PATCH 040/123] dvdplayer: allow rewinding at end of stream, do a
 seek after rewind

---
 xbmc/cores/dvdplayer/DVDPlayer.cpp | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index 974ebd1..b56423b 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -1555,7 +1555,7 @@ void CDVDPlayer::HandlePlaySpeed()
 
     }
     else if (m_CurrentVideo.id >= 0
-          &&  m_CurrentVideo.inited == true
+          &&  (m_CurrentVideo.inited == true || GetPlaySpeed() < 0) // allow rewind at end of file
           &&  m_SpeedState.lastpts  != m_dvdPlayerVideo.GetCurrentPts()
           &&  m_SpeedState.lasttime != GetTime())
     {
@@ -2221,6 +2221,12 @@ void CDVDPlayer::HandleMessages()
           pvrinputstream->Pause( speed == 0 );
         }
 
+        // do a seek after rewind, clock is not in sync with current pts
+        if (m_playSpeed < 0 && speed >= 0)
+        {
+          m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), true, true, true));
+        }
+
         // if playspeed is different then DVD_PLAYSPEED_NORMAL or DVD_PLAYSPEED_PAUSE
         // audioplayer, stops outputing audio to audiorendere, but still tries to
         // sleep an correct amount for each packet
-- 
1.8.1.6


From a308b831bd2e6e7a74589987a4ea805e3f10b2ae Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 15:22:05 +0200
Subject: [PATCH 041/123] X11: ditch SDL for video and window events

---
 xbmc/Application.cpp                |   2 +-
 xbmc/system.h                       |   5 +
 xbmc/windowing/Makefile             |   1 +
 xbmc/windowing/WinEvents.h          |   4 +
 xbmc/windowing/WinEventsX11.cpp     | 765 ++++++++++++++++++++++++++++++++++++
 xbmc/windowing/WinEventsX11.h       |  57 +++
 xbmc/windowing/X11/WinSystemX11.cpp | 370 ++++++++++++-----
 xbmc/windowing/X11/WinSystemX11.h   |   9 +-
 8 files changed, 1112 insertions(+), 101 deletions(-)
 create mode 100644 xbmc/windowing/WinEventsX11.cpp
 create mode 100644 xbmc/windowing/WinEventsX11.h

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index 3937ce8..a5603a2 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -833,7 +833,7 @@ bool CApplication::CreateGUI()
 
   uint32_t sdlFlags = 0;
 
-#if defined(HAS_SDL_OPENGL) || (HAS_GLES == 2)
+#if (defined(HAS_SDL_OPENGL) || (HAS_GLES == 2)) && !defined(HAS_GLX)
   sdlFlags |= SDL_INIT_VIDEO;
 #endif
 
diff --git a/xbmc/system.h b/xbmc/system.h
index 7ccda52..bb6b72e 100644
--- a/xbmc/system.h
+++ b/xbmc/system.h
@@ -171,16 +171,21 @@
 #define HAS_GL
 #ifdef HAVE_X11
 #define HAS_GLX
+#define HAS_X11_WIN_EVENTS
 #endif
 #ifdef HAVE_SDL
 #define HAS_SDL
 #ifndef HAS_SDL_OPENGL
 #define HAS_SDL_OPENGL
 #endif
+#ifndef HAVE_X11
 #define HAS_SDL_WIN_EVENTS
+#endif
 #else
+#ifndef HAVE_X11
 #define HAS_LINUX_EVENTS
 #endif
+#endif
 #define HAS_LINUX_NETWORK
 #define HAS_LIRC
 #ifdef HAVE_LIBPULSE
diff --git a/xbmc/windowing/Makefile b/xbmc/windowing/Makefile
index f109bec..f981642 100644
--- a/xbmc/windowing/Makefile
+++ b/xbmc/windowing/Makefile
@@ -1,6 +1,7 @@
 SRCS=WinEventsSDL.cpp \
      WinEventsLinux.cpp \
      WinSystem.cpp \
+     WinEventsX11.cpp \
      
 LIB=windowing.a
 
diff --git a/xbmc/windowing/WinEvents.h b/xbmc/windowing/WinEvents.h
index 5feb800..49adcdf 100644
--- a/xbmc/windowing/WinEvents.h
+++ b/xbmc/windowing/WinEvents.h
@@ -56,6 +56,10 @@ class CWinEventsBase
 #include "WinEventsSDL.h"
 #define CWinEvents CWinEventsSDL
 
+#elif defined(TARGET_LINUX) && defined(HAS_X11_WIN_EVENTS)
+#include "WinEventsX11.h"
+#define CWinEvents CWinEventsX11
+
 #elif defined(TARGET_LINUX) && defined(HAS_LINUX_EVENTS)
 #include "WinEventsLinux.h"
 #define CWinEvents CWinEventsLinux
diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
new file mode 100644
index 0000000..5a8bbb8
--- /dev/null
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -0,0 +1,765 @@
+/*
+*      Copyright (C) 2005-2012 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+
+#include "system.h"
+
+#ifdef HAS_X11_WIN_EVENTS
+
+#include "WinEvents.h"
+#include "WinEventsX11.h"
+#include "Application.h"
+#include "ApplicationMessenger.h"
+#include <X11/Xlib.h>
+#include "X11/WinSystemX11GL.h"
+#include "X11/keysymdef.h"
+#include "X11/XF86keysym.h"
+#include "utils/log.h"
+#include "guilib/GUIWindowManager.h"
+#include "input/MouseStat.h"
+
+CWinEventsX11* CWinEventsX11::WinEvents = 0;
+
+static uint32_t SymMappingsX11[][2] =
+{
+  {XK_BackSpace, XBMCK_BACKSPACE}
+, {XK_Tab, XBMCK_TAB}
+, {XK_Clear, XBMCK_CLEAR}
+, {XK_Return, XBMCK_RETURN}
+, {XK_Pause, XBMCK_PAUSE}
+, {XK_Escape, XBMCK_ESCAPE}
+, {XK_Delete, XBMCK_DELETE}
+// multi-media keys
+, {XF86XK_Back, XBMCK_BROWSER_BACK}
+, {XF86XK_Forward, XBMCK_BROWSER_FORWARD}
+, {XF86XK_Refresh, XBMCK_BROWSER_REFRESH}
+, {XF86XK_Stop, XBMCK_BROWSER_STOP}
+, {XF86XK_Search, XBMCK_BROWSER_SEARCH}
+, {XF86XK_Favorites, XBMCK_BROWSER_FAVORITES}
+, {XF86XK_HomePage, XBMCK_BROWSER_HOME}
+, {XF86XK_AudioMute, XBMCK_VOLUME_MUTE}
+, {XF86XK_AudioLowerVolume, XBMCK_VOLUME_DOWN}
+, {XF86XK_AudioRaiseVolume, XBMCK_VOLUME_UP}
+, {XF86XK_AudioNext, XBMCK_MEDIA_NEXT_TRACK}
+, {XF86XK_AudioPrev, XBMCK_MEDIA_PREV_TRACK}
+, {XF86XK_AudioStop, XBMCK_MEDIA_STOP}
+, {XF86XK_AudioPause, XBMCK_MEDIA_PLAY_PAUSE}
+, {XF86XK_Mail, XBMCK_LAUNCH_MAIL}
+, {XF86XK_Select, XBMCK_LAUNCH_MEDIA_SELECT}
+, {XF86XK_Launch0, XBMCK_LAUNCH_APP1}
+, {XF86XK_Launch1, XBMCK_LAUNCH_APP2}
+, {XF86XK_WWW, XBMCK_LAUNCH_FILE_BROWSER}
+, {XF86XK_AudioMedia, XBMCK_LAUNCH_MEDIA_CENTER }
+  // Numeric keypad
+, {XK_KP_0, XBMCK_KP0}
+, {XK_KP_1, XBMCK_KP1}
+, {XK_KP_2, XBMCK_KP2}
+, {XK_KP_3, XBMCK_KP3}
+, {XK_KP_4, XBMCK_KP4}
+, {XK_KP_5, XBMCK_KP5}
+, {XK_KP_6, XBMCK_KP6}
+, {XK_KP_7, XBMCK_KP7}
+, {XK_KP_8, XBMCK_KP8}
+, {XK_KP_9, XBMCK_KP9}
+, {XK_KP_Separator, XBMCK_KP_PERIOD}
+, {XK_KP_Divide, XBMCK_KP_DIVIDE}
+, {XK_KP_Multiply, XBMCK_KP_MULTIPLY}
+, {XK_KP_Subtract, XBMCK_KP_MINUS}
+, {XK_KP_Add, XBMCK_KP_PLUS}
+, {XK_KP_Enter, XBMCK_KP_ENTER}
+, {XK_KP_Equal, XBMCK_KP_EQUALS}
+  // Arrows + Home/End pad
+, {XK_Up, XBMCK_UP}
+, {XK_Down, XBMCK_DOWN}
+, {XK_Right, XBMCK_RIGHT}
+, {XK_Left, XBMCK_LEFT}
+, {XK_Insert, XBMCK_INSERT}
+, {XK_Home, XBMCK_HOME}
+, {XK_End, XBMCK_END}
+, {XK_Page_Up, XBMCK_PAGEUP}
+, {XK_Page_Down, XBMCK_PAGEDOWN}
+  // Function keys
+, {XK_F1, XBMCK_F1}
+, {XK_F2, XBMCK_F2}
+, {XK_F3, XBMCK_F3}
+, {XK_F4, XBMCK_F4}
+, {XK_F5, XBMCK_F5}
+, {XK_F6, XBMCK_F6}
+, {XK_F7, XBMCK_F7}
+, {XK_F8, XBMCK_F8}
+, {XK_F9, XBMCK_F9}
+, {XK_F10, XBMCK_F10}
+, {XK_F11, XBMCK_F11}
+, {XK_F12, XBMCK_F12}
+, {XK_F13, XBMCK_F13}
+, {XK_F14, XBMCK_F14}
+, {XK_F15, XBMCK_F15}
+  // Key state modifier keys
+, {XK_Num_Lock, XBMCK_NUMLOCK}
+, {XK_Caps_Lock, XBMCK_CAPSLOCK}
+, {XK_Scroll_Lock, XBMCK_SCROLLOCK}
+, {XK_Shift_R, XBMCK_RSHIFT}
+, {XK_Shift_L, XBMCK_LSHIFT}
+, {XK_Control_R, XBMCK_RCTRL}
+, {XK_Control_L, XBMCK_LCTRL}
+, {XK_Alt_R, XBMCK_RALT}
+, {XK_Alt_L, XBMCK_LALT}
+, {XK_Meta_R, XBMCK_RMETA}
+, {XK_Meta_L, XBMCK_LMETA}
+, {XK_Super_L, XBMCK_LSUPER}
+, {XK_Super_R, XBMCK_RSUPER}
+, {XK_Mode_switch, XBMCK_MODE}
+, {XK_Multi_key, XBMCK_COMPOSE}
+  // Miscellaneous function keys
+, {XK_Help, XBMCK_HELP}
+, {XK_Print, XBMCK_PRINT}
+//, {0, XBMCK_SYSREQ}
+, {XK_Break, XBMCK_BREAK}
+, {XK_Menu, XBMCK_MENU}
+, {XF86XK_PowerOff, XBMCK_POWER}
+, {XK_EcuSign, XBMCK_EURO}
+, {XK_Undo, XBMCK_UNDO}
+  /* Media keys */
+, {XF86XK_Eject, XBMCK_EJECT}
+, {XF86XK_Stop, XBMCK_STOP}
+, {XF86XK_AudioRecord, XBMCK_RECORD}
+, {XF86XK_AudioRewind, XBMCK_REWIND}
+, {XF86XK_Phone, XBMCK_PHONE}
+, {XF86XK_AudioPlay, XBMCK_PLAY}
+, {XF86XK_AudioRandomPlay, XBMCK_SHUFFLE}
+, {XF86XK_AudioForward, XBMCK_FASTFORWARD}
+};
+
+
+CWinEventsX11::CWinEventsX11()
+{
+  m_display = 0;
+  m_window = 0;
+  m_keybuf = 0;
+  m_utf16buf = 0;
+}
+
+CWinEventsX11::~CWinEventsX11()
+{
+  if (m_keybuf);
+  {
+    free(m_keybuf);
+    m_keybuf = 0;
+  }
+
+  if (m_utf16buf)
+  {
+    free(m_utf16buf);
+    m_utf16buf = 0;
+  }
+
+  if (m_xic)
+  {
+    XUnsetICFocus(m_xic);
+    XDestroyIC(m_xic);
+    m_xic = 0;
+  }
+
+  if (m_xim)
+  {
+    XCloseIM(m_xim);
+    m_xim = 0;
+  }
+
+  m_symLookupTable.clear();
+}
+
+bool CWinEventsX11::Init(Display *dpy, Window win)
+{
+  if (WinEvents)
+    return true;
+
+  WinEvents = new CWinEventsX11();
+  WinEvents->m_display = dpy;
+  WinEvents->m_window = win;
+  WinEvents->m_keybuf = (char*)malloc(32*sizeof(char));
+  WinEvents->m_utf16buf = (uint16_t*)malloc(32*sizeof(uint16_t));
+  WinEvents->m_keymodState = 0;
+  WinEvents->m_wmDeleteMessage = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
+  WinEvents->m_structureChanged = false;
+  memset(&(WinEvents->m_lastKey), 0, sizeof(XBMC_Event));
+
+  // open input method
+  char *old_locale = NULL, *old_modifiers = NULL;
+  char res_name[8];
+  const char *p;
+  size_t n;
+
+  // set resource name to xbmc, not used
+  strcpy(res_name, "xbmc");
+
+  // save current locale, this should be "C"
+  p = setlocale(LC_ALL, NULL);
+  if (p)
+  {
+    old_locale = (char*)malloc(strlen(p) +1);
+    strcpy(old_locale, p);
+  }
+  p = XSetLocaleModifiers(NULL);
+  if (p)
+  {
+    old_modifiers = (char*)malloc(strlen(p) +1);
+    strcpy(old_modifiers, p);
+  }
+
+  // set users preferences and open input method
+  p = setlocale(LC_ALL, "");
+  XSetLocaleModifiers("");
+  WinEvents->m_xim = XOpenIM(WinEvents->m_display, NULL, res_name, res_name);
+
+  // restore old locale
+  if (old_locale)
+  {
+    setlocale(LC_ALL, old_locale);
+    free(old_locale);
+  }
+  if (old_modifiers)
+  {
+    XSetLocaleModifiers(old_modifiers);
+    free(old_modifiers);
+  }
+
+  WinEvents->m_xic = NULL;
+  if (WinEvents->m_xim)
+  {
+    WinEvents->m_xic = XCreateIC(WinEvents->m_xim,
+                                 XNClientWindow, WinEvents->m_window,
+                                 XNFocusWindow, WinEvents->m_window,
+                                 XNInputStyle, XIMPreeditNothing | XIMStatusNothing,
+                                 XNResourceName, res_name,
+                                 XNResourceClass, res_name,
+                                 NULL);
+  }
+
+  if (!WinEvents->m_xic)
+    CLog::Log(LOGWARNING,"CWinEventsX11::Init - no input method found");
+
+  // build Keysym lookup table
+  for (unsigned int i = 0; i < sizeof(SymMappingsX11)/(2*sizeof(uint32_t)); ++i)
+  {
+    WinEvents->m_symLookupTable[SymMappingsX11[i][0]] = SymMappingsX11[i][1];
+  }
+
+  return true;
+}
+
+void CWinEventsX11::Quit()
+{
+  if (!WinEvents)
+    return;
+
+  delete WinEvents;
+  WinEvents = 0;
+}
+
+bool CWinEventsX11::HasStructureChanged()
+{
+  if (!WinEvents)
+    return false;
+
+  bool ret = WinEvents->m_structureChanged;
+  WinEvents->m_structureChanged = false;
+  return ret;
+}
+
+bool CWinEventsX11::MessagePump()
+{
+  if (!WinEvents)
+    return false;
+
+  bool ret = false;
+  XEvent xevent;
+  unsigned long serial = 0;
+
+  while (WinEvents && XPending(WinEvents->m_display))
+  {
+    memset(&xevent, 0, sizeof (XEvent));
+    XNextEvent(WinEvents->m_display, &xevent);
+
+    //  ignore events generated by auto-repeat
+    if (xevent.type == KeyRelease && XPending(WinEvents->m_display))
+    {
+      XEvent peekevent;
+      XPeekEvent(WinEvents->m_display, &peekevent);
+      if ((peekevent.type == KeyPress) &&
+          (peekevent.xkey.keycode == xevent.xkey.keycode) &&
+          ((peekevent.xkey.time - xevent.xkey.time) < 2))
+      {
+        XNextEvent(WinEvents->m_display, &peekevent);
+        continue;
+      }
+    }
+
+    if (XFilterEvent(&xevent, None))
+      continue;
+
+    switch (xevent.type)
+    {
+      case MapNotify:
+      {
+        g_application.SetRenderGUI(true);
+        break;
+      }
+
+      case UnmapNotify:
+      {
+        g_application.SetRenderGUI(false);
+        break;
+      }
+
+      case FocusIn:
+      {
+        if (WinEvents->m_xic)
+          XSetICFocus(WinEvents->m_xic);
+        g_application.m_AppFocused = true;
+        if (serial == xevent.xfocus.serial)
+          break;
+        g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
+        break;
+      }
+
+      case FocusOut:
+      {
+        if (WinEvents->m_xic)
+          XUnsetICFocus(WinEvents->m_xic);
+        g_application.m_AppFocused = false;
+        g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
+        serial = xevent.xfocus.serial;
+        break;
+      }
+
+      case Expose:
+      {
+        g_windowManager.MarkDirty();
+        break;
+      }
+
+      case ConfigureNotify:
+      {
+        if (xevent.xconfigure.window != WinEvents->m_window)
+          break;
+
+        WinEvents->m_structureChanged = true;
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_VIDEORESIZE;
+        newEvent.resize.w = xevent.xconfigure.width;
+        newEvent.resize.h = xevent.xconfigure.height;
+        ret |= g_application.OnEvent(newEvent);
+        g_windowManager.MarkDirty();
+        break;
+      }
+
+      case ClientMessage:
+      {
+        if (xevent.xclient.data.l[0] == WinEvents->m_wmDeleteMessage)
+          if (!g_application.m_bStop) CApplicationMessenger::Get().Quit();
+        break;
+      }
+
+      case KeyPress:
+      {
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_KEYDOWN;
+        KeySym xkeysym;
+
+        // fallback if we have no IM
+        if (!WinEvents->m_xic)
+        {
+          static XComposeStatus state;
+          char keybuf[32];
+          xkeysym = XLookupKeysym(&xevent.xkey, 0);
+          newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
+          newEvent.key.keysym.scancode = xevent.xkey.keycode;
+          newEvent.key.state = xevent.xkey.state;
+          newEvent.key.type = xevent.xkey.type;
+          if (XLookupString(&xevent.xkey, keybuf, sizeof(keybuf), NULL, &state))
+          {
+            newEvent.key.keysym.unicode = keybuf[0];
+          }
+          ret |= ProcessKey(newEvent, 500);
+          break;
+        }
+
+        Status status;
+        int utf16size;
+        int utf16length;
+        int len;
+        len = Xutf8LookupString(WinEvents->m_xic, &xevent.xkey,
+                                WinEvents->m_keybuf, sizeof(WinEvents->m_keybuf),
+                                &xkeysym, &status);
+        if (status == XBufferOverflow)
+        {
+          WinEvents->m_keybuf = (char*)realloc(WinEvents->m_keybuf, len*sizeof(char));
+          len = Xutf8LookupString(WinEvents->m_xic, &xevent.xkey,
+                                  WinEvents->m_keybuf, sizeof(WinEvents->m_keybuf),
+                                  &xkeysym, &status);
+        }
+        switch (status)
+        {
+          case XLookupNone:
+            break;
+          case XLookupChars:
+          case XLookupBoth:
+          {
+            if (len == 0)
+              break;
+            utf16size = len * sizeof(uint16_t);
+            if (utf16size > sizeof(WinEvents->m_utf16buf))
+            {
+              WinEvents->m_utf16buf = (uint16_t *)realloc(WinEvents->m_utf16buf,utf16size);
+              if (WinEvents->m_utf16buf == NULL)
+              {
+                break;
+              }
+            }
+            utf16length = Utf8ToUnicode(WinEvents->m_keybuf, len, WinEvents->m_utf16buf, utf16size);
+            if (utf16length < 0)
+            {
+              break;
+            }
+            for (unsigned int i = 0; i < utf16length - 1; i++)
+            {
+              newEvent.key.keysym.sym = XBMCK_UNKNOWN;
+              newEvent.key.keysym.unicode = WinEvents->m_utf16buf[i];
+              newEvent.key.state = xevent.xkey.state;
+              newEvent.key.type = xevent.xkey.type;
+              ret |= ProcessKey(newEvent, 500);
+            }
+            if (utf16length > 0)
+            {
+              newEvent.key.keysym.scancode = xevent.xkey.keycode;
+              xkeysym = XLookupKeysym(&xevent.xkey, 0);
+              newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
+              newEvent.key.keysym.unicode = WinEvents->m_utf16buf[utf16length - 1];
+              newEvent.key.state = xevent.xkey.state;
+              newEvent.key.type = xevent.xkey.type;
+
+              ret |= ProcessKey(newEvent, 500);
+            }
+            break;
+          }
+
+          case XLookupKeySym:
+          {
+            newEvent.key.keysym.scancode = xevent.xkey.keycode;
+            newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
+            newEvent.key.state = xevent.xkey.state;
+            newEvent.key.type = xevent.xkey.type;
+            ret |= ProcessKey(newEvent, 500);
+            break;
+          }
+
+        }// switch status
+        break;
+      } //KeyPress
+
+      case KeyRelease:
+      {
+        XBMC_Event newEvent;
+        KeySym xkeysym;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_KEYUP;
+        xkeysym = XLookupKeysym(&xevent.xkey, 0);
+        newEvent.key.keysym.scancode = xevent.xkey.keycode;
+        newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
+        newEvent.key.state = xevent.xkey.state;
+        newEvent.key.type = xevent.xkey.type;
+        ret |= ProcessKey(newEvent, 0);
+        break;
+      }
+
+      // lose mouse coverage
+      case LeaveNotify:
+      {
+        g_Mouse.SetActive(false);
+        break;
+      }
+
+      case MotionNotify:
+      {
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_MOUSEMOTION;
+        newEvent.motion.xrel = (int16_t)xevent.xmotion.x_root;
+        newEvent.motion.yrel = (int16_t)xevent.xmotion.y_root;
+        newEvent.motion.x = (int16_t)xevent.xmotion.x;
+        newEvent.motion.y = (int16_t)xevent.xmotion.y;
+        ret |= g_application.OnEvent(newEvent);
+        break;
+      }
+
+      case ButtonPress:
+      {
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_MOUSEBUTTONDOWN;
+        newEvent.button.button = (unsigned char)xevent.xbutton.button;
+        newEvent.button.state = XBMC_PRESSED;
+        newEvent.button.x = (int16_t)xevent.xbutton.x;
+        newEvent.button.y = (int16_t)xevent.xbutton.y;
+        ret |= g_application.OnEvent(newEvent);
+        break;
+      }
+
+      case ButtonRelease:
+      {
+        XBMC_Event newEvent;
+        memset(&newEvent, 0, sizeof(newEvent));
+        newEvent.type = XBMC_MOUSEBUTTONUP;
+        newEvent.button.button = (unsigned char)xevent.xbutton.button;
+        newEvent.button.state = XBMC_RELEASED;
+        newEvent.button.x = (int16_t)xevent.xbutton.x;
+        newEvent.button.y = (int16_t)xevent.xbutton.y;
+        ret |= g_application.OnEvent(newEvent);
+        break;
+      }
+
+      default:
+      {
+        break;
+      }
+    }// switch event.type
+  }// while
+
+  ret |= ProcessKeyRepeat();
+
+  return ret;
+}
+
+bool CWinEventsX11::ProcessKey(XBMC_Event &event, int repeatDelay)
+{
+  if (event.type == XBMC_KEYDOWN)
+  {
+    // check key modifiers
+    switch(event.key.keysym.sym)
+    {
+      case XBMCK_LSHIFT:
+        WinEvents->m_keymodState |= XBMCKMOD_LSHIFT;
+        break;
+      case XBMCK_RSHIFT:
+        WinEvents->m_keymodState |= XBMCKMOD_RSHIFT;
+        break;
+      case XBMCK_LCTRL:
+        WinEvents->m_keymodState |= XBMCKMOD_LCTRL;
+        break;
+      case XBMCK_RCTRL:
+        WinEvents->m_keymodState |= XBMCKMOD_RCTRL;
+        break;
+      case XBMCK_LALT:
+        WinEvents->m_keymodState |= XBMCKMOD_LALT;
+        break;
+      case XBMCK_RALT:
+        WinEvents->m_keymodState |= XBMCKMOD_RCTRL;
+        break;
+      case XBMCK_LMETA:
+        WinEvents->m_keymodState |= XBMCKMOD_LMETA;
+        break;
+      case XBMCK_RMETA:
+        WinEvents->m_keymodState |= XBMCKMOD_RMETA;
+        break;
+      case XBMCK_MODE:
+        WinEvents->m_keymodState |= XBMCKMOD_MODE;
+        break;
+      default:
+        break;
+    }
+    event.key.keysym.mod = (XBMCMod)WinEvents->m_keymodState;
+    memcpy(&(WinEvents->m_lastKey), &event, sizeof(event));
+    WinEvents->m_repeatKeyTimeout.Set(repeatDelay);
+
+    bool ret = ProcessShortcuts(event);
+    if (ret)
+      return ret;
+  }
+  else if (event.type == XBMC_KEYUP)
+  {
+    switch(event.key.keysym.sym)
+    {
+      case XBMCK_LSHIFT:
+        WinEvents->m_keymodState &= ~XBMCKMOD_LSHIFT;
+        break;
+      case XBMCK_RSHIFT:
+        WinEvents->m_keymodState &= ~XBMCKMOD_RSHIFT;
+        break;
+      case XBMCK_LCTRL:
+        WinEvents->m_keymodState &= ~XBMCKMOD_LCTRL;
+        break;
+      case XBMCK_RCTRL:
+        WinEvents->m_keymodState &= ~XBMCKMOD_RCTRL;
+        break;
+      case XBMCK_LALT:
+        WinEvents->m_keymodState &= ~XBMCKMOD_LALT;
+        break;
+      case XBMCK_RALT:
+        WinEvents->m_keymodState &= ~XBMCKMOD_RCTRL;
+        break;
+      case XBMCK_LMETA:
+        WinEvents->m_keymodState &= ~XBMCKMOD_LMETA;
+        break;
+      case XBMCK_RMETA:
+        WinEvents->m_keymodState &= ~XBMCKMOD_RMETA;
+        break;
+      case XBMCK_MODE:
+        WinEvents->m_keymodState &= ~XBMCKMOD_MODE;
+        break;
+      default:
+        break;
+    }
+    event.key.keysym.mod = (XBMCMod)WinEvents->m_keymodState;
+    memset(&(WinEvents->m_lastKey), 0, sizeof(event));
+  }
+
+  return g_application.OnEvent(event);
+}
+
+bool CWinEventsX11::ProcessShortcuts(XBMC_Event& event)
+{
+  if (event.key.keysym.mod & XBMCKMOD_ALT)
+  {
+    switch(event.key.keysym.sym)
+    {
+      case XBMCK_TAB:  // ALT+TAB to minimize/hide
+        g_application.Minimize();
+        return true;
+
+      default:
+        return false;
+    }
+  }
+  return false;
+}
+
+bool CWinEventsX11::ProcessKeyRepeat()
+{
+  if (WinEvents && (WinEvents->m_lastKey.type == XBMC_KEYDOWN))
+  {
+    if (WinEvents->m_repeatKeyTimeout.IsTimePast())
+    {
+      return ProcessKey(WinEvents->m_lastKey, 10);
+    }
+  }
+  return false;
+}
+
+int CWinEventsX11::Utf8ToUnicode(const char *utf8, const int utf8Length, uint16_t *utf16, const int utf16MaxLength)
+{
+  // p moves over the output buffer.  max_ptr points to the next to the last slot of the buffer.
+  uint16_t *p = utf16;
+  uint16_t const *const maxPtr = utf16 + utf16MaxLength;
+
+  // end_of_input points to the last byte of input as opposed to the next to the last byte.
+  char const *const endOfInput = utf8 + utf8Length - 1;
+
+  while (utf8 <= endOfInput)
+  {
+    unsigned char const c = *utf8;
+    if (p >= maxPtr)
+    {
+      //No more output space.
+      return -1;
+    }
+    if (c < 0x80)
+    {
+      //One byte ASCII.
+      *p++ = c;
+      utf8 += 1;
+    }
+    else if (c < 0xC0)
+    {
+      // Follower byte without preceding leader bytes.
+      return -1;
+    }
+    // 11 bits
+    else if (c < 0xE0)
+    {
+      // Two byte sequence.  We need one follower byte.
+      if (endOfInput - utf8 < 1 || (((utf8[1] ^ 0x80)) & 0xC0))
+      {
+        return -1;
+      }
+      *p++ = (uint16_t)(((c & 0x1F) << 6) + (utf8[1] & 0x3F));
+      utf8 += 2;
+    }
+    // 16 bis
+    else if (c < 0xF0)
+    {
+      // Three byte sequence.  We need two follower byte.
+      if (endOfInput - utf8 < 2 || ((utf8[1] ^ 0x80) & 0xC0) || ((utf8[2] ^ 0x80) & 0xC0))
+      {
+        return -1;
+      }
+      *p++ = (uint16_t)(((c & 0xF) << 12) + ((utf8[1] & 0x3F) << 6) + (utf8[2] & 0x3F));
+      utf8 += 3;
+    }
+    // 21 bits
+    else if (c < 0xF8)
+    {
+      int plane;
+      // Four byte sequence.  We need three follower bytes.
+      if (endOfInput - utf8 < 3 || ((utf8[1] ^ 0x80) & 0xC0) ||
+          ((utf8[2] ^ 0x80) & 0xC0) || ((utf8[3] ^ 0x80) & 0xC0))
+      {
+        return -1;
+      }
+      uint32_t unicode = ((c & 0x7) << 18) + ((utf8[1] & 0x3F) << 12) +
+                          ((utf8[2] & 0x3F) << 6) + (utf8[3] & 0x3F);
+      utf8 += 4;
+      CLog::Log(LOGERROR, "CWinEventsX11::Utf8ToUnicode: 4 byte unicode not supported");
+    }
+    // 26 bits
+    else if (c < 0xFC)
+    {
+      CLog::Log(LOGERROR, "CWinEventsX11::Utf8ToUnicode: 4 byte unicode not supported");
+      utf8 += 5;
+    }
+    // 31 bit
+    else
+    {
+      CLog::Log(LOGERROR, "CWinEventsX11::Utf8ToUnicode: 4 byte unicode not supported");
+      utf8 += 6;
+    }
+  }
+  return p - utf16;
+}
+
+XBMCKey CWinEventsX11::LookupXbmcKeySym(KeySym keysym)
+{
+  // try direct mapping first
+  std::map<uint32_t, uint32_t>::iterator it;
+  it = WinEvents->m_symLookupTable.find(keysym);
+  if (it != WinEvents->m_symLookupTable.end())
+  {
+    return (XBMCKey)(it->second);
+  }
+
+  // try ascii mappings
+  if (keysym>>8 == 0x00)
+    return (XBMCKey)(keysym & 0xFF);
+
+  return (XBMCKey)keysym;
+}
+#endif
diff --git a/xbmc/windowing/WinEventsX11.h b/xbmc/windowing/WinEventsX11.h
new file mode 100644
index 0000000..e9b7553
--- /dev/null
+++ b/xbmc/windowing/WinEventsX11.h
@@ -0,0 +1,57 @@
+/*
+*      Copyright (C) 2005-2012 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, write to
+*  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+*  http://www.gnu.org/copyleft/gpl.html
+*
+*/
+#pragma once
+
+#include "WinEvents.h"
+#include <X11/Xlib.h>
+#include "threads/SystemClock.h"
+#include <map>
+
+class CWinEventsX11 : public CWinEventsBase
+{
+public:
+  CWinEventsX11();
+  virtual ~CWinEventsX11();
+  static bool Init(Display *dpy, Window win);
+  static void Quit();
+  static bool HasStructureChanged();
+  static bool MessagePump();
+
+protected:
+  static int Utf8ToUnicode(const char *utf8, const int utf8Length, uint16_t *utf16, const int utf16MaxLength);
+  static XBMCKey LookupXbmcKeySym(KeySym keysym);
+  static bool ProcessKey(XBMC_Event &event, int repeatDelay);
+  static bool ProcessKeyRepeat();
+  static bool ProcessShortcuts(XBMC_Event& event);
+  static CWinEventsX11 *WinEvents;
+  Display *m_display;
+  Window m_window;
+  Atom m_wmDeleteMessage;
+  char *m_keybuf;
+  uint16_t *m_utf16buf;
+  XIM m_xim;
+  XIC m_xic;
+  XBMC_Event m_lastKey;
+  XbmcThreads::EndTime m_repeatKeyTimeout;
+  std::map<uint32_t,uint32_t> m_symLookupTable;
+  int m_keymodState;
+  bool m_structureChanged;
+};
diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index e28b712..68e482e 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -22,7 +22,6 @@
 
 #ifdef HAS_GLX
 
-#include <SDL/SDL_syswm.h>
 #include "WinSystemX11.h"
 #include "settings/DisplaySettings.h"
 #include "settings/Settings.h"
@@ -33,27 +32,30 @@
 #include "XRandR.h"
 #include <vector>
 #include "threads/SingleLock.h"
-#include <X11/Xlib.h>
 #include "cores/VideoRenderers/RenderManager.h"
 #include "utils/TimeUtils.h"
+#include "settings/GUISettings.h"
 
 #if defined(HAS_XRANDR)
 #include <X11/extensions/Xrandr.h>
 #endif
 
+#include "../WinEvents.h"
+#include "input/MouseStat.h"
+
 using namespace std;
 
 CWinSystemX11::CWinSystemX11() : CWinSystemBase()
 {
   m_eWindowSystem = WINDOW_SYSTEM_X11;
   m_glContext = NULL;
-  m_SDLSurface = NULL;
   m_dpy = NULL;
   m_glWindow = 0;
-  m_wmWindow = 0;
   m_bWasFullScreenBeforeMinimize = false;
   m_minimized = false;
+  m_bIgnoreNextFocusMessage = false;
   m_dpyLostTime = 0;
+  m_invisibleCursor = 0;
 
   XSetErrorHandler(XErrorHandler);
 }
@@ -66,18 +68,6 @@ bool CWinSystemX11::InitWindowSystem()
 {
   if ((m_dpy = XOpenDisplay(NULL)))
   {
-
-    SDL_EnableUNICODE(1);
-    // set repeat to 10ms to ensure repeat time < frame time
-    // so that hold times can be reliably detected
-    SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY, 10);
-
-    SDL_GL_SetAttribute(SDL_GL_RED_SIZE,   8);
-    SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);
-    SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE,  8);
-    SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8);
-    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
-
     return CWinSystemBase::InitWindowSystem();
   }
   else
@@ -115,45 +105,37 @@ bool CWinSystemX11::DestroyWindowSystem()
 
 bool CWinSystemX11::CreateNewWindow(const CStdString& name, bool fullScreen, RESOLUTION_INFO& res, PHANDLE_EVENT_FUNC userFunction)
 {
-  RESOLUTION_INFO& desktop = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP);
-
-  if (fullScreen &&
-      (res.iWidth != desktop.iWidth || res.iHeight != desktop.iHeight ||
-       res.fRefreshRate != desktop.fRefreshRate || res.iScreen != desktop.iScreen))
-  {
-    //on the first call to SDL_SetVideoMode, SDL stores the current displaymode
-    //SDL restores the displaymode on SDL_QUIT(), if we change the displaymode
-    //before the first call to SDL_SetVideoMode, SDL changes the displaymode back
-    //to the wrong mode on exit
-
-    CLog::Log(LOGINFO, "CWinSystemX11::CreateNewWindow initializing to desktop resolution first");
-    if (!SetFullScreen(true, desktop, false))
-      return false;
-  }
-
   if(!SetFullScreen(fullScreen, res, false))
     return false;
 
-  CBaseTexture* iconTexture = CTexture::LoadFromFile("special://xbmc/media/icon.png");
-
-  if (iconTexture)
-    SDL_WM_SetIcon(SDL_CreateRGBSurfaceFrom(iconTexture->GetPixels(), iconTexture->GetWidth(), iconTexture->GetHeight(), 32, iconTexture->GetPitch(), 0xff0000, 0x00ff00, 0x0000ff, 0xff000000L), NULL);
-  SDL_WM_SetCaption("XBMC Media Center", NULL);
-  delete iconTexture;
-
-  // register XRandR Events
-#if defined(HAS_XRANDR)
-  int iReturn;
-  XRRQueryExtension(m_dpy, &m_RREventBase, &iReturn);
-  XRRSelectInput(m_dpy, m_wmWindow, RRScreenChangeNotifyMask);
-#endif
-
   m_bWindowCreated = true;
   return true;
 }
 
 bool CWinSystemX11::DestroyWindow()
 {
+  if (!m_glWindow)
+    return true;
+
+  if (m_glContext)
+    glXMakeCurrent(m_dpy, None, NULL);
+
+  if (m_invisibleCursor)
+  {
+    XUndefineCursor(m_dpy, m_glWindow);
+    XFreeCursor(m_dpy, m_invisibleCursor);
+    m_invisibleCursor = 0;
+  }
+
+  CWinEvents::Quit();
+
+  XUnmapWindow(m_dpy, m_glWindow);
+  XSync(m_dpy,TRUE);
+  XUngrabKeyboard(m_dpy, CurrentTime);
+  XUngrabPointer(m_dpy, CurrentTime);
+  XDestroyWindow(m_dpy, m_glWindow);
+  m_glWindow = 0;
+
   return true;
 }
 
@@ -163,65 +145,105 @@ bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int n
   && m_nHeight == newHeight)
     return true;
 
+  if (!SetWindow(newWidth, newHeight, false))
+  {
+    return false;
+  }
+
+  RefreshGlxContext();
   m_nWidth  = newWidth;
   m_nHeight = newHeight;
+  m_bFullScreen = false;
 
-  int options = SDL_OPENGL;
-  if (m_bFullScreen)
-    options |= SDL_FULLSCREEN;
-  else
-    options |= SDL_RESIZABLE;
+  return false;
+}
+
+void CWinSystemX11::RefreshWindow()
+{
+  g_xrandr.Query(true);
+  XOutput out  = g_xrandr.GetCurrentOutput();
+  XMode   mode = g_xrandr.GetCurrentMode(out.name);
 
-  if ((m_SDLSurface = SDL_SetVideoMode(m_nWidth, m_nHeight, 0, options)))
+  // only overwrite desktop resolution, if we are not in fullscreen mode
+  if (!g_graphicsContext.IsFullScreenVideo())
   {
-    RefreshGlxContext();
-    return true;
+    CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshWindow - store desktop resolution, width: %d, height: %d, hz: %2.2f", mode.w, mode.h, mode.hz);
+    UpdateDesktopResolution(g_settings.m_ResInfo[RES_DESKTOP], 0, mode.w, mode.h, mode.hz);
+    g_settings.m_ResInfo[RES_DESKTOP].strId     = mode.id;
+    g_settings.m_ResInfo[RES_DESKTOP].strOutput = out.name;
   }
 
-  return false;
+  RESOLUTION_INFO res;
+  unsigned int i;
+  bool found(false);
+  for (i = RES_DESKTOP; i < g_settings.m_ResInfo.size(); ++i)
+  {
+    if (g_settings.m_ResInfo[i].strId == mode.id)
+    {
+      found = true;
+      break;
+    }
+  }
+
+  if (!found)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::RefreshWindow - could not find resolution");
+    return;
+  }
+
+  if (g_graphicsContext.IsFullScreenRoot())
+    g_graphicsContext.SetVideoResolution((RESOLUTION)i, true);
+  else
+    g_graphicsContext.SetVideoResolution(RES_WINDOW, true);
 }
 
 bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
 {
-  m_nWidth      = res.iWidth;
-  m_nHeight     = res.iHeight;
-  m_bFullScreen = fullScreen;
 
 #if defined(HAS_XRANDR)
   XOutput out;
   XMode mode;
-  out.name = res.strOutput;
-  mode.w   = res.iWidth;
-  mode.h   = res.iHeight;
-  mode.hz  = res.fRefreshRate;
-  mode.id  = res.strId;
+
+  if (fullScreen)
+  {
+    out.name = res.strOutput;
+    mode.w   = res.iWidth;
+    mode.h   = res.iHeight;
+    mode.hz  = res.fRefreshRate;
+    mode.id  = res.strId;
+  }
+  else
+  {
+    out.name = g_settings.m_ResInfo[RES_DESKTOP].strOutput;
+    mode.w   = g_settings.m_ResInfo[RES_DESKTOP].iWidth;
+    mode.h   = g_settings.m_ResInfo[RES_DESKTOP].iHeight;
+    mode.hz  = g_settings.m_ResInfo[RES_DESKTOP].fRefreshRate;
+    mode.id  = g_settings.m_ResInfo[RES_DESKTOP].strId;
+  }
  
-  if(m_bFullScreen)
+  XOutput currout  = g_xrandr.GetCurrentOutput();
+  XMode   currmode = g_xrandr.GetCurrentMode(currout.name);
+
+  // only call xrandr if mode changes
+  if (currout.name != out.name || currmode.w != mode.w || currmode.h != mode.h ||
+      currmode.hz != mode.hz || currmode.id != mode.id)
   {
+    CLog::Log(LOGNOTICE, "CWinSystemX11::SetFullScreen - calling xrandr");
     OnLostDevice();
     g_xrandr.SetMode(out, mode);
   }
-  else
-    g_xrandr.RestoreState();
 #endif
 
-  int options = SDL_OPENGL;
-  if (m_bFullScreen)
-    options |= SDL_FULLSCREEN;
-  else
-    options |= SDL_RESIZABLE;
-
-  if ((m_SDLSurface = SDL_SetVideoMode(m_nWidth, m_nHeight, 0, options)))
-  {
-    if ((m_SDLSurface->flags & SDL_OPENGL) != SDL_OPENGL)
-      CLog::Log(LOGERROR, "CWinSystemX11::SetFullScreen SDL_OPENGL not set, SDL_GetError:%s", SDL_GetError());
+  if (!SetWindow(res.iWidth, res.iHeight, fullScreen))
+    return false;
 
-    RefreshGlxContext();
+  RefreshGlxContext();
 
-    return true;
-  }
+  m_nWidth      = res.iWidth;
+  m_nHeight     = res.iHeight;
+  m_bFullScreen = fullScreen;
 
-  return false;
+  return true;
 }
 
 void CWinSystemX11::UpdateResolutions()
@@ -323,17 +345,10 @@ bool CWinSystemX11::IsSuitableVisual(XVisualInfo *vInfo)
 bool CWinSystemX11::RefreshGlxContext()
 {
   bool retVal = false;
-  SDL_SysWMinfo info;
-  SDL_VERSION(&info.version);
-  if (SDL_GetWMInfo(&info) <= 0)
-  {
-    CLog::Log(LOGERROR, "Failed to get window manager info from SDL");
-    return false;
-  }
 
-  if(m_glWindow == info.info.x11.window && m_glContext)
+  if (m_glContext)
   {
-    CLog::Log(LOGERROR, "GLX: Same window as before, refreshing context");
+    CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshGlxContext: refreshing context");
     glXMakeCurrent(m_dpy, None, NULL);
     glXMakeCurrent(m_dpy, m_glWindow, m_glContext);
     return true;
@@ -345,8 +360,6 @@ bool CWinSystemX11::RefreshGlxContext()
   int availableVisuals    = 0;
   vMask.screen = DefaultScreen(m_dpy);
   XWindowAttributes winAttr;
-  m_glWindow = info.info.x11.window;
-  m_wmWindow = info.info.x11.wmwindow;
 
   /* Assume a depth of 24 in case the below calls to XGetWindowAttributes()
      or XGetVisualInfo() fail. That shouldn't happen unless something is
@@ -417,7 +430,10 @@ bool CWinSystemX11::RefreshGlxContext()
 
 void CWinSystemX11::ShowOSMouse(bool show)
 {
-  SDL_ShowCursor(show ? 1 : 0);
+  if (show)
+    XUndefineCursor(m_dpy,m_glWindow);
+  else if (m_invisibleCursor)
+    XDefineCursor(m_dpy,m_glWindow, m_invisibleCursor);
 }
 
 void CWinSystemX11::ResetOSScreensaver()
@@ -431,8 +447,6 @@ void CWinSystemX11::ResetOSScreensaver()
     {
       m_screensaverReset.StartZero();
       XResetScreenSaver(m_dpy);
-      //need to flush the output buffer, since we don't check for events on m_dpy
-      XFlush(m_dpy);
     }
   }
   else
@@ -448,13 +462,27 @@ void CWinSystemX11::NotifyAppActiveChange(bool bActivated)
 
   m_minimized = !bActivated;
 }
+
+void CWinSystemX11::NotifyAppFocusChange(bool bGaining)
+{
+  if (bGaining && m_bWasFullScreenBeforeMinimize && !m_bIgnoreNextFocusMessage &&
+      !g_graphicsContext.IsFullScreenRoot())
+    g_graphicsContext.ToggleFullScreenRoot();
+  if (!bGaining)
+    m_bIgnoreNextFocusMessage = false;
+}
+
 bool CWinSystemX11::Minimize()
 {
   m_bWasFullScreenBeforeMinimize = g_graphicsContext.IsFullScreenRoot();
   if (m_bWasFullScreenBeforeMinimize)
+  {
+    m_bIgnoreNextFocusMessage = true;
     g_graphicsContext.ToggleFullScreenRoot();
+  }
+
+  XIconifyWindow(m_dpy, m_glWindow, DefaultScreen(m_dpy));
 
-  SDL_WM_IconifyWindow();
   m_minimized = true;
   return true;
 }
@@ -464,13 +492,13 @@ bool CWinSystemX11::Restore()
 }
 bool CWinSystemX11::Hide()
 {
-  XUnmapWindow(m_dpy, m_wmWindow);
+  XUnmapWindow(m_dpy, m_glWindow);
   XSync(m_dpy, False);
   return true;
 }
 bool CWinSystemX11::Show(bool raise)
 {
-  XMapWindow(m_dpy, m_wmWindow);
+  XMapWindow(m_dpy, m_glWindow);
   XSync(m_dpy, False);
   m_minimized = false;
   return true;
@@ -502,6 +530,7 @@ void CWinSystemX11::CheckDisplayEvents()
   if (bGotEvent || bTimeout)
   {
     CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
+    RefreshWindow();
 
     CSingleLock lock(m_resourceSection);
 
@@ -560,4 +589,151 @@ bool CWinSystemX11::EnableFrameLimiter()
   return m_minimized;
 }
 
+bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen)
+{
+  bool changeWindow = false;
+  bool changeSize = false;
+  bool mouseActive = false;
+  float mouseX, mouseY;
+
+  if (m_glWindow && (m_bFullScreen != fullscreen))
+  {
+    mouseActive = g_Mouse.IsActive();
+    if (mouseActive)
+    {
+      Window root_return, child_return;
+      int root_x_return, root_y_return;
+      int win_x_return, win_y_return;
+      unsigned int mask_return;
+      bool isInWin = XQueryPointer(m_dpy, m_glWindow, &root_return, &child_return,
+                                   &root_x_return, &root_y_return,
+                                   &win_x_return, &win_y_return,
+                                   &mask_return);
+      if (isInWin)
+      {
+        mouseX = (float)win_x_return/m_nWidth;
+        mouseY = (float)win_y_return/m_nHeight;
+        g_Mouse.SetActive(false);
+      }
+      else
+        mouseActive = false;
+    }
+    DestroyWindow();
+  }
+
+  // create main window
+  if (!m_glWindow)
+  {
+    GLint att[] =
+    {
+      GLX_RGBA,
+      GLX_RED_SIZE, 8,
+      GLX_GREEN_SIZE, 8,
+      GLX_BLUE_SIZE, 8,
+      GLX_ALPHA_SIZE, 8,
+      GLX_DEPTH_SIZE, 24,
+      GLX_DOUBLEBUFFER,
+      None
+    };
+    Colormap cmap;
+    XSetWindowAttributes swa;
+    XVisualInfo *vi;
+
+    vi = glXChooseVisual(m_dpy, DefaultScreen(m_dpy), att);
+    cmap = XCreateColormap(m_dpy, RootWindow(m_dpy, vi->screen), vi->visual, AllocNone);
+
+    int def_vis = (vi->visual == DefaultVisual(m_dpy, vi->screen));
+    swa.override_redirect = fullscreen ? True : False;
+    swa.border_pixel = fullscreen ? 0 : 5;
+    swa.background_pixel = def_vis ? BlackPixel(m_dpy, vi->screen) : 0;
+    swa.colormap = cmap;
+    swa.background_pixel = def_vis ? BlackPixel(m_dpy, vi->screen) : 0;
+    swa.event_mask = FocusChangeMask | KeyPressMask | KeyReleaseMask |
+                     ButtonPressMask | ButtonReleaseMask | PointerMotionMask |
+                     PropertyChangeMask | StructureNotifyMask | KeymapStateMask |
+                     EnterWindowMask | LeaveWindowMask | ExposureMask;
+    unsigned long mask = CWBackPixel | CWBorderPixel | CWColormap | CWOverrideRedirect | CWEventMask;
+
+    m_glWindow = XCreateWindow(m_dpy, RootWindow(m_dpy, vi->screen),
+                    0, 0, width, height, 0, vi->depth,
+                    InputOutput, vi->visual,
+                    mask, &swa);
+
+    // define invisible cursor
+    Pixmap bitmapNoData;
+    XColor black;
+    static char noData[] = { 0,0,0,0,0,0,0,0 };
+    black.red = black.green = black.blue = 0;
+
+    bitmapNoData = XCreateBitmapFromData(m_dpy, m_glWindow, noData, 8, 8);
+    m_invisibleCursor = XCreatePixmapCursor(m_dpy, bitmapNoData, bitmapNoData,
+                                            &black, &black, 0, 0);
+    XFreePixmap(m_dpy, bitmapNoData);
+    XDefineCursor(m_dpy,m_glWindow, m_invisibleCursor);
+
+    //init X11 events
+    CWinEvents::Init(m_dpy, m_glWindow);
+
+    changeWindow = true;
+    changeSize = true;
+  }
+
+  if (!CWinEvents::HasStructureChanged() && ((width != m_nWidth) || (height != m_nHeight)))
+  {
+    changeSize = true;
+  }
+
+  if (changeSize || changeWindow)
+  {
+    XResizeWindow(m_dpy, m_glWindow, width, height);
+  }
+
+  if (changeWindow)
+  {
+    if (!fullscreen)
+    {
+      XWMHints wm_hints;
+      XClassHint class_hints;
+      XTextProperty windowName, iconName;
+      std::string titleString = "XBMC Media Center";
+      char *title = (char*)titleString.c_str();
+
+      XStringListToTextProperty(&title, 1, &windowName);
+      XStringListToTextProperty(&title, 1, &iconName);
+      wm_hints.initial_state = NormalState;
+      wm_hints.input = True;
+      wm_hints.icon_pixmap = None;
+      wm_hints.flags = StateHint | IconPixmapHint | InputHint;
+
+      XSetWMProperties(m_dpy, m_glWindow, &windowName, &iconName,
+                            NULL, 0, NULL, &wm_hints,
+                            NULL);
+
+      // register interest in the delete window message
+      Atom wmDeleteMessage = XInternAtom(m_dpy, "WM_DELETE_WINDOW", False);
+      XSetWMProtocols(m_dpy, m_glWindow, &wmDeleteMessage, 1);
+    }
+    XMapRaised(m_dpy, m_glWindow);
+    XSync(m_dpy,TRUE);
+
+    if (changeWindow && mouseActive)
+    {
+      XWarpPointer(m_dpy, None, m_glWindow, 0, 0, 0, 0, mouseX*width, mouseY*height);
+    }
+
+    if (fullscreen)
+    {
+      int result = -1;
+      while (result != GrabSuccess)
+      {
+        result = XGrabPointer(m_dpy, m_glWindow, True, ButtonPressMask, GrabModeAsync, GrabModeAsync, m_glWindow, None, CurrentTime);
+        XbmcThreads::ThreadSleep(100);
+      }
+      XGrabKeyboard(m_dpy, m_glWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
+
+    }
+  }
+  return true;
+}
+
 #endif
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 3dae22c..25faaef 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -52,6 +52,7 @@ class CWinSystemX11 : public CWinSystemBase
   virtual bool EnableFrameLimiter();
 
   virtual void NotifyAppActiveChange(bool bActivated);
+  virtual void NotifyAppFocusChange(bool bGaining);
 
   virtual bool Minimize();
   virtual bool Restore() ;
@@ -64,19 +65,21 @@ class CWinSystemX11 : public CWinSystemBase
   Display*  GetDisplay() { return m_dpy; }
   GLXWindow GetWindow() { return m_glWindow; }
   GLXContext GetGlxContext() { return m_glContext; }
+  void RefreshWindow();
 
 protected:
   bool RefreshGlxContext();
   void CheckDisplayEvents();
   void OnLostDevice();
+  bool SetWindow(int width, int height, bool fullscreen);
 
-  SDL_Surface* m_SDLSurface;
+  Window       m_glWindow;
   GLXContext   m_glContext;
-  GLXWindow    m_glWindow;
-  Window       m_wmWindow;
   Display*     m_dpy;
+  Cursor       m_invisibleCursor;
   bool         m_bWasFullScreenBeforeMinimize;
   bool         m_minimized;
+  bool         m_bIgnoreNextFocusMessage;
   int          m_RREventBase;
   CCriticalSection             m_resourceSection;
   std::vector<IDispResource*>  m_resources;
-- 
1.8.1.6


From 9f772616412e5bc3a72e2d56ed5ae6ccc7264693 Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 15:24:22 +0200
Subject: [PATCH 042/123] X11: Add xbmc icon

---
 xbmc/windowing/X11/WinSystemX11.cpp | 126 +++++++++++++++++++++++++++++++++++-
 xbmc/windowing/X11/WinSystemX11.h   |   2 +
 2 files changed, 127 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 68e482e..9ee8d18 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -136,6 +136,9 @@ bool CWinSystemX11::DestroyWindow()
   XDestroyWindow(m_dpy, m_glWindow);
   m_glWindow = 0;
 
+  if (m_icon)
+    XFreePixmap(m_dpy, m_icon);
+
   return true;
 }
 
@@ -690,8 +693,10 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen)
 
   if (changeWindow)
   {
+    m_icon = None;
     if (!fullscreen)
     {
+      CreateIconPixmap();
       XWMHints wm_hints;
       XClassHint class_hints;
       XTextProperty windowName, iconName;
@@ -702,7 +707,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen)
       XStringListToTextProperty(&title, 1, &iconName);
       wm_hints.initial_state = NormalState;
       wm_hints.input = True;
-      wm_hints.icon_pixmap = None;
+      wm_hints.icon_pixmap = m_icon;
       wm_hints.flags = StateHint | IconPixmapHint | InputHint;
 
       XSetWMProperties(m_dpy, m_glWindow, &windowName, &iconName,
@@ -736,4 +741,123 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen)
   return true;
 }
 
+bool CWinSystemX11::CreateIconPixmap()
+{
+  int depth;
+  XImage *img = NULL;
+  Visual *vis;
+  XWindowAttributes wndattribs;
+  XVisualInfo visInfo;
+  double rRatio;
+  double gRatio;
+  double bRatio;
+  int outIndex = 0;
+  int i,j;
+  int numBufBytes;
+  unsigned char *buf;
+  uint32_t *newBuf = 0;
+  size_t numNewBufBytes;
+
+  // Get visual Info
+  XGetWindowAttributes(m_dpy, m_glWindow, &wndattribs);
+  visInfo.visualid = wndattribs.visual->visualid;
+  int nvisuals = 0;
+  XVisualInfo* visuals = XGetVisualInfo(m_dpy, VisualIDMask, &visInfo, &nvisuals);
+  if (nvisuals != 1)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - could not find visual");
+    return false;
+  }
+  visInfo = visuals[0];
+  XFree(visuals);
+
+  depth = visInfo.depth;
+  vis = visInfo.visual;
+
+  if (depth < 15)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - no suitable depth");
+    return false;
+  }
+
+  rRatio = vis->red_mask / 255.0;
+  gRatio = vis->green_mask / 255.0;
+  bRatio = vis->blue_mask / 255.0;
+
+  CTexture iconTexture;
+  iconTexture.LoadFromFile("special://xbmc/media/icon.png");
+  buf = iconTexture.GetPixels();
+
+  numBufBytes = iconTexture.GetWidth() * iconTexture.GetHeight() * 4;
+
+  if (depth>=24)
+    numNewBufBytes = (4 * (iconTexture.GetWidth() * iconTexture.GetHeight()));
+  else
+    numNewBufBytes = (2 * (iconTexture.GetWidth() * iconTexture.GetHeight()));
+
+  newBuf = (uint32_t*)malloc(numNewBufBytes);
+  if (!newBuf)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - malloc failed");
+    return false;
+  }
+
+  for (i=0; i<iconTexture.GetHeight();++i)
+  {
+    for (j=0; j<iconTexture.GetWidth();++j)
+    {
+      unsigned int pos = i*iconTexture.GetPitch()+j*4;
+      unsigned int r, g, b;
+      r = (buf[pos+2] * rRatio);
+      g = (buf[pos+1] * gRatio);
+      b = (buf[pos+0] * bRatio);
+      r &= vis->red_mask;
+      g &= vis->green_mask;
+      b &= vis->blue_mask;
+      newBuf[outIndex] = r | g | b;
+      ++outIndex;
+    }
+  }
+  img = XCreateImage(m_dpy, vis, depth,ZPixmap, 0, (char *)newBuf,
+                     iconTexture.GetWidth(), iconTexture.GetHeight(),
+                     (depth>=24)?32:16, 0);
+  if (!img)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - could not create image");
+    free(newBuf);
+    return false;
+  }
+  if (!XInitImage(img))
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::CreateIconPixmap - init image failed");
+    XDestroyImage(img);
+    return false;
+  }
+
+  // set byte order
+  union
+  {
+    char c[sizeof(short)];
+    short s;
+  } order;
+  order.s = 1;
+  if ((1 == order.c[0]))
+  {
+    img->byte_order = LSBFirst;
+  }
+  else
+  {
+    img->byte_order = MSBFirst;
+  }
+
+  // create icon pixmap from image
+  m_icon = XCreatePixmap(m_dpy, m_glWindow, img->width, img->height, depth);
+  GC gc = XCreateGC(m_dpy, m_glWindow, 0, NULL);
+  XPutImage(m_dpy, m_icon, gc, img, 0, 0, 0, 0, img->width, img->height);
+  XFreeGC(m_dpy, gc);
+  XDestroyImage(img); // this also frees newBuf
+
+  return true;
+}
+
 #endif
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 25faaef..c1e6cf1 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -77,6 +77,7 @@ class CWinSystemX11 : public CWinSystemBase
   GLXContext   m_glContext;
   Display*     m_dpy;
   Cursor       m_invisibleCursor;
+  Pixmap       m_icon;
   bool         m_bWasFullScreenBeforeMinimize;
   bool         m_minimized;
   bool         m_bIgnoreNextFocusMessage;
@@ -88,6 +89,7 @@ class CWinSystemX11 : public CWinSystemBase
 private:
   bool IsSuitableVisual(XVisualInfo *vInfo);
   static int XErrorHandler(Display* dpy, XErrorEvent* error);
+  bool CreateIconPixmap();
 
   CStopWatch m_screensaverReset;
 };
-- 
1.8.1.6


From c3a5e18e21191c785d31fecd9013f25bdada062d Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 20 May 2012 14:11:26 +0200
Subject: [PATCH 043/123] X11: add SDL joystick until we have a better solution

---
 xbmc/windowing/WinEventsX11.cpp | 26 ++++++++++++++++++++++++++
 1 file changed, 26 insertions(+)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index 5a8bbb8..5bc1de0 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -35,6 +35,10 @@
 #include "guilib/GUIWindowManager.h"
 #include "input/MouseStat.h"
 
+#ifdef HAS_SDL_JOYSTICK
+#include "input/SDLJoystick.h"
+#endif
+
 CWinEventsX11* CWinEventsX11::WinEvents = 0;
 
 static uint32_t SymMappingsX11[][2] =
@@ -547,6 +551,28 @@ bool CWinEventsX11::MessagePump()
 
   ret |= ProcessKeyRepeat();
 
+#ifdef HAS_SDL_JOYSTICK
+  SDL_Event event;
+  while (SDL_PollEvent(&event))
+  {
+    switch(event.type)
+    {
+      case SDL_JOYBUTTONUP:
+      case SDL_JOYBUTTONDOWN:
+      case SDL_JOYAXISMOTION:
+      case SDL_JOYBALLMOTION:
+      case SDL_JOYHATMOTION:
+        g_Joystick.Update(event);
+        ret = true;
+        break;
+
+      default:
+        break;
+    }
+    memset(&event, 0, sizeof(SDL_Event));
+  }
+#endif
+
   return ret;
 }
 
-- 
1.8.1.6


From cedafa3581d7893778c46473b32c90cde9306e9f Mon Sep 17 00:00:00 2001
From: Joakim Plate <elupus@xbmc.org>
Date: Thu, 5 Jul 2012 12:35:55 +0200
Subject: [PATCH 044/123] X11: factor out code handling device reset
 notification

---
 xbmc/windowing/X11/WinSystemX11.cpp | 22 ++++++++++++++--------
 xbmc/windowing/X11/WinSystemX11.h   |  1 +
 2 files changed, 15 insertions(+), 8 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 9ee8d18..fd51dc0 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -532,14 +532,7 @@ void CWinSystemX11::CheckDisplayEvents()
 
   if (bGotEvent || bTimeout)
   {
-    CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
-    RefreshWindow();
-
-    CSingleLock lock(m_resourceSection);
-
-    // tell any shared resources
-    for (vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); i++)
-      (*i)->OnResetDevice();
+    NotifyXRREvent();
 
     // reset fail safe timer
     m_dpyLostTime = 0;
@@ -547,6 +540,19 @@ void CWinSystemX11::CheckDisplayEvents()
 #endif
 }
 
+void CWinSystemX11::NotifyXRREvent()
+{
+  CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
+  RefreshWindow();
+
+  CSingleLock lock(m_resourceSection);
+
+  // tell any shared resources
+  for (vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); i++)
+    (*i)->OnResetDevice();
+
+}
+
 void CWinSystemX11::OnLostDevice()
 {
   CLog::Log(LOGDEBUG, "%s - notify display change event", __FUNCTION__);
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index c1e6cf1..041ea55 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -66,6 +66,7 @@ class CWinSystemX11 : public CWinSystemBase
   GLXWindow GetWindow() { return m_glWindow; }
   GLXContext GetGlxContext() { return m_glContext; }
   void RefreshWindow();
+  void NotifyXRREvent();
 
 protected:
   bool RefreshGlxContext();
-- 
1.8.1.6


From a6d829d266bc04a52e8340aa2e2ea79e2e258070 Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 15:02:00 +0200
Subject: [PATCH 045/123] X11: move xrandr events to WinEventsX11

---
 xbmc/windowing/WinEventsX11.cpp     | 42 +++++++++++++++++++++++++++++++++++++
 xbmc/windowing/WinEventsX11.h       |  5 +++++
 xbmc/windowing/X11/WinSystemX11.cpp |  6 +++++-
 3 files changed, 52 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index 5bc1de0..d9dc911 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -35,6 +35,10 @@
 #include "guilib/GUIWindowManager.h"
 #include "input/MouseStat.h"
 
+#if defined(HAS_XRANDR)
+#include <X11/extensions/Xrandr.h>
+#endif
+
 #ifdef HAS_SDL_JOYSTICK
 #include "input/SDLJoystick.h"
 #endif
@@ -203,6 +207,7 @@ bool CWinEventsX11::Init(Display *dpy, Window win)
   WinEvents->m_keymodState = 0;
   WinEvents->m_wmDeleteMessage = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
   WinEvents->m_structureChanged = false;
+  WinEvents->m_xrrEventPending = false;
   memset(&(WinEvents->m_lastKey), 0, sizeof(XBMC_Event));
 
   // open input method
@@ -266,6 +271,13 @@ bool CWinEventsX11::Init(Display *dpy, Window win)
     WinEvents->m_symLookupTable[SymMappingsX11[i][0]] = SymMappingsX11[i][1];
   }
 
+  // register for xrandr events
+#if defined(HAS_XRANDR)
+  int iReturn;
+  XRRQueryExtension(WinEvents->m_display, &WinEvents->m_RREventBase, &iReturn);
+  XRRSelectInput(WinEvents->m_display, WinEvents->m_window, RRScreenChangeNotifyMask);
+#endif
+
   return true;
 }
 
@@ -288,6 +300,15 @@ bool CWinEventsX11::HasStructureChanged()
   return ret;
 }
 
+void CWinEventsX11::SetXRRFailSafeTimer(int millis)
+{
+  if (!WinEvents)
+    return;
+
+  WinEvents->m_xrrFailSafeTimer.Set(millis);
+  WinEvents->m_xrrEventPending = true;
+}
+
 bool CWinEventsX11::MessagePump()
 {
   if (!WinEvents)
@@ -547,10 +568,31 @@ bool CWinEventsX11::MessagePump()
         break;
       }
     }// switch event.type
+
+#if defined(HAS_XRANDR)
+    if (WinEvents && (xevent.type == WinEvents->m_RREventBase + RRScreenChangeNotify))
+    {
+      XRRUpdateConfiguration(&xevent);
+      if (xevent.xgeneric.serial != serial)
+        g_Windowing.NotifyXRREvent();
+      WinEvents->m_xrrEventPending = false;
+      serial = xevent.xgeneric.serial;
+    }
+#endif
+
   }// while
 
   ret |= ProcessKeyRepeat();
 
+#if defined(HAS_XRANDR)
+  if (WinEvents && WinEvents->m_xrrEventPending && WinEvents->m_xrrFailSafeTimer.IsTimePast())
+  {
+    CLog::Log(LOGERROR,"CWinEventsX11::MessagePump - missed XRR Events");
+    g_Windowing.NotifyXRREvent();
+    WinEvents->m_xrrEventPending = false;
+  }
+#endif
+
 #ifdef HAS_SDL_JOYSTICK
   SDL_Event event;
   while (SDL_PollEvent(&event))
diff --git a/xbmc/windowing/WinEventsX11.h b/xbmc/windowing/WinEventsX11.h
index e9b7553..6100933 100644
--- a/xbmc/windowing/WinEventsX11.h
+++ b/xbmc/windowing/WinEventsX11.h
@@ -33,6 +33,8 @@ class CWinEventsX11 : public CWinEventsBase
   static bool Init(Display *dpy, Window win);
   static void Quit();
   static bool HasStructureChanged();
+  static void PendingResize(int width, int height);
+  static void SetXRRFailSafeTimer(int millis);
   static bool MessagePump();
 
 protected:
@@ -54,4 +56,7 @@ class CWinEventsX11 : public CWinEventsBase
   std::map<uint32_t,uint32_t> m_symLookupTable;
   int m_keymodState;
   bool m_structureChanged;
+  int m_RREventBase;
+  XbmcThreads::EndTime m_xrrFailSafeTimer;
+  bool m_xrrEventPending;
 };
diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index fd51dc0..d495443 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -509,7 +509,7 @@ bool CWinSystemX11::Show(bool raise)
 
 void CWinSystemX11::CheckDisplayEvents()
 {
-#if defined(HAS_XRANDR)
+#if defined(HAS_XRANDR) && defined(HAS_SDL_VIDEO_X11)
   bool bGotEvent(false);
   bool bTimeout(false);
   XEvent Event;
@@ -565,8 +565,12 @@ void CWinSystemX11::OnLostDevice()
       (*i)->OnLostDevice();
   }
 
+#if defined(HAS_SDL_VIDEO_X11)
   // fail safe timer
   m_dpyLostTime = CurrentHostCounter();
+#else
+  CWinEvents::SetXRRFailSafeTimer(3000);
+#endif
 }
 
 void CWinSystemX11::Register(IDispResource *resource)
-- 
1.8.1.6


From b8c92d9d5a2c7cbf6315d9a04be99d6501de7fe9 Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 12 Apr 2012 15:43:56 +0200
Subject: [PATCH 046/123] xrandr: remove method RestoreState

---
 xbmc/windowing/X11/WinSystemX11.cpp | 13 +++++++++++--
 xbmc/windowing/X11/XRandR.cpp       | 19 -------------------
 xbmc/windowing/X11/XRandR.h         |  1 -
 3 files changed, 11 insertions(+), 22 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index d495443..d7afc3f 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -79,9 +79,18 @@ bool CWinSystemX11::InitWindowSystem()
 bool CWinSystemX11::DestroyWindowSystem()
 {
 #if defined(HAS_XRANDR)
-  //restore videomode on exit
+  //restore desktop resolution on exit
   if (m_bFullScreen)
-    g_xrandr.RestoreState();
+  {
+    XOutput out;
+    XMode mode;
+    out.name = g_settings.m_ResInfo[RES_DESKTOP].strOutput;
+    mode.w   = g_settings.m_ResInfo[RES_DESKTOP].iWidth;
+    mode.h   = g_settings.m_ResInfo[RES_DESKTOP].iHeight;
+    mode.hz  = g_settings.m_ResInfo[RES_DESKTOP].fRefreshRate;
+    mode.id  = g_settings.m_ResInfo[RES_DESKTOP].strId;
+    g_xrandr.SetMode(out, mode);
+  }
 #endif
 
   if (m_dpy)
diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index 30c1909..b4c95f8 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -139,25 +139,6 @@ void CXRandR::SaveState()
   Query(true);
 }
 
-void CXRandR::RestoreState()
-{
-  vector<XOutput>::iterator outiter;
-  for (outiter=m_current.begin() ; outiter!=m_current.end() ; outiter++)
-  {
-    vector<XMode> modes = (*outiter).modes;
-    vector<XMode>::iterator modeiter;
-    for (modeiter=modes.begin() ; modeiter!=modes.end() ; modeiter++)
-    {
-      XMode mode = *modeiter;
-      if (mode.isCurrent)
-      {
-        SetMode(*outiter, mode);
-        return;
-      }
-    }
-  }
-}
-
 bool CXRandR::SetMode(XOutput output, XMode mode)
 {
   if ((output.name == m_currentOutput && mode.id == m_currentMode) || (output.name == "" && mode.id == ""))
diff --git a/xbmc/windowing/X11/XRandR.h b/xbmc/windowing/X11/XRandR.h
index e3450fe..cf22fbf 100644
--- a/xbmc/windowing/X11/XRandR.h
+++ b/xbmc/windowing/X11/XRandR.h
@@ -99,7 +99,6 @@ class CXRandR
   bool SetMode(XOutput output, XMode mode);
   void LoadCustomModeLinesToAllOutputs(void);
   void SaveState();
-  void RestoreState();
   //bool Has1080i();
   //bool Has1080p();
   //bool Has720p();
-- 
1.8.1.6


From 3715129c3cbfcf14b49f28e1721b4d869a370de3 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 20 May 2012 13:17:10 +0200
Subject: [PATCH 047/123] xrandr: observe orientation

---
 xbmc/windowing/X11/WinSystemX11.cpp | 89 ++++++++++++++++++++++++++++++-------
 xbmc/windowing/X11/WinSystemX11.h   |  2 +
 xbmc/windowing/X11/XRandR.cpp       |  7 +++
 xbmc/windowing/X11/XRandR.h         |  1 +
 4 files changed, 82 insertions(+), 17 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index d7afc3f..6b320f2 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -84,11 +84,11 @@ bool CWinSystemX11::DestroyWindowSystem()
   {
     XOutput out;
     XMode mode;
-    out.name = g_settings.m_ResInfo[RES_DESKTOP].strOutput;
-    mode.w   = g_settings.m_ResInfo[RES_DESKTOP].iWidth;
-    mode.h   = g_settings.m_ResInfo[RES_DESKTOP].iHeight;
-    mode.hz  = g_settings.m_ResInfo[RES_DESKTOP].fRefreshRate;
-    mode.id  = g_settings.m_ResInfo[RES_DESKTOP].strId;
+    out.name = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput;
+    mode.w   = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).iWidth;
+    mode.h   = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).iHeight;
+    mode.hz  = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).fRefreshRate;
+    mode.id  = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId;
     g_xrandr.SetMode(out, mode);
   }
 #endif
@@ -172,25 +172,34 @@ bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int n
 
 void CWinSystemX11::RefreshWindow()
 {
-  g_xrandr.Query(true);
+  if (!g_xrandr.Query(true))
+  {
+    CLog::Log(LOGERROR, "WinSystemX11::RefreshWindow - failed to query xrandr");
+    return;
+  }
   XOutput out  = g_xrandr.GetCurrentOutput();
   XMode   mode = g_xrandr.GetCurrentMode(out.name);
 
+  RotateResolutions();
+
   // only overwrite desktop resolution, if we are not in fullscreen mode
   if (!g_graphicsContext.IsFullScreenVideo())
   {
     CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshWindow - store desktop resolution, width: %d, height: %d, hz: %2.2f", mode.w, mode.h, mode.hz);
-    UpdateDesktopResolution(g_settings.m_ResInfo[RES_DESKTOP], 0, mode.w, mode.h, mode.hz);
-    g_settings.m_ResInfo[RES_DESKTOP].strId     = mode.id;
-    g_settings.m_ResInfo[RES_DESKTOP].strOutput = out.name;
+    if (!out.isRotated)
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
+    else
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.h, mode.w, mode.hz);
+    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId     = mode.id;
+    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = out.name;
   }
 
   RESOLUTION_INFO res;
   unsigned int i;
   bool found(false);
-  for (i = RES_DESKTOP; i < g_settings.m_ResInfo.size(); ++i)
+  for (i = RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); ++i)
   {
-    if (g_settings.m_ResInfo[i].strId == mode.id)
+    if (CDisplaySettings::Get().GetResolutionInfo(i).strId == mode.id)
     {
       found = true;
       break;
@@ -226,16 +235,24 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
   }
   else
   {
-    out.name = g_settings.m_ResInfo[RES_DESKTOP].strOutput;
-    mode.w   = g_settings.m_ResInfo[RES_DESKTOP].iWidth;
-    mode.h   = g_settings.m_ResInfo[RES_DESKTOP].iHeight;
-    mode.hz  = g_settings.m_ResInfo[RES_DESKTOP].fRefreshRate;
-    mode.id  = g_settings.m_ResInfo[RES_DESKTOP].strId;
+    out.name = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput;
+    mode.w   = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).iWidth;
+    mode.h   = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).iHeight;
+    mode.hz  = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).fRefreshRate;
+    mode.id  = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId;
   }
  
   XOutput currout  = g_xrandr.GetCurrentOutput();
   XMode   currmode = g_xrandr.GetCurrentMode(currout.name);
 
+  // flip h/w when rotated
+  if (m_bIsRotated)
+  {
+    int w = mode.w;
+    mode.w = mode.h;
+    mode.h = w;
+  }
+
   // only call xrandr if mode changes
   if (currout.name != out.name || currmode.w != mode.w || currmode.h != mode.h ||
       currmode.hz != mode.hz || currmode.id != mode.id)
@@ -268,7 +285,11 @@ void CWinSystemX11::UpdateResolutions()
   {
     XOutput out  = g_xrandr.GetCurrentOutput();
     XMode   mode = g_xrandr.GetCurrentMode(out.name);
-    UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
+    m_bIsRotated = out.isRotated;
+    if (!m_bIsRotated)
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
+    else
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.h, mode.w, mode.hz);
     CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId     = mode.id;
     CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = out.name;
   }
@@ -307,6 +328,16 @@ void CWinSystemX11::UpdateResolutions()
       res.iHeight = mode.h;
       res.iScreenWidth  = mode.w;
       res.iScreenHeight = mode.h;
+      if (!m_bIsRotated)
+      {
+        res.iWidth  = mode.w;
+        res.iHeight = mode.h;
+      }
+      else
+      {
+        res.iWidth  = mode.h;
+        res.iHeight = mode.w;
+      }
       if (mode.h>0 && mode.w>0 && out.hmm>0 && out.wmm>0)
         res.fPixelRatio = ((float)out.wmm/(float)mode.w) / (((float)out.hmm/(float)mode.h));
       else
@@ -334,6 +365,30 @@ void CWinSystemX11::UpdateResolutions()
 
 }
 
+void CWinSystemX11::RotateResolutions()
+{
+#if defined(HAS_XRANDR)
+  XOutput out  = g_xrandr.GetCurrentOutput();
+  if (out.isRotated == m_bIsRotated)
+    return;
+
+  for (unsigned int i = 0; i < CDisplaySettings::Get().ResolutionInfoSize(); ++i)
+  {
+    int width = CDisplaySettings::Get().GetResolutionInfo(i).iWidth;
+    CDisplaySettings::Get().GetResolutionInfo(i).iWidth = CDisplaySettings::Get().GetResolutionInfo(i).iHeight;
+    CDisplaySettings::Get().GetResolutionInfo(i).iHeight = width;
+  }
+  // update desktop resolution
+//  int h = g_settings.m_ResInfo[RES_DESKTOP].iHeight;
+//  int w = g_settings.m_ResInfo[RES_DESKTOP].iWidth;
+//  float hz = g_settings.m_ResInfo[RES_DESKTOP].fRefreshRate;
+//  UpdateDesktopResolution(g_settings.m_ResInfo[RES_DESKTOP], 0, w, h, hz);
+
+  m_bIsRotated = out.isRotated;
+
+#endif
+}
+
 bool CWinSystemX11::IsSuitableVisual(XVisualInfo *vInfo)
 {
   int value;
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 041ea55..0d4436b 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -73,12 +73,14 @@ class CWinSystemX11 : public CWinSystemBase
   void CheckDisplayEvents();
   void OnLostDevice();
   bool SetWindow(int width, int height, bool fullscreen);
+  void RotateResolutions();
 
   Window       m_glWindow;
   GLXContext   m_glContext;
   Display*     m_dpy;
   Cursor       m_invisibleCursor;
   Pixmap       m_icon;
+  bool         m_bIsRotated;
   bool         m_bWasFullScreenBeforeMinimize;
   bool         m_minimized;
   bool         m_bIgnoreNextFocusMessage;
diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index b4c95f8..e2576b2 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -98,6 +98,13 @@ bool CXRandR::Query(bool force)
     xoutput.y = (output->Attribute("y") != NULL ? atoi(output->Attribute("y")) : 0);
     xoutput.wmm = (output->Attribute("wmm") != NULL ? atoi(output->Attribute("wmm")) : 0);
     xoutput.hmm = (output->Attribute("hmm") != NULL ? atoi(output->Attribute("hmm")) : 0);
+    if (output->Attribute("rotation") != NULL
+        && (strcasecmp(output->Attribute("rotation"), "left") == 0 || strcasecmp(output->Attribute("rotation"), "right") == 0))
+    {
+      xoutput.isRotated = true;
+    }
+    else
+      xoutput.isRotated = false;
 
     if (!xoutput.isConnected)
        continue;
diff --git a/xbmc/windowing/X11/XRandR.h b/xbmc/windowing/X11/XRandR.h
index cf22fbf..71ffab4 100644
--- a/xbmc/windowing/X11/XRandR.h
+++ b/xbmc/windowing/X11/XRandR.h
@@ -86,6 +86,7 @@ class XOutput
   int wmm;
   int hmm;
   std::vector<XMode> modes;
+  bool isRotated;
 };
 
 class CXRandR
-- 
1.8.1.6


From 74087bc15aafee00399f86ce4387e07bcdc852b6 Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 11:54:15 +0200
Subject: [PATCH 048/123] xrandr: allow getting info for multiple screen's

Refactored by: Joakim Plate <elupus@xbmc.org>
---
 xbmc/windowing/X11/XRandR.cpp | 65 +++++++++++++++++++++++++++++++++----------
 xbmc/windowing/X11/XRandR.h   |  8 ++++--
 2 files changed, 57 insertions(+), 16 deletions(-)

diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index e2576b2..97b1e32 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -39,6 +39,7 @@
 CXRandR::CXRandR(bool query)
 {
   m_bInit = false;
+  m_numScreens = 1;
   if (query)
     Query();
 }
@@ -55,11 +56,21 @@ bool CXRandR::Query(bool force)
     return false;
 
   m_outputs.clear();
-  m_current.clear();
+  // query all screens
+  for(unsigned int screennum=0; screennum<m_numScreens; ++screennum)
+  {
+    if(!Query(force, screennum))
+      return false;
+  }
+  return true;
+}
 
+bool CXRandR::Query(bool force, int screennum)
+{
   CStdString cmd;
   cmd  = getenv("XBMC_BIN_HOME");
   cmd += "/xbmc-xrandr";
+  cmd.append("-q --screen %d", screennum);
 
   FILE* file = popen(cmd.c_str(),"r");
   if (!file)
@@ -79,7 +90,7 @@ bool CXRandR::Query(bool force)
   pclose(file);
 
   TiXmlElement *pRootElement = xmlDoc.RootElement();
-  if (strcasecmp(pRootElement->Value(), "screen") != 0)
+  if (strcasecmp(pRootElement->Value(), "screen") != screennum)
   {
     // TODO ERROR
     return false;
@@ -92,6 +103,7 @@ bool CXRandR::Query(bool force)
     xoutput.name.TrimLeft(" \n\r\t");
     xoutput.name.TrimRight(" \n\r\t");
     xoutput.isConnected = (strcasecmp(output->Attribute("connected"), "true") == 0);
+    xoutput.screen = screennum;
     xoutput.w = (output->Attribute("w") != NULL ? atoi(output->Attribute("w")) : 0);
     xoutput.h = (output->Attribute("h") != NULL ? atoi(output->Attribute("h")) : 0);
     xoutput.x = (output->Attribute("x") != NULL ? atoi(output->Attribute("x")) : 0);
@@ -123,7 +135,6 @@ bool CXRandR::Query(bool force)
       xoutput.modes.push_back(xmode);
       if (xmode.isCurrent)
       {
-        m_current.push_back(xoutput);
         hascurrent = true;
       }
     }
@@ -247,17 +258,6 @@ bool CXRandR::SetMode(XOutput output, XMode mode)
   return true;
 }
 
-XOutput CXRandR::GetCurrentOutput()
-{
-  Query();
-  for (unsigned int j = 0; j < m_outputs.size(); j++)
-  {
-    if(m_outputs[j].isConnected)
-      return m_outputs[j];
-  }
-  XOutput empty;
-  return empty;
-}
 XMode CXRandR::GetCurrentMode(CStdString outputName)
 {
   Query();
@@ -331,6 +331,43 @@ void CXRandR::LoadCustomModeLinesToAllOutputs(void)
   }
 }
 
+void CXRandR::SetNumScreens(unsigned int num)
+{
+  m_numScreens = num;
+  m_bInit = false;
+}
+
+bool CXRandR::IsOutputConnected(CStdString name)
+{
+  bool result = false;
+  Query();
+
+  for (unsigned int i = 0; i < m_outputs.size(); ++i)
+  {
+    if (m_outputs[i].name == name)
+    {
+      result = true;
+      break;
+    }
+  }
+  return result;
+}
+
+XOutput* CXRandR::GetOutput(CStdString outputName)
+{
+  XOutput *result = 0;
+  Query();
+  for (unsigned int i = 0; i < m_outputs.size(); ++i)
+  {
+    if (m_outputs[i].name == outputName)
+    {
+      result = &m_outputs[i];
+      break;
+    }
+  }
+  return result;
+}
+
 CXRandR g_xrandr;
 
 #endif // HAS_XRANDR
diff --git a/xbmc/windowing/X11/XRandR.h b/xbmc/windowing/X11/XRandR.h
index 71ffab4..26c2653 100644
--- a/xbmc/windowing/X11/XRandR.h
+++ b/xbmc/windowing/X11/XRandR.h
@@ -79,6 +79,7 @@ class XOutput
     }
   CStdString name;
   bool isConnected;
+  int screen;
   int w;
   int h;
   int x;
@@ -94,12 +95,15 @@ class CXRandR
 public:
   CXRandR(bool query=false);
   bool Query(bool force=false);
+  bool Query(bool force, int screennum);
   std::vector<XOutput> GetModes(void);
-  XOutput GetCurrentOutput();
   XMode   GetCurrentMode(CStdString outputName);
+  XOutput *GetOutput(CStdString outputName);
   bool SetMode(XOutput output, XMode mode);
   void LoadCustomModeLinesToAllOutputs(void);
   void SaveState();
+  void SetNumScreens(unsigned int num);
+  bool IsOutputConnected(CStdString name);
   //bool Has1080i();
   //bool Has1080p();
   //bool Has720p();
@@ -107,10 +111,10 @@ class CXRandR
 
 private:
   bool m_bInit;
-  std::vector<XOutput> m_current;
   std::vector<XOutput> m_outputs;
   CStdString m_currentOutput;
   CStdString m_currentMode;
+  unsigned int m_numScreens;
 };
 
 extern CXRandR g_xrandr;
-- 
1.8.1.6


From 962e8baf6d19fb165988939a07e350b55e7b379e Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 11:44:00 +0200
Subject: [PATCH 049/123] X11: fix multi-head setups

---
 language/English/strings.po         |   4 +-
 system/settings/settings.xml        |  11 ++
 xbmc/rendering/gl/RenderSystemGL.h  |   1 +
 xbmc/settings/DisplaySettings.cpp   |  44 +++++-
 xbmc/settings/DisplaySettings.h     |   2 +
 xbmc/settings/Settings.cpp          |   6 +
 xbmc/windowing/WinEventsX11.cpp     |   7 +
 xbmc/windowing/X11/WinSystemX11.cpp | 260 +++++++++++++++++++++---------------
 xbmc/windowing/X11/WinSystemX11.h   |  10 +-
 9 files changed, 229 insertions(+), 116 deletions(-)

diff --git a/language/English/strings.po b/language/English/strings.po
index eace353..10568ca 100644
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -999,7 +999,9 @@ msgctxt "#245"
 msgid "Sizing: (%i,%i)->(%i,%i) (Zoom x%2.2f) AR:%2.2f:1 (Pixels: %2.2f:1) (VShift: %2.2f)"
 msgstr ""
 
-#empty string with id 246
+msgctxt "#246"
+msgid "Monitor"
+msgstr ""
 
 msgctxt "#247"
 msgid "Scripts"
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index 15e9a75..9c63476 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -1841,6 +1841,15 @@
   <section id="system" label="13000" help="36349">
     <category id="videoscreen" label="21373" help="36350">
       <group id="1">
+        <setting id="videoscreen.monitor" type="string" label="246" help="">
+          <visible>HAS_GLX</visible>
+          <level>0</level>
+          <default>Default</default>
+          <constraints>
+            <options>monitors</options>
+          </constraints>
+          <control type="spinner" format="string" delayed="true" />
+        </setting>
         <setting id="videoscreen.screen" type="integer" label="240" help="36351">
           <level>0</level>
           <default>0</default>
@@ -1862,6 +1871,7 @@
             <dependency type="enable" setting="videoscreen.screen" operator="!is">-1</dependency> <!-- DM_WINDOWED -->
             <dependency type="update" setting="videoscreen.screen" />
             <dependency type="update" setting="videoscreen.screenmode" />
+            <dependency type="update" setting="videoscreen.monitor" />
           </dependencies>
           <control type="list" format="string" />
         </setting>
@@ -1879,6 +1889,7 @@
             <dependency type="enable" setting="videoscreen.screen" operator="!is">-1</dependency> <!-- DM_WINDOWED -->
             <dependency type="update" setting="videoscreen.screen" />
             <dependency type="update" setting="videoscreen.resolution" />
+            <dependency type="update" setting="videoscreen.monitor" />
           </dependencies>
           <control type="spinner" format="string" delayed="true" />
         </setting>
diff --git a/xbmc/rendering/gl/RenderSystemGL.h b/xbmc/rendering/gl/RenderSystemGL.h
index 5c7a288..f3fd4fb 100644
--- a/xbmc/rendering/gl/RenderSystemGL.h
+++ b/xbmc/rendering/gl/RenderSystemGL.h
@@ -44,6 +44,7 @@ class CRenderSystemGL : public CRenderSystemBase
   virtual bool IsExtSupported(const char* extension);
 
   virtual void SetVSync(bool vsync);
+  virtual void ResetVSync() { m_bVsyncInit = false; }
 
   virtual void SetViewPort(CRect& viewPort);
   virtual void GetViewPort(CRect& viewPort);
diff --git a/xbmc/settings/DisplaySettings.cpp b/xbmc/settings/DisplaySettings.cpp
index 49b50f4..203c0f1 100644
--- a/xbmc/settings/DisplaySettings.cpp
+++ b/xbmc/settings/DisplaySettings.cpp
@@ -198,13 +198,19 @@ bool CDisplaySettings::OnSettingChanging(const CSetting *setting)
 
   const std::string &settingId = setting->GetId();
   if (settingId == "videoscreen.resolution" ||
-      settingId == "videoscreen.screen")
+      settingId == "videoscreen.screen" ||
+      settingId == "videoscreen.monitor")
   {
     RESOLUTION newRes = RES_DESKTOP;
     if (settingId == "videoscreen.resolution")
       newRes = (RESOLUTION)((CSettingInt*)setting)->GetValue();
     else if (settingId == "videoscreen.screen")
       newRes = GetResolutionForScreen();
+    else if (settingId == "videoscreen.monitor")
+    {
+      g_Windowing.UpdateResolutions();
+      newRes = GetResolutionForScreen();
+    }
 
     string screenmode = GetStringFromResolution(newRes);
     CSettings::Get().SetString("videoscreen.screenmode", screenmode);
@@ -215,7 +221,11 @@ bool CDisplaySettings::OnSettingChanging(const CSetting *setting)
     RESOLUTION newRes = GetResolutionFromString(((CSettingString*)setting)->GetValue());
 
     SetCurrentResolution(newRes, false);
-    g_graphicsContext.SetVideoResolution(newRes);
+    bool outputChanged = false;
+#if defined(HAS_GLX)
+    outputChanged = !g_Windowing.IsCurrentOutput(CSettings::Get().GetString("videoscreen.monitor"));
+#endif
+    g_graphicsContext.SetVideoResolution(newRes, outputChanged);
 
     // check if the old or the new resolution was/is windowed
     // in which case we don't show any prompt to the user
@@ -571,6 +581,10 @@ void CDisplaySettings::SettingOptionsScreensFiller(const CSetting *setting, std:
   if (g_advancedSettings.m_canWindowed)
     list.push_back(make_pair(g_localizeStrings.Get(242), DM_WINDOWED));
 
+#if defined(HAS_GLX)
+  list.push_back(make_pair(g_localizeStrings.Get(244), 0));
+#else
+
   for (int idx = 0; idx < g_Windowing.GetNumScreens(); idx++)
   {
     int screen = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP + idx).iScreen;
@@ -585,6 +599,7 @@ void CDisplaySettings::SettingOptionsScreensFiller(const CSetting *setting, std:
     RESOLUTION_INFO resInfo = CDisplaySettings::Get().GetResolutionInfo(res);
     current = resInfo.iScreen;
   }
+#endif
 }
 
 void CDisplaySettings::SettingOptionsVerticalSyncsFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current)
@@ -596,3 +611,28 @@ void CDisplaySettings::SettingOptionsVerticalSyncsFiller(const CSetting *setting
   list.push_back(make_pair(g_localizeStrings.Get(13107), VSYNC_VIDEO));
   list.push_back(make_pair(g_localizeStrings.Get(13108), VSYNC_ALWAYS));
 }
+
+void CDisplaySettings::SettingOptionsMonitorsFiller(const CSetting *setting, std::vector< std::pair<std::string, std::string> > &list, std::string &current)
+{
+#if defined(HAS_GLX)
+  std::vector<CStdString> monitors;
+  g_Windowing.GetConnectedOutputs(&monitors);
+  for (unsigned int i=0; i<monitors.size(); ++i)
+  {
+    if(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput.Equals(monitors[i]))
+    {
+      current = monitors[i];
+    }
+    list.push_back(make_pair(monitors[i], monitors[i]));
+  }
+#endif
+}
+
+void CDisplaySettings::ClearCustomResolutions()
+{
+  if (m_resolutions.size() > RES_CUSTOM)
+  {
+    std::vector<RESOLUTION_INFO>::iterator firstCustom = m_resolutions.begin()+RES_CUSTOM;
+    m_resolutions.erase(firstCustom, m_resolutions.end());
+  }
+}
diff --git a/xbmc/settings/DisplaySettings.h b/xbmc/settings/DisplaySettings.h
index 056fc07..fe91a74 100644
--- a/xbmc/settings/DisplaySettings.h
+++ b/xbmc/settings/DisplaySettings.h
@@ -78,6 +78,7 @@ class CDisplaySettings : public ISettingCallback, public ISubSettings,
 
   void ApplyCalibrations();
   void UpdateCalibrations();
+  void ClearCustomResolutions();
 
   float GetZoomAmount() const { return m_zoomAmount; }
   void SetZoomAmount(float zoomAmount) { m_zoomAmount = zoomAmount; }
@@ -93,6 +94,7 @@ class CDisplaySettings : public ISettingCallback, public ISubSettings,
   static void SettingOptionsResolutionsFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current);
   static void SettingOptionsScreensFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current);
   static void SettingOptionsVerticalSyncsFiller(const CSetting *setting, std::vector< std::pair<std::string, int> > &list, int &current);
+  static void SettingOptionsMonitorsFiller(const CSetting *setting, std::vector< std::pair<std::string, std::string> > &list, std::string &current);
 
 protected:
   CDisplaySettings();
diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index ee97753..63cdf0e 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -374,6 +374,7 @@ void CSettings::Uninitialize()
   m_settingsManager->UnregisterSettingOptionsFiller("rendermethods");
   m_settingsManager->UnregisterSettingOptionsFiller("resolutions");
   m_settingsManager->UnregisterSettingOptionsFiller("screens");
+  m_settingsManager->UnregisterSettingOptionsFiller("monitors");
   m_settingsManager->UnregisterSettingOptionsFiller("shutdownstates");
   m_settingsManager->UnregisterSettingOptionsFiller("startupwindows");
   m_settingsManager->UnregisterSettingOptionsFiller("streamlanguages");
@@ -677,6 +678,7 @@ void CSettings::InitializeOptionFillers()
   m_settingsManager->RegisterSettingOptionsFiller("rendermethods", CBaseRenderer::SettingOptionsRenderMethodsFiller);
   m_settingsManager->RegisterSettingOptionsFiller("resolutions", CDisplaySettings::SettingOptionsResolutionsFiller);
   m_settingsManager->RegisterSettingOptionsFiller("screens", CDisplaySettings::SettingOptionsScreensFiller);
+  m_settingsManager->RegisterSettingOptionsFiller("monitors", CDisplaySettings::SettingOptionsMonitorsFiller);
   m_settingsManager->RegisterSettingOptionsFiller("shutdownstates", CPowerManager::SettingOptionsShutdownStatesFiller);
   m_settingsManager->RegisterSettingOptionsFiller("startupwindows", ADDON::CSkinInfo::SettingOptionsStartupWindowsFiller);
   m_settingsManager->RegisterSettingOptionsFiller("streamlanguages", CLangInfo::SettingOptionsStreamLanguagesFiller);
@@ -704,6 +706,9 @@ void CSettings::InitializeConditions()
 #ifdef HAS_GL
   m_settingsManager->AddCondition("has_gl");
 #endif
+#ifdef HAS_GLX
+  m_settingsManager->AddCondition("has_glx");
+#endif
 #ifdef HAS_GLES
   m_settingsManager->AddCondition("has_gles");
 #endif
@@ -837,6 +842,7 @@ void CSettings::InitializeISettingCallbacks()
   settingSet.insert("videoscreen.screen");
   settingSet.insert("videoscreen.resolution");
   settingSet.insert("videoscreen.screenmode");
+  settingSet.insert("videoscreen.monitor");
   m_settingsManager->RegisterCallback(&CDisplaySettings::Get(), settingSet);
 
   settingSet.clear();
diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index d9dc911..c58067b 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -517,9 +517,16 @@ bool CWinEventsX11::MessagePump()
         break;
       }
 
+      case EnterNotify:
+      {
+        g_Windowing.NotifyMouseCoverage(true);
+        break;
+      }
+
       // lose mouse coverage
       case LeaveNotify:
       {
+        g_Windowing.NotifyMouseCoverage(false);
         g_Mouse.SetActive(false);
         break;
       }
diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 6b320f2..41e7d6e 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -34,7 +34,8 @@
 #include "threads/SingleLock.h"
 #include "cores/VideoRenderers/RenderManager.h"
 #include "utils/TimeUtils.h"
-#include "settings/GUISettings.h"
+#include "settings/Settings.h"
+#include "windowing/WindowingFactory.h"
 
 #if defined(HAS_XRANDR)
 #include <X11/extensions/Xrandr.h>
@@ -56,6 +57,7 @@
   m_bIgnoreNextFocusMessage = false;
   m_dpyLostTime = 0;
   m_invisibleCursor = 0;
+  m_bIsInternalXrr = false;
 
   XSetErrorHandler(XErrorHandler);
 }
@@ -68,7 +70,8 @@ bool CWinSystemX11::InitWindowSystem()
 {
   if ((m_dpy = XOpenDisplay(NULL)))
   {
-    return CWinSystemBase::InitWindowSystem();
+    bool ret = CWinSystemBase::InitWindowSystem();
+    return ret;
   }
   else
     CLog::Log(LOGERROR, "GLX Error: No Display found");
@@ -105,6 +108,8 @@ bool CWinSystemX11::DestroyWindowSystem()
 
     //we don't call XCloseDisplay() here, since ati keeps a pointer to our m_dpy
     //so instead we just let m_dpy die on exit
+    // i have seen core dumps on ATI if the display is not closed here
+    XCloseDisplay(m_dpy);
   }
 
   // m_SDLSurface is free()'d by SDL_Quit().
@@ -127,7 +132,10 @@ bool CWinSystemX11::DestroyWindow()
     return true;
 
   if (m_glContext)
+  {
+    glFinish();
     glXMakeCurrent(m_dpy, None, NULL);
+  }
 
   if (m_invisibleCursor)
   {
@@ -157,7 +165,7 @@ bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int n
   && m_nHeight == newHeight)
     return true;
 
-  if (!SetWindow(newWidth, newHeight, false))
+  if (!SetWindow(newWidth, newHeight, false, CSettings::Get().GetString("videoscreen.monitor")))
   {
     return false;
   }
@@ -166,58 +174,11 @@ bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int n
   m_nWidth  = newWidth;
   m_nHeight = newHeight;
   m_bFullScreen = false;
+  m_currentOutput = CSettings::Get().GetString("videoscreen.monitor");
 
   return false;
 }
 
-void CWinSystemX11::RefreshWindow()
-{
-  if (!g_xrandr.Query(true))
-  {
-    CLog::Log(LOGERROR, "WinSystemX11::RefreshWindow - failed to query xrandr");
-    return;
-  }
-  XOutput out  = g_xrandr.GetCurrentOutput();
-  XMode   mode = g_xrandr.GetCurrentMode(out.name);
-
-  RotateResolutions();
-
-  // only overwrite desktop resolution, if we are not in fullscreen mode
-  if (!g_graphicsContext.IsFullScreenVideo())
-  {
-    CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshWindow - store desktop resolution, width: %d, height: %d, hz: %2.2f", mode.w, mode.h, mode.hz);
-    if (!out.isRotated)
-      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
-    else
-      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.h, mode.w, mode.hz);
-    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId     = mode.id;
-    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = out.name;
-  }
-
-  RESOLUTION_INFO res;
-  unsigned int i;
-  bool found(false);
-  for (i = RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); ++i)
-  {
-    if (CDisplaySettings::Get().GetResolutionInfo(i).strId == mode.id)
-    {
-      found = true;
-      break;
-    }
-  }
-
-  if (!found)
-  {
-    CLog::Log(LOGERROR, "CWinSystemX11::RefreshWindow - could not find resolution");
-    return;
-  }
-
-  if (g_graphicsContext.IsFullScreenRoot())
-    g_graphicsContext.SetVideoResolution((RESOLUTION)i, true);
-  else
-    g_graphicsContext.SetVideoResolution(RES_WINDOW, true);
-}
-
 bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
 {
 
@@ -242,8 +203,7 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
     mode.id  = CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId;
   }
  
-  XOutput currout  = g_xrandr.GetCurrentOutput();
-  XMode   currmode = g_xrandr.GetCurrentMode(currout.name);
+  XMode   currmode = g_xrandr.GetCurrentMode(out.name);
 
   // flip h/w when rotated
   if (m_bIsRotated)
@@ -254,16 +214,17 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
   }
 
   // only call xrandr if mode changes
-  if (currout.name != out.name || currmode.w != mode.w || currmode.h != mode.h ||
+  if (currmode.w != mode.w || currmode.h != mode.h ||
       currmode.hz != mode.hz || currmode.id != mode.id)
   {
     CLog::Log(LOGNOTICE, "CWinSystemX11::SetFullScreen - calling xrandr");
     OnLostDevice();
+    m_bIsInternalXrr = true;
     g_xrandr.SetMode(out, mode);
   }
 #endif
 
-  if (!SetWindow(res.iWidth, res.iHeight, fullScreen))
+  if (!SetWindow(res.iWidth, res.iHeight, fullScreen, CSettings::Get().GetString("videoscreen.monitor")))
     return false;
 
   RefreshGlxContext();
@@ -271,6 +232,7 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
   m_nWidth      = res.iWidth;
   m_nHeight     = res.iHeight;
   m_bFullScreen = fullScreen;
+  m_currentOutput = CSettings::Get().GetString("videoscreen.monitor");
 
   return true;
 }
@@ -279,19 +241,30 @@ void CWinSystemX11::UpdateResolutions()
 {
   CWinSystemBase::UpdateResolutions();
 
-
 #if defined(HAS_XRANDR)
-  if(g_xrandr.Query())
-  {
-    XOutput out  = g_xrandr.GetCurrentOutput();
-    XMode   mode = g_xrandr.GetCurrentMode(out.name);
-    m_bIsRotated = out.isRotated;
+  CStdString currentMonitor;
+  int numScreens = XScreenCount(m_dpy);
+  g_xrandr.SetNumScreens(numScreens);
+  if(g_xrandr.Query(true))
+  {
+    currentMonitor = CSettings::Get().GetString("videoscreen.monitor");
+    // check if the monitor is connected
+    XOutput *out = g_xrandr.GetOutput(currentMonitor);
+    if (!out)
+    {
+      // choose first output
+      currentMonitor = g_xrandr.GetModes()[0].name;
+      out = g_xrandr.GetOutput(currentMonitor);
+      CSettings::Get().SetString("videoscreen.monitor", currentMonitor);
+    }
+    XMode mode = g_xrandr.GetCurrentMode(currentMonitor);
+    m_bIsRotated = out->isRotated;
     if (!m_bIsRotated)
-      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), out->screen, mode.w, mode.h, mode.hz);
     else
-      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.h, mode.w, mode.hz);
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), out->screen, mode.h, mode.w, mode.hz);
     CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId     = mode.id;
-    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = out.name;
+    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = currentMonitor;
   }
   else
 #endif
@@ -302,23 +275,22 @@ void CWinSystemX11::UpdateResolutions()
     UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, w, h, 0.0);
   }
 
-
 #if defined(HAS_XRANDR)
 
+  // erase previous stored modes
+  CDisplaySettings::Get().ClearCustomResolutions();
+
   CLog::Log(LOGINFO, "Available videomodes (xrandr):");
-  vector<XOutput>::iterator outiter;
-  vector<XOutput> outs;
-  outs = g_xrandr.GetModes();
-  CLog::Log(LOGINFO, "Number of connected outputs: %"PRIdS"", outs.size());
+
+  XOutput *out = g_xrandr.GetOutput(currentMonitor);
   string modename = "";
 
-  for (outiter = outs.begin() ; outiter != outs.end() ; outiter++)
+  if (out != NULL)
   {
-    XOutput out = *outiter;
     vector<XMode>::iterator modeiter;
-    CLog::Log(LOGINFO, "Output '%s' has %"PRIdS" modes", out.name.c_str(), out.modes.size());
+    CLog::Log(LOGINFO, "Output '%s' has %"PRIdS" modes", out->name.c_str(), out->modes.size());
 
-    for (modeiter = out.modes.begin() ; modeiter!=out.modes.end() ; modeiter++)
+    for (modeiter = out->modes.begin() ; modeiter!=out->modes.end() ; modeiter++)
     {
       XMode mode = *modeiter;
       CLog::Log(LOGINFO, "ID:%s Name:%s Refresh:%f Width:%d Height:%d",
@@ -338,15 +310,15 @@ void CWinSystemX11::UpdateResolutions()
         res.iWidth  = mode.h;
         res.iHeight = mode.w;
       }
-      if (mode.h>0 && mode.w>0 && out.hmm>0 && out.wmm>0)
-        res.fPixelRatio = ((float)out.wmm/(float)mode.w) / (((float)out.hmm/(float)mode.h));
+      if (mode.h>0 && mode.w>0 && out->hmm>0 && out->wmm>0)
+        res.fPixelRatio = ((float)out->wmm/(float)mode.w) / (((float)out->hmm/(float)mode.h));
       else
         res.fPixelRatio = 1.0f;
 
       CLog::Log(LOGINFO, "Pixel Ratio: %f", res.fPixelRatio);
 
-      res.strMode.Format("%s: %s @ %.2fHz", out.name.c_str(), mode.name.c_str(), mode.hz);
-      res.strOutput    = out.name;
+      res.strMode.Format("%s: %s @ %.2fHz", out->name.c_str(), mode.name.c_str(), mode.hz);
+      res.strOutput    = out->name;
       res.strId        = mode.id;
       res.iSubtitles   = (int)(0.95*mode.h);
       res.fRefreshRate = mode.hz;
@@ -365,28 +337,19 @@ void CWinSystemX11::UpdateResolutions()
 
 }
 
-void CWinSystemX11::RotateResolutions()
+void CWinSystemX11::GetConnectedOutputs(std::vector<CStdString> *outputs)
 {
-#if defined(HAS_XRANDR)
-  XOutput out  = g_xrandr.GetCurrentOutput();
-  if (out.isRotated == m_bIsRotated)
-    return;
-
-  for (unsigned int i = 0; i < CDisplaySettings::Get().ResolutionInfoSize(); ++i)
+  vector<XOutput> outs;
+  outs = g_xrandr.GetModes();
+  for(unsigned int i=0; i<outs.size(); ++i)
   {
-    int width = CDisplaySettings::Get().GetResolutionInfo(i).iWidth;
-    CDisplaySettings::Get().GetResolutionInfo(i).iWidth = CDisplaySettings::Get().GetResolutionInfo(i).iHeight;
-    CDisplaySettings::Get().GetResolutionInfo(i).iHeight = width;
+    outputs->push_back(outs[i].name);
   }
-  // update desktop resolution
-//  int h = g_settings.m_ResInfo[RES_DESKTOP].iHeight;
-//  int w = g_settings.m_ResInfo[RES_DESKTOP].iWidth;
-//  float hz = g_settings.m_ResInfo[RES_DESKTOP].fRefreshRate;
-//  UpdateDesktopResolution(g_settings.m_ResInfo[RES_DESKTOP], 0, w, h, hz);
-
-  m_bIsRotated = out.isRotated;
+}
 
-#endif
+bool CWinSystemX11::IsCurrentOutput(CStdString output)
+{
+  return m_currentOutput.Equals(output);
 }
 
 bool CWinSystemX11::IsSuitableVisual(XVisualInfo *vInfo)
@@ -416,8 +379,11 @@ bool CWinSystemX11::RefreshGlxContext()
   if (m_glContext)
   {
     CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshGlxContext: refreshing context");
+    glFinish();
     glXMakeCurrent(m_dpy, None, NULL);
     glXMakeCurrent(m_dpy, m_glWindow, m_glContext);
+    XSync(m_dpy, FALSE);
+    g_Windowing.ResetVSync();
     return true;
   }
 
@@ -483,6 +449,8 @@ bool CWinSystemX11::RefreshGlxContext()
     {
       // make this context current
       glXMakeCurrent(m_dpy, m_glWindow, m_glContext);
+      g_Windowing.ResetVSync();
+      XSync(m_dpy, False);
       retVal = true;
     }
     else
@@ -524,24 +492,53 @@ void CWinSystemX11::ResetOSScreensaver()
 
 void CWinSystemX11::NotifyAppActiveChange(bool bActivated)
 {
-  if (bActivated && m_bWasFullScreenBeforeMinimize && !g_graphicsContext.IsFullScreenRoot())
+  if (bActivated && m_bWasFullScreenBeforeMinimize && !m_bFullScreen)
+  {
     g_graphicsContext.ToggleFullScreenRoot();
 
+    m_bWasFullScreenBeforeMinimize = false;
+  }
   m_minimized = !bActivated;
 }
 
 void CWinSystemX11::NotifyAppFocusChange(bool bGaining)
 {
   if (bGaining && m_bWasFullScreenBeforeMinimize && !m_bIgnoreNextFocusMessage &&
-      !g_graphicsContext.IsFullScreenRoot())
+      !m_bFullScreen)
+  {
+    m_bWasFullScreenBeforeMinimize = false;
     g_graphicsContext.ToggleFullScreenRoot();
+    m_minimized = false;
+  }
   if (!bGaining)
     m_bIgnoreNextFocusMessage = false;
 }
 
+void CWinSystemX11::NotifyMouseCoverage(bool covered)
+{
+  if (!m_bFullScreen)
+    return;
+
+  if (covered)
+  {
+    int result = -1;
+    while (result != GrabSuccess && result != AlreadyGrabbed)
+    {
+      result = XGrabPointer(m_dpy, m_glWindow, True, ButtonPressMask, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);
+      XbmcThreads::ThreadSleep(100);
+    }
+    XGrabKeyboard(m_dpy, m_glWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
+  }
+  else
+  {
+    XUngrabKeyboard(m_dpy, CurrentTime);
+    XUngrabPointer(m_dpy, CurrentTime);
+  }
+}
+
 bool CWinSystemX11::Minimize()
 {
-  m_bWasFullScreenBeforeMinimize = g_graphicsContext.IsFullScreenRoot();
+  m_bWasFullScreenBeforeMinimize = m_bFullScreen;
   if (m_bWasFullScreenBeforeMinimize)
   {
     m_bIgnoreNextFocusMessage = true;
@@ -607,13 +604,46 @@ void CWinSystemX11::CheckDisplayEvents()
 void CWinSystemX11::NotifyXRREvent()
 {
   CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
-  RefreshWindow();
+  m_windowDirty = true;
 
-  CSingleLock lock(m_resourceSection);
+  // if external event update resolutions
+  if (!m_bIsInternalXrr)
+  {
+    UpdateResolutions();
+  }
+  else if (!g_xrandr.Query(true))
+  {
+    CLog::Log(LOGERROR, "WinSystemX11::RefreshWindow - failed to query xrandr");
+    return;
+  }
+  m_bIsInternalXrr = false;
 
-  // tell any shared resources
-  for (vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); i++)
-    (*i)->OnResetDevice();
+  CStdString currentOutput = CSettings::Get().GetString("videoscreen.monitor");
+  XOutput *out = g_xrandr.GetOutput(currentOutput);
+  XMode   mode = g_xrandr.GetCurrentMode(currentOutput);
+
+  RESOLUTION_INFO res;
+  unsigned int i;
+  bool found(false);
+  for (i = RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); ++i)
+  {
+    if (CDisplaySettings::Get().GetResolutionInfo(i).strId == mode.id)
+    {
+      found = true;
+      break;
+    }
+  }
+
+  if (!found)
+  {
+    CLog::Log(LOGERROR, "CWinSystemX11::RefreshWindow - could not find resolution");
+    i = RES_DESKTOP;
+  }
+
+  if (g_graphicsContext.IsFullScreenRoot())
+    g_graphicsContext.SetVideoResolution((RESOLUTION)i, true);
+  else
+    g_graphicsContext.SetVideoResolution(RES_WINDOW, true);
 
 }
 
@@ -666,14 +696,14 @@ bool CWinSystemX11::EnableFrameLimiter()
   return m_minimized;
 }
 
-bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen)
+bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStdString &output)
 {
   bool changeWindow = false;
   bool changeSize = false;
   bool mouseActive = false;
   float mouseX, mouseY;
 
-  if (m_glWindow && (m_bFullScreen != fullscreen))
+  if (m_glWindow && ((m_bFullScreen != fullscreen) || !m_currentOutput.Equals(output) || m_windowDirty))
   {
     mouseActive = g_Mouse.IsActive();
     if (mouseActive)
@@ -695,6 +725,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen)
       else
         mouseActive = false;
     }
+    OnLostDevice();
     DestroyWindow();
   }
 
@@ -716,7 +747,11 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen)
     XSetWindowAttributes swa;
     XVisualInfo *vi;
 
-    vi = glXChooseVisual(m_dpy, DefaultScreen(m_dpy), att);
+    XOutput *out = g_xrandr.GetOutput(output);
+    if (!out)
+      out = g_xrandr.GetOutput(m_currentOutput);
+    m_nScreen = out->screen;
+    vi = glXChooseVisual(m_dpy, m_nScreen, att);
     cmap = XCreateColormap(m_dpy, RootWindow(m_dpy, vi->screen), vi->visual, AllocNone);
 
     int def_vis = (vi->visual == DefaultVisual(m_dpy, vi->screen));
@@ -732,7 +767,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen)
     unsigned long mask = CWBackPixel | CWBorderPixel | CWColormap | CWOverrideRedirect | CWEventMask;
 
     m_glWindow = XCreateWindow(m_dpy, RootWindow(m_dpy, vi->screen),
-                    0, 0, width, height, 0, vi->depth,
+                    out->x, out->y, width, height, 0, vi->depth,
                     InputOutput, vi->visual,
                     mask, &swa);
 
@@ -803,14 +838,19 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen)
     if (fullscreen)
     {
       int result = -1;
-      while (result != GrabSuccess)
+      while (result != GrabSuccess && result != AlreadyGrabbed)
       {
-        result = XGrabPointer(m_dpy, m_glWindow, True, ButtonPressMask, GrabModeAsync, GrabModeAsync, m_glWindow, None, CurrentTime);
+        result = XGrabPointer(m_dpy, m_glWindow, True, ButtonPressMask, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);
         XbmcThreads::ThreadSleep(100);
       }
       XGrabKeyboard(m_dpy, m_glWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
-
     }
+    CSingleLock lock(m_resourceSection);
+    // tell any shared resources
+    for (vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); i++)
+      (*i)->OnResetDevice();
+
+    m_windowDirty = false;
   }
   return true;
 }
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 0d4436b..0336b3b 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -65,15 +65,16 @@ class CWinSystemX11 : public CWinSystemBase
   Display*  GetDisplay() { return m_dpy; }
   GLXWindow GetWindow() { return m_glWindow; }
   GLXContext GetGlxContext() { return m_glContext; }
-  void RefreshWindow();
   void NotifyXRREvent();
+  void GetConnectedOutputs(std::vector<CStdString> *outputs);
+  bool IsCurrentOutput(CStdString output);
+  void NotifyMouseCoverage(bool covered);
 
 protected:
   bool RefreshGlxContext();
   void CheckDisplayEvents();
   void OnLostDevice();
-  bool SetWindow(int width, int height, bool fullscreen);
-  void RotateResolutions();
+  bool SetWindow(int width, int height, bool fullscreen, const CStdString &output);
 
   Window       m_glWindow;
   GLXContext   m_glContext;
@@ -88,6 +89,9 @@ class CWinSystemX11 : public CWinSystemBase
   CCriticalSection             m_resourceSection;
   std::vector<IDispResource*>  m_resources;
   uint64_t                     m_dpyLostTime;
+  CStdString                   m_currentOutput;
+  bool                         m_windowDirty;
+  bool                         m_bIsInternalXrr;
 
 private:
   bool IsSuitableVisual(XVisualInfo *vInfo);
-- 
1.8.1.6


From 1b9d4812607e358873e2a8868edf53b41c67cd15 Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 11:36:32 +0200
Subject: [PATCH 050/123] X11: remove all DefaultScreen and RootWindow macros

---
 xbmc/windowing/X11/WinSystemX11.cpp   | 6 +++---
 xbmc/windowing/X11/WinSystemX11.h     | 1 +
 xbmc/windowing/X11/WinSystemX11GL.cpp | 2 +-
 3 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 41e7d6e..fd07a80 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -269,7 +269,7 @@ void CWinSystemX11::UpdateResolutions()
   else
 #endif
   {
-    int x11screen = DefaultScreen(m_dpy);
+    int x11screen = m_nScreen;
     int w = DisplayWidth(m_dpy, x11screen);
     int h = DisplayHeight(m_dpy, x11screen);
     UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, w, h, 0.0);
@@ -391,7 +391,7 @@ bool CWinSystemX11::RefreshGlxContext()
   XVisualInfo *visuals;
   XVisualInfo *vInfo      = NULL;
   int availableVisuals    = 0;
-  vMask.screen = DefaultScreen(m_dpy);
+  vMask.screen = m_nScreen;
   XWindowAttributes winAttr;
 
   /* Assume a depth of 24 in case the below calls to XGetWindowAttributes()
@@ -545,7 +545,7 @@ bool CWinSystemX11::Minimize()
     g_graphicsContext.ToggleFullScreenRoot();
   }
 
-  XIconifyWindow(m_dpy, m_glWindow, DefaultScreen(m_dpy));
+  XIconifyWindow(m_dpy, m_glWindow, m_nScreen);
 
   m_minimized = true;
   return true;
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 0336b3b..393399f 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -47,6 +47,7 @@ class CWinSystemX11 : public CWinSystemBase
   virtual bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays);
   virtual void UpdateResolutions();
   virtual int  GetNumScreens() { return 1; }
+  virtual int  GetCurrentScreen() { return m_nScreen; }
   virtual void ShowOSMouse(bool show);
   virtual void ResetOSScreensaver();
   virtual bool EnableFrameLimiter();
diff --git a/xbmc/windowing/X11/WinSystemX11GL.cpp b/xbmc/windowing/X11/WinSystemX11GL.cpp
index 1bea366..cc39720 100644
--- a/xbmc/windowing/X11/WinSystemX11GL.cpp
+++ b/xbmc/windowing/X11/WinSystemX11GL.cpp
@@ -203,7 +203,7 @@ bool CWinSystemX11GL::CreateNewWindow(const CStdString& name, bool fullScreen, R
     return false;
 
   m_glxext  = " ";
-  m_glxext += (const char*)glXQueryExtensionsString(m_dpy, DefaultScreen(m_dpy));
+  m_glxext += (const char*)glXQueryExtensionsString(m_dpy, m_nScreen);
   m_glxext += " ";
 
   CLog::Log(LOGDEBUG, "GLX_EXTENSIONS:%s", m_glxext.c_str());
-- 
1.8.1.6


From 25cb8d56c21407abe41750eb4ac03a6a72cc005d Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 11:45:22 +0200
Subject: [PATCH 051/123] X11: remove all DefaultScreen and RootWindow macros
 (VideoRefClock)

Note this is on a separate display connection.
---
 xbmc/video/VideoReferenceClock.cpp | 15 ++++++++-------
 1 file changed, 8 insertions(+), 7 deletions(-)

diff --git a/xbmc/video/VideoReferenceClock.cpp b/xbmc/video/VideoReferenceClock.cpp
index ca239cf..687e3ff 100644
--- a/xbmc/video/VideoReferenceClock.cpp
+++ b/xbmc/video/VideoReferenceClock.cpp
@@ -270,7 +270,7 @@ bool CVideoReferenceClock::SetupGLX()
   }
 
   bool          ExtensionFound = false;
-  istringstream Extensions(glXQueryExtensionsString(m_Dpy, DefaultScreen(m_Dpy)));
+  istringstream Extensions(glXQueryExtensionsString(m_Dpy, g_Windowing.GetCurrentScreen()));
   string        ExtensionStr;
 
   while (!ExtensionFound)
@@ -297,7 +297,7 @@ bool CVideoReferenceClock::SetupGLX()
     m_bIsATI = true;
   }
 
-  m_vInfo = glXChooseVisual(m_Dpy, DefaultScreen(m_Dpy), singleBufferAttributes);
+  m_vInfo = glXChooseVisual(m_Dpy, g_Windowing.GetCurrentScreen(), singleBufferAttributes);
   if (!m_vInfo)
   {
     CLog::Log(LOGDEBUG, "CVideoReferenceClock: glXChooseVisual returned NULL");
@@ -308,15 +308,16 @@ bool CVideoReferenceClock::SetupGLX()
   {
     Swa.border_pixel = 0;
     Swa.event_mask = StructureNotifyMask;
-    Swa.colormap = XCreateColormap(m_Dpy, RootWindow(m_Dpy, m_vInfo->screen), m_vInfo->visual, AllocNone );
+    Swa.colormap = XCreateColormap(m_Dpy, g_Windowing.GetWindow(), m_vInfo->visual, AllocNone );
     SwaMask = CWBorderPixel | CWColormap | CWEventMask;
 
-    m_Window = XCreateWindow(m_Dpy, RootWindow(m_Dpy, m_vInfo->screen), 0, 0, 256, 256, 0,
+    m_Window = XCreateWindow(m_Dpy, g_Windowing.GetWindow(), 0, 0, 256, 256, 0,
                            m_vInfo->depth, InputOutput, m_vInfo->visual, SwaMask, &Swa);
   }
   else
   {
-    m_pixmap = XCreatePixmap(m_Dpy, DefaultRootWindow(m_Dpy), 256, 256, m_vInfo->depth);
+    Window window = g_Windowing.GetWindow();
+    m_pixmap = XCreatePixmap(m_Dpy, window, 256, 256, m_vInfo->depth);
     if (!m_pixmap)
     {
       CLog::Log(LOGDEBUG, "CVideoReferenceClock: unable to create pixmap");
@@ -383,7 +384,7 @@ bool CVideoReferenceClock::SetupGLX()
 
   //set up receiving of RandR events, we'll get one when the refreshrate changes
   XRRQueryExtension(m_Dpy, &m_RREventBase, &ReturnV);
-  XRRSelectInput(m_Dpy, RootWindow(m_Dpy, m_vInfo->screen), RRScreenChangeNotifyMask);
+  XRRSelectInput(m_Dpy, g_Windowing.GetWindow(), RRScreenChangeNotifyMask);
 
   UpdateRefreshrate(true); //forced refreshrate update
   m_MissedVblanks = 0;
@@ -518,7 +519,7 @@ int CVideoReferenceClock::GetRandRRate()
   int RefreshRate;
   XRRScreenConfiguration *CurrInfo;
 
-  CurrInfo = XRRGetScreenInfo(m_Dpy, RootWindow(m_Dpy, m_vInfo->screen));
+  CurrInfo = XRRGetScreenInfo(m_Dpy, g_Windowing.GetWindow());
   RefreshRate = XRRConfigCurrentRate(CurrInfo);
   XRRFreeScreenConfigInfo(CurrInfo);
 
-- 
1.8.1.6


From dde7b8a4d232d927c23b3d101687df45dba94886 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Wed, 20 Jun 2012 17:37:11 +0200
Subject: [PATCH 052/123] X11: recreate gl context after output has changed

---
 xbmc/windowing/X11/WinSystemX11.cpp   | 24 ++++++++++++++----------
 xbmc/windowing/X11/WinSystemX11.h     |  1 +
 xbmc/windowing/X11/WinSystemX11GL.cpp |  9 +++++++++
 3 files changed, 24 insertions(+), 10 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index fd07a80..8f56cec 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -170,7 +170,6 @@ bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int n
     return false;
   }
 
-  RefreshGlxContext();
   m_nWidth  = newWidth;
   m_nHeight = newHeight;
   m_bFullScreen = false;
@@ -221,14 +220,13 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
     OnLostDevice();
     m_bIsInternalXrr = true;
     g_xrandr.SetMode(out, mode);
+    return true;
   }
 #endif
 
   if (!SetWindow(res.iWidth, res.iHeight, fullScreen, CSettings::Get().GetString("videoscreen.monitor")))
     return false;
 
-  RefreshGlxContext();
-
   m_nWidth      = res.iWidth;
   m_nHeight     = res.iHeight;
   m_bFullScreen = fullScreen;
@@ -379,11 +377,8 @@ bool CWinSystemX11::RefreshGlxContext()
   if (m_glContext)
   {
     CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshGlxContext: refreshing context");
-    glFinish();
     glXMakeCurrent(m_dpy, None, NULL);
     glXMakeCurrent(m_dpy, m_glWindow, m_glContext);
-    XSync(m_dpy, FALSE);
-    g_Windowing.ResetVSync();
     return true;
   }
 
@@ -443,14 +438,14 @@ bool CWinSystemX11::RefreshGlxContext()
     {
       glXMakeCurrent(m_dpy, None, NULL);
       glXDestroyContext(m_dpy, m_glContext);
+      XSync(m_dpy, FALSE);
+      m_newGlContext = true;
     }
 
     if ((m_glContext = glXCreateContext(m_dpy, vInfo, NULL, True)))
     {
       // make this context current
       glXMakeCurrent(m_dpy, m_glWindow, m_glContext);
-      g_Windowing.ResetVSync();
-      XSync(m_dpy, False);
       retVal = true;
     }
     else
@@ -727,6 +722,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     }
     OnLostDevice();
     DestroyWindow();
+    m_windowDirty = true;
   }
 
   // create main window
@@ -845,13 +841,21 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
       }
       XGrabKeyboard(m_dpy, m_glWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
     }
+
+    CDirtyRegionList dr;
+    RefreshGlxContext();
+    XSync(m_dpy, FALSE);
+    g_graphicsContext.Clear(0);
+    g_graphicsContext.Flip(dr);
+    g_Windowing.ResetVSync();
+    m_windowDirty = false;
+
     CSingleLock lock(m_resourceSection);
     // tell any shared resources
     for (vector<IDispResource *>::iterator i = m_resources.begin(); i != m_resources.end(); i++)
       (*i)->OnResetDevice();
-
-    m_windowDirty = false;
   }
+
   return true;
 }
 
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 393399f..2227320 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -93,6 +93,7 @@ class CWinSystemX11 : public CWinSystemBase
   CStdString                   m_currentOutput;
   bool                         m_windowDirty;
   bool                         m_bIsInternalXrr;
+  bool                         m_newGlContext;
 
 private:
   bool IsSuitableVisual(XVisualInfo *vInfo);
diff --git a/xbmc/windowing/X11/WinSystemX11GL.cpp b/xbmc/windowing/X11/WinSystemX11GL.cpp
index cc39720..dda7b14 100644
--- a/xbmc/windowing/X11/WinSystemX11GL.cpp
+++ b/xbmc/windowing/X11/WinSystemX11GL.cpp
@@ -23,6 +23,7 @@
 
 #include "WinSystemX11GL.h"
 #include "utils/log.h"
+#include "Application.h"
 
 CWinSystemX11GL::CWinSystemX11GL()
 {
@@ -245,17 +246,25 @@ bool CWinSystemX11GL::CreateNewWindow(const CStdString& name, bool fullScreen, R
 
 bool CWinSystemX11GL::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop)
 {
+  m_newGlContext = false;
   CWinSystemX11::ResizeWindow(newWidth, newHeight, newLeft, newTop);
   CRenderSystemGL::ResetRenderSystem(newWidth, newHeight, false, 0);
 
+  if (m_newGlContext)
+    g_application.ReloadSkin();
+
   return true;
 }
 
 bool CWinSystemX11GL::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays)
 {
+  m_newGlContext = false;
   CWinSystemX11::SetFullScreen(fullScreen, res, blankOtherDisplays);
   CRenderSystemGL::ResetRenderSystem(res.iWidth, res.iHeight, fullScreen, res.fRefreshRate);
 
+  if (m_newGlContext)
+    g_application.ReloadSkin();
+
   return true;
 }
 
-- 
1.8.1.6


From 04b267d0ada69b62e07d05dd840fde3ff2e8d72c Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 12:06:25 +0200
Subject: [PATCH 053/123] X11: hook video reference clock in windowing

---
 xbmc/video/VideoReferenceClock.cpp | 71 +++++++++++++++++++++++++++-----------
 xbmc/video/VideoReferenceClock.h   | 13 ++++++-
 2 files changed, 63 insertions(+), 21 deletions(-)

diff --git a/xbmc/video/VideoReferenceClock.cpp b/xbmc/video/VideoReferenceClock.cpp
index 687e3ff..4287e8f 100644
--- a/xbmc/video/VideoReferenceClock.cpp
+++ b/xbmc/video/VideoReferenceClock.cpp
@@ -135,12 +135,23 @@
   m_Context = NULL;
   m_pixmap = None;
   m_glPixmap = None;
-  m_RREventBase = 0;
   m_UseNvSettings = true;
   m_bIsATI = false;
 #endif
 }
 
+CVideoReferenceClock::~CVideoReferenceClock()
+{
+#if defined(HAS_GLX)
+  // some ATI voodoo, if we don't close the display, we crash on exit
+  if (m_Dpy)
+  {
+    XCloseDisplay(m_Dpy);
+    m_Dpy = NULL;
+  }
+#endif
+}
+
 void CVideoReferenceClock::Process()
 {
   bool SetupSuccess = false;
@@ -151,6 +162,10 @@ void CVideoReferenceClock::Process()
   m_D3dCallback.Reset();
   g_Windowing.Register(&m_D3dCallback);
 #endif
+#if defined(HAS_GLX) && defined(HAS_XRANDR)
+  g_Windowing.Register(this);
+  m_xrrEvent = false;
+#endif
 
   while(!m_bStop)
   {
@@ -211,6 +226,16 @@ void CVideoReferenceClock::Process()
     //clean up the vblank clock
 #if defined(HAS_GLX) && defined(HAS_XRANDR)
     CleanupGLX();
+    if (m_xrrEvent)
+    {
+      m_releaseEvent.Set();
+      while (!m_bStop)
+      {
+        if (m_resetEvent.WaitMSec(100))
+          break;
+      }
+      m_xrrEvent = false;
+    }
 #elif defined(TARGET_WINDOWS) && defined(HAS_DX)
     CleanupD3D();
 #elif defined(TARGET_DARWIN)
@@ -222,6 +247,9 @@ void CVideoReferenceClock::Process()
 #if defined(TARGET_WINDOWS) && defined(HAS_DX)
   g_Windowing.Unregister(&m_D3dCallback);
 #endif
+#if defined(HAS_GLX)
+  g_Windowing.Unregister(this);
+#endif
 }
 
 bool CVideoReferenceClock::WaitStarted(int MSecs)
@@ -231,6 +259,24 @@ bool CVideoReferenceClock::WaitStarted(int MSecs)
 }
 
 #if defined(HAS_GLX) && defined(HAS_XRANDR)
+
+void CVideoReferenceClock::OnLostDevice()
+{
+  if (!m_xrrEvent)
+  {
+    m_releaseEvent.Reset();
+    m_resetEvent.Reset();
+    m_xrrEvent = true;
+    m_releaseEvent.Wait();
+  }
+}
+
+void CVideoReferenceClock::OnResetDevice()
+{
+  m_xrrEvent = false;
+  m_resetEvent.Set();
+}
+
 bool CVideoReferenceClock::SetupGLX()
 {
   int singleBufferAttributes[] = {
@@ -382,10 +428,6 @@ bool CVideoReferenceClock::SetupGLX()
     return false;
   }
 
-  //set up receiving of RandR events, we'll get one when the refreshrate changes
-  XRRQueryExtension(m_Dpy, &m_RREventBase, &ReturnV);
-  XRRSelectInput(m_Dpy, g_Windowing.GetWindow(), RRScreenChangeNotifyMask);
-
   UpdateRefreshrate(true); //forced refreshrate update
   m_MissedVblanks = 0;
 
@@ -586,6 +628,9 @@ void CVideoReferenceClock::RunGLX()
 
   while(!m_bStop)
   {
+    if (m_xrrEvent)
+      return;
+
     //wait for the next vblank
     if (!m_bIsATI)
     {
@@ -649,7 +694,6 @@ void CVideoReferenceClock::RunGLX()
       UpdateClock((int)(VblankCount - PrevVblankCount), true);
       SingleLock.Leave();
       SendVblankSignal();
-      UpdateRefreshrate();
       IsReset = false;
     }
     else if (!m_bStop)
@@ -1186,23 +1230,10 @@ bool CVideoReferenceClock::UpdateRefreshrate(bool Forced /*= false*/)
 
 #if defined(HAS_GLX) && defined(HAS_XRANDR)
 
-  //check for RandR events
-  bool   GotEvent = Forced || m_RefreshChanged == 2;
-  XEvent Event;
-  while (XCheckTypedEvent(m_Dpy, m_RREventBase + RRScreenChangeNotify, &Event))
-  {
-    if (Event.type == m_RREventBase + RRScreenChangeNotify)
-    {
-      CLog::Log(LOGDEBUG, "CVideoReferenceClock: Received RandR event %i", Event.type);
-      GotEvent = true;
-    }
-    XRRUpdateConfiguration(&Event);
-  }
-
   if (!Forced)
     m_RefreshChanged = 0;
 
-  if (!GotEvent) //refreshrate did not change
+  if (!Forced) //refreshrate did not change
     return false;
 
   //the refreshrate can be wrong on nvidia drivers, so read it from nvidia-settings when it's available
diff --git a/xbmc/video/VideoReferenceClock.h b/xbmc/video/VideoReferenceClock.h
index 1791570..bcabc9f 100644
--- a/xbmc/video/VideoReferenceClock.h
+++ b/xbmc/video/VideoReferenceClock.h
@@ -30,6 +30,7 @@
   #include <X11/X.h>
   #include <X11/Xlib.h>
   #include <GL/glx.h>
+  #include "guilib/DispResource.h"
 #elif defined(TARGET_WINDOWS) && defined(HAS_DX)
   #include <d3d9.h>
   #include "guilib/D3DResource.h"
@@ -56,9 +57,13 @@ class CD3DCallback : public ID3DResource
 #endif
 
 class CVideoReferenceClock : public CThread
+#if defined(HAS_GLX) && defined(HAS_XRANDR)
+                            ,public IDispResource
+#endif
 {
   public:
     CVideoReferenceClock();
+    virtual ~CVideoReferenceClock();
 
     int64_t GetTime(bool interpolated = true);
     int64_t GetFrequency();
@@ -75,6 +80,11 @@ class CVideoReferenceClock : public CThread
     void VblankHandler(int64_t nowtime, double fps);
 #endif
 
+#if defined(HAS_GLX) && defined(HAS_XRANDR)
+    virtual void OnLostDevice();
+    virtual void OnResetDevice();
+#endif
+
   private:
     void    Process();
     bool    UpdateRefreshrate(bool Forced = false);
@@ -121,7 +131,8 @@ class CVideoReferenceClock : public CThread
     GLXContext   m_Context;
     Pixmap       m_pixmap;
     GLXPixmap    m_glPixmap;
-    int          m_RREventBase;
+    bool         m_xrrEvent;
+    CEvent       m_releaseEvent, m_resetEvent;
 
     bool         m_UseNvSettings;
     bool         m_bIsATI;
-- 
1.8.1.6


From ec444ec34ecb704349dc4e82417a8014e4252e3c Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 21 Jun 2012 17:26:51 +0200
Subject: [PATCH 054/123] X11: fix video calibrations

---
 xbmc/windowing/WinSystem.h          |  1 +
 xbmc/windowing/X11/WinSystemX11.cpp | 36 +++++++++++++++++++++++++++++++++++-
 xbmc/windowing/X11/WinSystemX11.h   |  1 +
 3 files changed, 37 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/WinSystem.h b/xbmc/windowing/WinSystem.h
index f1a9d6f..7a812b2 100644
--- a/xbmc/windowing/WinSystem.h
+++ b/xbmc/windowing/WinSystem.h
@@ -103,6 +103,7 @@ class CWinSystemBase
   std::vector<RESOLUTION_WHR> ScreenResolutions(int screen, float refreshrate);
   std::vector<REFRESHRATE> RefreshRates(int screen, int width, int height, uint32_t dwFlags);
   REFRESHRATE DefaultRefreshRate(int screen, std::vector<REFRESHRATE> rates);
+  virtual bool HasCalibration(const RESOLUTION_INFO &resInfo) { return true; };
 
   // text input interface
   virtual void EnableTextInput(bool bEnable) {}
diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 8f56cec..0ead0e8 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -318,7 +318,7 @@ void CWinSystemX11::UpdateResolutions()
       res.strMode.Format("%s: %s @ %.2fHz", out->name.c_str(), mode.name.c_str(), mode.hz);
       res.strOutput    = out->name;
       res.strId        = mode.id;
-      res.iSubtitles   = (int)(0.95*mode.h);
+      res.iSubtitles   = (int)(0.965*mode.h);
       res.fRefreshRate = mode.hz;
       res.bFullScreen  = true;
 
@@ -331,8 +331,42 @@ void CWinSystemX11::UpdateResolutions()
       CDisplaySettings::Get().AddResolutionInfo(res);
     }
   }
+  CDisplaySettings::Get().ApplyCalibrations();
 #endif
+}
+
+bool CWinSystemX11::HasCalibration(const RESOLUTION_INFO &resInfo)
+{
+  XOutput *out = g_xrandr.GetOutput(m_currentOutput);
+
+  // keep calibrations done on a not connected output
+  if (!out->name.Equals(resInfo.strOutput))
+    return true;
+
+  // keep calibrations not updated with resolution data
+  if (resInfo.iWidth == 0)
+    return true;
+
+  float fPixRatio;
+  if (resInfo.iHeight>0 && resInfo.iWidth>0 && out->hmm>0 && out->wmm>0)
+    fPixRatio = ((float)out->wmm/(float)resInfo.iWidth) / (((float)out->hmm/(float)resInfo.iHeight));
+  else
+    fPixRatio = 1.0f;
 
+  if (resInfo.Overscan.left != 0)
+    return true;
+  if (resInfo.Overscan.top != 0)
+    return true;
+  if (resInfo.Overscan.right != resInfo.iWidth)
+    return true;
+  if (resInfo.Overscan.bottom != resInfo.iHeight)
+    return true;
+  if (resInfo.fPixelRatio != fPixRatio)
+    return true;
+  if (resInfo.iSubtitles != (int)(0.965*resInfo.iHeight))
+    return true;
+
+  return false;
 }
 
 void CWinSystemX11::GetConnectedOutputs(std::vector<CStdString> *outputs)
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 2227320..630c0e2 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -61,6 +61,7 @@ class CWinSystemX11 : public CWinSystemBase
   virtual bool Show(bool raise = true);
   virtual void Register(IDispResource *resource);
   virtual void Unregister(IDispResource *resource);
+  virtual bool HasCalibration(const RESOLUTION_INFO &resInfo);
 
   // Local to WinSystemX11 only
   Display*  GetDisplay() { return m_dpy; }
-- 
1.8.1.6


From d29b764e4396e21d57260832012ec8d05ca0f3f8 Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 12:00:26 +0200
Subject: [PATCH 055/123] X11: deactivate screen saver on startup

---
 xbmc/windowing/X11/WinSystemX11.cpp | 29 +++++++++++++++++++++++++++++
 xbmc/windowing/X11/WinSystemX11.h   |  1 +
 2 files changed, 30 insertions(+)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 0ead0e8..c643177 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -519,6 +519,33 @@ void CWinSystemX11::ResetOSScreensaver()
   }
 }
 
+void CWinSystemX11::EnableSystemScreenSaver(bool bEnable)
+{
+  if (!m_dpy)
+    return;
+
+  if (bEnable)
+    XForceScreenSaver(m_dpy, ScreenSaverActive);
+  else
+  {
+    Window root_return, child_return;
+    int root_x_return, root_y_return;
+    int win_x_return, win_y_return;
+    unsigned int mask_return;
+    bool isInWin = XQueryPointer(m_dpy, RootWindow(m_dpy, m_nScreen), &root_return, &child_return,
+                                 &root_x_return, &root_y_return,
+                                 &win_x_return, &win_y_return,
+                                 &mask_return);
+
+    XWarpPointer(m_dpy, None, RootWindow(m_dpy, m_nScreen), 0, 0, 0, 0, root_x_return+300, root_y_return+300);
+    XSync(m_dpy, FALSE);
+    XWarpPointer(m_dpy, None, RootWindow(m_dpy, m_nScreen), 0, 0, 0, 0, 0, 0);
+    XSync(m_dpy, FALSE);
+    XWarpPointer(m_dpy, None, RootWindow(m_dpy, m_nScreen), 0, 0, 0, 0, root_x_return, root_y_return);
+    XSync(m_dpy, FALSE);
+  }
+}
+
 void CWinSystemX11::NotifyAppActiveChange(bool bActivated)
 {
   if (bActivated && m_bWasFullScreenBeforeMinimize && !m_bFullScreen)
@@ -762,6 +789,8 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
   // create main window
   if (!m_glWindow)
   {
+    EnableSystemScreenSaver(false);
+
     GLint att[] =
     {
       GLX_RGBA,
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 630c0e2..f78f613 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -51,6 +51,7 @@ class CWinSystemX11 : public CWinSystemBase
   virtual void ShowOSMouse(bool show);
   virtual void ResetOSScreensaver();
   virtual bool EnableFrameLimiter();
+  virtual void EnableSystemScreenSaver(bool bEnable);
 
   virtual void NotifyAppActiveChange(bool bActivated);
   virtual void NotifyAppFocusChange(bool bGaining);
-- 
1.8.1.6


From 8fc2d01d984fa1dcba0b6a135d085f70e02516f8 Mon Sep 17 00:00:00 2001
From: FernetMenta <fernetmenta@online.de>
Date: Thu, 5 Jul 2012 12:10:09 +0200
Subject: [PATCH 056/123] X11: change method of going full-screen

---
 xbmc/windowing/X11/WinSystemX11.cpp | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index c643177..e1e1096 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -36,6 +36,7 @@
 #include "utils/TimeUtils.h"
 #include "settings/Settings.h"
 #include "windowing/WindowingFactory.h"
+#include <X11/Xatom.h>
 
 #if defined(HAS_XRANDR)
 #include <X11/extensions/Xrandr.h>
@@ -814,7 +815,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     cmap = XCreateColormap(m_dpy, RootWindow(m_dpy, vi->screen), vi->visual, AllocNone);
 
     int def_vis = (vi->visual == DefaultVisual(m_dpy, vi->screen));
-    swa.override_redirect = fullscreen ? True : False;
+    swa.override_redirect = False;
     swa.border_pixel = fullscreen ? 0 : 5;
     swa.background_pixel = def_vis ? BlackPixel(m_dpy, vi->screen) : 0;
     swa.colormap = cmap;
@@ -830,6 +831,12 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
                     InputOutput, vi->visual,
                     mask, &swa);
 
+    if (fullscreen)
+    {
+      Atom fs = XInternAtom(m_dpy, "_NET_WM_STATE_FULLSCREEN", True);
+      XChangeProperty(m_dpy, m_glWindow, XInternAtom(m_dpy, "_NET_WM_STATE", True), XA_ATOM, 32, PropModeReplace, (unsigned char *) &fs, 1);
+    }
+
     // define invisible cursor
     Pixmap bitmapNoData;
     XColor black;
-- 
1.8.1.6


From c0ef76639af991ea31bd9188c431692f3a3c526d Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 28 Jun 2012 19:12:39 +0200
Subject: [PATCH 057/123] X11: reset key repeat and key modifier on focus lost
 and gain

---
 xbmc/windowing/WinEventsX11.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index c58067b..c9f8a20 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -359,6 +359,8 @@ bool CWinEventsX11::MessagePump()
         if (WinEvents->m_xic)
           XSetICFocus(WinEvents->m_xic);
         g_application.m_AppFocused = true;
+        memset(&(WinEvents->m_lastKey), 0, sizeof(XBMC_Event));
+        WinEvents->m_keymodState = 0;
         if (serial == xevent.xfocus.serial)
           break;
         g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
@@ -370,6 +372,7 @@ bool CWinEventsX11::MessagePump()
         if (WinEvents->m_xic)
           XUnsetICFocus(WinEvents->m_xic);
         g_application.m_AppFocused = false;
+        memset(&(WinEvents->m_lastKey), 0, sizeof(XBMC_Event));
         g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
         serial = xevent.xfocus.serial;
         break;
-- 
1.8.1.6


From c7a3b7a4ce52000bbdb260e9f2142297bb531617 Mon Sep 17 00:00:00 2001
From: Joakim Plate <elupus@xbmc.org>
Date: Thu, 5 Jul 2012 14:18:46 +0200
Subject: [PATCH 058/123] X11: replace custom utf8 to unicode with charset
 convertor (squash to x11 events)

---
 xbmc/windowing/WinEventsX11.cpp | 119 ++++------------------------------------
 xbmc/windowing/WinEventsX11.h   |   2 -
 2 files changed, 11 insertions(+), 110 deletions(-)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index c9f8a20..1a81d05 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -32,6 +32,7 @@
 #include "X11/keysymdef.h"
 #include "X11/XF86keysym.h"
 #include "utils/log.h"
+#include "utils/CharsetConverter.h"
 #include "guilib/GUIWindowManager.h"
 #include "input/MouseStat.h"
 
@@ -161,7 +162,6 @@
   m_display = 0;
   m_window = 0;
   m_keybuf = 0;
-  m_utf16buf = 0;
 }
 
 CWinEventsX11::~CWinEventsX11()
@@ -172,12 +172,6 @@
     m_keybuf = 0;
   }
 
-  if (m_utf16buf)
-  {
-    free(m_utf16buf);
-    m_utf16buf = 0;
-  }
-
   if (m_xic)
   {
     XUnsetICFocus(m_xic);
@@ -203,7 +197,6 @@ bool CWinEventsX11::Init(Display *dpy, Window win)
   WinEvents->m_display = dpy;
   WinEvents->m_window = win;
   WinEvents->m_keybuf = (char*)malloc(32*sizeof(char));
-  WinEvents->m_utf16buf = (uint16_t*)malloc(32*sizeof(uint16_t));
   WinEvents->m_keymodState = 0;
   WinEvents->m_wmDeleteMessage = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
   WinEvents->m_structureChanged = false;
@@ -433,8 +426,6 @@ bool CWinEventsX11::MessagePump()
         }
 
         Status status;
-        int utf16size;
-        int utf16length;
         int len;
         len = Xutf8LookupString(WinEvents->m_xic, &xevent.xkey,
                                 WinEvents->m_keybuf, sizeof(WinEvents->m_keybuf),
@@ -453,36 +444,29 @@ bool CWinEventsX11::MessagePump()
           case XLookupChars:
           case XLookupBoth:
           {
-            if (len == 0)
-              break;
-            utf16size = len * sizeof(uint16_t);
-            if (utf16size > sizeof(WinEvents->m_utf16buf))
-            {
-              WinEvents->m_utf16buf = (uint16_t *)realloc(WinEvents->m_utf16buf,utf16size);
-              if (WinEvents->m_utf16buf == NULL)
-              {
-                break;
-              }
-            }
-            utf16length = Utf8ToUnicode(WinEvents->m_keybuf, len, WinEvents->m_utf16buf, utf16size);
-            if (utf16length < 0)
+            CStdString   data(WinEvents->m_keybuf, len);
+            CStdStringW keys;
+            g_charsetConverter.utf8ToW(data, keys, false);
+
+            if (keys.length() == 0)
             {
               break;
             }
-            for (unsigned int i = 0; i < utf16length - 1; i++)
+
+            for (unsigned int i = 0; i < keys.length() - 1; i++)
             {
               newEvent.key.keysym.sym = XBMCK_UNKNOWN;
-              newEvent.key.keysym.unicode = WinEvents->m_utf16buf[i];
+              newEvent.key.keysym.unicode = keys[i];
               newEvent.key.state = xevent.xkey.state;
               newEvent.key.type = xevent.xkey.type;
               ret |= ProcessKey(newEvent, 500);
             }
-            if (utf16length > 0)
+            if (keys.length() > 0)
             {
               newEvent.key.keysym.scancode = xevent.xkey.keycode;
               xkeysym = XLookupKeysym(&xevent.xkey, 0);
               newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
-              newEvent.key.keysym.unicode = WinEvents->m_utf16buf[utf16length - 1];
+              newEvent.key.keysym.unicode = keys[keys.length() - 1];
               newEvent.key.state = xevent.xkey.state;
               newEvent.key.type = xevent.xkey.type;
 
@@ -743,87 +727,6 @@ bool CWinEventsX11::ProcessKeyRepeat()
   return false;
 }
 
-int CWinEventsX11::Utf8ToUnicode(const char *utf8, const int utf8Length, uint16_t *utf16, const int utf16MaxLength)
-{
-  // p moves over the output buffer.  max_ptr points to the next to the last slot of the buffer.
-  uint16_t *p = utf16;
-  uint16_t const *const maxPtr = utf16 + utf16MaxLength;
-
-  // end_of_input points to the last byte of input as opposed to the next to the last byte.
-  char const *const endOfInput = utf8 + utf8Length - 1;
-
-  while (utf8 <= endOfInput)
-  {
-    unsigned char const c = *utf8;
-    if (p >= maxPtr)
-    {
-      //No more output space.
-      return -1;
-    }
-    if (c < 0x80)
-    {
-      //One byte ASCII.
-      *p++ = c;
-      utf8 += 1;
-    }
-    else if (c < 0xC0)
-    {
-      // Follower byte without preceding leader bytes.
-      return -1;
-    }
-    // 11 bits
-    else if (c < 0xE0)
-    {
-      // Two byte sequence.  We need one follower byte.
-      if (endOfInput - utf8 < 1 || (((utf8[1] ^ 0x80)) & 0xC0))
-      {
-        return -1;
-      }
-      *p++ = (uint16_t)(((c & 0x1F) << 6) + (utf8[1] & 0x3F));
-      utf8 += 2;
-    }
-    // 16 bis
-    else if (c < 0xF0)
-    {
-      // Three byte sequence.  We need two follower byte.
-      if (endOfInput - utf8 < 2 || ((utf8[1] ^ 0x80) & 0xC0) || ((utf8[2] ^ 0x80) & 0xC0))
-      {
-        return -1;
-      }
-      *p++ = (uint16_t)(((c & 0xF) << 12) + ((utf8[1] & 0x3F) << 6) + (utf8[2] & 0x3F));
-      utf8 += 3;
-    }
-    // 21 bits
-    else if (c < 0xF8)
-    {
-      int plane;
-      // Four byte sequence.  We need three follower bytes.
-      if (endOfInput - utf8 < 3 || ((utf8[1] ^ 0x80) & 0xC0) ||
-          ((utf8[2] ^ 0x80) & 0xC0) || ((utf8[3] ^ 0x80) & 0xC0))
-      {
-        return -1;
-      }
-      uint32_t unicode = ((c & 0x7) << 18) + ((utf8[1] & 0x3F) << 12) +
-                          ((utf8[2] & 0x3F) << 6) + (utf8[3] & 0x3F);
-      utf8 += 4;
-      CLog::Log(LOGERROR, "CWinEventsX11::Utf8ToUnicode: 4 byte unicode not supported");
-    }
-    // 26 bits
-    else if (c < 0xFC)
-    {
-      CLog::Log(LOGERROR, "CWinEventsX11::Utf8ToUnicode: 4 byte unicode not supported");
-      utf8 += 5;
-    }
-    // 31 bit
-    else
-    {
-      CLog::Log(LOGERROR, "CWinEventsX11::Utf8ToUnicode: 4 byte unicode not supported");
-      utf8 += 6;
-    }
-  }
-  return p - utf16;
-}
-
 XBMCKey CWinEventsX11::LookupXbmcKeySym(KeySym keysym)
 {
   // try direct mapping first
diff --git a/xbmc/windowing/WinEventsX11.h b/xbmc/windowing/WinEventsX11.h
index 6100933..72955ad 100644
--- a/xbmc/windowing/WinEventsX11.h
+++ b/xbmc/windowing/WinEventsX11.h
@@ -38,7 +38,6 @@ class CWinEventsX11 : public CWinEventsBase
   static bool MessagePump();
 
 protected:
-  static int Utf8ToUnicode(const char *utf8, const int utf8Length, uint16_t *utf16, const int utf16MaxLength);
   static XBMCKey LookupXbmcKeySym(KeySym keysym);
   static bool ProcessKey(XBMC_Event &event, int repeatDelay);
   static bool ProcessKeyRepeat();
@@ -48,7 +47,6 @@ class CWinEventsX11 : public CWinEventsBase
   Window m_window;
   Atom m_wmDeleteMessage;
   char *m_keybuf;
-  uint16_t *m_utf16buf;
   XIM m_xim;
   XIC m_xic;
   XBMC_Event m_lastKey;
-- 
1.8.1.6


From b99781ba1c13380f8c98414fd2b0e7735da27046 Mon Sep 17 00:00:00 2001
From: Joakim Plate <elupus@xbmc.org>
Date: Thu, 5 Jul 2012 14:23:54 +0200
Subject: [PATCH 059/123] X11: fixed invalid usage of sizeof() (squash into x11
 changes)

---
 xbmc/windowing/WinEventsX11.cpp | 11 +++++++----
 xbmc/windowing/WinEventsX11.h   |  1 +
 2 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index 1a81d05..4a5aab4 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -162,6 +162,7 @@
   m_display = 0;
   m_window = 0;
   m_keybuf = 0;
+  m_keybuf_len = 0;
 }
 
 CWinEventsX11::~CWinEventsX11()
@@ -196,7 +197,8 @@ bool CWinEventsX11::Init(Display *dpy, Window win)
   WinEvents = new CWinEventsX11();
   WinEvents->m_display = dpy;
   WinEvents->m_window = win;
-  WinEvents->m_keybuf = (char*)malloc(32*sizeof(char));
+  WinEvents->m_keybuf_len = 32*sizeof(char);
+  WinEvents->m_keybuf = (char*)malloc(WinEvents->m_keybuf_len);
   WinEvents->m_keymodState = 0;
   WinEvents->m_wmDeleteMessage = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
   WinEvents->m_structureChanged = false;
@@ -428,13 +430,14 @@ bool CWinEventsX11::MessagePump()
         Status status;
         int len;
         len = Xutf8LookupString(WinEvents->m_xic, &xevent.xkey,
-                                WinEvents->m_keybuf, sizeof(WinEvents->m_keybuf),
+                                WinEvents->m_keybuf, WinEvents->m_keybuf_len,
                                 &xkeysym, &status);
         if (status == XBufferOverflow)
         {
-          WinEvents->m_keybuf = (char*)realloc(WinEvents->m_keybuf, len*sizeof(char));
+          WinEvents->m_keybuf_len = len;
+          WinEvents->m_keybuf = (char*)realloc(WinEvents->m_keybuf, WinEvents->m_keybuf_len);
           len = Xutf8LookupString(WinEvents->m_xic, &xevent.xkey,
-                                  WinEvents->m_keybuf, sizeof(WinEvents->m_keybuf),
+                                  WinEvents->m_keybuf, WinEvents->m_keybuf_len,
                                   &xkeysym, &status);
         }
         switch (status)
diff --git a/xbmc/windowing/WinEventsX11.h b/xbmc/windowing/WinEventsX11.h
index 72955ad..102a076 100644
--- a/xbmc/windowing/WinEventsX11.h
+++ b/xbmc/windowing/WinEventsX11.h
@@ -47,6 +47,7 @@ class CWinEventsX11 : public CWinEventsBase
   Window m_window;
   Atom m_wmDeleteMessage;
   char *m_keybuf;
+  size_t m_keybuf_len;
   XIM m_xim;
   XIC m_xic;
   XBMC_Event m_lastKey;
-- 
1.8.1.6


From b279aabe373a8a7e2bfc65e2a7f5c9f539b2d86e Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sat, 9 Jun 2012 18:23:53 +0200
Subject: [PATCH 060/123] add missing keys to xbmc keytable

---
 xbmc/input/XBMC_keytable.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/input/XBMC_keytable.cpp b/xbmc/input/XBMC_keytable.cpp
index f18e9b1..066cd77 100644
--- a/xbmc/input/XBMC_keytable.cpp
+++ b/xbmc/input/XBMC_keytable.cpp
@@ -179,6 +179,8 @@
 , { XBMCK_LAUNCH_APP2,            0,    0, XBMCVK_LAUNCH_APP2,         "launch_app2_pc_icon" }
 , { XBMCK_LAUNCH_FILE_BROWSER,    0,    0, XBMCVK_LAUNCH_FILE_BROWSER, "launch_file_browser" }
 , { XBMCK_LAUNCH_MEDIA_CENTER,    0,    0, XBMCVK_LAUNCH_MEDIA_CENTER, "launch_media_center" }
+, { XBMCK_PLAY,                   0,    0, XBMCVK_MEDIA_PLAY_PAUSE,    "play_pause" }
+, { XBMCK_STOP,                   0,    0, XBMCVK_MEDIA_STOP,          "stop" }
 
 // Function keys
 , { XBMCK_F1,                     0,    0, XBMCVK_F1,            "f1"}
-- 
1.8.1.6


From 156e9d1e3b67b4444366009b19b47410fd4ee60a Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Fri, 16 Mar 2012 15:57:51 +0100
Subject: [PATCH 061/123] videorefclock: temp deactivate of nv settings

---
 xbmc/video/VideoReferenceClock.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/video/VideoReferenceClock.cpp b/xbmc/video/VideoReferenceClock.cpp
index 4287e8f..21f59b8 100644
--- a/xbmc/video/VideoReferenceClock.cpp
+++ b/xbmc/video/VideoReferenceClock.cpp
@@ -135,7 +135,7 @@
   m_Context = NULL;
   m_pixmap = None;
   m_glPixmap = None;
-  m_UseNvSettings = true;
+  m_UseNvSettings = false;
   m_bIsATI = false;
 #endif
 }
-- 
1.8.1.6


From 0a143d6a5ea9581125f476c892ab9deb93730d4b Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 20 Aug 2012 09:09:09 +0200
Subject: [PATCH 062/123] videorefclock: ask graphics context for refresh rate

---
 xbmc/video/VideoReferenceClock.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/video/VideoReferenceClock.cpp b/xbmc/video/VideoReferenceClock.cpp
index 21f59b8..0156b2c 100644
--- a/xbmc/video/VideoReferenceClock.cpp
+++ b/xbmc/video/VideoReferenceClock.cpp
@@ -30,6 +30,7 @@
   #include <sstream>
   #include <X11/extensions/Xrandr.h>
   #include "windowing/WindowingFactory.h"
+  #include "guilib/GraphicContext.h"
   #define NVSETTINGSCMD "nvidia-settings -nt -q RefreshRate3"
 #elif defined(TARGET_DARWIN_OSX)
   #include <QuartzCore/CVDisplayLink.h>
@@ -1254,7 +1255,7 @@ bool CVideoReferenceClock::UpdateRefreshrate(bool Forced /*= false*/)
   }
 
   CSingleLock SingleLock(m_CritSection);
-  m_RefreshRate = GetRandRRate();
+  m_RefreshRate = MathUtils::round_int(g_graphicsContext.GetFPS());
 
   CLog::Log(LOGDEBUG, "CVideoReferenceClock: Detected refreshrate: %i hertz", (int)m_RefreshRate);
 
-- 
1.8.1.6


From 224633df916fd15c03b9042ce8ac4d23912ce4cc Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 9 Jul 2012 14:00:18 +0200
Subject: [PATCH 063/123] X11: fix icon texture after
 cc5ed3c2474084ebc0373a3046410e6f766e03f4

---
 xbmc/windowing/X11/WinSystemX11.cpp | 43 ++++++++++++++++++++++---------------
 1 file changed, 26 insertions(+), 17 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index e1e1096..ace57ff 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -872,22 +872,24 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     if (!fullscreen)
     {
       CreateIconPixmap();
-      XWMHints wm_hints;
-      XClassHint class_hints;
+      XWMHints *wm_hints;
       XTextProperty windowName, iconName;
       std::string titleString = "XBMC Media Center";
       char *title = (char*)titleString.c_str();
 
       XStringListToTextProperty(&title, 1, &windowName);
       XStringListToTextProperty(&title, 1, &iconName);
-      wm_hints.initial_state = NormalState;
-      wm_hints.input = True;
-      wm_hints.icon_pixmap = m_icon;
-      wm_hints.flags = StateHint | IconPixmapHint | InputHint;
 
+      wm_hints = XAllocWMHints();
+      wm_hints->initial_state = NormalState;
+      wm_hints->icon_pixmap = m_icon;
+      wm_hints->flags = StateHint | IconPixmapHint;
+
+      XSync(m_dpy,False);
       XSetWMProperties(m_dpy, m_glWindow, &windowName, &iconName,
-                            NULL, 0, NULL, &wm_hints,
+                            NULL, 0, NULL, wm_hints,
                             NULL);
+      XFree(wm_hints);
 
       // register interest in the delete window message
       Atom wmDeleteMessage = XInternAtom(m_dpy, "WM_DELETE_WINDOW", False);
@@ -972,16 +974,21 @@ bool CWinSystemX11::CreateIconPixmap()
   gRatio = vis->green_mask / 255.0;
   bRatio = vis->blue_mask / 255.0;
 
-  CTexture iconTexture;
-  iconTexture.LoadFromFile("special://xbmc/media/icon.png");
-  buf = iconTexture.GetPixels();
+  CBaseTexture *iconTexture = CBaseTexture::LoadFromFile("special://xbmc/media/icon.png");
+
+  if (!iconTexture)
+    return false;
 
-  numBufBytes = iconTexture.GetWidth() * iconTexture.GetHeight() * 4;
+  buf = iconTexture->GetPixels();
+
+  numBufBytes = iconTexture->GetWidth() * iconTexture->GetHeight() * 4;
+  int wid = iconTexture->GetWidth();
+  int hi = iconTexture->GetHeight();
 
   if (depth>=24)
-    numNewBufBytes = (4 * (iconTexture.GetWidth() * iconTexture.GetHeight()));
+    numNewBufBytes = (4 * (iconTexture->GetWidth() * iconTexture->GetHeight()));
   else
-    numNewBufBytes = (2 * (iconTexture.GetWidth() * iconTexture.GetHeight()));
+    numNewBufBytes = (2 * (iconTexture->GetWidth() * iconTexture->GetHeight()));
 
   newBuf = (uint32_t*)malloc(numNewBufBytes);
   if (!newBuf)
@@ -990,11 +997,11 @@ bool CWinSystemX11::CreateIconPixmap()
     return false;
   }
 
-  for (i=0; i<iconTexture.GetHeight();++i)
+  for (i=0; i<iconTexture->GetHeight();++i)
   {
-    for (j=0; j<iconTexture.GetWidth();++j)
+    for (j=0; j<iconTexture->GetWidth();++j)
     {
-      unsigned int pos = i*iconTexture.GetPitch()+j*4;
+      unsigned int pos = i*iconTexture->GetPitch()+j*4;
       unsigned int r, g, b;
       r = (buf[pos+2] * rRatio);
       g = (buf[pos+1] * gRatio);
@@ -1007,7 +1014,7 @@ bool CWinSystemX11::CreateIconPixmap()
     }
   }
   img = XCreateImage(m_dpy, vis, depth,ZPixmap, 0, (char *)newBuf,
-                     iconTexture.GetWidth(), iconTexture.GetHeight(),
+                     iconTexture->GetWidth(), iconTexture->GetHeight(),
                      (depth>=24)?32:16, 0);
   if (!img)
   {
@@ -1045,6 +1052,8 @@ bool CWinSystemX11::CreateIconPixmap()
   XFreeGC(m_dpy, gc);
   XDestroyImage(img); // this also frees newBuf
 
+  delete iconTexture;
+
   return true;
 }
 
-- 
1.8.1.6


From e5eac0a49cf2bf417683ea22d185424473b846b8 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Tue, 10 Jul 2012 11:14:12 +0200
Subject: [PATCH 064/123] X11: check for window manager

---
 xbmc/windowing/X11/WinSystemX11.cpp | 74 ++++++++++++++++++++++++++++++++++++-
 xbmc/windowing/X11/WinSystemX11.h   |  1 +
 2 files changed, 73 insertions(+), 2 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index ace57ff..188864b 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -814,8 +814,10 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     vi = glXChooseVisual(m_dpy, m_nScreen, att);
     cmap = XCreateColormap(m_dpy, RootWindow(m_dpy, vi->screen), vi->visual, AllocNone);
 
+    bool hasWM = HasWindowManager();
+
     int def_vis = (vi->visual == DefaultVisual(m_dpy, vi->screen));
-    swa.override_redirect = False;
+    swa.override_redirect = hasWM ? False : True;
     swa.border_pixel = fullscreen ? 0 : 5;
     swa.background_pixel = def_vis ? BlackPixel(m_dpy, vi->screen) : 0;
     swa.colormap = cmap;
@@ -831,7 +833,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
                     InputOutput, vi->visual,
                     mask, &swa);
 
-    if (fullscreen)
+    if (fullscreen && hasWM)
     {
       Atom fs = XInternAtom(m_dpy, "_NET_WM_STATE_FULLSCREEN", True);
       XChangeProperty(m_dpy, m_glWindow, XInternAtom(m_dpy, "_NET_WM_STATE", True), XA_ATOM, 32, PropModeReplace, (unsigned char *) &fs, 1);
@@ -1057,4 +1059,72 @@ bool CWinSystemX11::CreateIconPixmap()
   return true;
 }
 
+bool CWinSystemX11::HasWindowManager()
+{
+  Window wm_check;
+  unsigned char *data;
+  int status, real_format;
+  Atom real_type, prop;
+  unsigned long items_read, items_left, i;
+  char req = 0;
+
+  prop = XInternAtom(m_dpy, "_NET_SUPPORTING_WM_CHECK", True);
+  if (prop == None)
+    return false;
+  status = XGetWindowProperty(m_dpy, DefaultRootWindow(m_dpy), prop,
+                      0L, 1L, False, XA_WINDOW, &real_type, &real_format,
+                      &items_read, &items_left, &data);
+  if(status != Success || ! items_read)
+  {
+    if(status == Success)
+      XFree(data);
+    return false;
+  }
+
+  wm_check = ((Window*)data)[0];
+  XFree(data);
+
+  status = XGetWindowProperty(m_dpy, wm_check, prop,
+                      0L, 1L, False, XA_WINDOW, &real_type, &real_format,
+                      &items_read, &items_left, &data);
+
+  if(status != Success || !items_read)
+  {
+    if(status == Success)
+      XFree(data);
+    return false;
+  }
+
+  if(wm_check != ((Window*)data)[0])
+  {
+    XFree(data);
+    return false;
+  }
+
+  XFree(data);
+
+  prop = XInternAtom(m_dpy, "_NET_WM_NAME", True);
+  if (prop == None)
+  {
+    CLog::Log(LOGDEBUG,"Window Manager Name: ");
+    return true;
+  }
+
+  status = XGetWindowProperty(m_dpy, wm_check, prop,
+                        0L, (~0L), False, AnyPropertyType, &real_type, &real_format,
+                        &items_read, &items_left, &data);
+
+  if(status == Success && items_read)
+  {
+    CLog::Log(LOGDEBUG,"Window Manager Name: %s", data);
+  }
+  else
+    CLog::Log(LOGDEBUG,"Window Manager Name: ");
+
+  if(status == Success)
+    XFree(data);
+
+  return true;
+}
+
 #endif
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index f78f613..f479c27 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -101,6 +101,7 @@ class CWinSystemX11 : public CWinSystemBase
   bool IsSuitableVisual(XVisualInfo *vInfo);
   static int XErrorHandler(Display* dpy, XErrorEvent* error);
   bool CreateIconPixmap();
+  bool HasWindowManager();
 
   CStopWatch m_screensaverReset;
 };
-- 
1.8.1.6


From 1e0e335c33da59271313f587d14bec4fcda1db15 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 12 Jul 2012 11:11:47 +0200
Subject: [PATCH 065/123] X11: dont set window on xrandr if no mode available

---
 xbmc/windowing/X11/WinSystemX11.cpp | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 188864b..076ed82 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -663,16 +663,17 @@ void CWinSystemX11::NotifyXRREvent()
   CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
   m_windowDirty = true;
 
+  if (!g_xrandr.Query(true))
+  {
+    CLog::Log(LOGERROR, "WinSystemX11::RefreshWindow - failed to query xrandr");
+    return;
+  }
+
   // if external event update resolutions
   if (!m_bIsInternalXrr)
   {
     UpdateResolutions();
   }
-  else if (!g_xrandr.Query(true))
-  {
-    CLog::Log(LOGERROR, "WinSystemX11::RefreshWindow - failed to query xrandr");
-    return;
-  }
   m_bIsInternalXrr = false;
 
   CStdString currentOutput = CSettings::Get().GetString("videoscreen.monitor");
-- 
1.8.1.6


From 8a637a5c920ad2491e1f45c36ada25fd675fe8e3 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 26 Jul 2012 09:34:28 +0200
Subject: [PATCH 066/123] X11: fix crash after a resolution change on startup

---
 xbmc/windowing/X11/WinSystemX11.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 076ed82..ee339d9 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -221,7 +221,8 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
     OnLostDevice();
     m_bIsInternalXrr = true;
     g_xrandr.SetMode(out, mode);
-    return true;
+    if (m_glWindow)
+      return true;
   }
 #endif
 
-- 
1.8.1.6


From 6fdb9269d58e784b1ffe846707732faadf505974 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sat, 15 Sep 2012 18:27:29 +0200
Subject: [PATCH 067/123] X11: lock graphics context in NotifyXRREvent

---
 xbmc/windowing/X11/WinSystemX11.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index ee339d9..d2dcccd 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -664,6 +664,8 @@ void CWinSystemX11::NotifyXRREvent()
   CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
   m_windowDirty = true;
 
+  CSingleLock lock(g_graphicsContext);
+
   if (!g_xrandr.Query(true))
   {
     CLog::Log(LOGERROR, "WinSystemX11::RefreshWindow - failed to query xrandr");
-- 
1.8.1.6


From cf823969dd79b155ccf6e797312ec447da8c80a9 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 8 Oct 2011 16:45:13 +0200
Subject: [PATCH 068/123] ffmpeg: add xvba hwaccel

---
 lib/ffmpeg/configure                  |  11 ++
 lib/ffmpeg/libavcodec/Makefile        |   6 ++
 lib/ffmpeg/libavcodec/allcodecs.c     |   4 +
 lib/ffmpeg/libavcodec/h264.c          |   3 +
 lib/ffmpeg/libavcodec/xvba.c          |  66 ++++++++++++
 lib/ffmpeg/libavcodec/xvba.h          |  71 +++++++++++++
 lib/ffmpeg/libavcodec/xvba_h264.c     | 192 ++++++++++++++++++++++++++++++++++
 lib/ffmpeg/libavcodec/xvba_internal.h |  24 +++++
 lib/ffmpeg/libavcodec/xvba_mpeg2.c    |  52 +++++++++
 lib/ffmpeg/libavcodec/xvba_vc1.c      | 190 +++++++++++++++++++++++++++++++++
 lib/ffmpeg/libavutil/pixdesc.c        |   6 ++
 lib/ffmpeg/libavutil/pixfmt.h         |   1 +
 12 files changed, 626 insertions(+)
 create mode 100644 lib/ffmpeg/libavcodec/xvba.c
 create mode 100644 lib/ffmpeg/libavcodec/xvba.h
 create mode 100644 lib/ffmpeg/libavcodec/xvba_h264.c
 create mode 100644 lib/ffmpeg/libavcodec/xvba_internal.h
 create mode 100644 lib/ffmpeg/libavcodec/xvba_mpeg2.c
 create mode 100644 lib/ffmpeg/libavcodec/xvba_vc1.c

diff --git a/lib/ffmpeg/configure b/lib/ffmpeg/configure
index 351611d..876a6ea 100755
--- a/lib/ffmpeg/configure
+++ b/lib/ffmpeg/configure
@@ -144,6 +144,7 @@ Hardware accelerators:
   --enable-vaapi           enable VAAPI code
   --enable-vda             enable VDA code
   --enable-vdpau           enable VDPAU code
+  --disable-xvba           disable XVBA code
 
 Individual component options:
   --disable-everything     disable all components listed below
@@ -1197,6 +1198,7 @@ HWACCEL_LIST="
     vaapi
     vda
     vdpau
+    xvba
 "
 
 LIBRARY_LIST="
@@ -1827,6 +1829,7 @@ crystalhd_deps="libcrystalhd_libcrystalhd_if_h"
 dxva2_deps="dxva2api_h"
 vaapi_deps="va_va_h"
 vda_deps="VideoDecodeAcceleration_VDADecoder_h pthreads"
+xvba_deps="amd_amdxvba_h"
 vda_extralibs="-framework CoreFoundation -framework VideoDecodeAcceleration -framework QuartzCore"
 vdpau_deps="vdpau_vdpau_h vdpau_vdpau_x11_h"
 
@@ -1847,6 +1850,8 @@ h264_vdpau_decoder_deps="vdpau"
 h264_vdpau_decoder_select="h264_decoder"
 h264_vdpau_hwaccel_deps="vdpau"
 h264_vdpau_hwaccel_select="h264_decoder"
+h264_xvba_hwaccel_select="h264_decoder"
+h264_xvba_hwaccel_deps="xvba"
 mpeg_vdpau_decoder_deps="vdpau"
 mpeg_vdpau_decoder_select="mpegvideo_decoder"
 mpeg1_vdpau_decoder_deps="vdpau"
@@ -1859,6 +1864,8 @@ mpeg2_dxva2_hwaccel_select="mpeg2video_decoder"
 mpeg2_vaapi_hwaccel_deps="vaapi"
 mpeg2_vaapi_hwaccel_select="mpeg2video_decoder"
 mpeg2_vdpau_hwaccel_deps="vdpau"
+mpeg2_xvba_hwaccel_select="mpeg2video_decoder"
+mpeg2_xvba_hwaccel_deps="xvba"
 mpeg2_vdpau_hwaccel_select="mpeg2video_decoder"
 mpeg4_crystalhd_decoder_select="crystalhd"
 mpeg4_vaapi_hwaccel_deps="vaapi"
@@ -1877,11 +1884,14 @@ vc1_vdpau_decoder_deps="vdpau"
 vc1_vdpau_decoder_select="vc1_decoder"
 vc1_vdpau_hwaccel_deps="vdpau"
 vc1_vdpau_hwaccel_select="vc1_decoder"
+vc1_xvba_hwaccel_select="vc1_decoder"
+vc1_xvba_hwaccel_deps="xvba"
 wmv3_crystalhd_decoder_select="crystalhd"
 wmv3_dxva2_hwaccel_select="vc1_dxva2_hwaccel"
 wmv3_vaapi_hwaccel_select="vc1_vaapi_hwaccel"
 wmv3_vdpau_decoder_select="vc1_vdpau_decoder"
 wmv3_vdpau_hwaccel_select="vc1_vdpau_hwaccel"
+wmv3_xvba_hwaccel_select="vc1_xvba_hwaccel"
 
 # parsers
 h264_parser_select="golomb h264chroma h264dsp h264pred h264qpel videodsp"
@@ -3832,6 +3842,7 @@ check_header termios.h
 check_header unistd.h
 check_header vdpau/vdpau.h
 check_header vdpau/vdpau_x11.h
+check_header amd/amdxvba.h
 check_cpp_condition vdpau/vdpau.h "defined(VDP_DECODER_PROFILE_MPEG4_PART2_SP)" && enable vdpau_mpeg4_support
 
 check_header VideoDecodeAcceleration/VDADecoder.h
diff --git a/lib/ffmpeg/libavcodec/Makefile b/lib/ffmpeg/libavcodec/Makefile
index dc065a5..c386923 100644
--- a/lib/ffmpeg/libavcodec/Makefile
+++ b/lib/ffmpeg/libavcodec/Makefile
@@ -12,6 +12,7 @@ HEADERS = avcodec.h                                                     \
           vdpau.h                                                       \
           version.h                                                     \
           xvmc.h                                                        \
+          xvba.h                                                        \
 
 OBJS = allcodecs.o                                                      \
        audioconvert.o                                                   \
@@ -73,6 +74,7 @@ OBJS-$(CONFIG_SHARED)                  += log2_tab.o
 OBJS-$(CONFIG_SINEWIN)                 += sinewin.o
 OBJS-$(CONFIG_VAAPI)                   += vaapi.o
 OBJS-$(CONFIG_VDPAU)                   += vdpau.o
+OBJS-$(CONFIG_XVBA)                    += xvba.o
 OBJS-$(CONFIG_VIDEODSP)                += videodsp.o
 OBJS-$(CONFIG_VP3DSP)                  += vp3dsp.o
 
@@ -232,6 +234,7 @@ OBJS-$(CONFIG_H264_VAAPI_HWACCEL)      += vaapi_h264.o
 OBJS-$(CONFIG_H264_VDA_HWACCEL)        += vda_h264.o
 OBJS-$(CONFIG_H264_VDA_DECODER)        += vda_h264_dec.o
 OBJS-$(CONFIG_H264_VDPAU_HWACCEL)      += vdpau_h264.o
+OBJS-$(CONFIG_H264_XVBA_HWACCEL)       += xvba_h264.o
 OBJS-$(CONFIG_HUFFYUV_DECODER)         += huffyuv.o huffyuvdec.o
 OBJS-$(CONFIG_HUFFYUV_ENCODER)         += huffyuv.o huffyuvenc.o
 OBJS-$(CONFIG_IAC_DECODER)             += imc.o
@@ -295,6 +298,7 @@ OBJS-$(CONFIG_MPEG1VIDEO_ENCODER)      += mpeg12enc.o mpeg12.o          \
 OBJS-$(CONFIG_MPEG2_DXVA2_HWACCEL)     += dxva2_mpeg2.o
 OBJS-$(CONFIG_MPEG2_VAAPI_HWACCEL)     += vaapi_mpeg2.o
 OBJS-$(CONFIG_MPEG2_VDPAU_HWACCEL)     += vdpau_mpeg12.o
+OBJS-$(CONFIG_MPEG2_XVBA_HWACCEL)      += xvba_mpeg2.o
 OBJS-$(CONFIG_MPEG2VIDEO_DECODER)      += mpeg12.o mpeg12data.o
 OBJS-$(CONFIG_MPEG2VIDEO_ENCODER)      += mpeg12enc.o mpeg12.o          \
                                           timecode.o
@@ -459,6 +463,7 @@ OBJS-$(CONFIG_VC1_DECODER)             += vc1dec.o vc1.o vc1data.o vc1dsp.o \
 OBJS-$(CONFIG_VC1_DXVA2_HWACCEL)       += dxva2_vc1.o
 OBJS-$(CONFIG_VC1_VAAPI_HWACCEL)       += vaapi_vc1.o
 OBJS-$(CONFIG_VC1_VDPAU_HWACCEL)       += vdpau_vc1.o
+OBJS-$(CONFIG_VC1_XVBA_HWACCEL)        += xvba_vc1.o
 OBJS-$(CONFIG_VCR1_DECODER)            += vcr1.o
 OBJS-$(CONFIG_VMDAUDIO_DECODER)        += vmdav.o
 OBJS-$(CONFIG_VMDVIDEO_DECODER)        += vmdav.o
@@ -788,6 +793,7 @@ SKIPHEADERS-$(CONFIG_LIBSCHROEDINGER)  += libschroedinger.h
 SKIPHEADERS-$(CONFIG_LIBUTVIDEO)       += libutvideo.h
 SKIPHEADERS-$(CONFIG_MPEG_XVMC_DECODER) += xvmc.h
 SKIPHEADERS-$(CONFIG_VAAPI)            += vaapi_internal.h
+SKIPHEADERS-$(CONFIG_XVBA)             += xvba_internal.h
 SKIPHEADERS-$(CONFIG_VDA)              += vda.h
 SKIPHEADERS-$(CONFIG_VDPAU)            += vdpau.h
 SKIPHEADERS-$(HAVE_OS2THREADS)         += os2threads.h
diff --git a/lib/ffmpeg/libavcodec/allcodecs.c b/lib/ffmpeg/libavcodec/allcodecs.c
index 584446f..7a8f61c 100644
--- a/lib/ffmpeg/libavcodec/allcodecs.c
+++ b/lib/ffmpeg/libavcodec/allcodecs.c
@@ -79,18 +79,22 @@ void avcodec_register_all(void)
     REGISTER_HWACCEL(H264_VAAPI,        h264_vaapi);
     REGISTER_HWACCEL(H264_VDA,          h264_vda);
     REGISTER_HWACCEL(H264_VDPAU,        h264_vdpau);
+    REGISTER_HWACCEL(H264_XVBA,         h264_xvba);
     REGISTER_HWACCEL(MPEG1_VDPAU,       mpeg1_vdpau);
     REGISTER_HWACCEL(MPEG2_DXVA2,       mpeg2_dxva2);
     REGISTER_HWACCEL(MPEG2_VAAPI,       mpeg2_vaapi);
     REGISTER_HWACCEL(MPEG2_VDPAU,       mpeg2_vdpau);
+    REGISTER_HWACCEL(MPEG2_XVBA,        mpeg2_xvba);
     REGISTER_HWACCEL(MPEG4_VAAPI,       mpeg4_vaapi);
     REGISTER_HWACCEL(MPEG4_VDPAU,       mpeg4_vdpau);
     REGISTER_HWACCEL(VC1_DXVA2,         vc1_dxva2);
     REGISTER_HWACCEL(VC1_VAAPI,         vc1_vaapi);
     REGISTER_HWACCEL(VC1_VDPAU,         vc1_vdpau);
+    REGISTER_HWACCEL(VC1_XVBA,          vc1_xvba);
     REGISTER_HWACCEL(WMV3_DXVA2,        wmv3_dxva2);
     REGISTER_HWACCEL(WMV3_VAAPI,        wmv3_vaapi);
     REGISTER_HWACCEL(WMV3_VDPAU,        wmv3_vdpau);
+    REGISTER_HWACCEL(WMV3_XVBA,         wmv3_xvba);
 
     /* video codecs */
     REGISTER_ENCODER(A64MULTI,          a64multi);
diff --git a/lib/ffmpeg/libavcodec/h264.c b/lib/ffmpeg/libavcodec/h264.c
index 937ad7a..299039f 100644
--- a/lib/ffmpeg/libavcodec/h264.c
+++ b/lib/ffmpeg/libavcodec/h264.c
@@ -81,6 +81,9 @@
 #if CONFIG_H264_VDPAU_HWACCEL
     AV_PIX_FMT_VDPAU,
 #endif
+#if CONFIG_H264_XVBA_HWACCEL
+    AV_PIX_FMT_XVBA_VLD,
+#endif
     AV_PIX_FMT_YUV420P,
     AV_PIX_FMT_NONE
 };
diff --git a/lib/ffmpeg/libavcodec/xvba.c b/lib/ffmpeg/libavcodec/xvba.c
new file mode 100644
index 0000000..be29e5d
--- /dev/null
+++ b/lib/ffmpeg/libavcodec/xvba.c
@@ -0,0 +1,66 @@
+/*
+ * HW decode acceleration for MPEG-2, H.264 and VC-1
+ *
+ * Copyright (C) 2005-2011 Team XBMC
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+
+/**
+ * \addtogroup XVBA_Decoding
+ *
+ * @{
+ */
+
+#include <stdint.h>
+#include "xvba.h"
+#include "xvba_internal.h"
+#include "avcodec.h"
+
+int ff_xvba_translate_profile(int profile) {
+
+  if (profile == 66)
+    return 1;
+  else if (profile == 77)
+    return 2;
+  else if (profile == 100)
+    return 3;
+  else if (profile == 0)
+    return 4;
+  else if (profile == 1)
+    return 5;
+  else if (profile == 3)
+    return 6;
+  else
+    return -1;
+}
+
+void ff_xvba_add_slice_data(struct xvba_render_state *render, const uint8_t *buffer, uint32_t size) {
+
+  render->buffers = av_fast_realloc(
+         render->buffers,
+         &render->buffers_alllocated,
+         sizeof(struct xvba_bitstream_buffers)*(render->num_slices + 1)
+  );
+
+  render->buffers[render->num_slices].buffer = buffer;
+  render->buffers[render->num_slices].size = size;
+
+  render->num_slices++;
+}
+
diff --git a/lib/ffmpeg/libavcodec/xvba.h b/lib/ffmpeg/libavcodec/xvba.h
new file mode 100644
index 0000000..9f9ff0c
--- /dev/null
+++ b/lib/ffmpeg/libavcodec/xvba.h
@@ -0,0 +1,71 @@
+/*
+ * HW decode acceleration for MPEG-2, H.264 and VC-1
+ *
+ * Copyright (C) 2005-2011 Team XBMC
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_XVBA_H
+#define AVCODEC_XVBA_H
+
+#include <stdint.h>
+#include <X11/Xlib.h>
+#include <amd/amdxvba.h>
+
+
+/**
+ * \defgroup XVBA_Decoding VA API Decoding
+ * \ingroup Decoder
+ * @{
+ */
+
+/** \brief The videoSurface is used for rendering. */
+#define FF_XVBA_STATE_USED_FOR_RENDER 1
+
+/**
+ * \brief The videoSurface is needed for reference/prediction.
+ * The codec manipulates this.
+ */
+#define FF_XVBA_STATE_USED_FOR_REFERENCE 2
+
+/**
+ * \brief The videoSurface holds a decoded frame.
+ * The codec manipulates this.
+ */
+#define FF_XVBA_STATE_DECODED 4
+
+/* @} */
+
+struct xvba_bitstream_buffers
+{
+  const void *buffer;
+  unsigned int size;
+};
+
+struct xvba_render_state {
+
+  int state; ///< Holds FF_XVBA_STATE_* values.
+  void *surface;
+  XVBAPictureDescriptor *picture_descriptor;
+  XVBAQuantMatrixAvc *iq_matrix;
+  unsigned int num_slices;
+  struct xvba_bitstream_buffers *buffers;
+  uint32_t buffers_alllocated;
+};
+
+#endif /* AVCODEC_XVBA_H */
diff --git a/lib/ffmpeg/libavcodec/xvba_h264.c b/lib/ffmpeg/libavcodec/xvba_h264.c
new file mode 100644
index 0000000..ae45f3a
--- /dev/null
+++ b/lib/ffmpeg/libavcodec/xvba_h264.c
@@ -0,0 +1,192 @@
+/*
+ * H.264 HW decode acceleration through XVBA
+ *
+ * Copyright (C) 2005-2011 Team XBMC
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "xvba.h"
+#include "xvba_internal.h"
+#include "h264.h"
+#include <assert.h>
+
+/** @file
+ *  This file implements the glue code between FFmpeg's and XvBA API's
+ *  structures for H.264 decoding.
+ */
+
+
+/** Initialize and start decoding a frame with XVBA. */
+static int start_frame(AVCodecContext          *avctx,
+                       av_unused const uint8_t *buffer,
+                       av_unused uint32_t       size)
+{
+  H264Context * const h = avctx->priv_data;
+  struct xvba_render_state *render;
+  XVBAPictureDescriptor *pic_descriptor;
+  int i;
+
+  render = (struct xvba_render_state *)h->cur_pic_ptr->f.data[0];
+  assert(render);
+
+  if (render->picture_descriptor == 0)
+    return -1;
+
+  pic_descriptor = render->picture_descriptor;
+
+  for (i = 0; i < 2; ++i) {
+      int foc = h->cur_pic_ptr->field_poc[i];
+      if (foc == INT_MAX)
+          foc = 0;
+      pic_descriptor->avc_curr_field_order_cnt_list[i] = foc;
+  }
+
+  pic_descriptor->avc_frame_num = h->frame_num;
+
+  render->num_slices = 0;
+
+  return 0;
+}
+
+/** End a hardware decoding based frame. */
+static int end_frame(AVCodecContext *avctx)
+{
+  H264Context * const h = avctx->priv_data;
+  struct xvba_render_state *render;
+  XVBAPictureDescriptor *pic_descriptor;
+  XVBAQuantMatrixAvc *iq_matrix;
+
+  render = (struct xvba_render_state *)h->cur_pic_ptr->f.data[0];
+  assert(render);
+
+  if (render->picture_descriptor == 0 || render->iq_matrix == 0)
+    return -1;
+
+  pic_descriptor = render->picture_descriptor;
+  iq_matrix = render->iq_matrix;
+
+  av_dlog(avctx, "end_frame()\n");
+
+  /* Fill in Picture Parameters*/
+  pic_descriptor->profile                                     = ff_xvba_translate_profile(avctx->profile);
+  pic_descriptor->level                                       = avctx->level;
+  pic_descriptor->width_in_mb                                 = h->mb_width;
+  pic_descriptor->height_in_mb                                = h->mb_height;
+  pic_descriptor->picture_structure                           = h->picture_structure;
+  pic_descriptor->chroma_format                               = h->chroma_format_idc ? h->chroma_format_idc : 1;
+  pic_descriptor->avc_intra_flag                              = (h->slice_type == AV_PICTURE_TYPE_I) ? 1 : 0;
+  pic_descriptor->avc_reference                               = (h->cur_pic_ptr->f.reference & 3) ? 1 : 0;
+
+  pic_descriptor->avc_bit_depth_luma_minus8                   = h->sps.bit_depth_luma - 8;
+  pic_descriptor->avc_bit_depth_chroma_minus8                 = h->sps.bit_depth_chroma - 8;
+  pic_descriptor->avc_log2_max_frame_num_minus4               = h->sps.log2_max_frame_num -4;
+  pic_descriptor->avc_pic_order_cnt_type                      = h->sps.poc_type;
+  pic_descriptor->avc_log2_max_pic_order_cnt_lsb_minus4       = h->sps.log2_max_poc_lsb - 4;
+  pic_descriptor->avc_num_ref_frames                          = h->sps.ref_frame_count;
+  pic_descriptor->avc_reserved_8bit                           = 0;
+
+  /* Set a level that can decode stuff in every case without a lookup table 
+     xvba seems to have problems only when the number of Reframes goes beyond
+     the max support number of Level4.1@High. So in praxis decoding a Level 3.0
+     file that in deed has level4.1@High specs does not matter. We use this fact
+     and check if the ref_frames stay in the range Level4.1@high can decode if
+     not, we set Level5.1 */
+  if (pic_descriptor->avc_num_ref_frames > 4) {
+    const unsigned int mbw = pic_descriptor->width_in_mb;
+    const unsigned int mbh = pic_descriptor->height_in_mb;
+    // this matches Level4.1@High stats to differ between <= 4.1 and 5.1
+    const unsigned int max_ref_frames = 12288 * 1024 / (mbw * mbh * 384);
+    const unsigned int num_ref_frames = pic_descriptor->avc_num_ref_frames;
+    if (max_ref_frames < num_ref_frames)
+        pic_descriptor->level = 51;
+  }
+
+  pic_descriptor->avc_num_slice_groups_minus1                 = h->pps.slice_group_count - 1;
+  pic_descriptor->avc_num_ref_idx_l0_active_minus1            = h->pps.ref_count[0] - 1;
+  pic_descriptor->avc_num_ref_idx_l1_active_minus1            = h->pps.ref_count[1] - 1;
+
+  pic_descriptor->avc_pic_init_qp_minus26                     = h->pps.init_qp - 26;
+  pic_descriptor->avc_pic_init_qs_minus26                     = h->pps.init_qs - 26;
+  pic_descriptor->avc_chroma_qp_index_offset                  = h->pps.chroma_qp_index_offset[0];
+  pic_descriptor->avc_second_chroma_qp_index_offset           = h->pps.chroma_qp_index_offset[1];
+  pic_descriptor->avc_slice_group_change_rate_minus1          = 0; // not implemented in ffmpeg
+  pic_descriptor->avc_reserved_16bit                          = 0; // must be 0
+  memset(pic_descriptor->avc_field_order_cnt_list,0,sizeof(pic_descriptor->avc_field_order_cnt_list)); // must be 0
+  memset(pic_descriptor->avc_slice_group_map,0,sizeof(pic_descriptor->avc_slice_group_map)); // must be 0
+
+  // sps
+  pic_descriptor->sps_info.avc.delta_pic_always_zero_flag     = h->sps.delta_pic_order_always_zero_flag;
+  pic_descriptor->sps_info.avc.direct_8x8_inference_flag      = h->sps.direct_8x8_inference_flag;
+  pic_descriptor->sps_info.avc.frame_mbs_only_flag            = h->sps.frame_mbs_only_flag;
+  pic_descriptor->sps_info.avc.gaps_in_frame_num_value_allowed_flag = h->sps.gaps_in_frame_num_allowed_flag;
+  pic_descriptor->sps_info.avc.mb_adaptive_frame_field_flag   = h->sps.mb_aff;
+  pic_descriptor->sps_info.avc.residual_colour_transform_flag = h->sps.residual_color_transform_flag;
+  pic_descriptor->sps_info.avc.xvba_avc_sps_reserved          = 0;
+
+  // pps
+  pic_descriptor->pps_info.avc.entropy_coding_mode_flag       = h->pps.cabac;
+  pic_descriptor->pps_info.avc.pic_order_present_flag         = h->pps.pic_order_present;
+  pic_descriptor->pps_info.avc.weighted_pred_flag             = h->pps.weighted_pred;
+  pic_descriptor->pps_info.avc.weighted_bipred_idc            = h->pps.weighted_bipred_idc;
+  pic_descriptor->pps_info.avc.deblocking_filter_control_present_flag = h->pps.deblocking_filter_parameters_present;
+  pic_descriptor->pps_info.avc.constrained_intra_pred_flag    = h->pps.constrained_intra_pred;
+  pic_descriptor->pps_info.avc.redundant_pic_cnt_present_flag = h->pps.redundant_pic_cnt_present;
+  pic_descriptor->pps_info.avc.transform_8x8_mode_flag        = h->pps.transform_8x8_mode;
+  pic_descriptor->pps_info.avc.xvba_avc_pps_reserved          = 0; // must be 0
+
+  memcpy(iq_matrix->bScalingLists4x4, h->pps.scaling_matrix4, sizeof(iq_matrix->bScalingLists4x4));
+  memcpy(iq_matrix->bScalingLists8x8[0], h->pps.scaling_matrix8[0], sizeof(iq_matrix->bScalingLists8x8[0]));
+  memcpy(iq_matrix->bScalingLists8x8[1], h->pps.scaling_matrix8[3], sizeof(iq_matrix->bScalingLists8x8[0]));
+
+  // Wait for an I-frame before start decoding. Workaround for ATI UVD and UVD+ GPUs
+  if (!h->got_first_iframe) {
+      if (h->slice_type != AV_PICTURE_TYPE_I && h->slice_type != AV_PICTURE_TYPE_SI)
+          return -1;
+      h->got_first_iframe = 1;
+  }
+
+  ff_draw_horiz_band(h->avctx, &h->dsp, h->cur_pic_ptr, NULL, 0, h->avctx->height, h->picture_structure, h->first_field, 0, 0, 0, 0);
+
+  return 0;
+}
+
+/** Decode the given H.264 slice with XVBA. */
+static int decode_slice(AVCodecContext *avctx,
+                        const uint8_t  *buffer,
+                        uint32_t        size)
+{
+  H264Context * const h = avctx->priv_data;
+  struct xvba_render_state *render;
+
+  render = (struct xvba_render_state *)h->cur_pic_ptr->f.data[0];
+  assert(render);
+
+  ff_xvba_add_slice_data(render, buffer, size);
+
+  return 0;
+}
+
+AVHWAccel ff_h264_xvba_hwaccel = {
+    .name           = "h264_xvba",
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = CODEC_ID_H264,
+    .pix_fmt        = AV_PIX_FMT_XVBA_VLD,
+    .start_frame    = start_frame,
+    .end_frame      = end_frame,
+    .decode_slice   = decode_slice,
+};
diff --git a/lib/ffmpeg/libavcodec/xvba_internal.h b/lib/ffmpeg/libavcodec/xvba_internal.h
new file mode 100644
index 0000000..9653f85
--- /dev/null
+++ b/lib/ffmpeg/libavcodec/xvba_internal.h
@@ -0,0 +1,24 @@
+/*
+ * HW decode acceleration for MPEG-2, H.264 and VC-1
+ *
+ * Copyright (C) 2005-2011 Team XBMC
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+int ff_xvba_translate_profile(int profile);
+void ff_xvba_add_slice_data(struct xvba_render_state *render, const uint8_t *buffer, uint32_t size);
diff --git a/lib/ffmpeg/libavcodec/xvba_mpeg2.c b/lib/ffmpeg/libavcodec/xvba_mpeg2.c
new file mode 100644
index 0000000..0fc7d78
--- /dev/null
+++ b/lib/ffmpeg/libavcodec/xvba_mpeg2.c
@@ -0,0 +1,52 @@
+/*
+ * MPEG-2 HW decode acceleration through XVBA
+ *
+ * Copyright (C) 2005-2011 Team XBMC
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "dsputil.h"
+
+static int start_frame(AVCodecContext *avctx, av_unused const uint8_t *buffer, av_unused uint32_t size)
+{
+    struct MpegEncContext * const s = avctx->priv_data;
+    return 0;
+}
+
+static int end_frame(AVCodecContext *avctx)
+{
+    return 0;
+}
+
+static int decode_slice(AVCodecContext *avctx, const uint8_t *buffer, uint32_t size)
+{
+    struct MpegEncContext * const s = avctx->priv_data;
+    return 0;
+}
+
+AVHWAccel ff_mpeg2_xvba_hwaccel = {
+    .name           = "mpeg2_xvba",
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = CODEC_ID_MPEG2VIDEO,
+    .pix_fmt        = AV_PIX_FMT_XVBA_VLD,
+    .capabilities   = 0,
+    .start_frame    = start_frame,
+    .end_frame      = end_frame,
+    .decode_slice   = decode_slice,
+    .priv_data_size = 0,
+};
diff --git a/lib/ffmpeg/libavcodec/xvba_vc1.c b/lib/ffmpeg/libavcodec/xvba_vc1.c
new file mode 100644
index 0000000..bf3d9c2
--- /dev/null
+++ b/lib/ffmpeg/libavcodec/xvba_vc1.c
@@ -0,0 +1,190 @@
+/*
+ * VC-1 HW decode acceleration through XVBA
+ *
+ * Copyright (C) 2005-2011 Team XBMC
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "xvba.h"
+#include "xvba_internal.h"
+#include "vc1.h"
+#include "vc1data.h"
+#include <assert.h>
+
+
+/** @file
+ * Implement structures of ffmpeg <-> XvBA
+ */
+
+/* Initialize and start decoding a frame with XvBA */
+static int start_frame(AVCodecContext *avctx,
+				av_unused const uint8_t *buffer, 
+				av_unused uint32_t size)
+{
+    VC1Context * const v = avctx->priv_data;
+    MpegEncContext * const s = &v->s;
+    struct xvba_render_state *render;
+
+    render = (struct xvba_render_state *)s->current_picture_ptr->f.data[0];
+    assert(render);
+    
+    render->num_slices = 0;
+    return 0;
+}
+
+/* End a hardware decoding based frame */
+static int end_frame(AVCodecContext *avctx)
+{
+    VC1Context* const v = avctx->priv_data;
+    MpegEncContext* const s = &v->s;
+    struct xvba_render_state *render, *last, *next;
+    XVBAPictureDescriptor *pic_descriptor;
+
+    render = (struct xvba_render_state *)s->current_picture_ptr->f.data[0];
+    assert(render);
+
+    if (render->picture_descriptor == 0)
+      return -1;
+
+    pic_descriptor = render->picture_descriptor;
+    
+    av_dlog(avctx, "xvba_vc1_end_frame()\n");
+    
+    memset(pic_descriptor, 0, sizeof(*pic_descriptor));
+
+    /* Fill in Parameters - for reference see AMD sdk documentation */
+    pic_descriptor->profile                                 = ff_xvba_translate_profile(v->profile);
+    pic_descriptor->level                                   = v->level;
+    //done like in va-driver and vaapi
+    if (v->profile == PROFILE_ADVANCED) {
+      pic_descriptor->width_in_mb                           = s->avctx->coded_width;
+      pic_descriptor->height_in_mb                          = s->avctx->coded_height;
+    } else {
+      pic_descriptor->width_in_mb                           = s->mb_width;
+      pic_descriptor->height_in_mb                          = s->mb_height;
+    }
+    pic_descriptor->picture_structure                       = s->picture_structure;
+    // xvba-video set this to 1 only 4:2:0 supported
+    // doc says: if not set, choose 1 - we try this
+    pic_descriptor->chroma_format                           = 1;
+    pic_descriptor->avc_intra_flag                          = s->pict_type == AV_PICTURE_TYPE_I || v->bi_type == 1;
+    pic_descriptor->avc_reference                           = (s->current_picture_ptr->f.reference & 3) ? 1 : 0;
+    
+    // VC-1 explicit parameters see page 30 of sdk
+    // sps_info
+    pic_descriptor->sps_info.vc1.postprocflag               = v->postprocflag;
+    
+    // done as in vaapi
+    pic_descriptor->sps_info.vc1.pulldown                   = v->broadcast;
+    pic_descriptor->sps_info.vc1.interlace                  = v->interlace;
+    pic_descriptor->sps_info.vc1.tfcntrflag                 = v->tfcntrflag;
+    pic_descriptor->sps_info.vc1.finterpflag                = v->finterpflag;
+    pic_descriptor->sps_info.vc1.reserved                   = 1;
+    // eventually check if this makes sense together with interlace
+    pic_descriptor->sps_info.vc1.psf                        = v->psf;
+    // what about if it is a frame (page 31)
+    // looked at xvba-driver
+    pic_descriptor->sps_info.vc1.second_field               = !s->first_field;
+    pic_descriptor->sps_info.vc1.xvba_vc1_sps_reserved      = 0;
+    
+    // VC-1 explicit parameters see page 30 of sdk
+    // pps_info
+    pic_descriptor->pps_info.vc1.panscan_flag               = v->panscanflag;
+    pic_descriptor->pps_info.vc1.refdist_flag               = v->refdist_flag;
+    pic_descriptor->pps_info.vc1.loopfilter                 = s->loop_filter;
+    pic_descriptor->pps_info.vc1.fastuvmc                   = v->fastuvmc;
+    pic_descriptor->pps_info.vc1.extended_mv                = v->extended_mv;
+    pic_descriptor->pps_info.vc1.dquant                     = v->dquant;
+    pic_descriptor->pps_info.vc1.vstransform                = v->vstransform;
+    pic_descriptor->pps_info.vc1.overlap                    = v->overlap;
+    pic_descriptor->pps_info.vc1.quantizer                  = v->quantizer_mode;
+    pic_descriptor->pps_info.vc1.extended_dmv               = v->extended_dmv;   
+    pic_descriptor->pps_info.vc1.maxbframes                 = s->avctx->max_b_frames;
+    pic_descriptor->pps_info.vc1.rangered                   = (pic_descriptor->profile == PROFILE_SIMPLE) ? 0 : v->rangered;   
+    pic_descriptor->pps_info.vc1.syncmarker                 = (pic_descriptor->profile == PROFILE_SIMPLE) ? 0 : s->resync_marker;
+    pic_descriptor->pps_info.vc1.multires                   = v->multires;
+    pic_descriptor->pps_info.vc1.reserved                   = 1;
+    pic_descriptor->pps_info.vc1.range_mapy_flag            = v->range_mapy_flag;
+    pic_descriptor->pps_info.vc1.range_mapy                 = v->range_mapy;
+    pic_descriptor->pps_info.vc1.range_mapuv_flag           = v->range_mapuv_flag;
+    pic_descriptor->pps_info.vc1.range_mapuv                = v->range_mapuv;
+    pic_descriptor->pps_info.vc1.xvba_vc1_pps_reserved      = 0;
+    
+    pic_descriptor->past_surface                            = 0;
+    pic_descriptor->future_surface                          = 0;
+    switch (s->pict_type) {
+    case AV_PICTURE_TYPE_B:
+        next = (struct xvba_render_state *)s->next_picture.f.data[0];
+        assert(next);
+        if (next)
+          pic_descriptor->past_surface = next->surface;
+        // fall-through
+    case AV_PICTURE_TYPE_P:
+        last = (struct xvba_render_state *)s->last_picture.f.data[0];
+        assert(last);
+        if (last)
+          pic_descriptor->future_surface = last->surface;
+        break;
+    }
+
+    ff_draw_horiz_band(s->avctx, &s->dsp, s->current_picture_ptr, s->last_picture_ptr, 0, s->avctx->height, s->picture_structure, s->first_field, (s->unrestricted_mv && !s->intra_only), s->low_delay, s->v_edge_pos, s->h_edge_pos);
+
+    return 0;
+}
+
+static int decode_slice(AVCodecContext *avctx, const uint8_t *buffer, uint32_t size)
+{
+  VC1Context* const v = avctx->priv_data;
+  MpegEncContext* const s = &v->s;
+  struct xvba_render_state *render;
+
+  render = (struct xvba_render_state *)s->current_picture_ptr->f.data[0];
+  assert(render);
+
+  if (avctx->codec_id == CODEC_ID_VC1 &&
+      size >= 4 && IS_MARKER(AV_RB32(buffer))) {
+      buffer += 4;
+      size   -= 4;
+  }
+
+  ff_xvba_add_slice_data(render, buffer, size);
+
+  return 0;
+}
+
+#if CONFIG_WMV3_XVBA_HWACCEL
+AVHWAccel ff_wmv3_xvba_hwaccel = {
+    .name           = "wmv3_xvba",
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = CODEC_ID_WMV3,
+    .pix_fmt        = AV_PIX_FMT_XVBA_VLD,
+    .start_frame    = start_frame,
+    .end_frame      = end_frame,
+    .decode_slice   = decode_slice,
+};
+#endif
+
+AVHWAccel ff_vc1_xvba_hwaccel = {
+    .name           = "vc1_xvba",
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = CODEC_ID_VC1,
+    .pix_fmt        = AV_PIX_FMT_XVBA_VLD,
+    .start_frame    = start_frame,
+    .end_frame      = end_frame,
+    .decode_slice   = decode_slice,
+};
diff --git a/lib/ffmpeg/libavutil/pixdesc.c b/lib/ffmpeg/libavutil/pixdesc.c
index 1016dba..53dfec1 100644
--- a/lib/ffmpeg/libavutil/pixdesc.c
+++ b/lib/ffmpeg/libavutil/pixdesc.c
@@ -1141,6 +1141,12 @@ void av_write_image_line(const uint16_t *src,
         .log2_chroma_h = 1,
         .flags = PIX_FMT_HWACCEL,
     },
+    [AV_PIX_FMT_XVBA_VLD] = {
+        .name = "xvba_vld",
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = PIX_FMT_HWACCEL,
+    },
     [AV_PIX_FMT_YUV420P9LE] = {
         .name = "yuv420p9le",
         .nb_components = 3,
diff --git a/lib/ffmpeg/libavutil/pixfmt.h b/lib/ffmpeg/libavutil/pixfmt.h
index 1c00ac4..6437e29 100644
--- a/lib/ffmpeg/libavutil/pixfmt.h
+++ b/lib/ffmpeg/libavutil/pixfmt.h
@@ -124,6 +124,7 @@ enum AVPixelFormat {
     AV_PIX_FMT_VAAPI_MOCO, ///< HW acceleration through VA API at motion compensation entry-point, Picture.data[3] contains a vaapi_render_state struct which contains macroblocks as well as various fields extracted from headers
     AV_PIX_FMT_VAAPI_IDCT, ///< HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers
     AV_PIX_FMT_VAAPI_VLD,  ///< HW decoding through VA API, Picture.data[3] contains a vaapi_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
+    AV_PIX_FMT_XVBA_VLD,  ///< HW decoding through xvba, Picture.data[3] contains a xvba_rander_state struct which contains the bitstream of the slices
 
     AV_PIX_FMT_YUV420P16LE,  ///< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
     AV_PIX_FMT_YUV420P16BE,  ///< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
-- 
1.8.1.6


From 93c92af6eceb08981a57ddd5b082118cffeb81ba Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 12 Apr 2012 12:09:31 +0200
Subject: [PATCH 069/123] xvba: add decoder

---
 configure.in                                       |   47 +
 language/English/strings.po                        |   12 +-
 system/settings/settings.xml                       |    5 +
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp      |  216 +-
 xbmc/cores/VideoRenderers/LinuxRendererGL.h        |   15 +-
 xbmc/cores/VideoRenderers/RenderFormats.h          |    1 +
 xbmc/cores/VideoRenderers/RenderManager.cpp        |    4 +
 .../dvdplayer/DVDCodecs/Video/DVDVideoCodec.h      |    4 +
 .../DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp        |   16 +
 xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in   |    3 +
 xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp      | 2367 ++++++++++++++++++++
 xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.h        |  383 ++++
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp            |    1 +
 xbmc/settings/VideoSettings.h                      |    2 +
 xbmc/video/dialogs/GUIDialogVideoSettings.cpp      |    1 +
 15 files changed, 3070 insertions(+), 7 deletions(-)
 create mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp
 create mode 100644 xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.h

diff --git a/configure.in b/configure.in
index bd2934d..94f6455 100644
--- a/configure.in
+++ b/configure.in
@@ -143,6 +143,8 @@ vaapi_not_found="== Could not find libva. VAAPI support disabled. =="
 vaapi_disabled="== VAAPI support manually disabled. =="
 crystalhd_not_found="== Could not find libcrystalhd. CrystalHD support disabled. =="
 crystalhd_disabled="== CrystalHD support manually disabled. =="
+xvba_not_found="== Could not find amdxvba.h. XVBA support disabled. =="
+xvba_disabled="== XVBA support manually disabled. =="
 vtbdecoder_enabled="== VTBDecoder support enabled. =="
 vtbdecoder_disabled="== VTBDecoder support manually disabled. =="
 openmax_disabled="== OpenMax support manually disabled. =="
@@ -262,6 +264,12 @@ AC_ARG_ENABLE([crystalhd],
   [enable CrystalHD decoding (default is auto)])],
   [use_crystalhd=$enableval],
   [use_crystalhd=auto])
+  
+AC_ARG_ENABLE([xvba],
+  [AS_HELP_STRING([--enable-xvba],
+  [enable XVBA decoding (default is auto)])],
+  [use_xvba=$enableval],
+  [use_xvba=auto])  
 
 AC_ARG_ENABLE([vtbdecoder],
   [AS_HELP_STRING([--enable-vtbdecoder],
@@ -1780,6 +1788,37 @@ else
   USE_CRYSTALHD=0
 fi
 
+# XVBA
+if test "x$use_xvba" != "xno"; then
+  if test "$host_vendor" = "apple" ; then
+    if test "x$use_xvba" = "xyes"; then
+      AC_MSG_ERROR([XVBA not supported on this platform])
+    else
+      use_xvba="no"
+      AC_MSG_NOTICE($xvba_disabled)
+    fi
+    USE_XVBA=0
+  else
+    initial_val=$use_xvba
+    AC_CHECK_HEADER([amd/amdxvba.h],, use_xvba=no, [#include <X11/Xlib.h>])
+
+    if test "x$use_xvba" = "xno"; then
+      if test "x$initial_val" = "xyes"; then
+        AC_MSG_ERROR($xvba_not_found)
+      else
+        AC_MSG_RESULT($xvba_not_found)
+      fi
+      USE_XVBA=0
+    else
+      AC_DEFINE([HAVE_LIBXVBA], [1], [Define to 1 if you have the 'xvba' header (amdxvba.h)])
+      USE_XVBA=1
+    fi
+  fi
+else
+  AC_MSG_NOTICE($xvba_disabled)
+  USE_XVBA=0
+fi
+
 # VTBDecoder
 if test "x$use_vtbdecoder" != "xno"; then
   if test "$host_vendor" = "apple" ; then
@@ -1977,6 +2016,12 @@ else
   final_message="$final_message\n  CrystalHD:\tNo"
 fi
 
+if test "x$use_xvba" != "xno"; then
+  final_message="$final_message\n  XVBA:\t\tYes"
+else
+  final_message="$final_message\n  XVBA:\t\tNo"
+fi
+
 if test "x$use_vtbdecoder" != "xno"; then
   final_message="$final_message\n  VTBDecoder:\tYes"
 else
@@ -2447,6 +2492,7 @@ AC_SUBST(USE_OPENGLES)
 AC_SUBST(USE_VDPAU)
 AC_SUBST(USE_VAAPI)
 AC_SUBST(USE_CRYSTALHD)
+AC_SUBST(USE_XVBA)
 AC_SUBST(USE_LIBSMBCLIENT)
 AC_SUBST(USE_LIBNFS)
 AC_SUBST(USE_LIBAFPCLIENT)
@@ -2631,6 +2677,7 @@ XB_CONFIG_MODULE([lib/ffmpeg], [
       `if test "x$use_vdpau" != "xno"; then echo --enable-vdpau; else echo --disable-vdpau; fi` \
       `if test "x$use_vaapi" != "xno"; then echo --enable-vaapi; else echo --disable-vaapi; fi` \
       `if test "$use_optimizations" != "no"; then echo --enable-optimizations; else echo --disable-optimizations; fi` \
+      `if test "x$use_xvba" != "xno"; then echo --enable-xvba; else echo --disable-xvba; fi` \
       --enable-protocol=http \
       --enable-pthreads \
       --enable-runtime-cpudetect \
diff --git a/language/English/strings.po b/language/English/strings.po
index 10568ca..d603702 100644
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -5773,7 +5773,11 @@ msgctxt "#13436"
 msgid "Prefer VDPAU Video Mixer"
 msgstr ""
 
-#empty strings from id 13437 to 13499
+msgctxt "#13437"
+msgid "Allow hardware acceleration (XVBA)"
+msgstr ""
+
+#empty strings from id 13438 to 13499
 
 #: system/settings/settings.xml
 msgctxt "#13500"
@@ -6851,7 +6855,11 @@ msgctxt "#16325"
 msgid "VDPAU - Bob"
 msgstr ""
 
-#empty strings from id 16326 to 16399
+msgctxt "#16326"
+msgid "XVBA"
+msgstr ""
+
+#empty strings from id 16327 to 16399
 
 msgctxt "#16400"
 msgid "Post-processing"
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index 9c63476..a863dae 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -410,6 +410,11 @@
           <level>2</level>
           <default>true</default>
         </setting>
+        <setting id="videoplayer.usexvba" type="boolean" label="13437" help="">
+          <visible>HAVE_LIBXVBA</visible>
+          <level>2</level>
+          <default>true</default>
+        </setting>
         <setting id="videoplayer.usepbo" type="boolean" label="13424" help="36163">
           <visible>HAS_GL</visible>
           <level>4</level>
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index 3d9f22a..c663423 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -65,6 +65,9 @@
        VA_MICRO_VERSION == 0 && VA_SDS_VERSION < 5)))
 
 #endif
+#ifdef HAVE_LIBXVBA
+#include "cores/dvdplayer/DVDCodecs/Video/XVBA.h"
+#endif
 
 #ifdef TARGET_DARWIN
   #include "osx/CocoaInterface.h"
@@ -135,6 +138,9 @@
 #ifdef TARGET_DARWIN_OSX
   cvBufferRef = NULL;
 #endif
+#ifdef HAVE_LIBXVBA
+  xvba = NULL;
+#endif
 }
 
 CLinuxRendererGL::YUVBUFFER::~YUVBUFFER()
@@ -604,6 +610,9 @@ void CLinuxRendererGL::ReleaseBuffer(int idx)
 #ifdef HAVE_LIBVDPAU
   SAFE_RELEASE(buf.vdpau);
 #endif
+#ifdef HAVE_LIBXVBA
+  SAFE_RELEASE(buf.xvba);
+#endif
 #ifdef HAVE_LIBVA
   buf.vaapi.surface.reset();
 #endif
@@ -869,7 +878,7 @@ void CLinuxRendererGL::UpdateVideoFilter()
   case VS_SCALINGMETHOD_LINEAR:
     SetTextureFilter(m_scalingMethod == VS_SCALINGMETHOD_NEAREST ? GL_NEAREST : GL_LINEAR);
     m_renderQuality = RQ_SINGLEPASS;
-    if (((m_renderMethod & RENDER_VDPAU) || (m_renderMethod & RENDER_VAAPI)) && m_nonLinStretch)
+    if (((m_renderMethod & RENDER_VDPAU) || (m_renderMethod & RENDER_VAAPI) || (m_renderMethod & RENDER_XVBA)) && m_nonLinStretch)
     {
       m_pVideoFilterShader = new StretchFilterShader();
       if (!m_pVideoFilterShader->CompileAndLink())
@@ -955,6 +964,11 @@ void CLinuxRendererGL::LoadShaders(int field)
     CLog::Log(LOGNOTICE, "GL: Using CVBREF render method");
     m_renderMethod = RENDER_CVREF;
   }
+  else if (m_format == RENDER_FMT_XVBA)
+  {
+    CLog::Log(LOGNOTICE, "GL: Using XVBA render method");
+    m_renderMethod = RENDER_XVBA;
+  }
   else
   {
     int requestedMethod = CSettings::Get().GetInt("videoplayer.rendermethod");
@@ -1103,6 +1117,12 @@ void CLinuxRendererGL::LoadShaders(int field)
     m_textureCreate = &CLinuxRendererGL::CreateCVRefTexture;
     m_textureDelete = &CLinuxRendererGL::DeleteCVRefTexture;
   }
+  else if (m_format == RENDER_FMT_XVBA)
+  {
+    m_textureUpload = &CLinuxRendererGL::UploadXVBATexture;
+    m_textureCreate = &CLinuxRendererGL::CreateXVBATexture;
+    m_textureDelete = &CLinuxRendererGL::DeleteXVBATexture;
+  }
   else
   {
     // setup default YV12 texture handlers
@@ -1215,6 +1235,13 @@ void CLinuxRendererGL::Render(DWORD flags, int renderBuffer)
     RenderVAAPI(renderBuffer, m_currentField);
   }
 #endif
+#ifdef HAVE_LIBXVBA
+  else if (m_renderMethod & RENDER_XVBA)
+  {
+    UpdateVideoFilter();
+    RenderXVBA(renderBuffer, m_currentField);
+  }
+#endif
   else
   {
     // RENDER_CVREF uses the same render as the default case
@@ -1731,6 +1758,77 @@ void CLinuxRendererGL::RenderVAAPI(int index, int field)
 #endif
 }
 
+void CLinuxRendererGL::RenderXVBA(int index, int field)
+{
+#ifdef HAVE_LIBXVBA
+  YUVPLANE &plane = m_buffers[index].fields[0][1];
+
+  glEnable(m_textureTarget);
+  glActiveTextureARB(GL_TEXTURE0);
+
+  glBindTexture(m_textureTarget, plane.id);
+
+  // Try some clamping or wrapping
+  glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+  glTexParameteri(m_textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+
+  if (m_pVideoFilterShader)
+  {
+    GLint filter;
+    if (!m_pVideoFilterShader->GetTextureFilter(filter))
+      filter = m_scalingMethod == VS_SCALINGMETHOD_NEAREST ? GL_NEAREST : GL_LINEAR;
+
+    glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, filter);
+    glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, filter);
+    m_pVideoFilterShader->SetSourceTexture(0);
+    m_pVideoFilterShader->SetWidth(m_sourceWidth);
+    m_pVideoFilterShader->SetHeight(m_sourceHeight);
+
+    //disable non-linear stretch when a dvd menu is shown, parts of the menu are rendered through the overlay renderer
+    //having non-linear stretch on breaks the alignment
+    if (g_application.m_pPlayer && g_application.m_pPlayer->IsInMenu())
+      m_pVideoFilterShader->SetNonLinStretch(1.0);
+    else
+      m_pVideoFilterShader->SetNonLinStretch(pow(CDisplaySettings::Get().GetPixelRatio(), g_advancedSettings.m_videoNonLinStretchRatio));
+
+    m_pVideoFilterShader->Enable();
+  }
+  else
+  {
+    GLint filter = m_scalingMethod == VS_SCALINGMETHOD_NEAREST ? GL_NEAREST : GL_LINEAR;
+    glTexParameteri(m_textureTarget, GL_TEXTURE_MAG_FILTER, filter);
+    glTexParameteri(m_textureTarget, GL_TEXTURE_MIN_FILTER, filter);
+  }
+
+  glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+  VerifyGLState();
+
+  glBegin(GL_QUADS);
+  if (m_textureTarget==GL_TEXTURE_2D)
+  {
+    glTexCoord2f(plane.rect.x1, plane.rect.y1); glVertex2f(m_destRect.x1, m_destRect.y1);
+    glTexCoord2f(plane.rect.x2, plane.rect.y1); glVertex2f(m_destRect.x2, m_destRect.y1);
+    glTexCoord2f(plane.rect.x2, plane.rect.y2); glVertex2f(m_destRect.x2, m_destRect.y2);
+    glTexCoord2f(plane.rect.x1, plane.rect.y2); glVertex2f(m_destRect.x1, m_destRect.y2);
+  }
+  else
+  {
+    glTexCoord2f(m_destRect.x1, m_destRect.y1); glVertex4f(m_destRect.x1, m_destRect.y1, 0.0f, 0.0f);
+    glTexCoord2f(m_destRect.x2, m_destRect.y1); glVertex4f(m_destRect.x2, m_destRect.y1, 1.0f, 0.0f);
+    glTexCoord2f(m_destRect.x2, m_destRect.y2); glVertex4f(m_destRect.x2, m_destRect.y2, 1.0f, 1.0f);
+    glTexCoord2f(m_destRect.x1, m_destRect.y2); glVertex4f(m_destRect.x1, m_destRect.y2, 0.0f, 1.0f);
+  }
+  glEnd();
+  VerifyGLState();
+
+  if (m_pVideoFilterShader)
+    m_pVideoFilterShader->Disable();
+
+  glBindTexture (m_textureTarget, 0);
+  glDisable(m_textureTarget);
+#endif
+}
+
 void CLinuxRendererGL::RenderSoftware(int index, int field)
 {
   // used for textues uploaded from rgba or CVPixelBuffers.
@@ -2764,6 +2862,88 @@ bool CLinuxRendererGL::CreateCVRefTexture(int index)
   return true;
 }
 
+void CLinuxRendererGL::DeleteXVBATexture(int index)
+{
+#ifdef HAVE_LIBXVBA
+  YUVPLANE &plane = m_buffers[index].fields[0][0];
+  YUVFIELDS &fields = m_buffers[index].fields;
+
+  SAFE_RELEASE(m_buffers[index].xvba);
+
+  if(plane.id && glIsTexture(plane.id))
+    glDeleteTextures(1, &plane.id);
+  plane.id = 0;
+  fields[0][1].id = 0;
+#endif
+}
+
+bool CLinuxRendererGL::CreateXVBATexture(int index)
+{
+#ifdef HAVE_LIBXVBA
+  YV12Image &im = m_buffers[index].image;
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE &plane = fields[0][0];
+
+  DeleteXVBATexture(index);
+
+  memset(&im , 0, sizeof(im));
+  memset(&fields, 0, sizeof(fields));
+
+  glGenTextures(1, &plane.id);
+
+#endif
+  return true;
+}
+
+void CLinuxRendererGL::UploadXVBATexture(int index)
+{
+#ifdef HAVE_LIBXVBA
+  XVBA::CXvbaRenderPicture *xvba = m_buffers[index].xvba;
+  YV12Image &im = m_buffers[index].image;
+
+  YUVFIELDS &fields = m_buffers[index].fields;
+  YUVPLANE &plane = fields[0][1];
+
+  if (!xvba || !xvba->valid)
+  {
+    m_skipRender = true;
+    return;
+  }
+
+  plane.id = xvba->texture;
+
+  im.height = xvba->texHeight;
+  im.width  = xvba->texWidth;
+
+  plane.texwidth  = xvba->texWidth;
+  plane.texheight = xvba->texHeight;
+  plane.pixpertex_x = 1;
+  plane.pixpertex_y = 1;
+
+  plane.rect = m_sourceRect;
+  plane.width  = im.width;
+  plane.height = im.height;
+
+  plane.height  /= plane.pixpertex_y;
+  plane.rect.y1 /= plane.pixpertex_y;
+  plane.rect.y2 /= plane.pixpertex_y;
+  plane.width   /= plane.pixpertex_x;
+  plane.rect.x1 /= plane.pixpertex_x;
+  plane.rect.x2 /= plane.pixpertex_x;
+
+  if (m_textureTarget == GL_TEXTURE_2D)
+  {
+    plane.height  /= plane.texheight;
+    plane.rect.y1 /= plane.texheight;
+    plane.rect.y2 /= plane.texheight;
+    plane.width   /= plane.texwidth;
+    plane.rect.x1 /= plane.texwidth;
+    plane.rect.x2 /= plane.texwidth;
+  }
+
+#endif
+}
+
 void CLinuxRendererGL::UploadYUV422PackedTexture(int source)
 {
   YUVBUFFER& buf    =  m_buffers[source];
@@ -3338,6 +3518,9 @@ bool CLinuxRendererGL::Supports(ERENDERFEATURE feature)
     if (m_renderMethod & RENDER_VAAPI)
       return false;
 
+    if (m_renderMethod & RENDER_XVBA)
+      return false;
+
     return (m_renderMethod & RENDER_GLSL)
         || (m_renderMethod & RENDER_ARB)
         || ((m_renderMethod & RENDER_SW) && glewIsSupported("GL_ARB_imaging") == GL_TRUE);
@@ -3351,6 +3534,9 @@ bool CLinuxRendererGL::Supports(ERENDERFEATURE feature)
     if (m_renderMethod & RENDER_VAAPI)
       return false;
 
+    if (m_renderMethod & RENDER_XVBA)
+      return false;
+
     return (m_renderMethod & RENDER_GLSL)
         || (m_renderMethod & RENDER_ARB)
         || ((m_renderMethod & RENDER_SW) && glewIsSupported("GL_ARB_imaging") == GL_TRUE);
@@ -3374,7 +3560,8 @@ bool CLinuxRendererGL::Supports(ERENDERFEATURE feature)
   if (feature == RENDERFEATURE_NONLINSTRETCH)
   {
     if (((m_renderMethod & RENDER_GLSL) && !(m_renderMethod & RENDER_POT)) ||
-        (m_renderMethod & RENDER_VDPAU) || (m_renderMethod & RENDER_VAAPI))
+        (m_renderMethod & RENDER_VDPAU) || (m_renderMethod & RENDER_VAAPI) ||
+        (m_renderMethod & RENDER_XVBA))
       return true;
   }
 
@@ -3446,6 +3633,16 @@ bool CLinuxRendererGL::Supports(EINTERLACEMETHOD method)
     return false;
   }
 
+  if(m_renderMethod & RENDER_XVBA)
+  {
+#ifdef HAVE_LIBXVBA
+    XVBA::CXvbaRenderPicture *xvba = m_buffers[m_iYV12RenderBuffer].xvba;
+    if(xvba)
+      return xvba->xvba->Supports(method);
+#endif
+    return false;
+  }
+
 #ifdef TARGET_DARWIN
   // YADIF too slow for HD but we have no methods to fall back
   // to something that works so just turn it off.
@@ -3495,7 +3692,7 @@ bool CLinuxRendererGL::Supports(ESCALINGMETHOD method)
       return false;
 
     if ((glewIsSupported("GL_EXT_framebuffer_object") && (m_renderMethod & RENDER_GLSL)) ||
-        (m_renderMethod & RENDER_VDPAU) || (m_renderMethod & RENDER_VAAPI))
+        (m_renderMethod & RENDER_VDPAU) || (m_renderMethod & RENDER_VAAPI) || (m_renderMethod & RENDER_XVBA))
     {
       // spline36 and lanczos3 are only allowed through advancedsettings.xml
       if(method != VS_SCALINGMETHOD_SPLINE36
@@ -3562,7 +3759,8 @@ unsigned int CLinuxRendererGL::GetProcessorSize()
   if(m_format == RENDER_FMT_VDPAU
   || m_format == RENDER_FMT_VDPAU_420
   || m_format == RENDER_FMT_VAAPI
-  || m_format == RENDER_FMT_CVBREF)
+  || m_format == RENDER_FMT_CVBREF
+  || m_format == RENDER_FMT_XVBA)
     return 1;
   else
     return 0;
@@ -3618,4 +3816,14 @@ void CLinuxRendererGL::AddProcessor(struct __CVBuffer *cvBufferRef, int index)
 }
 #endif
 
+#ifdef HAVE_LIBXVBA
+void CLinuxRendererGL::AddProcessor(XVBA::CXvbaRenderPicture* xvba, int index)
+{
+  YUVBUFFER &buf = m_buffers[index];
+  XVBA::CXvbaRenderPicture *pic = xvba->Acquire();
+  SAFE_RELEASE(buf.xvba);
+  buf.xvba = pic;
+}
+#endif
+
 #endif
diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.h b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
index 4494eca..161c43f 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.h
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.h
@@ -44,6 +44,8 @@
 namespace Shaders { class BaseVideoFilterShader; }
 namespace VAAPI   { struct CHolder; }
 namespace VDPAU   { class CVdpauRenderPicture; }
+namespace XVBA    { class CXvbaRenderPicture; }
+
 
 #undef ALIGN
 #define ALIGN(value, alignment) (((value)+((alignment)-1))&~((alignment)-1))
@@ -89,6 +91,7 @@ enum RenderMethod
   RENDER_POT=0x10,
   RENDER_VAAPI=0x20,
   RENDER_CVREF = 0x40,
+  RENDER_XVBA=0x80,
 };
 
 enum RenderQuality
@@ -151,7 +154,9 @@ class CLinuxRendererGL : public CBaseRenderer
 #ifdef TARGET_DARWIN
   virtual void         AddProcessor(struct __CVBuffer *cvBufferRef, int index);
 #endif
-
+#ifdef HAVE_LIBXVBA
+  virtual void         AddProcessor(XVBA::CXvbaRenderPicture* xvba, int index);
+#endif
   virtual void RenderUpdate(bool clear, DWORD flags = 0, DWORD alpha = 255);
 
   // Feature support
@@ -210,6 +215,10 @@ class CLinuxRendererGL : public CBaseRenderer
   void DeleteYUV422PackedTexture(int index);
   bool CreateYUV422PackedTexture(int index);
 
+  void UploadXVBATexture(int index);
+  void DeleteXVBATexture(int index);
+  bool CreateXVBATexture(int index);
+
   void UploadRGBTexture(int index);
   void ToRGBFrame(YV12Image* im, unsigned flipIndexPlane, unsigned flipIndexBuf);
   void ToRGBFields(YV12Image* im, unsigned flipIndexPlaneTop, unsigned flipIndexPlaneBot, unsigned flipIndexBuf);
@@ -225,6 +234,7 @@ class CLinuxRendererGL : public CBaseRenderer
   void RenderVDPAU(int renderBuffer, int field);      // render using vdpau hardware
   void RenderProgressiveWeave(int renderBuffer, int field); // render using vdpau hardware
   void RenderVAAPI(int renderBuffer, int field);      // render using vdpau hardware
+  void RenderXVBA(int renderBuffer, int field);      // render using xvba hardware
 
   struct
   {
@@ -293,6 +303,9 @@ class CLinuxRendererGL : public CBaseRenderer
 #ifdef TARGET_DARWIN_OSX
     struct __CVBuffer *cvBufferRef;
 #endif
+#ifdef HAVE_LIBXVBA
+    XVBA::CXvbaRenderPicture *xvba;
+#endif
   };
 
   typedef YUVBUFFER          YUVBUFFERS[NUM_BUFFERS];
diff --git a/xbmc/cores/VideoRenderers/RenderFormats.h b/xbmc/cores/VideoRenderers/RenderFormats.h
index 6ed62be..70ae9bf 100644
--- a/xbmc/cores/VideoRenderers/RenderFormats.h
+++ b/xbmc/cores/VideoRenderers/RenderFormats.h
@@ -35,6 +35,7 @@ enum ERenderFormat {
   RENDER_FMT_OMXEGL,
   RENDER_FMT_CVBREF,
   RENDER_FMT_BYPASS,
+  RENDER_FMT_XVBA,
 };
 
 #endif
diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index a59ee4d..f94760c 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -941,6 +941,10 @@ int CXBMCRenderManager::AddVideoPicture(DVDVideoPicture& pic)
   else if(pic.format == RENDER_FMT_VAAPI)
     m_pRenderer->AddProcessor(*pic.vaapi, index);
 #endif
+#ifdef HAVE_LIBXVBA
+  else if(pic.format == RENDER_FMT_XVBA)
+    m_pRenderer->AddProcessor(pic.xvba, index);
+#endif
   m_pRenderer->ReleaseImage(index, false);
 
   return index;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
index 13a2648..347f09b 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h
@@ -35,6 +35,7 @@
 namespace DXVA { class CSurfaceContext; }
 namespace VAAPI { struct CHolder; }
 namespace VDPAU { class CVdpauRenderPicture; }
+namespace XVBA { class CXvbaRenderPicture; }
 class COpenMax;
 class COpenMaxVideo;
 struct OpenMaxVideoBuffer;
@@ -60,6 +61,9 @@ struct DVDVideoPicture
     struct {
       VAAPI::CHolder* vaapi;
     };
+    struct {
+      XVBA::CXvbaRenderPicture* xvba;
+    };
 
     struct {
       COpenMax *openMax;
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
index ec93844..9d4a6b4 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/DVDVideoCodecFFmpeg.cpp
@@ -60,6 +60,9 @@
 #ifdef TARGET_DARWIN_OSX
 #include "VDA.h"
 #endif
+#ifdef HAVE_LIBXVBA
+#include "XVBA.h"
+#endif
 
 using namespace boost;
 
@@ -101,6 +104,19 @@ enum PixelFormat CDVDVideoCodecFFmpeg::GetFormat( struct AVCodecContext * avctx
       dec->Release();
   }
 #endif
+#ifdef HAVE_LIBXVBA
+    if(*cur == AV_PIX_FMT_XVBA_VLD && CSettings::Get().GetBool("videoplayer.usexvba"))
+    {
+      XVBA::CDecoder* dec = new XVBA::CDecoder();
+      if(dec->Open(avctx, *cur, ctx->m_uSurfacesCount))
+      {
+        ctx->SetHardware(dec);
+        return *cur;
+      }
+      else
+        dec->Release();
+    }
+#endif
 #ifdef HAVE_LIBVA
     // mpeg4 vaapi decoding is disabled
     if(*cur == PIX_FMT_VAAPI_VLD && CSettings::Get().GetBool("videoplayer.usevaapi") 
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
index 979e3ce..cacc876 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile.in
@@ -22,6 +22,9 @@ SRCS += OpenMax.cpp
 SRCS += OpenMaxVideo.cpp
 SRCS += DVDVideoCodecOpenMax.cpp
 endif
+ifeq (@USE_XVBA@,1)
+SRCS += XVBA.cpp
+endif
 
 ifeq (@USE_LIBAMCODEC@,1)
 SRCS += AMLCodec.cpp
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp
new file mode 100644
index 0000000..43a331f
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp
@@ -0,0 +1,2367 @@
+/*
+ *      Copyright (C) 2005-2011 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "system.h"
+#ifdef HAVE_LIBXVBA
+
+#include "system_gl.h"
+#include <dlfcn.h>
+#include <string>
+#include "XVBA.h"
+#include "windowing/WindowingFactory.h"
+#include "guilib/GraphicContext.h"
+#include "settings/Settings.h"
+#include "settings/MediaSettings.h"
+#include "utils/TimeUtils.h"
+#include "cores/dvdplayer/DVDClock.h"
+
+using namespace XVBA;
+
+// XVBA interface
+
+#define XVBA_LIBRARY    "libXvBAW.so.1"
+
+typedef Bool        (*XVBAQueryExtensionProc)       (Display *dpy, int *vers);
+typedef Status      (*XVBACreateContextProc)        (void *input, void *output);
+typedef Status      (*XVBADestroyContextProc)       (void *context);
+typedef Bool        (*XVBAGetSessionInfoProc)       (void *input, void *output);
+typedef Status      (*XVBACreateSurfaceProc)        (void *input, void *output);
+typedef Status      (*XVBACreateGLSharedSurfaceProc)(void *input, void *output);
+typedef Status      (*XVBADestroySurfaceProc)       (void *surface);
+typedef Status      (*XVBACreateDecodeBuffersProc)  (void *input, void *output);
+typedef Status      (*XVBADestroyDecodeBuffersProc) (void *input);
+typedef Status      (*XVBAGetCapDecodeProc)         (void *input, void *output);
+typedef Status      (*XVBACreateDecodeProc)         (void *input, void *output);
+typedef Status      (*XVBADestroyDecodeProc)        (void *session);
+typedef Status      (*XVBAStartDecodePictureProc)   (void *input);
+typedef Status      (*XVBADecodePictureProc)        (void *input);
+typedef Status      (*XVBAEndDecodePictureProc)     (void *input);
+typedef Status      (*XVBASyncSurfaceProc)          (void *input, void *output);
+typedef Status      (*XVBAGetSurfaceProc)           (void *input);
+typedef Status      (*XVBATransferSurfaceProc)      (void *input);
+
+static struct
+{
+  XVBAQueryExtensionProc              QueryExtension;
+  XVBACreateContextProc               CreateContext;
+  XVBADestroyContextProc              DestroyContext;
+  XVBAGetSessionInfoProc              GetSessionInfo;
+  XVBACreateSurfaceProc               CreateSurface;
+  XVBACreateGLSharedSurfaceProc       CreateGLSharedSurface;
+  XVBADestroySurfaceProc              DestroySurface;
+  XVBACreateDecodeBuffersProc         CreateDecodeBuffers;
+  XVBADestroyDecodeBuffersProc        DestroyDecodeBuffers;
+  XVBAGetCapDecodeProc                GetCapDecode;
+  XVBACreateDecodeProc                CreateDecode;
+  XVBADestroyDecodeProc               DestroyDecode;
+  XVBAStartDecodePictureProc          StartDecodePicture;
+  XVBADecodePictureProc               DecodePicture;
+  XVBAEndDecodePictureProc            EndDecodePicture;
+  XVBASyncSurfaceProc                 SyncSurface;
+  XVBAGetSurfaceProc                  GetSurface;
+  XVBATransferSurfaceProc             TransferSurface;
+}g_XVBA_vtable;
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+
+CXVBAContext *CXVBAContext::m_context = 0;
+CCriticalSection CXVBAContext::m_section;
+Display *CXVBAContext::m_display = 0;
+void *CXVBAContext::m_dlHandle = 0;
+
+CXVBAContext::CXVBAContext()
+{
+  m_context = 0;
+//  m_dlHandle = 0;
+  m_xvbaContext = 0;
+  m_refCount = 0;
+}
+
+void CXVBAContext::Release()
+{
+  CSingleLock lock(m_section);
+
+  m_refCount--;
+  if (m_refCount <= 0)
+  {
+    Close();
+    delete this;
+    m_context = 0;
+  }
+}
+
+void CXVBAContext::Close()
+{
+  CLog::Log(LOGNOTICE, "XVBA::Close - closing decoder context");
+
+  DestroyContext();
+//  if (m_dlHandle)
+//  {
+//    dlclose(m_dlHandle);
+//    m_dlHandle = 0;
+//  }
+}
+
+bool CXVBAContext::EnsureContext(CXVBAContext **ctx)
+{
+  CSingleLock lock(m_section);
+
+  if (m_context)
+  {
+    m_context->m_refCount++;
+    *ctx = m_context;
+    return true;
+  }
+
+  m_context = new CXVBAContext();
+  *ctx = m_context;
+  {
+    CSingleLock gLock(g_graphicsContext);
+    if (!m_context->LoadSymbols() || !m_context->CreateContext())
+    {
+      delete m_context;
+      m_context = 0;
+      return false;
+    }
+  }
+
+  m_context->m_refCount++;
+
+  *ctx = m_context;
+  return true;
+}
+
+bool CXVBAContext::LoadSymbols()
+{
+  if (!m_dlHandle)
+  {
+    m_dlHandle  = dlopen(XVBA_LIBRARY, RTLD_LAZY);
+    if (!m_dlHandle)
+    {
+      const char* error = dlerror();
+      if (!error)
+        error = "dlerror() returned NULL";
+
+      CLog::Log(LOGERROR,"XVBA::LoadSymbols: Unable to get handle to lib: %s", error);
+      return false;
+    }
+  }
+  else
+    return true;
+
+#define INIT_PROC(PREFIX, PROC) do {                            \
+        g_##PREFIX##_vtable.PROC = (PREFIX##PROC##Proc)         \
+            dlsym(m_dlHandle, #PREFIX #PROC);                   \
+    } while (0)
+
+#define INIT_PROC_CHECK(PREFIX, PROC) do {                      \
+        dlerror();                                              \
+        INIT_PROC(PREFIX, PROC);                                \
+        if (dlerror()) {                                        \
+            dlclose(m_dlHandle);                                \
+            m_dlHandle = NULL;                                  \
+            return false;                                       \
+        }                                                       \
+    } while (0)
+
+#define XVBA_INIT_PROC(PROC) INIT_PROC_CHECK(XVBA, PROC)
+
+  XVBA_INIT_PROC(QueryExtension);
+  XVBA_INIT_PROC(CreateContext);
+  XVBA_INIT_PROC(DestroyContext);
+  XVBA_INIT_PROC(GetSessionInfo);
+  XVBA_INIT_PROC(CreateSurface);
+  XVBA_INIT_PROC(CreateGLSharedSurface);
+  XVBA_INIT_PROC(DestroySurface);
+  XVBA_INIT_PROC(CreateDecodeBuffers);
+  XVBA_INIT_PROC(DestroyDecodeBuffers);
+  XVBA_INIT_PROC(GetCapDecode);
+  XVBA_INIT_PROC(CreateDecode);
+  XVBA_INIT_PROC(DestroyDecode);
+  XVBA_INIT_PROC(StartDecodePicture);
+  XVBA_INIT_PROC(DecodePicture);
+  XVBA_INIT_PROC(EndDecodePicture);
+  XVBA_INIT_PROC(SyncSurface);
+  XVBA_INIT_PROC(GetSurface);
+  XVBA_INIT_PROC(TransferSurface);
+
+#undef XVBA_INIT_PROC
+#undef INIT_PROC
+
+  return true;
+}
+
+bool CXVBAContext::CreateContext()
+{
+  if (m_xvbaContext)
+    return true;
+
+  CLog::Log(LOGNOTICE,"XVBA::CreateContext - creating decoder context");
+
+  Drawable window;
+  { CSingleLock lock(g_graphicsContext);
+    if (!m_display)
+      m_display = XOpenDisplay(NULL);
+    window = 0;
+  }
+
+  int version;
+  if (!g_XVBA_vtable.QueryExtension(m_display, &version))
+    return false;
+  CLog::Log(LOGNOTICE,"XVBA::CreateContext - opening xvba version: %i", version);
+
+  // create XVBA Context
+  XVBA_Create_Context_Input contextInput;
+  XVBA_Create_Context_Output contextOutput;
+  contextInput.size = sizeof(contextInput);
+  contextInput.display = m_display;
+  contextInput.draw = window;
+  contextOutput.size = sizeof(contextOutput);
+  if(Success != g_XVBA_vtable.CreateContext(&contextInput, &contextOutput))
+  {
+    CLog::Log(LOGERROR,"XVBA::CreateContext - failed to create context");
+    return false;
+  }
+  m_xvbaContext = contextOutput.context;
+
+  return true;
+}
+
+void CXVBAContext::DestroyContext()
+{
+  if (!m_xvbaContext)
+    return;
+
+  g_XVBA_vtable.DestroyContext(m_xvbaContext);
+  m_xvbaContext = 0;
+//  XCloseDisplay(m_display);
+}
+
+void *CXVBAContext::GetContext()
+{
+  return m_xvbaContext;
+}
+
+//-----------------------------------------------------------------------------
+//-----------------------------------------------------------------------------
+
+static unsigned int decoderId = 0;
+
+CDecoder::CDecoder() : m_xvbaOutput(&m_inMsgEvent)
+{
+  m_xvbaConfig.context = 0;
+  m_xvbaConfig.xvbaSession = 0;
+  m_xvbaConfig.videoSurfaces = &m_videoSurfaces;
+  m_xvbaConfig.videoSurfaceSec = &m_videoSurfaceSec;
+  m_xvbaConfig.apiSec = &m_apiSec;
+
+  m_displayState = XVBA_OPEN;
+}
+
+CDecoder::~CDecoder()
+{
+  Close();
+}
+
+typedef struct {
+    unsigned int  size;
+    unsigned int  num_of_decodecaps;
+    XVBADecodeCap decode_caps_list[];
+} XVBA_GetCapDecode_Output_Base;
+
+void CDecoder::OnLostDevice()
+{
+  CLog::Log(LOGNOTICE,"XVBA::OnLostDevice event");
+
+  CSingleLock lock(m_decoderSection);
+  DestroySession();
+  if (m_xvbaConfig.context)
+    m_xvbaConfig.context->Release();
+  m_xvbaConfig.context = 0;
+
+  m_displayState = XVBA_LOST;
+  m_displayEvent.Reset();
+}
+
+void CDecoder::OnResetDevice()
+{
+  CLog::Log(LOGNOTICE,"XVBA::OnResetDevice event");
+
+  CSingleLock lock(m_decoderSection);
+  if (m_displayState == XVBA_LOST)
+  {
+    m_displayState = XVBA_RESET;
+    lock.Leave();
+    m_displayEvent.Set();
+  }
+}
+
+bool CDecoder::Open(AVCodecContext* avctx, const enum PixelFormat fmt, unsigned int surfaces)
+{
+  std::string Vendor = g_Windowing.GetRenderVendor();
+  std::transform(Vendor.begin(), Vendor.end(), Vendor.begin(), ::tolower);
+  if (Vendor.compare(0, 3, "ati") != 0)
+  {
+    return false;
+  }
+
+  m_decoderId = decoderId++;
+
+  CLog::Log(LOGNOTICE,"(XVBA::Open) opening xvba decoder, id: %d", m_decoderId);
+
+  if(avctx->coded_width  == 0
+  || avctx->coded_height == 0)
+  {
+    CLog::Log(LOGWARNING,"(XVBA) no width/height available, can't init");
+    return false;
+  }
+
+  // Fixme: Revisit with new SDK
+  // Workaround for 0.74.01-AES-2 that does not signal if surfaces are too large
+  // it seems that xvba does not support anything > 2k
+  // return false, for files that are larger
+  // if you are unlucky, this would kill your decoder
+  // we limit to 2048x1536(+8) now - as this was tested working
+  int surfaceWidth = (avctx->coded_width+15) & ~15;
+  int surfaceHeight = (avctx->coded_height+15) & ~15;
+  if(surfaceHeight > 1544 || surfaceWidth > 2048)
+  {
+    CLog::Log(LOGERROR, "Surface too large, decoder skipped: surfaceWidth %u, surfaceHeight %u",
+                        surfaceWidth, surfaceHeight);
+    return false;
+  }
+
+  if (!m_dllAvUtil.Load())
+    return false;
+
+  if (!CXVBAContext::EnsureContext(&m_xvbaConfig.context))
+    return false;
+
+  // xvba get session info
+  XVBA_GetSessionInfo_Input sessionInput;
+  XVBA_GetSessionInfo_Output sessionOutput;
+  sessionInput.size = sizeof(sessionInput);
+  sessionInput.context = m_xvbaConfig.context->GetContext();
+  sessionOutput.size = sizeof(sessionOutput);
+  if (Success != g_XVBA_vtable.GetSessionInfo(&sessionInput, &sessionOutput))
+  {
+    CLog::Log(LOGERROR,"(XVBA) can't get session info");
+    return false;
+  }
+  if (sessionOutput.getcapdecode_output_size == 0)
+  {
+    CLog::Log(LOGERROR,"(XVBA) session decode not supported");
+    return false;
+  }
+
+  // get decoder capabilities
+  XVBA_GetCapDecode_Input capInput;
+  XVBA_GetCapDecode_Output *capOutput;
+  capInput.size = sizeof(capInput);
+  capInput.context = m_xvbaConfig.context->GetContext();
+  capOutput = (XVBA_GetCapDecode_Output *)calloc(sessionOutput.getcapdecode_output_size, 1);
+  capOutput->size = sessionOutput.getcapdecode_output_size;
+  if (Success != g_XVBA_vtable.GetCapDecode(&capInput, capOutput))
+  {
+    CLog::Log(LOGERROR,"(XVBA) can't get decode capabilities");
+    return false;
+  }
+
+  int match = -1;
+  if (avctx->codec_id == CODEC_ID_H264)
+  {
+    // search for profile high
+    for (unsigned int i = 0; i < capOutput->num_of_decodecaps; ++i)
+    {
+      if (capOutput->decode_caps_list[i].capability_id == XVBA_H264 &&
+          capOutput->decode_caps_list[i].flags == XVBA_H264_HIGH)
+      {
+        match = (int) i;
+        break;
+      }
+    }
+    if (match < 0)
+    {
+      CLog::Log(LOGNOTICE, "(XVBA::Open) - profile XVBA_H264_HIGH not found");
+    }
+  }
+  else if (avctx->codec_id == CODEC_ID_VC1)
+  {
+    // search for profile advanced
+    for (unsigned int i = 0; i < capOutput->num_of_decodecaps; ++i)
+    {
+      if (capOutput->decode_caps_list[i].capability_id == XVBA_VC1 &&
+          capOutput->decode_caps_list[i].flags == XVBA_VC1_ADVANCED)
+      {
+        match = (int) i;
+        break;
+      }
+    }
+    if (match < 0)
+    {
+      CLog::Log(LOGNOTICE, "(XVBA::Open) - profile XVBA_VC1_ADVANCED not found");
+    }
+  }
+  else if (avctx->codec_id == CODEC_ID_MPEG2VIDEO)
+  {
+    // search for profile high
+    for (unsigned int i = 0; i < capOutput->num_of_decodecaps; ++i)
+    {
+      if (capOutput->decode_caps_list[i].capability_id == XVBA_MPEG2_VLD)
+      {
+        // XXX: uncomment when implemented
+        // match = (int) i;
+        // break;
+      }
+    }
+    if (match < 0)
+    {
+      CLog::Log(LOGNOTICE, "(XVBA::Open) - profile XVBA_MPEG2_VLD not found");
+    }
+  }
+  else if (avctx->codec_id == CODEC_ID_WMV3)
+  {
+    // search for profile high
+    for (unsigned int i = 0; i < capOutput->num_of_decodecaps; ++i)
+    {
+      if (capOutput->decode_caps_list[i].capability_id == XVBA_VC1 &&
+          capOutput->decode_caps_list[i].flags == XVBA_VC1_MAIN)
+      {
+        match = (int) i;
+        break;
+      }
+    }
+    if (match < 0)
+    {
+      CLog::Log(LOGNOTICE, "(XVBA::Open) - profile XVBA_VC1_MAIN not found");
+    }
+  }
+
+  if (match < 0)
+  {
+    free(capOutput);
+    return false;
+  }
+
+  CLog::Log(LOGNOTICE,"(XVBA) using decoder capability id: %i flags: %i",
+                          capOutput->decode_caps_list[match].capability_id,
+                          capOutput->decode_caps_list[match].flags);
+  CLog::Log(LOGNOTICE,"(XVBA) using surface type: %x",
+                          capOutput->decode_caps_list[match].surface_type);
+
+  m_xvbaConfig.decoderCap = capOutput->decode_caps_list[match];
+
+  free(capOutput);
+
+  // set some varables
+  m_xvbaConfig.xvbaSession = 0;
+  m_xvbaBufferPool.data_buffer = 0;
+  m_xvbaBufferPool.iq_matrix_buffer = 0;
+  m_xvbaBufferPool.picture_descriptor_buffer = 0;
+  m_presentPicture = 0;
+  m_xvbaConfig.numRenderBuffers = surfaces;
+  m_decoderThread = CThread::GetCurrentThreadId();
+  m_speed = DVD_PLAYSPEED_NORMAL;
+
+  if (1) //g_guiSettings.GetBool("videoplayer.usexvbasharedsurface"))
+    m_xvbaConfig.useSharedSurfaces = true;
+  else
+    m_xvbaConfig.useSharedSurfaces = false;
+
+  m_displayState = XVBA_OPEN;
+
+  // setup ffmpeg
+  avctx->thread_count    = 1;
+  avctx->get_buffer      = CDecoder::FFGetBuffer;
+  avctx->release_buffer  = CDecoder::FFReleaseBuffer;
+  avctx->draw_horiz_band = CDecoder::FFDrawSlice;
+  avctx->slice_flags     = SLICE_FLAG_CODED_ORDER|SLICE_FLAG_ALLOW_FIELD;
+
+  g_Windowing.Register(this);
+  return true;
+}
+
+void CDecoder::Close()
+{
+  CLog::Log(LOGNOTICE, "XVBA::Close - closing decoder, id: %d", m_decoderId);
+
+  if (!m_xvbaConfig.context)
+    return;
+
+  DestroySession();
+  if (m_xvbaConfig.context)
+    m_xvbaConfig.context->Release();
+  m_xvbaConfig.context = 0;
+
+  while (!m_videoSurfaces.empty())
+  {
+    xvba_render_state *render = m_videoSurfaces.back();
+    if(render->buffers_alllocated > 0)
+      m_dllAvUtil.av_free(render->buffers);
+    m_videoSurfaces.pop_back();
+    free(render);
+  }
+
+  g_Windowing.Unregister(this);
+  m_dllAvUtil.Unload();
+}
+
+long CDecoder::Release()
+{
+  // check if we should do some pre-cleanup here
+  // a second decoder might need resources
+  if (m_xvbaConfig.xvbaSession)
+  {
+    CSingleLock lock(m_decoderSection);
+    CLog::Log(LOGNOTICE,"XVBA::Release pre-cleanup");
+    DestroySession(true);
+  }
+  return IHardwareDecoder::Release();
+}
+
+long CDecoder::ReleasePicReference()
+{
+  return IHardwareDecoder::Release();
+}
+
+bool CDecoder::Supports(EINTERLACEMETHOD method)
+{
+  if(method == VS_INTERLACEMETHOD_AUTO)
+    return true;
+
+  if (1) //g_guiSettings.GetBool("videoplayer.usexvbasharedsurface"))
+  {
+    if (method == VS_INTERLACEMETHOD_XVBA)
+      return true;
+  }
+
+  return false;
+}
+
+void CDecoder::ResetState()
+{
+  m_displayState = XVBA_OPEN;
+}
+
+int CDecoder::Check(AVCodecContext* avctx)
+{
+  EDisplayState state;
+
+  { CSingleLock lock(m_decoderSection);
+    state = m_displayState;
+  }
+
+  if (state == XVBA_LOST)
+  {
+    CLog::Log(LOGNOTICE,"XVBA::Check waiting for display reset event");
+    if (!m_displayEvent.WaitMSec(2000))
+    {
+      CLog::Log(LOGERROR, "XVBA::Check - device didn't reset in reasonable time");
+      state = XVBA_RESET;;
+    }
+    else
+    { CSingleLock lock(m_decoderSection);
+      state = m_displayState;
+    }
+  }
+  if (state == XVBA_RESET || state == XVBA_ERROR)
+  {
+    CLog::Log(LOGNOTICE,"XVBA::Check - Attempting recovery");
+
+    CSingleLock gLock(g_graphicsContext);
+    CSingleLock lock(m_decoderSection);
+
+    DestroySession();
+    ResetState();
+    CXVBAContext::EnsureContext(&m_xvbaConfig.context);
+
+    if (state == XVBA_RESET)
+      return VC_FLUSHED;
+    else
+      return VC_ERROR;
+  }
+  return 0;
+}
+
+void CDecoder::SetError(const char* function, const char* msg, int line)
+{
+  CLog::Log(LOGERROR, "XVBA::%s - %s, line %d", function, msg, line);
+  CSingleLock lock(m_decoderSection);
+  m_displayState = XVBA_ERROR;
+}
+
+bool CDecoder::CreateSession(AVCodecContext* avctx)
+{
+  m_xvbaConfig.surfaceWidth = (avctx->coded_width+15) & ~15;
+  m_xvbaConfig.surfaceHeight = (avctx->coded_height+15) & ~15;
+
+  m_xvbaConfig.vidWidth = avctx->width;
+  m_xvbaConfig.vidHeight = avctx->height;
+
+  XVBA_Create_Decode_Session_Input sessionInput;
+  XVBA_Create_Decode_Session_Output sessionOutput;
+
+  sessionInput.size = sizeof(sessionInput);
+  sessionInput.width = m_xvbaConfig.surfaceWidth;
+  sessionInput.height = m_xvbaConfig.surfaceHeight;
+  sessionInput.context = m_xvbaConfig.context->GetContext();
+  sessionInput.decode_cap = &m_xvbaConfig.decoderCap;
+  sessionOutput.size = sizeof(sessionOutput);
+
+  if (Success != g_XVBA_vtable.CreateDecode(&sessionInput, &sessionOutput))
+  {
+    SetError(__FUNCTION__, "failed to create decoder session", __LINE__);
+    CLog::Log(LOGERROR, "Decoder failed with following stats: m_surfaceWidth %u, m_surfaceHeight %u,"
+                        " m_vidWidth %u, m_vidHeight %u, coded_width %d, coded_height %d",
+                        m_xvbaConfig.surfaceWidth,
+                        m_xvbaConfig.surfaceHeight,
+                        m_xvbaConfig.vidWidth,
+                        m_xvbaConfig.vidHeight,
+                        avctx->coded_width,
+                        avctx->coded_height);
+    return false;
+  }
+  m_xvbaConfig.xvbaSession = sessionOutput.session;
+
+  // create decode buffers
+  XVBA_Create_DecodeBuff_Input bufferInput;
+  XVBA_Create_DecodeBuff_Output bufferOutput;
+
+  bufferInput.size = sizeof(bufferInput);
+  bufferInput.session = m_xvbaConfig.xvbaSession;
+  bufferInput.buffer_type = XVBA_PICTURE_DESCRIPTION_BUFFER;
+  bufferInput.num_of_buffers = 1;
+  bufferOutput.size = sizeof(bufferOutput);
+  if (Success != g_XVBA_vtable.CreateDecodeBuffers(&bufferInput, &bufferOutput)
+      || bufferOutput.num_of_buffers_in_list != 1)
+  {
+    SetError(__FUNCTION__, "failed to create picture buffer", __LINE__);
+    return false;
+  }
+  m_xvbaBufferPool.picture_descriptor_buffer = bufferOutput.buffer_list;
+
+  // data buffer
+  bufferInput.buffer_type = XVBA_DATA_BUFFER;
+  if (Success != g_XVBA_vtable.CreateDecodeBuffers(&bufferInput, &bufferOutput)
+      || bufferOutput.num_of_buffers_in_list != 1)
+  {
+    SetError(__FUNCTION__, "failed to create data buffer", __LINE__);
+    return false;
+  }
+  m_xvbaBufferPool.data_buffer = bufferOutput.buffer_list;
+
+  // QO Buffer
+  bufferInput.buffer_type = XVBA_QM_BUFFER;
+  if (Success != g_XVBA_vtable.CreateDecodeBuffers(&bufferInput, &bufferOutput)
+      || bufferOutput.num_of_buffers_in_list != 1)
+  {
+    SetError(__FUNCTION__, "failed to create qm buffer", __LINE__);
+    return false;
+  }
+  m_xvbaBufferPool.iq_matrix_buffer = bufferOutput.buffer_list;
+
+
+  // initialize output
+  CSingleLock lock(g_graphicsContext);
+  m_xvbaConfig.stats = &m_bufferStats;
+  m_bufferStats.Reset();
+  m_xvbaOutput.Start();
+  Message *reply;
+  if (m_xvbaOutput.m_controlPort.SendOutMessageSync(COutputControlProtocol::INIT,
+                                                 &reply,
+                                                 2000,
+                                                 &m_xvbaConfig,
+                                                 sizeof(m_xvbaConfig)))
+  {
+    bool success = reply->signal == COutputControlProtocol::ACC ? true : false;
+    reply->Release();
+    if (!success)
+    {
+      CLog::Log(LOGERROR, "XVBA::%s - vdpau output returned error", __FUNCTION__);
+      m_xvbaOutput.Dispose();
+      return false;
+    }
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "XVBA::%s - failed to init output", __FUNCTION__);
+    m_xvbaOutput.Dispose();
+    return false;
+  }
+  m_inMsgEvent.Reset();
+
+  return true;
+}
+
+void CDecoder::DestroySession(bool precleanup /*= false*/)
+{
+  // wait for unfinished decoding jobs
+  XbmcThreads::EndTime timer;
+  if (m_xvbaConfig.xvbaSession)
+  {
+    for (unsigned int i = 0; i < m_videoSurfaces.size(); ++i)
+    {
+      xvba_render_state *render = m_videoSurfaces[i];
+      if (render->surface)
+      {
+        XVBA_Surface_Sync_Input syncInput;
+        XVBA_Surface_Sync_Output syncOutput;
+        syncInput.size = sizeof(syncInput);
+        syncInput.session = m_xvbaConfig.xvbaSession;
+        syncInput.surface = render->surface;
+        syncInput.query_status = XVBA_GET_SURFACE_STATUS;
+        syncOutput.size = sizeof(syncOutput);
+        timer.Set(1000);
+        while(!timer.IsTimePast())
+        {
+          if (Success != g_XVBA_vtable.SyncSurface(&syncInput, &syncOutput))
+          {
+            CLog::Log(LOGERROR,"XVBA::DestroySession - failed sync surface");
+            break;
+          }
+          if (!(syncOutput.status_flags & XVBA_STILL_PENDING))
+            break;
+          Sleep(10);
+        }
+        if (timer.IsTimePast())
+          CLog::Log(LOGERROR,"XVBA::DestroySession - unfinished decoding job");
+      }
+    }
+  }
+
+  if (precleanup)
+  {
+    Message *reply;
+    if (m_xvbaOutput.m_controlPort.SendOutMessageSync(COutputControlProtocol::PRECLEANUP,
+                                                   &reply,
+                                                   2000))
+    {
+      bool success = reply->signal == COutputControlProtocol::ACC ? true : false;
+      reply->Release();
+      if (!success)
+      {
+        CLog::Log(LOGERROR, "XVBA::%s - pre-cleanup returned error", __FUNCTION__);
+        m_displayState = XVBA_ERROR;
+      }
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "XVBA::%s - pre-cleanup timed out", __FUNCTION__);
+      m_displayState = XVBA_ERROR;
+    }
+  }
+  else
+    m_xvbaOutput.Dispose();
+
+  XVBA_Destroy_Decode_Buffers_Input bufInput;
+  bufInput.size = sizeof(bufInput);
+  bufInput.num_of_buffers_in_list = 1;
+  bufInput.session = m_xvbaConfig.xvbaSession;
+
+  for (unsigned int i=0; i<m_xvbaBufferPool.data_control_buffers.size() ; ++i)
+  {
+    bufInput.buffer_list = m_xvbaBufferPool.data_control_buffers[i];
+    g_XVBA_vtable.DestroyDecodeBuffers(&bufInput);
+  }
+  m_xvbaBufferPool.data_control_buffers.clear();
+
+  if (m_xvbaConfig.xvbaSession && m_xvbaBufferPool.data_buffer)
+  {
+    bufInput.buffer_list = m_xvbaBufferPool.data_buffer;
+    g_XVBA_vtable.DestroyDecodeBuffers(&bufInput);
+  }
+  m_xvbaBufferPool.data_buffer = 0;
+
+  if (m_xvbaConfig.xvbaSession && m_xvbaBufferPool.picture_descriptor_buffer)
+  {
+    bufInput.buffer_list = m_xvbaBufferPool.picture_descriptor_buffer;
+    g_XVBA_vtable.DestroyDecodeBuffers(&bufInput);
+  }
+  m_xvbaBufferPool.picture_descriptor_buffer = 0;
+
+  if (m_xvbaConfig.xvbaSession && m_xvbaBufferPool.iq_matrix_buffer)
+  {
+    bufInput.buffer_list = m_xvbaBufferPool.iq_matrix_buffer;
+    g_XVBA_vtable.DestroyDecodeBuffers(&bufInput);
+  }
+  m_xvbaBufferPool.iq_matrix_buffer = 0;
+
+  for (unsigned int i = 0; i < m_videoSurfaces.size(); ++i)
+  {
+    xvba_render_state *render = m_videoSurfaces[i];
+    if (m_xvbaConfig.xvbaSession && render->surface)
+    {
+      g_XVBA_vtable.DestroySurface(render->surface);
+      render->surface = 0;
+      render->state = 0;
+      render->picture_descriptor = 0;
+      render->iq_matrix = 0;
+    }
+  }
+
+  if (m_xvbaConfig.xvbaSession)
+    g_XVBA_vtable.DestroyDecode(m_xvbaConfig.xvbaSession);
+  m_xvbaConfig.xvbaSession = 0;
+}
+
+bool CDecoder::IsSurfaceValid(xvba_render_state *render)
+{
+  // find render state in queue
+  bool found(false);
+  unsigned int i;
+  for(i = 0; i < m_videoSurfaces.size(); ++i)
+  {
+    if(m_videoSurfaces[i] == render)
+    {
+      found = true;
+      break;
+    }
+  }
+  if (!found)
+  {
+    CLog::Log(LOGERROR,"%s - video surface not found", __FUNCTION__);
+    return false;
+  }
+  if (m_videoSurfaces[i]->surface == 0)
+  {
+    m_videoSurfaces[i]->state = 0;
+    return false;
+  }
+
+  return true;
+}
+
+bool CDecoder::EnsureDataControlBuffers(unsigned int num)
+{
+  if (m_xvbaBufferPool.data_control_buffers.size() >= num)
+    return true;
+
+  unsigned int missing = num - m_xvbaBufferPool.data_control_buffers.size();
+
+  XVBA_Create_DecodeBuff_Input bufferInput;
+  XVBA_Create_DecodeBuff_Output bufferOutput;
+  bufferInput.size = sizeof(bufferInput);
+  bufferInput.session = m_xvbaConfig.xvbaSession;
+  bufferInput.buffer_type = XVBA_DATA_CTRL_BUFFER;
+  bufferInput.num_of_buffers = 1;
+  bufferOutput.size = sizeof(bufferOutput);
+
+  for (unsigned int i=0; i<missing; ++i)
+  {
+    { CSingleLock lock(m_apiSec);
+      if (Success != g_XVBA_vtable.CreateDecodeBuffers(&bufferInput, &bufferOutput)
+          || bufferOutput.num_of_buffers_in_list != 1)
+      {
+        SetError(__FUNCTION__, "failed to create data control buffer", __LINE__);
+        return false;
+      }
+    }
+    m_xvbaBufferPool.data_control_buffers.push_back(bufferOutput.buffer_list);
+  }
+
+  return true;
+}
+
+void CDecoder::FFReleaseBuffer(AVCodecContext *avctx, AVFrame *pic)
+{
+  CDVDVideoCodecFFmpeg* ctx   = (CDVDVideoCodecFFmpeg*)avctx->opaque;
+  CDecoder*             xvba  = (CDecoder*)ctx->GetHardware();
+  unsigned int i;
+
+  CSingleLock lock(xvba->m_decoderSection);
+
+  xvba_render_state * render = NULL;
+  render = (xvba_render_state*)pic->data[0];
+  if(!render)
+  {
+    CLog::Log(LOGERROR, "XVBA::FFReleaseBuffer - invalid context handle provided");
+    return;
+  }
+
+  for(i=0; i<4; i++)
+    pic->data[i]= NULL;
+
+  // find render state in queue
+  if (!xvba->IsSurfaceValid(render))
+  {
+    CLog::Log(LOGDEBUG, "XVBA::FFReleaseBuffer - ignoring invalid buffer");
+    return;
+  }
+
+  render->state &= ~FF_XVBA_STATE_USED_FOR_REFERENCE;
+}
+
+void CDecoder::FFDrawSlice(struct AVCodecContext *avctx,
+                             const AVFrame *src, int offset[4],
+                             int y, int type, int height)
+{
+  CDVDVideoCodecFFmpeg* ctx   = (CDVDVideoCodecFFmpeg*)avctx->opaque;
+  CDecoder*             xvba  = (CDecoder*)ctx->GetHardware();
+
+  CSingleLock lock(xvba->m_decoderSection);
+
+  if(xvba->m_displayState != XVBA_OPEN)
+    return;
+
+  if(src->linesize[0] || src->linesize[1] || src->linesize[2]
+    || offset[0] || offset[1] || offset[2])
+  {
+    CLog::Log(LOGERROR, "XVBA::FFDrawSlice - invalid linesizes or offsets provided");
+    return;
+  }
+
+  xvba_render_state * render;
+
+  render = (xvba_render_state*)src->data[0];
+  if(!render)
+  {
+    CLog::Log(LOGERROR, "XVBA::FFDrawSlice - invalid context handle provided");
+    return;
+  }
+
+  // ffmpeg vc-1 decoder does not flush, make sure the data buffer is still valid
+  if (!xvba->IsSurfaceValid(render))
+  {
+    CLog::Log(LOGWARNING, "XVBA::FFDrawSlice - ignoring invalid buffer");
+    return;
+  }
+
+  // decoding
+  XVBA_Decode_Picture_Start_Input startInput;
+  startInput.size = sizeof(startInput);
+  startInput.session = xvba->m_xvbaConfig.xvbaSession;
+  startInput.target_surface = render->surface;
+  { CSingleLock lock(xvba->m_apiSec);
+    if (Success != g_XVBA_vtable.StartDecodePicture(&startInput))
+    {
+      xvba->SetError(__FUNCTION__, "failed to start decoding", __LINE__);
+      return;
+    }
+  }
+
+  XVBA_Decode_Picture_Input picInput;
+  picInput.size = sizeof(picInput);
+  picInput.session = xvba->m_xvbaConfig.xvbaSession;
+  XVBABufferDescriptor *list[2];
+  picInput.buffer_list = list;
+  list[0] = xvba->m_xvbaBufferPool.picture_descriptor_buffer;
+  picInput.num_of_buffers_in_list = 1;
+  if (avctx->codec_id == CODEC_ID_H264)
+  {
+    list[1] = xvba->m_xvbaBufferPool.iq_matrix_buffer;
+    picInput.num_of_buffers_in_list = 2;
+  }
+
+  { CSingleLock lock(xvba->m_apiSec);
+    if (Success != g_XVBA_vtable.DecodePicture(&picInput))
+    {
+      xvba->SetError(__FUNCTION__, "failed to decode picture 1", __LINE__);
+      return;
+    }
+  }
+
+  if (!xvba->EnsureDataControlBuffers(render->num_slices))
+    return;
+
+  XVBADataCtrl *dataControl;
+  int location = 0;
+  xvba->m_xvbaBufferPool.data_buffer->data_size_in_buffer = 0;
+  for (unsigned int j = 0; j < render->num_slices; ++j)
+  {
+    int startCodeSize = 0;
+    uint8_t startCode[] = {0x00,0x00,0x01};
+    if (avctx->codec_id == CODEC_ID_H264)
+    {
+      startCodeSize = 3;
+      memcpy((uint8_t*)xvba->m_xvbaBufferPool.data_buffer->bufferXVBA+location,
+          startCode, 3);
+    }
+    else if (avctx->codec_id == CODEC_ID_VC1 &&
+        (memcmp(render->buffers[j].buffer, startCode, 3) != 0))
+    {
+      startCodeSize = 4;
+      uint8_t sdf = 0x0d;
+      memcpy((uint8_t*)xvba->m_xvbaBufferPool.data_buffer->bufferXVBA+location,
+          startCode, 3);
+      memcpy((uint8_t*)xvba->m_xvbaBufferPool.data_buffer->bufferXVBA+location+3,
+          &sdf, 1);
+    }
+    // check for potential buffer overwrite
+    unsigned int bytesToCopy = render->buffers[j].size;
+    unsigned int freeBufferSize = xvba->m_xvbaBufferPool.data_buffer->buffer_size -
+        xvba->m_xvbaBufferPool.data_buffer->data_size_in_buffer;
+    if (bytesToCopy >= freeBufferSize)
+    {
+      xvba->SetError(__FUNCTION__, "bitstream buffer too large, maybe corrupted packet", __LINE__);
+      return;
+    }
+    memcpy((uint8_t*)xvba->m_xvbaBufferPool.data_buffer->bufferXVBA+location+startCodeSize,
+        render->buffers[j].buffer,
+        render->buffers[j].size);
+    dataControl = (XVBADataCtrl*)xvba->m_xvbaBufferPool.data_control_buffers[j]->bufferXVBA;
+    dataControl->SliceDataLocation = location;
+    dataControl->SliceBytesInBuffer = render->buffers[j].size+startCodeSize;
+    dataControl->SliceBitsInBuffer = dataControl->SliceBytesInBuffer * 8;
+    xvba->m_xvbaBufferPool.data_buffer->data_size_in_buffer += dataControl->SliceBytesInBuffer;
+    location += dataControl->SliceBytesInBuffer;
+  }
+
+  int bufSize = xvba->m_xvbaBufferPool.data_buffer->data_size_in_buffer;
+  int padding = bufSize % 128;
+  if (padding)
+  {
+    padding = 128 - padding;
+    xvba->m_xvbaBufferPool.data_buffer->data_size_in_buffer += padding;
+    memset((uint8_t*)xvba->m_xvbaBufferPool.data_buffer->bufferXVBA+bufSize,0,padding);
+  }
+
+  picInput.num_of_buffers_in_list = 2;
+  for (unsigned int i = 0; i < render->num_slices; ++i)
+  {
+    list[0] = xvba->m_xvbaBufferPool.data_buffer;
+    list[0]->data_offset = 0;
+    list[1] = xvba->m_xvbaBufferPool.data_control_buffers[i];
+    list[1]->data_size_in_buffer = sizeof(*dataControl);
+    { CSingleLock lock(xvba->m_apiSec);
+      if (Success != g_XVBA_vtable.DecodePicture(&picInput))
+      {
+        xvba->SetError(__FUNCTION__, "failed to decode picture 2", __LINE__);
+        return;
+      }
+    }
+  }
+  XVBA_Decode_Picture_End_Input endInput;
+  endInput.size = sizeof(endInput);
+  endInput.session = xvba->m_xvbaConfig.xvbaSession;
+  { CSingleLock lock(xvba->m_apiSec);
+    if (Success != g_XVBA_vtable.EndDecodePicture(&endInput))
+    {
+      xvba->SetError(__FUNCTION__, "failed to decode picture 3", __LINE__);
+      return;
+    }
+  }
+
+  // decode sync and error
+  XVBA_Surface_Sync_Input syncInput;
+  XVBA_Surface_Sync_Output syncOutput;
+  syncInput.size = sizeof(syncInput);
+  syncInput.session = xvba->m_xvbaConfig.xvbaSession;
+  syncInput.surface = render->surface;
+  syncInput.query_status = XVBA_GET_SURFACE_STATUS;
+  syncOutput.size = sizeof(syncOutput);
+  int64_t start = CurrentHostCounter();
+  while (1)
+  {
+    { CSingleLock lock(xvba->m_apiSec);
+      if (Success != g_XVBA_vtable.SyncSurface(&syncInput, &syncOutput))
+      {
+        xvba->SetError(__FUNCTION__, "failed sync surface 1", __LINE__);
+        return;
+      }
+    }
+    if (!(syncOutput.status_flags & XVBA_STILL_PENDING))
+      break;
+    if (CurrentHostCounter() - start > CurrentHostFrequency())
+    {
+      xvba->SetError(__FUNCTION__, "timed out waiting for surface", __LINE__);
+      break;
+    }
+    usleep(100);
+  }
+  render->state |= FF_XVBA_STATE_DECODED;
+}
+
+int CDecoder::FFGetBuffer(AVCodecContext *avctx, AVFrame *pic)
+{
+  CDVDVideoCodecFFmpeg* ctx   = (CDVDVideoCodecFFmpeg*)avctx->opaque;
+  CDecoder*             xvba  = (CDecoder*)ctx->GetHardware();
+
+  pic->data[0] =
+  pic->data[1] =
+  pic->data[2] =
+  pic->data[3] = 0;
+
+  pic->linesize[0] =
+  pic->linesize[1] =
+  pic->linesize[2] =
+  pic->linesize[3] = 0;
+
+  CSingleLock lock(xvba->m_decoderSection);
+
+  if(xvba->m_displayState != XVBA_OPEN)
+    return -1;
+
+  if (xvba->m_xvbaConfig.xvbaSession == 0)
+  {
+    if (!xvba->CreateSession(avctx))
+      return -1;
+  }
+
+  xvba_render_state * render = NULL;
+  // find unused surface
+  { CSingleLock lock(xvba->m_videoSurfaceSec);
+    for(unsigned int i = 0; i < xvba->m_videoSurfaces.size(); ++i)
+    {
+      if(!(xvba->m_videoSurfaces[i]->state & (FF_XVBA_STATE_USED_FOR_REFERENCE | FF_XVBA_STATE_USED_FOR_RENDER)))
+      {
+        render = xvba->m_videoSurfaces[i];
+        render->state = 0;
+        break;
+      }
+    }
+  }
+
+  // create a new render state
+  if (render == NULL)
+  {
+    render = (xvba_render_state*)calloc(sizeof(xvba_render_state), 1);
+    if (render == NULL)
+    {
+      CLog::Log(LOGERROR, "XVBA::FFGetBuffer - calloc failed");
+      return -1;
+    }
+    render->surface = 0;
+    render->buffers_alllocated = 0;
+    CSingleLock lock(xvba->m_videoSurfaceSec);
+    xvba->m_videoSurfaces.push_back(render);
+  }
+
+  // create a new surface
+  if (render->surface == 0)
+  {
+    XVBA_Create_Surface_Input surfaceInput;
+    XVBA_Create_Surface_Output surfaceOutput;
+    surfaceInput.size = sizeof(surfaceInput);
+    surfaceInput.surface_type = xvba->m_xvbaConfig.decoderCap.surface_type;
+    surfaceInput.width = xvba->m_xvbaConfig.surfaceWidth;
+    surfaceInput.height = xvba->m_xvbaConfig.surfaceHeight;
+    surfaceInput.session = xvba->m_xvbaConfig.xvbaSession;
+    surfaceOutput.size = sizeof(surfaceOutput);
+    { CSingleLock lock(xvba->m_apiSec);
+      if (Success != g_XVBA_vtable.CreateSurface(&surfaceInput, &surfaceOutput))
+      {
+        xvba->SetError(__FUNCTION__, "failed to create video surface", __LINE__);
+        return -1;
+      }
+    }
+    render->surface = surfaceOutput.surface;
+    render->picture_descriptor = (XVBAPictureDescriptor *)xvba->m_xvbaBufferPool.picture_descriptor_buffer->bufferXVBA;
+    render->iq_matrix = (XVBAQuantMatrixAvc *)xvba->m_xvbaBufferPool.iq_matrix_buffer->bufferXVBA;
+    CLog::Log(LOGDEBUG, "XVBA::FFGetBuffer - created video surface");
+  }
+
+  if (render == NULL)
+    return -1;
+
+  pic->data[0] = (uint8_t*)render;
+
+  pic->type= FF_BUFFER_TYPE_USER;
+
+  render->state |= FF_XVBA_STATE_USED_FOR_REFERENCE;
+  render->state &= ~FF_XVBA_STATE_DECODED;
+  pic->reordered_opaque= avctx->reordered_opaque;
+
+  return 0;
+}
+
+int CDecoder::Decode(AVCodecContext* avctx, AVFrame* frame)
+{
+  int result = Check(avctx);
+  if (result)
+    return result;
+
+  CSingleLock lock(m_decoderSection);
+
+  if(frame)
+  { // we have a new frame from decoder
+
+    xvba_render_state * render = (xvba_render_state*)frame->data[0];
+    if(!render)
+    {
+      CLog::Log(LOGERROR, "XVBA::Decode - no render buffer");
+      return VC_ERROR;
+    }
+
+    // ffmpeg vc-1 decoder does not flush, make sure the data buffer is still valid
+    if (!IsSurfaceValid(render))
+    {
+      CLog::Log(LOGWARNING, "XVBA::Decode - ignoring invalid buffer");
+      return VC_BUFFER;
+    }
+    if (!(render->state & FF_XVBA_STATE_DECODED))
+    {
+      CLog::Log(LOGDEBUG, "XVBA::Decode - ffmpeg failed");
+      return VC_BUFFER;
+    }
+
+    CSingleLock lock(m_videoSurfaceSec);
+    render->state |= FF_XVBA_STATE_USED_FOR_RENDER;
+    lock.Leave();
+
+    // send frame to output for processing
+    CXvbaDecodedPicture pic;
+    memset(&pic.DVDPic, 0, sizeof(pic.DVDPic));
+    ((CDVDVideoCodecFFmpeg*)avctx->opaque)->GetPictureCommon(&pic.DVDPic);
+    pic.render = render;
+    m_bufferStats.IncDecoded();
+    m_xvbaOutput.m_dataPort.SendOutMessage(COutputDataProtocol::NEWFRAME, &pic, sizeof(pic));
+
+    m_codecControl = pic.DVDPic.iFlags & (DVP_FLAG_DRAIN | DVP_FLAG_NO_POSTPROC);
+  }
+
+  int retval = 0;
+  uint16_t decoded, processed, render;
+  Message *msg;
+  while (m_xvbaOutput.m_controlPort.ReceiveInMessage(&msg))
+  {
+    if (msg->signal == COutputControlProtocol::ERROR)
+    {
+      m_displayState = XVBA_ERROR;
+      retval |= VC_ERROR;
+    }
+    msg->Release();
+  }
+
+  m_bufferStats.Get(decoded, processed, render);
+
+  uint64_t startTime = CurrentHostCounter();
+  while (!retval)
+  {
+    if (m_xvbaOutput.m_dataPort.ReceiveInMessage(&msg))
+    {
+      if (msg->signal == COutputDataProtocol::PICTURE)
+      {
+        if (m_presentPicture)
+        {
+          m_presentPicture->ReturnUnused();
+          m_presentPicture = 0;
+        }
+
+        m_presentPicture = *(CXvbaRenderPicture**)msg->data;
+        m_presentPicture->xvba = this;
+        m_bufferStats.DecRender();
+        m_bufferStats.Get(decoded, processed, render);
+        retval |= VC_PICTURE;
+      }
+      msg->Release();
+    }
+    else if (m_xvbaOutput.m_controlPort.ReceiveInMessage(&msg))
+    {
+      if (msg->signal == COutputControlProtocol::STATS)
+      {
+        m_bufferStats.Get(decoded, processed, render);
+      }
+      else
+      {
+        m_displayState = XVBA_ERROR;
+        retval |= VC_ERROR;
+      }
+      msg->Release();
+    }
+
+    if ((m_codecControl & DVP_FLAG_DRAIN))
+    {
+      if (decoded + processed + render < 2)
+      {
+        retval |= VC_BUFFER;
+      }
+    }
+    else
+    {
+      if (decoded + processed + render < 4)
+      {
+        retval |= VC_BUFFER;
+      }
+    }
+
+    if (!retval && !m_inMsgEvent.WaitMSec(2000))
+      break;
+  }
+  uint64_t diff = CurrentHostCounter() - startTime;
+  if (retval & VC_PICTURE)
+  {
+    m_bufferStats.SetParams(diff, m_speed);
+    if (diff*1000/CurrentHostFrequency() > 50)
+      CLog::Log(LOGDEBUG,"XVBA::Decode long wait: %d", (int)((diff*1000)/CurrentHostFrequency()));
+  }
+
+  if (!retval)
+  {
+    CLog::Log(LOGERROR, "XVBA::%s - timed out waiting for output message", __FUNCTION__);
+    m_displayState = XVBA_ERROR;
+    retval |= VC_ERROR;
+  }
+
+  return retval;
+
+}
+
+bool CDecoder::GetPicture(AVCodecContext* avctx, AVFrame* frame, DVDVideoPicture* picture)
+{
+  CSingleLock lock(m_decoderSection);
+
+  if (m_displayState != XVBA_OPEN)
+    return false;
+
+  *picture = m_presentPicture->DVDPic;
+  picture->xvba = m_presentPicture;
+
+  return true;
+}
+
+void CDecoder::ReturnRenderPicture(CXvbaRenderPicture *renderPic)
+{
+  m_xvbaOutput.m_dataPort.SendOutMessage(COutputDataProtocol::RETURNPIC, &renderPic, sizeof(renderPic));
+}
+
+
+//void CDecoder::CopyYV12(int index, uint8_t *dest)
+//{
+//  CSharedLock lock(m_decoderSection);
+//
+//  { CSharedLock dLock(m_displaySection);
+//    if(m_displayState != XVBA_OPEN)
+//      return;
+//  }
+//
+//  if (!m_flipBuffer[index].outPic)
+//  {
+//    CLog::Log(LOGWARNING, "XVBA::Present: present picture is NULL");
+//    return;
+//  }
+//
+//  XVBA_GetSurface_Target target;
+//  target.size = sizeof(target);
+//  target.surfaceType = XVBA_YV12;
+//  target.flag = XVBA_FRAME;
+//
+//  XVBA_Get_Surface_Input input;
+//  input.size = sizeof(input);
+//  input.session = m_xvbaSession;
+//  input.src_surface = m_flipBuffer[index].outPic->render->surface;
+//  input.target_buffer = dest;
+//  input.target_pitch = m_surfaceWidth;
+//  input.target_width = m_surfaceWidth;
+//  input.target_height = m_surfaceHeight;
+//  input.target_parameter = target;
+//  { CSingleLock lock(m_apiSec);
+//    if (Success != g_XVBA_vtable.GetSurface(&input))
+//    {
+//      CLog::Log(LOGERROR,"(XVBA::CopyYV12) failed to get  surface");
+//    }
+//  }
+//}
+
+void CDecoder::Reset()
+{
+  CSingleLock lock(m_decoderSection);
+
+  if (!m_xvbaConfig.xvbaSession)
+    return;
+
+  Message *reply;
+  if (m_xvbaOutput.m_controlPort.SendOutMessageSync(COutputControlProtocol::FLUSH,
+                                                 &reply,
+                                                 2000))
+  {
+    bool success = reply->signal == COutputControlProtocol::ACC ? true : false;
+    reply->Release();
+    if (!success)
+    {
+      CLog::Log(LOGERROR, "XVBA::%s - flush returned error", __FUNCTION__);
+      m_displayState = XVBA_ERROR;
+    }
+    else
+      m_bufferStats.Reset();
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "XVBA::%s - flush timed out", __FUNCTION__);
+    m_displayState = XVBA_ERROR;
+  }
+}
+
+bool CDecoder::CanSkipDeint()
+{
+  return m_bufferStats.CanSkipDeint();
+}
+
+void CDecoder::SetSpeed(int speed)
+{
+  m_speed = speed;
+}
+
+//-----------------------------------------------------------------------------
+// RenderPicture
+//-----------------------------------------------------------------------------
+
+CXvbaRenderPicture* CXvbaRenderPicture::Acquire()
+{
+  CSingleLock lock(*renderPicSection);
+
+  if (refCount == 0)
+    xvba->Acquire();
+
+  refCount++;
+  return this;
+}
+
+long CXvbaRenderPicture::Release()
+{
+  CSingleLock lock(*renderPicSection);
+
+  refCount--;
+  if (refCount > 0)
+    return refCount;
+
+  lock.Leave();
+  xvba->ReturnRenderPicture(this);
+  xvba->ReleasePicReference();
+
+  return refCount;
+}
+
+void CXvbaRenderPicture::ReturnUnused()
+{
+  { CSingleLock lock(*renderPicSection);
+    if (refCount > 0)
+      return;
+  }
+  if (xvba)
+    xvba->ReturnRenderPicture(this);
+}
+
+//-----------------------------------------------------------------------------
+// Output
+//-----------------------------------------------------------------------------
+COutput::COutput(CEvent *inMsgEvent) :
+  CThread("XVBA Output Thread"),
+  m_controlPort("OutputControlPort", inMsgEvent, &m_outMsgEvent),
+  m_dataPort("OutputDataPort", inMsgEvent, &m_outMsgEvent)
+{
+  m_inMsgEvent = inMsgEvent;
+
+  CXvbaRenderPicture pic;
+  pic.renderPicSection = &m_bufferPool.renderPicSec;
+  pic.refCount = 0;
+  for (unsigned int i = 0; i < NUM_RENDER_PICS; i++)
+  {
+    m_bufferPool.allRenderPics.push_back(pic);
+  }
+  for (unsigned int i = 0; i < m_bufferPool.allRenderPics.size(); ++i)
+  {
+    m_bufferPool.freeRenderPics.push_back(&m_bufferPool.allRenderPics[i]);
+  }
+}
+
+void COutput::Start()
+{
+  Create();
+}
+
+COutput::~COutput()
+{
+  Dispose();
+
+  m_bufferPool.freeRenderPics.clear();
+  m_bufferPool.usedRenderPics.clear();
+  m_bufferPool.allRenderPics.clear();
+}
+
+void COutput::Dispose()
+{
+  CSingleLock lock(g_graphicsContext);
+  m_bStop = true;
+  m_outMsgEvent.Set();
+  StopThread();
+  m_controlPort.Purge();
+  m_dataPort.Purge();
+}
+
+void COutput::OnStartup()
+{
+  CLog::Log(LOGNOTICE, "COutput::OnStartup: Output Thread created");
+}
+
+void COutput::OnExit()
+{
+  CLog::Log(LOGNOTICE, "COutput::OnExit: Output Thread terminated");
+}
+
+enum OUTPUT_STATES
+{
+  O_TOP = 0,                      // 0
+  O_TOP_ERROR,                    // 1
+  O_TOP_UNCONFIGURED,             // 2
+  O_TOP_CONFIGURED,               // 3
+  O_TOP_CONFIGURED_WAIT_RES1,     // 4
+  O_TOP_CONFIGURED_WAIT_DEC,      // 5
+  O_TOP_CONFIGURED_STEP1,         // 6
+  O_TOP_CONFIGURED_WAIT_RES2,     // 7
+  O_TOP_CONFIGURED_STEP2,         // 8
+};
+
+int OUTPUT_parentStates[] = {
+    -1,
+    0, //TOP_ERROR
+    0, //TOP_UNCONFIGURED
+    0, //TOP_CONFIGURED
+    3, //TOP_CONFIGURED_WAIT_RES1
+    3, //TOP_CONFIGURED_WAIT_DEC
+    3, //TOP_CONFIGURED_STEP1
+    3, //TOP_CONFIGURED_WAIT_RES2
+    3, //TOP_CONFIGURED_STEP2
+};
+
+void COutput::StateMachine(int signal, Protocol *port, Message *msg)
+{
+  for (int state = m_state; ; state = OUTPUT_parentStates[state])
+  {
+    switch (state)
+    {
+    case O_TOP: // TOP
+      if (port == &m_controlPort)
+      {
+        switch (signal)
+        {
+        case COutputControlProtocol::FLUSH:
+          msg->Reply(COutputControlProtocol::ACC);
+          return;
+        case COutputControlProtocol::PRECLEANUP:
+          msg->Reply(COutputControlProtocol::ACC);
+          return;
+        default:
+          break;
+        }
+      }
+      else if (port == &m_dataPort)
+      {
+        switch (signal)
+        {
+        case COutputDataProtocol::RETURNPIC:
+          CXvbaRenderPicture *pic;
+          pic = *((CXvbaRenderPicture**)msg->data);
+          ProcessReturnPicture(pic);
+          return;
+        default:
+          break;
+        }
+      }
+      {
+        std::string portName = port == NULL ? "timer" : port->portName;
+        CLog::Log(LOGWARNING, "COutput::%s - signal: %d form port: %s not handled for state: %d", __FUNCTION__, signal, portName.c_str(), m_state);
+      }
+      return;
+
+    case O_TOP_ERROR:
+      m_extTimeout = 1000;
+      break;
+
+    case O_TOP_UNCONFIGURED:
+      if (port == &m_controlPort)
+      {
+        switch (signal)
+        {
+        case COutputControlProtocol::INIT:
+          CXvbaConfig *data;
+          data = (CXvbaConfig*)msg->data;
+          if (data)
+          {
+            m_config = *data;
+          }
+          Init();
+          EnsureBufferPool();
+          if (!m_xvbaError)
+          {
+            m_state = O_TOP_CONFIGURED_WAIT_RES1;
+            msg->Reply(COutputControlProtocol::ACC);
+          }
+          else
+          {
+            m_state = O_TOP_ERROR;
+            msg->Reply(COutputControlProtocol::ERROR);
+          }
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case O_TOP_CONFIGURED:
+      if (port == &m_controlPort)
+      {
+        switch (signal)
+        {
+        case COutputControlProtocol::FLUSH:
+          m_state = O_TOP_CONFIGURED_WAIT_RES1;
+          Flush();
+          msg->Reply(COutputControlProtocol::ACC);
+          return;
+        case COutputControlProtocol::PRECLEANUP:
+          m_state = O_TOP_UNCONFIGURED;
+          m_extTimeout = 10000;
+          Flush();
+          ReleaseBufferPool(true);
+          msg->Reply(COutputControlProtocol::ACC);
+          return;
+        default:
+          break;
+        }
+      }
+      else if (port == &m_dataPort)
+      {
+        switch (signal)
+        {
+        case COutputDataProtocol::NEWFRAME:
+          CXvbaDecodedPicture *frame;
+          frame = (CXvbaDecodedPicture*)msg->data;
+          if (frame)
+          {
+            m_decodedPics.push(*frame);
+            m_extTimeout = 0;
+          }
+          return;
+        case COutputDataProtocol::RETURNPIC:
+          CXvbaRenderPicture *pic;
+          pic = *((CXvbaRenderPicture**)msg->data);
+          ProcessReturnPicture(pic);
+          m_controlPort.SendInMessage(COutputControlProtocol::STATS);
+          m_extTimeout = 0;
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case O_TOP_CONFIGURED_WAIT_RES1:
+      if (port == NULL) // timeout
+      {
+        switch (signal)
+        {
+        case COutputControlProtocol::TIMEOUT:
+          if (!m_decodedPics.empty() && FindFreeSurface() >= 0 && !m_bufferPool.freeRenderPics.empty())
+          {
+            m_state = O_TOP_CONFIGURED_WAIT_DEC;
+            m_bStateMachineSelfTrigger = true;
+          }
+          else
+          {
+            if (m_extTimeout != 0)
+            {
+              uint16_t decoded, processed, render;
+              m_config.stats->Get(decoded, processed, render);
+//              CLog::Log(LOGDEBUG, "CVDPAU::COutput - timeout idle: decoded: %d, proc: %d, render: %d", decoded, processed, render);
+            }
+            m_extTimeout = 100;
+          }
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case O_TOP_CONFIGURED_WAIT_DEC:
+       if (port == NULL) // timeout
+       {
+         switch (signal)
+         {
+         case COutputControlProtocol::TIMEOUT:
+           if (IsDecodingFinished())
+           {
+             m_state = O_TOP_CONFIGURED_STEP1;
+             m_bStateMachineSelfTrigger = true;
+           }
+           else
+           {
+             m_extTimeout = 1;
+           }
+           return;
+         default:
+           break;
+         }
+       }
+       break;
+
+    case O_TOP_CONFIGURED_STEP1:
+      if (port == NULL) // timeout
+      {
+        switch (signal)
+        {
+        case COutputControlProtocol::TIMEOUT:
+          m_processPicture = m_decodedPics.front();
+          m_decodedPics.pop();
+          InitCycle();
+          CXvbaRenderPicture *pic;
+          pic = ProcessPicture();
+          if (pic)
+          {
+            m_config.stats->IncRender();
+            m_dataPort.SendInMessage(COutputDataProtocol::PICTURE, &pic, sizeof(pic));
+          }
+          if (m_xvbaError)
+          {
+            m_state = O_TOP_ERROR;
+            return;
+          }
+          if (m_deinterlacing && !m_deintSkip)
+          {
+            m_state = O_TOP_CONFIGURED_WAIT_RES2;
+            m_extTimeout = 0;
+          }
+          else
+          {
+            FiniCycle();
+            m_state = O_TOP_CONFIGURED_WAIT_RES1;
+            m_extTimeout = 0;
+          }
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case O_TOP_CONFIGURED_WAIT_RES2:
+      if (port == NULL) // timeout
+      {
+        switch (signal)
+        {
+        case COutputControlProtocol::TIMEOUT:
+          if (FindFreeSurface() >= 0 && !m_bufferPool.freeRenderPics.empty())
+          {
+            m_state = O_TOP_CONFIGURED_STEP2;
+            m_bStateMachineSelfTrigger = true;
+          }
+          else
+          {
+            if (m_extTimeout != 0)
+            {
+              uint16_t decoded, processed, render;
+              m_config.stats->Get(decoded, processed, render);
+              CLog::Log(LOGDEBUG, "CVDPAU::COutput - timeout idle: decoded: %d, proc: %d, render: %d", decoded, processed, render);
+            }
+            m_extTimeout = 100;
+          }
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    case O_TOP_CONFIGURED_STEP2:
+      if (port == NULL) // timeout
+      {
+        switch (signal)
+        {
+        case COutputControlProtocol::TIMEOUT:
+          CXvbaRenderPicture *pic;
+          m_deintStep = 1;
+          pic = ProcessPicture();
+          if (pic)
+          {
+            m_config.stats->IncRender();
+            m_dataPort.SendInMessage(COutputDataProtocol::PICTURE, &pic, sizeof(pic));
+          }
+          if (m_xvbaError)
+          {
+            m_state = O_TOP_ERROR;
+            return;
+          }
+          FiniCycle();
+          m_state = O_TOP_CONFIGURED_WAIT_RES1;
+          m_extTimeout = 0;
+          return;
+        default:
+          break;
+        }
+      }
+      break;
+
+    default: // we are in no state, should not happen
+      CLog::Log(LOGERROR, "COutput::%s - no valid state: %d", __FUNCTION__, m_state);
+      return;
+    }
+  } // for
+}
+
+void COutput::Process()
+{
+  Message *msg = NULL;
+  Protocol *port = NULL;
+  bool gotMsg;
+
+  m_state = O_TOP_UNCONFIGURED;
+  m_extTimeout = 1000;
+  m_bStateMachineSelfTrigger = false;
+
+  while (!m_bStop)
+  {
+    gotMsg = false;
+
+    if (m_bStateMachineSelfTrigger)
+    {
+      m_bStateMachineSelfTrigger = false;
+      // self trigger state machine
+      StateMachine(msg->signal, port, msg);
+      if (!m_bStateMachineSelfTrigger)
+      {
+        msg->Release();
+        msg = NULL;
+      }
+      continue;
+    }
+    // check control port
+    else if (m_controlPort.ReceiveOutMessage(&msg))
+    {
+      gotMsg = true;
+      port = &m_controlPort;
+    }
+    // check data port
+    else if (m_dataPort.ReceiveOutMessage(&msg))
+    {
+      gotMsg = true;
+      port = &m_dataPort;
+    }
+    if (gotMsg)
+    {
+      StateMachine(msg->signal, port, msg);
+      if (!m_bStateMachineSelfTrigger)
+      {
+        msg->Release();
+        msg = NULL;
+      }
+      continue;
+    }
+
+    // wait for message
+    else if (m_outMsgEvent.WaitMSec(m_extTimeout))
+    {
+      continue;
+    }
+    // time out
+    else
+    {
+      msg = m_controlPort.GetMessage();
+      msg->signal = COutputControlProtocol::TIMEOUT;
+      port = 0;
+      // signal timeout to state machine
+      StateMachine(msg->signal, port, msg);
+      if (!m_bStateMachineSelfTrigger)
+      {
+        msg->Release();
+        msg = NULL;
+      }
+    }
+  }
+  Flush();
+  Uninit();
+}
+
+bool COutput::Init()
+{
+  if (!CreateGlxContext())
+    return false;
+
+  m_xvbaError = false;
+  m_processPicture.render = 0;
+  m_fence = None;
+
+  return true;
+}
+
+bool COutput::Uninit()
+{
+  ReleaseBufferPool();
+  DestroyGlxContext();
+  return true;
+}
+
+void COutput::Flush()
+{
+  while (!m_decodedPics.empty())
+  {
+    CXvbaDecodedPicture pic = m_decodedPics.front();
+    m_decodedPics.pop();
+    CSingleLock lock(*m_config.videoSurfaceSec);
+    if (pic.render)
+      pic.render->state &= ~(FF_XVBA_STATE_USED_FOR_RENDER | FF_XVBA_STATE_DECODED);
+  }
+
+  if (m_processPicture.render)
+  {
+    CSingleLock lock(*m_config.videoSurfaceSec);
+    m_processPicture.render->state &= ~(FF_XVBA_STATE_USED_FOR_RENDER | FF_XVBA_STATE_DECODED);
+    m_processPicture.render = 0;
+  }
+
+  Message *msg;
+  while (m_dataPort.ReceiveOutMessage(&msg))
+  {
+    if (msg->signal == COutputDataProtocol::NEWFRAME)
+    {
+      CXvbaDecodedPicture pic = *(CXvbaDecodedPicture*)msg->data;
+      CSingleLock lock(*m_config.videoSurfaceSec);
+      if (pic.render)
+        pic.render->state &= ~(FF_XVBA_STATE_USED_FOR_RENDER | FF_XVBA_STATE_DECODED);
+    }
+    else if (msg->signal == COutputDataProtocol::RETURNPIC)
+    {
+      CXvbaRenderPicture *pic;
+      pic = *((CXvbaRenderPicture**)msg->data);
+      ProcessReturnPicture(pic);
+    }
+    msg->Release();
+  }
+
+  while (m_dataPort.ReceiveInMessage(&msg))
+  {
+    if (msg->signal == COutputDataProtocol::PICTURE)
+    {
+      CXvbaRenderPicture *pic;
+      pic = *((CXvbaRenderPicture**)msg->data);
+      ProcessReturnPicture(pic);
+    }
+  }
+}
+
+bool COutput::IsDecodingFinished()
+{
+  // check for decoding to be finished
+  CXvbaDecodedPicture decodedPic = m_decodedPics.front();
+
+  XVBA_Surface_Sync_Input syncInput;
+  XVBA_Surface_Sync_Output syncOutput;
+  syncInput.size = sizeof(syncInput);
+  syncInput.session = m_config.xvbaSession;
+  syncInput.surface = decodedPic.render->surface;
+  syncInput.query_status = XVBA_GET_SURFACE_STATUS;
+  syncOutput.size = sizeof(syncOutput);
+  { CSingleLock lock(*(m_config.apiSec));
+    if (Success != g_XVBA_vtable.SyncSurface(&syncInput, &syncOutput))
+    {
+      CLog::Log(LOGERROR,"XVBA - failed sync surface");
+      m_xvbaError = true;
+      return false;
+    }
+  }
+  if (!(syncOutput.status_flags & XVBA_STILL_PENDING))
+    return true;
+
+  return false;
+}
+
+CXvbaRenderPicture* COutput::ProcessPicture()
+{
+  CXvbaRenderPicture *retPic = 0;
+
+  if (m_deintStep == 1)
+  {
+    if(m_field == XVBA_TOP_FIELD)
+      m_field = XVBA_BOTTOM_FIELD;
+    else
+      m_field = XVBA_TOP_FIELD;
+  }
+
+  // find unused shared surface
+  unsigned int idx = FindFreeSurface();
+  XvbaBufferPool::GLVideoSurface *glSurface = &m_bufferPool.glSurfaces[idx];
+  glSurface->used = true;
+  glSurface->field = m_field;
+  glSurface->render = m_processPicture.render;
+  glSurface->transferred = false;
+
+  int cmd = 0;
+  m_config.stats->GetCmd(cmd);
+
+//  if (m_fence)
+//    glDeleteSync(m_fence);
+//  m_fence = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
+
+  // transfer surface
+  XVBA_Transfer_Surface_Input transInput;
+  transInput.size = sizeof(transInput);
+  transInput.session = m_config.xvbaSession;
+  transInput.src_surface = m_processPicture.render->surface;
+  transInput.target_surface = glSurface->glSurface;
+  transInput.flag = m_field;
+  { CSingleLock lock(*(m_config.apiSec));
+    if (Success != g_XVBA_vtable.TransferSurface(&transInput))
+    {
+      CLog::Log(LOGERROR,"(XVBA) failed to transfer surface");
+      m_xvbaError = true;
+      return retPic;
+    }
+  }
+
+  // prepare render pic
+  retPic = m_bufferPool.freeRenderPics.front();
+  m_bufferPool.freeRenderPics.pop_front();
+  m_bufferPool.usedRenderPics.push_back(retPic);
+  retPic->sourceIdx = glSurface->id;
+  retPic->DVDPic = m_processPicture.DVDPic;
+  retPic->valid = true;
+  retPic->texture = glSurface->texture;
+  retPic->crop = CRect(0,0,0,0);
+  retPic->texWidth = m_config.surfaceWidth;
+  retPic->texHeight = m_config.surfaceHeight;
+  retPic->xvbaOutput = this;
+
+  // set repeat pic for de-interlacing
+  if (m_deinterlacing)
+  {
+    if (m_deintStep == 1)
+    {
+      retPic->DVDPic.pts = DVD_NOPTS_VALUE;
+      retPic->DVDPic.dts = DVD_NOPTS_VALUE;
+    }
+    retPic->DVDPic.iRepeatPicture = 0.0;
+  }
+
+  return retPic;
+}
+
+void COutput::ProcessReturnPicture(CXvbaRenderPicture *pic)
+{
+  std::deque<CXvbaRenderPicture*>::iterator it;
+  it = std::find(m_bufferPool.usedRenderPics.begin(), m_bufferPool.usedRenderPics.end(), pic);
+  if (it == m_bufferPool.usedRenderPics.end())
+  {
+    CLog::Log(LOGWARNING, "COutput::ProcessReturnPicture - pic not found");
+    return;
+  }
+  m_bufferPool.usedRenderPics.erase(it);
+  m_bufferPool.freeRenderPics.push_back(pic);
+  if (!pic->valid)
+  {
+    CLog::Log(LOGDEBUG, "COutput::%s - return of invalid render pic", __FUNCTION__);
+    return;
+  }
+
+  xvba_render_state *render = m_bufferPool.glSurfaces[pic->sourceIdx].render;
+  if (render)
+  {
+    // check if video surface is referenced by other glSurfaces
+    bool referenced(false);
+    for (unsigned int i=0; i<m_bufferPool.glSurfaces.size();++i)
+    {
+      if (i == pic->sourceIdx)
+        continue;
+      if (m_bufferPool.glSurfaces[i].render == render)
+      {
+        referenced = true;
+        break;
+      }
+    }
+    if (m_processPicture.render == render)
+      referenced = true;
+
+    // release video surface
+    if (!referenced)
+    {
+      CSingleLock lock(*m_config.videoSurfaceSec);
+      render->state &= ~(FF_XVBA_STATE_USED_FOR_RENDER | FF_XVBA_STATE_DECODED);
+    }
+
+    // unreference video surface
+    m_bufferPool.glSurfaces[pic->sourceIdx].render = 0;
+
+    m_bufferPool.glSurfaces[pic->sourceIdx].used = false;
+    return;
+  }
+}
+
+int COutput::FindFreeSurface()
+{
+  // find free shared surface
+  unsigned int i;
+  for (i = 0; i < m_bufferPool.glSurfaces.size(); ++i)
+  {
+    if (!m_bufferPool.glSurfaces[i].used)
+      break;
+  }
+  if (i == m_bufferPool.glSurfaces.size())
+    return -1;
+  else
+    return i;
+}
+
+void COutput::InitCycle()
+{
+  uint64_t latency;
+  int speed;
+  m_config.stats->GetParams(latency, speed);
+  latency = (latency*1000)/CurrentHostFrequency();
+
+  m_config.stats->SetCanSkipDeint(false);
+
+  EDEINTERLACEMODE   mode = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
+  EINTERLACEMETHOD method = CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod;
+  bool interlaced = m_processPicture.DVDPic.iFlags & DVP_FLAG_INTERLACED;
+
+  if (mode == VS_DEINTERLACEMODE_FORCE ||
+     (mode == VS_DEINTERLACEMODE_AUTO && interlaced))
+  {
+    if((method == VS_INTERLACEMETHOD_AUTO && interlaced)
+      ||  method == VS_INTERLACEMETHOD_XVBA)
+    {
+      m_deinterlacing = true;
+      m_deintSkip = false;
+      m_config.stats->SetCanSkipDeint(true);
+
+      if (m_processPicture.DVDPic.iFlags & DVP_FLAG_DROPDEINT)
+      {
+        m_deintSkip = true;
+      }
+
+      // do only half deinterlacing
+      if (speed != DVD_PLAYSPEED_NORMAL || !g_graphicsContext.IsFullScreenVideo())
+      {
+        m_config.stats->SetCanSkipDeint(false);
+        m_deintSkip = true;
+      }
+
+      if(m_processPicture.DVDPic.iFlags & DVP_FLAG_TOP_FIELD_FIRST)
+        m_field = XVBA_TOP_FIELD;
+      else
+        m_field = XVBA_BOTTOM_FIELD;
+    }
+  }
+  else
+  {
+    m_deinterlacing = false;
+    m_field = XVBA_FRAME;
+  }
+
+  m_processPicture.DVDPic.format = RENDER_FMT_XVBA;
+  m_processPicture.DVDPic.iFlags &= ~(DVP_FLAG_TOP_FIELD_FIRST |
+                                    DVP_FLAG_REPEAT_TOP_FIELD |
+                                    DVP_FLAG_INTERLACED);
+  m_processPicture.DVDPic.iWidth = m_config.vidWidth;
+  m_processPicture.DVDPic.iHeight = m_config.vidHeight;
+
+  m_deintStep = 0;
+}
+
+void COutput::FiniCycle()
+{
+//  { CSingleLock lock(*m_config.videoSurfaceSec);
+//    m_processPicture.render->state &= ~FF_XVBA_STATE_USED_FOR_RENDER;
+//  }
+  m_processPicture.render = 0;
+  m_config.stats->DecDecoded();
+}
+
+bool COutput::EnsureBufferPool()
+{
+  if (m_config.useSharedSurfaces && m_bufferPool.glSurfaces.empty())
+  {
+    GLenum textureTarget;
+    if (!glewIsSupported("GL_ARB_texture_non_power_of_two") && glewIsSupported("GL_ARB_texture_rectangle"))
+    {
+      textureTarget = GL_TEXTURE_RECTANGLE_ARB;
+    }
+    else
+      textureTarget = GL_TEXTURE_2D;
+
+    // create shared surfaces
+    XvbaBufferPool::GLVideoSurface surface;
+    for (unsigned int i = 0; i < NUM_RENDER_PICS; ++i)
+    {
+      glEnable(textureTarget);
+      glGenTextures(1, &surface.texture);
+      glBindTexture(textureTarget, surface.texture);
+      glTexParameteri(textureTarget, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      glTexParameteri(textureTarget, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      glTexParameteri(textureTarget, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+      glTexParameteri(textureTarget, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+      glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
+      glTexImage2D(textureTarget, 0, GL_RGBA, m_config.surfaceWidth, m_config.surfaceHeight, 0, GL_BGRA, GL_UNSIGNED_BYTE, NULL);
+
+      XVBA_Create_GLShared_Surface_Input surfInput;
+      XVBA_Create_GLShared_Surface_Output surfOutput;
+      surfInput.size = sizeof(surfInput);
+      surfInput.session = m_config.xvbaSession;
+      surfInput.gltexture = surface.texture;
+      surfInput.glcontext = m_glContext;
+      surfOutput.size = sizeof(surfOutput);
+      surfOutput.surface = 0;
+      if (Success != g_XVBA_vtable.CreateGLSharedSurface(&surfInput, &surfOutput))
+      {
+        CLog::Log(LOGERROR,"(XVBA) failed to create shared surface");
+        m_xvbaError = true;
+        break;
+      }
+      CLog::Log(LOGDEBUG, "XVBA::GetTexture - created shared surface");
+
+      surface.glSurface = surfOutput.surface;
+      surface.id = i;
+      surface.used = false;
+      surface.render = 0;
+      m_bufferPool.glSurfaces.push_back(surface);
+    }
+    glDisable(textureTarget);
+  }
+
+  return true;
+}
+
+void COutput::ReleaseBufferPool(bool precleanup /*= false*/)
+{
+//  if (m_fence)
+//  {
+//    uint64_t maxTimeout = 1000000000LL;
+//    glClientWaitSync(m_fence, GL_SYNC_FLUSH_COMMANDS_BIT, maxTimeout);
+//    glDeleteSync(m_fence);
+//    m_fence = None;
+//  }
+
+  CSingleLock lock(m_bufferPool.renderPicSec);
+
+  for (unsigned int i = 0; i < m_bufferPool.glSurfaces.size(); ++i)
+  {
+    if (m_bufferPool.glSurfaces[i].glSurface)
+    {
+      g_XVBA_vtable.DestroySurface(m_bufferPool.glSurfaces[i].glSurface);
+      m_bufferPool.glSurfaces[i].glSurface = 0;
+    }
+    if (m_bufferPool.glSurfaces[i].texture && !precleanup)
+    {
+      glDeleteTextures(1, &m_bufferPool.glSurfaces[i].texture);
+      m_bufferPool.glSurfaces[i].texture = 0;
+    }
+    m_bufferPool.glSurfaces[i].render = 0;
+    m_bufferPool.glSurfaces[i].used = true;
+  }
+
+  if (!precleanup)
+  {
+    m_bufferPool.glSurfaces.clear();
+
+    // invalidate all used render pictures
+    for (unsigned int i = 0; i < m_bufferPool.usedRenderPics.size(); ++i)
+    {
+      m_bufferPool.usedRenderPics[i]->valid = false;
+    }
+  }
+}
+
+void COutput::PreReleaseBufferPool()
+{
+  CSingleLock lock(m_bufferPool.renderPicSec);
+
+  if (m_config.useSharedSurfaces)
+  {
+    for (unsigned int i = 0; i < m_bufferPool.glSurfaces.size(); ++i)
+    {
+      if (!m_bufferPool.glSurfaces[i].used)
+      {
+        g_XVBA_vtable.DestroySurface(m_bufferPool.glSurfaces[i].glSurface);
+        glDeleteTextures(1, &m_bufferPool.glSurfaces[i].texture);
+        m_bufferPool.glSurfaces[i].glSurface = 0;
+        m_bufferPool.glSurfaces[i].used = true;
+      }
+    }
+  }
+}
+
+bool COutput::CreateGlxContext()
+{
+  GLXContext   glContext;
+
+  m_Display = g_Windowing.GetDisplay();
+  glContext = g_Windowing.GetGlxContext();
+  m_Window = g_Windowing.GetWindow();
+
+  // Get our window attribs.
+  XWindowAttributes wndattribs;
+  XGetWindowAttributes(m_Display, m_Window, &wndattribs);
+
+  // Get visual Info
+  XVisualInfo visInfo;
+  visInfo.visualid = wndattribs.visual->visualid;
+  int nvisuals = 0;
+  XVisualInfo* visuals = XGetVisualInfo(m_Display, VisualIDMask, &visInfo, &nvisuals);
+  if (nvisuals != 1)
+  {
+    CLog::Log(LOGERROR, "XVBA::COutput::CreateGlxContext - could not find visual");
+    return false;
+  }
+  visInfo = visuals[0];
+  XFree(visuals);
+
+  m_pixmap = XCreatePixmap(m_Display,
+                           m_Window,
+                           192,
+                           108,
+                           visInfo.depth);
+  if (!m_pixmap)
+  {
+    CLog::Log(LOGERROR, "XVBA::COutput::CreateGlxContext - Unable to create XPixmap");
+    return false;
+  }
+
+  // create gl pixmap
+  m_glPixmap = glXCreateGLXPixmap(m_Display, &visInfo, m_pixmap);
+
+  if (!m_glPixmap)
+  {
+    CLog::Log(LOGINFO, "XVBA::COutput::CreateGlxContext - Could not create glPixmap");
+    return false;
+  }
+
+  m_glContext = glXCreateContext(m_Display, &visInfo, glContext, True);
+
+  if (!glXMakeCurrent(m_Display, m_glPixmap, m_glContext))
+  {
+    CLog::Log(LOGINFO, "XVBA::COutput::CreateGlxContext - Could not make Pixmap current");
+    return false;
+  }
+
+  CLog::Log(LOGNOTICE, "XVBA::COutput::CreateGlxContext - created context");
+  return true;
+}
+
+bool COutput::DestroyGlxContext()
+{
+  if (m_glContext)
+  {
+    glXMakeCurrent(m_Display, None, NULL);
+    glXDestroyContext(m_Display, m_glContext);
+  }
+  m_glContext = 0;
+
+  if (m_glPixmap)
+    glXDestroyPixmap(m_Display, m_glPixmap);
+  m_glPixmap = 0;
+
+  if (m_pixmap)
+    XFreePixmap(m_Display, m_pixmap);
+  m_pixmap = 0;
+
+  return true;
+}
+
+#endif
diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.h b/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.h
new file mode 100644
index 0000000..3bd0cea
--- /dev/null
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.h
@@ -0,0 +1,383 @@
+/*
+ *      Copyright (C) 2005-2011 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+#pragma once
+
+#include "X11/Xlib.h"
+#include "amd/amdxvba.h"
+#include "DllAvCodec.h"
+#include "DVDCodecs/Video/DVDVideoCodecFFmpeg.h"
+#include "threads/Thread.h"
+#include "threads/CriticalSection.h"
+#include "threads/SharedSection.h"
+#include "threads/Event.h"
+#include "guilib/DispResource.h"
+#include "guilib/Geometry.h"
+#include "libavcodec/xvba.h"
+#include "utils/ActorProtocol.h"
+#include "settings/VideoSettings.h"
+#include <GL/glx.h>
+#include <vector>
+#include <deque>
+
+using namespace Actor;
+
+
+namespace XVBA
+{
+
+//-----------------------------------------------------------------------------
+// XVBA data structs
+//-----------------------------------------------------------------------------
+
+class CDecoder;
+class CXVBAContext;
+class COutput;
+
+#define NUM_RENDER_PICS 9
+
+/**
+ * Buffer statistics used to control number of frames in queue
+ */
+
+class CXvbaBufferStats
+{
+public:
+  uint16_t decodedPics;
+  uint16_t processedPics;
+  uint16_t renderPics;
+  uint64_t latency;         // time decoder has waited for a frame, ideally there is no latency
+  int playSpeed;
+  bool canSkipDeint;
+  int processCmd;
+
+  void IncDecoded() { CSingleLock l(m_sec); decodedPics++;}
+  void DecDecoded() { CSingleLock l(m_sec); decodedPics--;}
+  void IncProcessed() { CSingleLock l(m_sec); processedPics++;}
+  void DecProcessed() { CSingleLock l(m_sec); processedPics--;}
+  void IncRender() { CSingleLock l(m_sec); renderPics++;}
+  void DecRender() { CSingleLock l(m_sec); renderPics--;}
+  void Reset() { CSingleLock l(m_sec); decodedPics=0; processedPics=0;renderPics=0;latency=0;}
+  void Get(uint16_t &decoded, uint16_t &processed, uint16_t &render) {CSingleLock l(m_sec); decoded = decodedPics, processed=processedPics, render=renderPics;}
+  void SetParams(uint64_t time, int speed) { CSingleLock l(m_sec); latency = time; playSpeed = speed; }
+  void GetParams(uint64_t &lat, int &speed) { CSingleLock l(m_sec); lat = latency; speed = playSpeed; }
+  void SetCmd(int cmd) { CSingleLock l(m_sec); processCmd = cmd; }
+  void GetCmd(int &cmd) { CSingleLock l(m_sec); cmd = processCmd; processCmd = 0; }
+  void SetCanSkipDeint(bool canSkip) { CSingleLock l(m_sec); canSkipDeint = canSkip; }
+  bool CanSkipDeint() { CSingleLock l(m_sec); if (canSkipDeint) return true; else return false;}
+private:
+  CCriticalSection m_sec;
+};
+
+/**
+ *  CXvbaConfig holds all configuration parameters needed by vdpau
+ *  The structure is sent to the internal classes CMixer and COutput
+ *  for init.
+ */
+
+struct CXvbaConfig
+{
+  int surfaceWidth;
+  int surfaceHeight;
+  int vidWidth;
+  int vidHeight;
+  int outWidth;
+  int outHeight;
+  bool useSharedSurfaces;
+
+  CXVBAContext *context;
+  XVBADecodeCap decoderCap;
+  void *xvbaSession;
+  std::vector<xvba_render_state*> *videoSurfaces;
+  CCriticalSection *videoSurfaceSec;
+  CCriticalSection *apiSec;
+
+  CXvbaBufferStats *stats;
+  int numRenderBuffers;
+  uint32_t maxReferences;
+};
+
+/**
+ * Holds a decoded frame
+ * Input to COutput for further processing
+ */
+struct CXvbaDecodedPicture
+{
+  DVDVideoPicture DVDPic;
+  xvba_render_state *render;
+};
+
+/**
+ * Ready to render textures
+ * Sent from COutput back to CDecoder
+ * Objects are referenced by DVDVideoPicture and are sent
+ * to renderer
+ */
+class CXvbaRenderPicture
+{
+  friend class CDecoder;
+  friend class COutput;
+public:
+  DVDVideoPicture DVDPic;
+  int texWidth, texHeight;
+  CRect crop;
+  GLuint texture;
+  uint32_t sourceIdx;
+  bool valid;
+  CDecoder *xvba;
+  CXvbaRenderPicture* Acquire();
+  long Release();
+private:
+  void ReturnUnused();
+  int refCount;
+  CCriticalSection *renderPicSection;
+  COutput *xvbaOutput;
+};
+
+//-----------------------------------------------------------------------------
+// Output
+//-----------------------------------------------------------------------------
+
+/**
+ * Buffer pool holds allocated xvba and gl resources
+ * Embedded in COutput
+ */
+struct XvbaBufferPool
+{
+  struct GLVideoSurface
+  {
+    unsigned int id;
+    bool used;
+    bool transferred;
+    GLuint texture;
+    void *glSurface;
+    xvba_render_state *render;
+    XVBA_SURFACE_FLAG field;
+  };
+  std::vector<GLVideoSurface> glSurfaces;
+  std::vector<CXvbaRenderPicture> allRenderPics;
+  std::deque<CXvbaRenderPicture*> usedRenderPics;
+  std::deque<CXvbaRenderPicture*> freeRenderPics;
+  CCriticalSection renderPicSec;
+};
+
+class COutputControlProtocol : public Protocol
+{
+public:
+  COutputControlProtocol(std::string name, CEvent* inEvent, CEvent *outEvent) : Protocol(name, inEvent, outEvent) {};
+  enum OutSignal
+  {
+    INIT,
+    FLUSH,
+    PRECLEANUP,
+    TIMEOUT,
+  };
+  enum InSignal
+  {
+    ACC,
+    ERROR,
+    STATS,
+  };
+};
+
+class COutputDataProtocol : public Protocol
+{
+public:
+  COutputDataProtocol(std::string name, CEvent* inEvent, CEvent *outEvent) : Protocol(name, inEvent, outEvent) {};
+  enum OutSignal
+  {
+    NEWFRAME = 0,
+    RETURNPIC,
+  };
+  enum InSignal
+  {
+    PICTURE,
+  };
+};
+
+/**
+ * COutput is embedded in CDecoder and embeds CMixer
+ * The class has its own OpenGl context which is shared with render thread
+ * COuput generated ready to render textures and passes them back to
+ * CDecoder
+ */
+class COutput : private CThread
+{
+public:
+  COutput(CEvent *inMsgEvent);
+  virtual ~COutput();
+  void Start();
+  void Dispose();
+  COutputControlProtocol m_controlPort;
+  COutputDataProtocol m_dataPort;
+protected:
+  void OnStartup();
+  void OnExit();
+  void Process();
+  void StateMachine(int signal, Protocol *port, Message *msg);
+  bool HasWork();
+  bool IsDecodingFinished();
+  CXvbaRenderPicture* ProcessPicture();
+  void ProcessReturnPicture(CXvbaRenderPicture *pic);
+  int FindFreeSurface();
+  void InitCycle();
+  void FiniCycle();
+  bool Init();
+  bool Uninit();
+  void Flush();
+  bool CreateGlxContext();
+  bool DestroyGlxContext();
+  bool EnsureBufferPool();
+  void ReleaseBufferPool(bool precleanup = false);
+  void PreReleaseBufferPool();
+  CEvent m_outMsgEvent;
+  CEvent *m_inMsgEvent;
+  int m_state;
+  bool m_bStateMachineSelfTrigger;
+
+  // extended state variables for state machine
+  int m_extTimeout;
+  bool m_xvbaError;
+  CXvbaConfig m_config;
+  XvbaBufferPool m_bufferPool;
+  Display *m_Display;
+  Window m_Window;
+  GLXContext m_glContext;
+  GLXWindow m_glWindow;
+  Pixmap    m_pixmap;
+  GLXPixmap m_glPixmap;
+  GLsync m_fence;
+  std::queue<CXvbaDecodedPicture> m_decodedPics;
+  CXvbaDecodedPicture m_processPicture;
+  XVBA_SURFACE_FLAG m_field;
+  bool m_deinterlacing;
+  int m_deintStep;
+  bool m_deintSkip;
+};
+
+//-----------------------------------------------------------------------------
+// XVBA decoder
+//-----------------------------------------------------------------------------
+
+class CXVBAContext
+{
+public:
+  static bool EnsureContext(CXVBAContext **ctx);
+  void *GetContext();
+  void Release();
+private:
+  CXVBAContext();
+  void Close();
+  bool LoadSymbols();
+  bool CreateContext();
+  void DestroyContext();
+  static CXVBAContext *m_context;
+  static CCriticalSection m_section;
+  static Display *m_display;
+  int m_refCount;
+  static void *m_dlHandle;
+  void *m_xvbaContext;
+};
+
+class CDecoder : public CDVDVideoCodecFFmpeg::IHardwareDecoder,
+                 public IDispResource
+{
+  friend class CXvbaRenderPicture;
+
+public:
+
+  struct pictureAge
+  {
+    int b_age;
+    int ip_age[2];
+  };
+
+  enum EDisplayState
+  { XVBA_OPEN
+  , XVBA_RESET
+  , XVBA_LOST
+  , XVBA_ERROR
+  };
+
+  CDecoder();
+  virtual ~CDecoder();
+  virtual void OnLostDevice();
+  virtual void OnResetDevice();
+
+  virtual bool Open(AVCodecContext* avctx, const enum PixelFormat fmt, unsigned int surfaces = 0);
+  virtual int  Decode    (AVCodecContext* avctx, AVFrame* frame);
+  virtual bool GetPicture(AVCodecContext* avctx, AVFrame* frame, DVDVideoPicture* picture);
+  virtual void Reset();
+  virtual void Close();
+  virtual int  Check(AVCodecContext* avctx);
+  virtual long Release();
+  virtual const std::string Name() { return "xvba"; }
+  virtual bool CanSkipDeint();
+  virtual void SetSpeed(int speed);
+  virtual unsigned GetAllowedReferences() { return 5; }
+
+  bool Supports(EINTERLACEMETHOD method);
+  long ReleasePicReference();
+
+protected:
+  bool CreateSession(AVCodecContext* avctx);
+  void DestroySession(bool precleanup = false);
+  bool EnsureDataControlBuffers(unsigned int num);
+  void ResetState();
+  void SetError(const char* function, const char* msg, int line);
+  bool IsSurfaceValid(xvba_render_state *render);
+  void ReturnRenderPicture(CXvbaRenderPicture *renderPic);
+
+  // callbacks for ffmpeg
+  static void  FFReleaseBuffer(AVCodecContext *avctx, AVFrame *pic);
+  static void  FFDrawSlice(struct AVCodecContext *avctx,
+                               const AVFrame *src, int offset[4],
+                               int y, int type, int height);
+  static int   FFGetBuffer(AVCodecContext *avctx, AVFrame *pic);
+
+  DllAvUtil m_dllAvUtil;
+  CCriticalSection m_decoderSection;
+  CEvent m_displayEvent;
+  EDisplayState m_displayState;
+  CXvbaConfig  m_xvbaConfig;
+  std::vector<xvba_render_state*> m_videoSurfaces;
+  CCriticalSection m_apiSec, m_videoSurfaceSec;
+  ThreadIdentifier m_decoderThread;
+
+  unsigned int m_decoderId;
+  struct XVBABufferPool
+  {
+    XVBABufferDescriptor *picture_descriptor_buffer;
+    XVBABufferDescriptor *iq_matrix_buffer;
+    XVBABufferDescriptor *data_buffer;
+    std::vector<XVBABufferDescriptor*> data_control_buffers;
+  };
+  XVBABufferPool m_xvbaBufferPool;
+
+  COutput       m_xvbaOutput;
+  CXvbaBufferStats m_bufferStats;
+  CEvent        m_inMsgEvent;
+  CXvbaRenderPicture *m_presentPicture;
+
+  int m_speed;
+  int m_codecControl;
+};
+
+}
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 1a17145..41e64a5 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1017,6 +1017,7 @@ static std::string GetRenderFormatName(ERenderFormat format)
     case RENDER_FMT_OMXEGL:    return "OMXEGL";
     case RENDER_FMT_CVBREF:    return "BGRA";
     case RENDER_FMT_BYPASS:    return "BYPASS";
+    case RENDER_FMT_XVBA:      return "XVBA";
     case RENDER_FMT_NONE:      return "NONE";
   }
   return "UNKNOWN";
diff --git a/xbmc/settings/VideoSettings.h b/xbmc/settings/VideoSettings.h
index b7c4116..a370bd8 100644
--- a/xbmc/settings/VideoSettings.h
+++ b/xbmc/settings/VideoSettings.h
@@ -63,6 +63,8 @@ enum EINTERLACEMETHOD
   VS_INTERLACEMETHOD_SW_BLEND = 20,
   VS_INTERLACEMETHOD_AUTO_ION = 21,
 
+  VS_INTERLACEMETHOD_XVBA = 22,
+
   VS_INTERLACEMETHOD_MAX // do not use and keep as last enum value.
 };
 
diff --git a/xbmc/video/dialogs/GUIDialogVideoSettings.cpp b/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
index 27ed5ee..007ad74 100644
--- a/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
+++ b/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
@@ -111,6 +111,7 @@ void CGUIDialogVideoSettings::CreateSettings()
     entries.push_back(make_pair(VS_INTERLACEMETHOD_DXVA_BOB                   , 16320));
     entries.push_back(make_pair(VS_INTERLACEMETHOD_DXVA_BEST                  , 16321));
     entries.push_back(make_pair(VS_INTERLACEMETHOD_AUTO_ION                   , 16325));
+    entries.push_back(make_pair(VS_INTERLACEMETHOD_XVBA                       , 16326));
 
     /* remove unsupported methods */
     for(vector<pair<int, int> >::iterator it = entries.begin(); it != entries.end();)
-- 
1.8.1.6


From a1d6b330e8316cb52b0b9f97c3be92269760a878 Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Sun, 4 Nov 2012 16:24:10 +0100
Subject: [PATCH 070/123] xvba: add string for available decoders - we are
 important so make sure we are there

---
 xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
index 1477264..37a5994 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
@@ -177,6 +177,11 @@ CDVDVideoCodec* CDVDFactoryCodec::CreateVideoCodec(CDVDStreamInfo &hint, unsigne
 #elif defined(TARGET_POSIX) && !defined(TARGET_DARWIN)
   hwSupport += "VAAPI:no ";
 #endif
+#if defined(HAVE_LIBXVBA) && defined(TARGET_LINUX)
+  hwSupport += "XVBA:yes ";
+#elif defined(TARGET_LINUX)
+  hwSupport += "XVBA:no ";
+#endif
 
   CLog::Log(LOGDEBUG, "CDVDFactoryCodec: compiled in hardware support: %s", hwSupport.c_str());
 #if !defined(HAS_LIBAMCODEC)
-- 
1.8.1.6


From 033dbfbc37f33a1670357c39e6f82dd36e457ab0 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sat, 16 Jun 2012 12:46:30 +0200
Subject: [PATCH 071/123] xvba: do not use vaapi if xvba is present

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
index 2343b11..f102cba 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VAAPI.cpp
@@ -261,6 +261,15 @@ void CDecoder::Close()
 
 bool CDecoder::Open(AVCodecContext *avctx, enum PixelFormat fmt, unsigned int surfaces)
 {
+#ifdef HAVE_LIBXVBA
+  std::string Vendor = g_Windowing.GetRenderVendor();
+  std::transform(Vendor.begin(), Vendor.end(), Vendor.begin(), ::tolower);
+  if (Vendor.compare(0, 3, "ati") == 0)
+  {
+    return false;
+  }
+#endif
+
   VAEntrypoint entrypoint = VAEntrypointVLD;
   VAProfile    profile;
 
-- 
1.8.1.6


From 4115edbecd5b2dd346f1ea727191737a5d7cfe74 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 23 Aug 2012 19:39:49 +0200
Subject: [PATCH 072/123] ffmpeg: add av_find_default_stream_index to interface

---
 lib/DllAvFormat.h | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/lib/DllAvFormat.h b/lib/DllAvFormat.h
index ee41fa8..56605cb 100644
--- a/lib/DllAvFormat.h
+++ b/lib/DllAvFormat.h
@@ -100,6 +100,7 @@ class DllAvFormatInterface
   virtual int avformat_write_header (AVFormatContext *s, AVDictionary **options)=0;
   virtual int av_write_trailer(AVFormatContext *s)=0;
   virtual int av_write_frame  (AVFormatContext *s, AVPacket *pkt)=0;
+  virtual int av_find_default_stream_index(AVFormatContext *s)=0;
 };
 
 #if (defined USE_EXTERNAL_FFMPEG) || (defined TARGET_DARWIN) 
@@ -157,6 +158,7 @@ class DllAvFormat : public DllDynamic, DllAvFormatInterface
   virtual int avformat_write_header (AVFormatContext *s, AVDictionary **options) { return ::avformat_write_header (s, options); }
   virtual int av_write_trailer(AVFormatContext *s) { return ::av_write_trailer(s); }
   virtual int av_write_frame  (AVFormatContext *s, AVPacket *pkt) { return ::av_write_frame(s, pkt); }
+  virtual int av_find_default_stream_index(AVFormatContext *s) { return ::av_find_default_stream_index(s); }
 
   // DLL faking.
   virtual bool ResolveExports() { return true; }
@@ -225,6 +227,7 @@ class DllAvFormat : public DllDynamic, DllAvFormatInterface
   DEFINE_METHOD2(int, avformat_write_header , (AVFormatContext *p1, AVDictionary **p2))
   DEFINE_METHOD1(int, av_write_trailer, (AVFormatContext *p1))
   DEFINE_METHOD2(int, av_write_frame  , (AVFormatContext *p1, AVPacket *p2))
+  DEFINE_METHOD1(int, av_find_default_stream_index, (AVFormatContext *p1))
   BEGIN_METHOD_RESOLVE()
     RESOLVE_METHOD_RENAME(av_register_all, av_register_all_dont_call)
     RESOLVE_METHOD_RENAME(avformat_network_init,   avformat_network_init_dont_call)
@@ -261,6 +264,7 @@ class DllAvFormat : public DllDynamic, DllAvFormatInterface
     RESOLVE_METHOD(avformat_write_header)
     RESOLVE_METHOD(av_write_trailer)
     RESOLVE_METHOD(av_write_frame)
+    RESOLVE_METHOD(av_find_default_stream_index)
   END_METHOD_RESOLVE()
 
   /* dependencies of libavformat */
-- 
1.8.1.6


From 8ffb30c17bd7e2547d8f9822ea3c7ba79ddd5d85 Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Sat, 13 Apr 2013 11:30:39 +0200
Subject: [PATCH 073/123] XVBA: revisit draw functions

---
 lib/ffmpeg/libavcodec/xvba_h264.c | 2 +-
 lib/ffmpeg/libavcodec/xvba_vc1.c  | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/lib/ffmpeg/libavcodec/xvba_h264.c b/lib/ffmpeg/libavcodec/xvba_h264.c
index ae45f3a..309d928 100644
--- a/lib/ffmpeg/libavcodec/xvba_h264.c
+++ b/lib/ffmpeg/libavcodec/xvba_h264.c
@@ -160,7 +160,7 @@ static int end_frame(AVCodecContext *avctx)
       h->got_first_iframe = 1;
   }
 
-  ff_draw_horiz_band(h->avctx, &h->dsp, h->cur_pic_ptr, NULL, 0, h->avctx->height, h->picture_structure, h->first_field, 0, 0, 0, 0);
+  ff_h264_draw_horiz_band(h, 0, h->avctx->height);
 
   return 0;
 }
diff --git a/lib/ffmpeg/libavcodec/xvba_vc1.c b/lib/ffmpeg/libavcodec/xvba_vc1.c
index bf3d9c2..ff35a28 100644
--- a/lib/ffmpeg/libavcodec/xvba_vc1.c
+++ b/lib/ffmpeg/libavcodec/xvba_vc1.c
@@ -142,7 +142,7 @@ static int end_frame(AVCodecContext *avctx)
         break;
     }
 
-    ff_draw_horiz_band(s->avctx, &s->dsp, s->current_picture_ptr, s->last_picture_ptr, 0, s->avctx->height, s->picture_structure, s->first_field, (s->unrestricted_mv && !s->intra_only), s->low_delay, s->v_edge_pos, s->h_edge_pos);
+    ff_mpeg_draw_horiz_band(s, 0, s->avctx->height);
 
     return 0;
 }
-- 
1.8.1.6


From 79d420cd213211980405eaec3985973c5747ec20 Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Sat, 13 Apr 2013 12:06:02 +0200
Subject: [PATCH 074/123] (ffmpeg): Make XVBA codec available

---
 lib/ffmpeg/libavcodec/vc1dec.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/lib/ffmpeg/libavcodec/vc1dec.c b/lib/ffmpeg/libavcodec/vc1dec.c
index 2130c74..4d611f9 100644
--- a/lib/ffmpeg/libavcodec/vc1dec.c
+++ b/lib/ffmpeg/libavcodec/vc1dec.c
@@ -5807,6 +5807,9 @@ static int vc1_decode_frame(AVCodecContext *avctx, void *data,
 #if CONFIG_VDPAU
     AV_PIX_FMT_VDPAU,
 #endif
+#if CONFIG_XVBA
+    AV_PIX_FMT_XVBA_VLD,
+#endif
     AV_PIX_FMT_YUV420P,
     AV_PIX_FMT_NONE
 };
-- 
1.8.1.6


From ac4379b9aae918e85751a5dfcf9be58387696da8 Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Sat, 13 Apr 2013 16:38:50 +0200
Subject: [PATCH 075/123] ffmpeg: XVBA-VC1 use v->second_field instead of
 !s->first_field to make VC1 interlaced working

---
 lib/ffmpeg/libavcodec/xvba_vc1.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/ffmpeg/libavcodec/xvba_vc1.c b/lib/ffmpeg/libavcodec/xvba_vc1.c
index ff35a28..04e7983 100644
--- a/lib/ffmpeg/libavcodec/xvba_vc1.c
+++ b/lib/ffmpeg/libavcodec/xvba_vc1.c
@@ -99,7 +99,7 @@ static int end_frame(AVCodecContext *avctx)
     pic_descriptor->sps_info.vc1.psf                        = v->psf;
     // what about if it is a frame (page 31)
     // looked at xvba-driver
-    pic_descriptor->sps_info.vc1.second_field               = !s->first_field;
+    pic_descriptor->sps_info.vc1.second_field               = v->second_field;
     pic_descriptor->sps_info.vc1.xvba_vc1_sps_reserved      = 0;
     
     // VC-1 explicit parameters see page 30 of sdk
-- 
1.8.1.6


From 7f1f427783474710997c79fc53a087c1bf23537d Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Sat, 27 Apr 2013 17:36:15 +0200
Subject: [PATCH 076/123] XVBA: Only set second_field when we are interlaced
 and an interlaced field

---
 lib/ffmpeg/libavcodec/xvba_vc1.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/ffmpeg/libavcodec/xvba_vc1.c b/lib/ffmpeg/libavcodec/xvba_vc1.c
index 04e7983..eb90c12 100644
--- a/lib/ffmpeg/libavcodec/xvba_vc1.c
+++ b/lib/ffmpeg/libavcodec/xvba_vc1.c
@@ -99,7 +99,7 @@ static int end_frame(AVCodecContext *avctx)
     pic_descriptor->sps_info.vc1.psf                        = v->psf;
     // what about if it is a frame (page 31)
     // looked at xvba-driver
-    pic_descriptor->sps_info.vc1.second_field               = v->second_field;
+    pic_descriptor->sps_info.vc1.second_field               = v->interlace && v->second_field && (v->fcm == ILACE_FIELD);
     pic_descriptor->sps_info.vc1.xvba_vc1_sps_reserved      = 0;
     
     // VC-1 explicit parameters see page 30 of sdk
-- 
1.8.1.6


From b58048413f9b77a3cb6495607743ee5cb6e8b452 Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Sat, 27 Apr 2013 22:08:50 +0200
Subject: [PATCH 077/123] xvba: translate picture_structure to a value xvba
 understands

---
 lib/ffmpeg/libavcodec/xvba.c          | 11 +++++++++++
 lib/ffmpeg/libavcodec/xvba_h264.c     |  4 +++-
 lib/ffmpeg/libavcodec/xvba_internal.h |  1 +
 lib/ffmpeg/libavcodec/xvba_vc1.c      |  4 +++-
 4 files changed, 18 insertions(+), 2 deletions(-)

diff --git a/lib/ffmpeg/libavcodec/xvba.c b/lib/ffmpeg/libavcodec/xvba.c
index be29e5d..566922e 100644
--- a/lib/ffmpeg/libavcodec/xvba.c
+++ b/lib/ffmpeg/libavcodec/xvba.c
@@ -31,6 +31,7 @@
 #include "xvba.h"
 #include "xvba_internal.h"
 #include "avcodec.h"
+#include "mpegvideo.h"
 
 int ff_xvba_translate_profile(int profile) {
 
@@ -50,6 +51,16 @@ int ff_xvba_translate_profile(int profile) {
     return -1;
 }
 
+// See page 25 of the documentation
+int ff_xvba_translate_picture_structure(int picture_structure) {
+  if(picture_structure == PICT_TOP_FIELD)
+    return 0;
+  else if (picture_structure == PICT_BOTTOM_FIELD)
+    return 1;
+  else //PICT_FRAME by default
+    return 3;
+}
+
 void ff_xvba_add_slice_data(struct xvba_render_state *render, const uint8_t *buffer, uint32_t size) {
 
   render->buffers = av_fast_realloc(
diff --git a/lib/ffmpeg/libavcodec/xvba_h264.c b/lib/ffmpeg/libavcodec/xvba_h264.c
index 309d928..20ba2f2 100644
--- a/lib/ffmpeg/libavcodec/xvba_h264.c
+++ b/lib/ffmpeg/libavcodec/xvba_h264.c
@@ -87,7 +87,9 @@ static int end_frame(AVCodecContext *avctx)
   pic_descriptor->level                                       = avctx->level;
   pic_descriptor->width_in_mb                                 = h->mb_width;
   pic_descriptor->height_in_mb                                = h->mb_height;
-  pic_descriptor->picture_structure                           = h->picture_structure;
+
+  pic_descriptor->picture_structure                           = ff_xvba_translate_picture_structure(h->picture_structure);
+
   pic_descriptor->chroma_format                               = h->chroma_format_idc ? h->chroma_format_idc : 1;
   pic_descriptor->avc_intra_flag                              = (h->slice_type == AV_PICTURE_TYPE_I) ? 1 : 0;
   pic_descriptor->avc_reference                               = (h->cur_pic_ptr->f.reference & 3) ? 1 : 0;
diff --git a/lib/ffmpeg/libavcodec/xvba_internal.h b/lib/ffmpeg/libavcodec/xvba_internal.h
index 9653f85..18faa3e 100644
--- a/lib/ffmpeg/libavcodec/xvba_internal.h
+++ b/lib/ffmpeg/libavcodec/xvba_internal.h
@@ -21,4 +21,5 @@
  */
 
 int ff_xvba_translate_profile(int profile);
+int ff_xvba_translate_picture_structure(int picture_structure);
 void ff_xvba_add_slice_data(struct xvba_render_state *render, const uint8_t *buffer, uint32_t size);
diff --git a/lib/ffmpeg/libavcodec/xvba_vc1.c b/lib/ffmpeg/libavcodec/xvba_vc1.c
index eb90c12..c98dba5 100644
--- a/lib/ffmpeg/libavcodec/xvba_vc1.c
+++ b/lib/ffmpeg/libavcodec/xvba_vc1.c
@@ -78,7 +78,9 @@ static int end_frame(AVCodecContext *avctx)
       pic_descriptor->width_in_mb                           = s->mb_width;
       pic_descriptor->height_in_mb                          = s->mb_height;
     }
-    pic_descriptor->picture_structure                       = s->picture_structure;
+
+    pic_descriptor->picture_structure                       = ff_xvba_translate_picture_structure(s->picture_structure);
+
     // xvba-video set this to 1 only 4:2:0 supported
     // doc says: if not set, choose 1 - we try this
     pic_descriptor->chroma_format                           = 1;
-- 
1.8.1.6


From 50a161f1bc214ad3383ec0c089bc4c92d8e2df4b Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Tue, 30 Apr 2013 21:18:55 +0200
Subject: [PATCH 078/123] ffmpeg xvba: fix vc1 field interlace

---
 lib/ffmpeg/libavcodec/xvba.c     | 4 ++--
 lib/ffmpeg/libavcodec/xvba.h     | 1 +
 lib/ffmpeg/libavcodec/xvba_vc1.c | 1 +
 3 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/lib/ffmpeg/libavcodec/xvba.c b/lib/ffmpeg/libavcodec/xvba.c
index 566922e..c6ff2fe 100644
--- a/lib/ffmpeg/libavcodec/xvba.c
+++ b/lib/ffmpeg/libavcodec/xvba.c
@@ -53,9 +53,9 @@ int ff_xvba_translate_profile(int profile) {
 
 // See page 25 of the documentation
 int ff_xvba_translate_picture_structure(int picture_structure) {
-  if(picture_structure == PICT_TOP_FIELD)
+  if(picture_structure == PICT_BOTTOM_FIELD)
     return 0;
-  else if (picture_structure == PICT_BOTTOM_FIELD)
+  else if (picture_structure == PICT_TOP_FIELD)
     return 1;
   else //PICT_FRAME by default
     return 3;
diff --git a/lib/ffmpeg/libavcodec/xvba.h b/lib/ffmpeg/libavcodec/xvba.h
index 9f9ff0c..e590faf 100644
--- a/lib/ffmpeg/libavcodec/xvba.h
+++ b/lib/ffmpeg/libavcodec/xvba.h
@@ -66,6 +66,7 @@ struct xvba_render_state {
   unsigned int num_slices;
   struct xvba_bitstream_buffers *buffers;
   uint32_t buffers_alllocated;
+  int psf;
 };
 
 #endif /* AVCODEC_XVBA_H */
diff --git a/lib/ffmpeg/libavcodec/xvba_vc1.c b/lib/ffmpeg/libavcodec/xvba_vc1.c
index c98dba5..e7a85a7 100644
--- a/lib/ffmpeg/libavcodec/xvba_vc1.c
+++ b/lib/ffmpeg/libavcodec/xvba_vc1.c
@@ -143,6 +143,7 @@ static int end_frame(AVCodecContext *avctx)
           pic_descriptor->future_surface = last->surface;
         break;
     }
+    render->psf = v->psf;
 
     ff_mpeg_draw_horiz_band(s, 0, s->avctx->height);
 
-- 
1.8.1.6


From 53256575a97d81b9fcedd1438c34323dc0b27824 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Tue, 30 Apr 2013 21:19:07 +0200
Subject: [PATCH 079/123] xvba: fix vc1 field interlace

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp
index 43a331f..568632f 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp
@@ -1000,6 +1000,9 @@ void CDecoder::FFDrawSlice(struct AVCodecContext *avctx,
     {
       startCodeSize = 4;
       uint8_t sdf = 0x0d;
+      if (render->picture_descriptor->sps_info.vc1.second_field)
+        sdf = 0x0c;
+
       memcpy((uint8_t*)xvba->m_xvbaBufferPool.data_buffer->bufferXVBA+location,
           startCode, 3);
       memcpy((uint8_t*)xvba->m_xvbaBufferPool.data_buffer->bufferXVBA+location+3,
-- 
1.8.1.6


From 66f7bfd6bdf9f765fc2a6eecfb58d69883e7a059 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Tue, 30 Apr 2013 21:40:55 +0200
Subject: [PATCH 080/123] xvba: vc1 - honor psf

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp
index 568632f..1db9363 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp
@@ -1181,6 +1181,7 @@ int CDecoder::FFGetBuffer(AVCodecContext *avctx, AVFrame *pic)
 
   render->state |= FF_XVBA_STATE_USED_FOR_REFERENCE;
   render->state &= ~FF_XVBA_STATE_DECODED;
+  render->psf = 0;
   pic->reordered_opaque= avctx->reordered_opaque;
 
   return 0;
@@ -1225,6 +1226,8 @@ int CDecoder::Decode(AVCodecContext* avctx, AVFrame* frame)
     memset(&pic.DVDPic, 0, sizeof(pic.DVDPic));
     ((CDVDVideoCodecFFmpeg*)avctx->opaque)->GetPictureCommon(&pic.DVDPic);
     pic.render = render;
+    if (render->psf)
+      pic.DVDPic.iFlags &= ~DVP_FLAG_INTERLACED;
     m_bufferStats.IncDecoded();
     m_xvbaOutput.m_dataPort.SendOutMessage(COutputDataProtocol::NEWFRAME, &pic, sizeof(pic));
 
-- 
1.8.1.6


From 5b328a69f54b582ba3987cb218233bbe587e91f9 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sat, 4 May 2013 10:31:32 +0200
Subject: [PATCH 081/123] xvba: squash me, settings

---
 xbmc/settings/Settings.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/xbmc/settings/Settings.cpp b/xbmc/settings/Settings.cpp
index 63cdf0e..02eef76 100644
--- a/xbmc/settings/Settings.cpp
+++ b/xbmc/settings/Settings.cpp
@@ -747,6 +747,9 @@ void CSettings::InitializeConditions()
 #ifdef HAVE_LIBVDPAU
   m_settingsManager->AddCondition("have_libvdpau");
 #endif
+#ifdef HAVE_LIBXVBA
+  m_settingsManager->AddCondition("have_libxvba");
+#endif
 #ifdef HAVE_VIDEOTOOLBOXDECODER
   m_settingsManager->AddCondition("have_videotoolboxdecoder");
   if (g_sysinfo.HasVideoToolBoxDecoder())
-- 
1.8.1.6


From 0aaeb0a6313953818000e7203d527dfee8906f83 Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Fri, 24 May 2013 12:02:02 +0200
Subject: [PATCH 082/123] XVBA: Limit video to 2048x1152 as this is the max all
 blocks can handle

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp
index 1db9363..54d7aea 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp
@@ -340,10 +340,12 @@ bool CDecoder::Open(AVCodecContext* avctx, const enum PixelFormat fmt, unsigned
   // it seems that xvba does not support anything > 2k
   // return false, for files that are larger
   // if you are unlucky, this would kill your decoder
-  // we limit to 2048x1536(+8) now - as this was tested working
+  // we limit to 2048x1152 now - as this was reported by ckoenig the UVD OSS 
+  // engineer to be the maximum technically possible for all hardware with UVD.
+  // Some chips can do a bit more, but we use the safe default.
   int surfaceWidth = (avctx->coded_width+15) & ~15;
   int surfaceHeight = (avctx->coded_height+15) & ~15;
-  if(surfaceHeight > 1544 || surfaceWidth > 2048)
+  if(surfaceHeight > 1152 || surfaceWidth > 2048)
   {
     CLog::Log(LOGERROR, "Surface too large, decoder skipped: surfaceWidth %u, surfaceHeight %u",
                         surfaceWidth, surfaceHeight);
-- 
1.8.1.6


From f4f97fb0313df385610d2d3d2164cbb2f4390773 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 20 Aug 2012 16:06:39 +0200
Subject: [PATCH 083/123] dvdplayer: observe pts counter overflow

---
 .../cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp | 198 ++++++++++++++++++++-
 xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h  |   4 +
 2 files changed, 201 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
index 18c1c4b..0e25041 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
@@ -18,7 +18,6 @@
  *
  */
 
-#include "system.h"
 #ifndef __STDC_CONSTANT_MACROS
 #define __STDC_CONSTANT_MACROS
 #endif
@@ -26,6 +25,7 @@
 #define __STDC_LIMIT_MACROS
 #endif
 #ifdef TARGET_POSIX
+#include "system.h"
 #include "stdint.h"
 #endif
 #include "DVDDemuxFFmpeg.h"
@@ -489,6 +489,9 @@ bool CDVDDemuxFFmpeg::Open(CDVDInputStream* pInput)
 
   CreateStreams();
 
+  m_bPtsWrapChecked = false;
+  m_bPtsWrap = false;
+
   return true;
 }
 
@@ -629,6 +632,12 @@ double CDVDDemuxFFmpeg::ConvertTimestamp(int64_t pts, int den, int num)
   if (pts == (int64_t)AV_NOPTS_VALUE)
     return DVD_NOPTS_VALUE;
 
+  if (m_bPtsWrap)
+  {
+    if (pts < m_iStartTime && pts < m_iEndTime)
+      pts += m_iMaxTime;
+  }
+
   // do calculations in floats as they can easily overflow otherwise
   // we don't care for having a completly exact timestamp anyway
   double timestamp = (double)pts * num  / den;
@@ -768,6 +777,24 @@ DemuxPacket* CDVDDemuxFFmpeg::Read()
           m_pkt.pkt.pts = AV_NOPTS_VALUE;
         }
 
+        if (!m_bPtsWrapChecked && m_pFormatContext->iformat->flags & AVFMT_TS_DISCONT)
+        {
+          int defaultStream = m_dllAvFormat.av_find_default_stream_index(m_pFormatContext);
+          int64_t duration = m_pFormatContext->streams[defaultStream]->duration * 1.5;
+          m_iMaxTime = 1LL<<m_pFormatContext->streams[defaultStream]->pts_wrap_bits;
+          m_iStartTime = m_pFormatContext->streams[defaultStream]->start_time;
+          if (m_iStartTime != DVD_NOPTS_VALUE)
+          {
+            m_iEndTime = (m_iStartTime + duration) & ~m_iMaxTime;
+            if (m_iEndTime < m_iStartTime)
+            {
+              CLog::Log(LOGNOTICE,"CDVDDemuxFFmpeg::Read - file contains pts overflow");
+              m_bPtsWrap = true;
+            }
+          }
+          m_bPtsWrapChecked = true;
+        }
+
         // copy contents into our own packet
         pPacket->iSize = m_pkt.pkt.size;
 
@@ -897,10 +924,20 @@ bool CDVDDemuxFFmpeg::SeekTime(int time, bool backwords, double *startpts)
   int ret;
   {
     CSingleLock lock(m_critSection);
+
     ret = m_dllAvFormat.av_seek_frame(m_pFormatContext, -1, seek_pts, backwords ? AVSEEK_FLAG_BACKWARD : 0);
 
     if(ret >= 0)
+    {
       UpdateCurrentPTS();
+
+      // seek may fail silently on streams which allow discontinuity
+      // if current timestamp is way off asume a pts overflow and try bisect seek
+      if (m_bPtsWrap && fabs(time - m_iCurrentPts/1000) > 10000)
+      {
+        ret = SeekTimeDiscont(seek_pts, backwords) ? 1 : -1;
+      }
+    }
   }
 
   if(m_iCurrentPts == DVD_NOPTS_VALUE)
@@ -919,6 +956,165 @@ bool CDVDDemuxFFmpeg::SeekTime(int time, bool backwords, double *startpts)
   return (ret >= 0);
 }
 
+bool CDVDDemuxFFmpeg::SeekTimeDiscont(int64_t pts, bool backwards)
+{
+  // this code is taken from ffmpeg function ff_gen_search
+  // it is modified to assume a pts overflow if timestamp < start_time
+  if (!m_pFormatContext->iformat->read_timestamp)
+    return false;
+
+  int defaultStream = m_dllAvFormat.av_find_default_stream_index(m_pFormatContext);
+
+  if (defaultStream < 0)
+  {
+    return false;
+  }
+
+  // timestamp for default must be expressed in AV_TIME_BASE units
+  pts = m_dllAvUtil.av_rescale_rnd(pts, m_pFormatContext->streams[defaultStream]->time_base.den,
+                      AV_TIME_BASE * (int64_t)m_pFormatContext->streams[defaultStream]->time_base.num,
+                      AV_ROUND_NEAR_INF);
+
+  int64_t pos, pos_min, pos_max, pos_limit, ts, ts_min, ts_max;
+  int64_t start_pos, filesize;
+  int no_change;
+
+  pos_min = m_pFormatContext->data_offset;
+  ts_min = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                     &pos_min, INT64_MAX);
+  if (ts_min == AV_NOPTS_VALUE)
+    return false;
+
+  if(ts_min >= pts)
+  {
+    pos = pos_min;
+    return true;
+  }
+
+  int step= 1024;
+  filesize = m_pInput->GetLength();
+  pos_max = filesize - 1;
+  do
+  {
+    pos_max -= step;
+    ts_max = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                       &pos_max, pos_max + step);
+    step += step;
+  }while (ts_max == AV_NOPTS_VALUE && pos_max >= step);
+
+  if (ts_max == AV_NOPTS_VALUE)
+    return false;
+
+  if (ts_max < m_iStartTime && ts_max < m_iEndTime)
+    ts_max += m_iMaxTime;
+
+  for(;;)
+  {
+    int64_t tmp_pos = pos_max + 1;
+    int64_t tmp_ts = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                               &tmp_pos, INT64_MAX);
+    if(tmp_ts == AV_NOPTS_VALUE)
+      break;
+
+    if (tmp_ts < m_iStartTime && tmp_ts < m_iEndTime)
+      tmp_ts += m_iMaxTime;
+
+    ts_max = tmp_ts;
+    pos_max = tmp_pos;
+    if (tmp_pos >= filesize)
+      break;
+  }
+  pos_limit = pos_max;
+
+  if(ts_max <= pts)
+  {
+    bool ret = SeekByte(pos_max);
+    if (ret)
+    {
+      m_iCurrentPts = ConvertTimestamp(ts_max, m_pFormatContext->streams[defaultStream]->time_base.den,
+                                       m_pFormatContext->streams[defaultStream]->time_base.num);
+    }
+    return ret;
+  }
+
+  if(ts_min > ts_max)
+  {
+    return false;
+  }
+  else if (ts_min == ts_max)
+  {
+    pos_limit = pos_min;
+  }
+
+  no_change=0;
+  while (pos_min < pos_limit)
+  {
+    if (no_change == 0)
+    {
+      int64_t approximate_keyframe_distance= pos_max - pos_limit;
+      // interpolate position (better than dichotomy)
+      pos = m_dllAvUtil.av_rescale_rnd(pts - ts_min, pos_max - pos_min,
+                                       ts_max - ts_min, AV_ROUND_NEAR_INF)
+          + pos_min - approximate_keyframe_distance;
+    }
+    else if (no_change == 1)
+    {
+      // bisection, if interpolation failed to change min or max pos last time
+      pos = (pos_min + pos_limit) >> 1;
+    }
+    else
+    {
+      /* linear search if bisection failed, can only happen if there
+         are very few or no keyframes between min/max */
+      pos = pos_min;
+    }
+    if (pos <= pos_min)
+      pos= pos_min + 1;
+    else if (pos > pos_limit)
+      pos= pos_limit;
+    start_pos = pos;
+
+    ts = m_pFormatContext->iformat->read_timestamp(m_pFormatContext, defaultStream,
+                                                   &pos, INT64_MAX);
+    if (pos == pos_max)
+      no_change++;
+    else
+      no_change=0;
+
+    if (ts == AV_NOPTS_VALUE)
+    {
+      return false;
+    }
+
+    if (ts < m_iStartTime && ts < m_iEndTime)
+      ts += m_iMaxTime;
+
+    if (pts <= ts)
+    {
+      pos_limit = start_pos - 1;
+      pos_max = pos;
+      ts_max = ts;
+    }
+    if (pts >= ts)
+    {
+      pos_min = pos;
+      ts_min = ts;
+    }
+  }
+
+  pos = (backwards) ? pos_min : pos_max;
+  ts  = (backwards) ?  ts_min :  ts_max;
+
+  bool ret = SeekByte(pos);
+  if (ret)
+  {
+    m_iCurrentPts = ConvertTimestamp(ts, m_pFormatContext->streams[defaultStream]->time_base.den,
+                                     m_pFormatContext->streams[defaultStream]->time_base.num);
+  }
+
+  return ret;
+}
+
 bool CDVDDemuxFFmpeg::SeekByte(int64_t pos)
 {
   CSingleLock lock(m_critSection);
diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
index b78094e..17d2f7a 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.h
@@ -100,6 +100,7 @@ class CDVDDemuxFFmpeg : public CDVDDemux
   DemuxPacket* Read();
 
   bool SeekTime(int time, bool backwords = false, double* startpts = NULL);
+  bool SeekTimeDiscont(int64_t pts, bool backwards);
   bool SeekByte(int64_t pos);
   int GetStreamLength();
   CDemuxStream* GetStream(int iStreamId);
@@ -158,5 +159,8 @@ class CDVDDemuxFFmpeg : public CDVDDemux
     AVPacket pkt;       // packet ffmpeg returned
     int      result;    // result from av_read_packet
   }m_pkt;
+
+  bool m_bPtsWrap, m_bPtsWrapChecked;
+  int64_t m_iStartTime, m_iMaxTime, m_iEndTime;
 };
 
-- 
1.8.1.6


From 1936aa6817db5c98cd21a2ab7a9656f183ac9509 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Tue, 2 Oct 2012 13:02:10 +0200
Subject: [PATCH 084/123] dvdplayer: avoid short screen flicker caused by
 unnecessary reconfigure of renderer

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 41e64a5..74b4391 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1095,7 +1095,7 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
    || ( m_output.height          != pPicture->iHeight )
    || ( m_output.dwidth          != pPicture->iDisplayWidth )
    || ( m_output.dheight         != pPicture->iDisplayHeight )
-   || ( m_output.framerate       != config_framerate )
+   || (!m_bFpsInvalid && fmod(m_output.framerate, config_framerate) != 0.0 )
    || ( m_output.color_format    != (unsigned int)pPicture->format )
    || ( m_output.extended_format != pPicture->extended_format )
    || ( m_output.color_matrix    != pPicture->color_matrix    && pPicture->color_matrix    != 0 ) // don't reconfigure on unspecified
@@ -1148,7 +1148,7 @@ int CDVDPlayerVideo::OutputPicture(const DVDVideoPicture* src, double pts)
     m_output.height          = pPicture->iHeight;
     m_output.dwidth          = pPicture->iDisplayWidth;
     m_output.dheight         = pPicture->iDisplayHeight;
-    m_output.framerate       = config_framerate;
+    m_output.framerate       = config_framerate == 0.0 ? g_graphicsContext.GetFPS() : config_framerate;
     m_output.color_format    = pPicture->format;
     m_output.extended_format = pPicture->extended_format;
     m_output.color_matrix    = pPicture->color_matrix;
-- 
1.8.1.6


From 869811cf0359978019c5edc2277610d9a58a47e1 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 11 Oct 2012 12:05:50 +0200
Subject: [PATCH 085/123] vdpau: advanced settings for auto deinterlacing

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 8 ++++----
 xbmc/settings/AdvancedSettings.cpp             | 4 ++++
 xbmc/settings/AdvancedSettings.h               | 2 ++
 3 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 4b4b3c3..fc4c030 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -1800,10 +1800,10 @@ EINTERLACEMETHOD CMixer::GetDeinterlacingMethod(bool log /* = false */)
   if (method == VS_INTERLACEMETHOD_AUTO)
   {
     int deint = -1;
-//    if (m_config.outHeight >= 720)
-//      deint = g_advancedSettings.m_videoVDPAUdeintHD;
-//    else
-//      deint = g_advancedSettings.m_videoVDPAUdeintSD;
+    if (m_config.outHeight >= 720)
+      deint = g_advancedSettings.m_videoVDPAUdeintHD;
+    else
+      deint = g_advancedSettings.m_videoVDPAUdeintSD;
 
     if (deint != -1)
     {
diff --git a/xbmc/settings/AdvancedSettings.cpp b/xbmc/settings/AdvancedSettings.cpp
index bd08884..a7a7233 100644
--- a/xbmc/settings/AdvancedSettings.cpp
+++ b/xbmc/settings/AdvancedSettings.cpp
@@ -169,6 +169,8 @@ void CAdvancedSettings::Initialize()
   m_videoAllowMpeg4VAAPI = false;  
   m_videoDisableBackgroundDeinterlace = false;
   m_videoCaptureUseOcclusionQuery = -1; //-1 is auto detect
+  m_videoVDPAUdeintHD = -1;
+  m_videoVDPAUdeintSD = -1;
   m_videoVDPAUtelecine = false;
   m_videoVDPAUdeintSkipChromaHD = false;
   m_DXVACheckCompatibility = false;
@@ -583,6 +585,8 @@ void CAdvancedSettings::ParseSettingsFile(const CStdString &file)
     XMLUtils::GetBoolean(pElement,"allowmpeg4vaapi",m_videoAllowMpeg4VAAPI);    
     XMLUtils::GetBoolean(pElement, "disablebackgrounddeinterlace", m_videoDisableBackgroundDeinterlace);
     XMLUtils::GetInt(pElement, "useocclusionquery", m_videoCaptureUseOcclusionQuery, -1, 1);
+    XMLUtils::GetInt(pElement,"vdpauHDdeint",m_videoVDPAUdeintHD);
+    XMLUtils::GetInt(pElement,"vdpauSDdeint",m_videoVDPAUdeintSD);
     XMLUtils::GetBoolean(pElement,"vdpauInvTelecine",m_videoVDPAUtelecine);
     XMLUtils::GetBoolean(pElement,"vdpauHDdeintSkipChroma",m_videoVDPAUdeintSkipChromaHD);
 
diff --git a/xbmc/settings/AdvancedSettings.h b/xbmc/settings/AdvancedSettings.h
index 3a52878..3e6901b 100644
--- a/xbmc/settings/AdvancedSettings.h
+++ b/xbmc/settings/AdvancedSettings.h
@@ -147,6 +147,8 @@ class CAdvancedSettings : public ISettingCallback, public ISettingsHandler
     int m_videoPercentSeekBackwardBig;
     CStdString m_videoPPFFmpegDeint;
     CStdString m_videoPPFFmpegPostProc;
+    int m_videoVDPAUdeintHD;
+    int m_videoVDPAUdeintSD;
     bool m_videoVDPAUtelecine;
     bool m_videoVDPAUdeintSkipChromaHD;
     bool m_musicUseTimeSeeking;
-- 
1.8.1.6


From ad793502d0586581120666555f6b6d231c1b249d Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Fri, 2 Nov 2012 13:20:03 +0100
Subject: [PATCH 086/123] player: fix rewind

---
 xbmc/cores/dvdplayer/DVDMessage.h       |  5 ++++-
 xbmc/cores/dvdplayer/DVDPlayer.cpp      | 30 +++++++++++++++++++-----------
 xbmc/cores/dvdplayer/DVDPlayer.h        |  7 ++++---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp |  4 +++-
 xbmc/cores/dvdplayer/DVDPlayerVideo.h   |  1 +
 5 files changed, 31 insertions(+), 16 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDMessage.h b/xbmc/cores/dvdplayer/DVDMessage.h
index 3f65ced..ad434d2 100644
--- a/xbmc/cores/dvdplayer/DVDMessage.h
+++ b/xbmc/cores/dvdplayer/DVDMessage.h
@@ -220,7 +220,7 @@ class CDVDMsgPlayerSetState : public CDVDMsg
 class CDVDMsgPlayerSeek : public CDVDMsg
 {
 public:
-  CDVDMsgPlayerSeek(int time, bool backward, bool flush = true, bool accurate = true, bool restore = true, bool trickplay = false)
+  CDVDMsgPlayerSeek(int time, bool backward, bool flush = true, bool accurate = true, bool restore = true, bool trickplay = false, bool sync = true)
     : CDVDMsg(PLAYER_SEEK)
     , m_time(time)
     , m_backward(backward)
@@ -228,6 +228,7 @@ class CDVDMsgPlayerSeek : public CDVDMsg
     , m_accurate(accurate)
     , m_restore(restore)
     , m_trickplay(trickplay)
+    , m_sync(sync)
   {}
   int  GetTime()              { return m_time; }
   bool GetBackward()          { return m_backward; }
@@ -235,6 +236,7 @@ class CDVDMsgPlayerSeek : public CDVDMsg
   bool GetAccurate()          { return m_accurate; }
   bool GetRestore()           { return m_restore; }
   bool GetTrickPlay()         { return m_trickplay; }
+  bool GetSync()              { return m_sync; }
 private:
   int  m_time;
   bool m_backward;
@@ -242,6 +244,7 @@ class CDVDMsgPlayerSeek : public CDVDMsg
   bool m_accurate;
   bool m_restore; // whether to restore any EDL cut time
   bool m_trickplay;
+  bool m_sync;
 };
 
 class CDVDMsgPlayerSeekChapter : public CDVDMsg
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.cpp b/xbmc/cores/dvdplayer/DVDPlayer.cpp
index b56423b..cdc4b95 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayer.cpp
@@ -1556,11 +1556,13 @@ void CDVDPlayer::HandlePlaySpeed()
     }
     else if (m_CurrentVideo.id >= 0
           &&  (m_CurrentVideo.inited == true || GetPlaySpeed() < 0) // allow rewind at end of file
-          &&  m_SpeedState.lastpts  != m_dvdPlayerVideo.GetCurrentPts()
+          &&  (m_SpeedState.lastpts  != m_dvdPlayerVideo.GetCurrentPts() || fabs(m_SpeedState.lastabstime - CDVDClock::GetAbsoluteClock()) > DVD_MSEC_TO_TIME(200))
+          &&  (m_dvdPlayerVideo.GetCurrentPts() != DVD_NOPTS_VALUE)
           &&  m_SpeedState.lasttime != GetTime())
     {
       m_SpeedState.lastpts  = m_dvdPlayerVideo.GetCurrentPts();
       m_SpeedState.lasttime = GetTime();
+      m_SpeedState.lastabstime = CDVDClock::GetAbsoluteClock();
       // check how much off clock video is when ff/rw:ing
       // a problem here is that seeking isn't very accurate
       // and since the clock will be resynced after seek
@@ -1579,7 +1581,7 @@ void CDVDPlayer::HandlePlaySpeed()
       {
         CLog::Log(LOGDEBUG, "CDVDPlayer::Process - Seeking to catch up");
         int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset + 500000.0 * m_playSpeed / DVD_PLAYSPEED_NORMAL);
-        m_messenger.Put(new CDVDMsgPlayerSeek(iTime, (GetPlaySpeed() < 0), true, false, false, true));
+        m_messenger.Put(new CDVDMsgPlayerSeek(iTime, (GetPlaySpeed() < 0), true, false, false, true, false));
       }
     }
   }
@@ -2067,7 +2069,7 @@ void CDVDPlayer::HandleMessages()
           else
             m_StateInput.dts = start;
 
-          FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate());
+          FlushBuffers(!msg.GetFlush(), start, msg.GetAccurate(), msg.GetSync());
         }
         else
           CLog::Log(LOGWARNING, "error while seeking");
@@ -2206,9 +2208,10 @@ void CDVDPlayer::HandleMessages()
           double offset;
           offset  = CDVDClock::GetAbsoluteClock() - m_State.timestamp;
           offset *= m_playSpeed / DVD_PLAYSPEED_NORMAL;
+          offset  = DVD_TIME_TO_MSEC(offset);
           if(offset >  1000) offset =  1000;
           if(offset < -1000) offset = -1000;
-          m_State.time     += DVD_TIME_TO_MSEC(offset);
+          m_State.time     += offset;
           m_State.timestamp =  CDVDClock::GetAbsoluteClock();
         }
 
@@ -2224,7 +2227,8 @@ void CDVDPlayer::HandleMessages()
         // do a seek after rewind, clock is not in sync with current pts
         if (m_playSpeed < 0 && speed >= 0)
         {
-          m_messenger.Put(new CDVDMsgPlayerSeek(GetTime(), true, true, true));
+          int64_t iTime = (int64_t)DVD_TIME_TO_MSEC(m_clock.GetClock() + m_State.time_offset);
+          m_messenger.Put(new CDVDMsgPlayerSeek(iTime, true, true, false, false, true));
         }
 
         // if playspeed is different then DVD_PLAYSPEED_NORMAL or DVD_PLAYSPEED_PAUSE
@@ -3173,7 +3177,7 @@ bool CDVDPlayer::CloseTeletextStream(bool bWaitForBuffers)
   return true;
 }
 
-void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
+void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate, bool sync)
 {
   double startpts;
   if(accurate)
@@ -3185,19 +3189,23 @@ void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
   if(startpts != DVD_NOPTS_VALUE)
     startpts -= m_offset_pts;
 
-  m_CurrentAudio.inited      = false;
+  if (sync)
+  {
+    m_CurrentAudio.inited      = false;
+    m_CurrentVideo.inited      = false;
+    m_CurrentSubtitle.inited   = false;
+    m_CurrentTeletext.inited   = false;
+  }
+
   m_CurrentAudio.dts         = DVD_NOPTS_VALUE;
   m_CurrentAudio.startpts    = startpts;
 
-  m_CurrentVideo.inited      = false;
   m_CurrentVideo.dts         = DVD_NOPTS_VALUE;
   m_CurrentVideo.startpts    = startpts;
 
-  m_CurrentSubtitle.inited   = false;
   m_CurrentSubtitle.dts      = DVD_NOPTS_VALUE;
   m_CurrentSubtitle.startpts = startpts;
 
-  m_CurrentTeletext.inited   = false;
   m_CurrentTeletext.dts      = DVD_NOPTS_VALUE;
   m_CurrentTeletext.startpts = startpts;
 
@@ -3241,7 +3249,7 @@ void CDVDPlayer::FlushBuffers(bool queued, double pts, bool accurate)
       m_CurrentTeletext.started = false;
     }
 
-    if(pts != DVD_NOPTS_VALUE)
+    if(pts != DVD_NOPTS_VALUE && sync)
       m_clock.Discontinuity(pts);
     UpdatePlayState(0);
 
diff --git a/xbmc/cores/dvdplayer/DVDPlayer.h b/xbmc/cores/dvdplayer/DVDPlayer.h
index 6da30eb..69b659b 100644
--- a/xbmc/cores/dvdplayer/DVDPlayer.h
+++ b/xbmc/cores/dvdplayer/DVDPlayer.h
@@ -304,7 +304,7 @@ class CDVDPlayer : public IPlayer, public CThread, public IDVDPlayer
   bool GetCachingTimes(double& play_left, double& cache_left, double& file_offset);
 
 
-  void FlushBuffers(bool queued, double pts = DVD_NOPTS_VALUE, bool accurate = true);
+  void FlushBuffers(bool queued, double pts = DVD_NOPTS_VALUE, bool accurate = true, bool sync = true);
 
   void HandleMessages();
   void HandlePlaySpeed();
@@ -353,8 +353,9 @@ class CDVDPlayer : public IPlayer, public CThread, public IDVDPlayer
   int m_playSpeed;
   struct SSpeedState
   {
-    double lastpts;  // holds last display pts during ff/rw operations
-    double lasttime;
+    double  lastpts;  // holds last display pts during ff/rw operations
+    int64_t lasttime;
+    double  lastabstime;
   } m_SpeedState;
 
   int m_errorCount;
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 74b4391..11e0b26 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -1500,7 +1500,7 @@ double CDVDPlayerVideo::GetCurrentPts()
 
   if( m_stalled )
     iRenderPts = DVD_NOPTS_VALUE;
-  else
+  else if ( m_speed == DVD_PLAYSPEED_NORMAL)
     iRenderPts = iRenderPts - max(0.0, iSleepTime);
 
   return iRenderPts;
@@ -1600,6 +1600,8 @@ int CDVDPlayerVideo::CalcDropRequirement(double pts)
   int    iSkippedDeint = 0;
   int    iBufferLevel;
 
+  m_droppingStats.m_lastPts = pts;
+
   // get decoder stats
   if (!m_pVideoCodec->GetCodecStats(iDecoderPts, iSkippedDeint, interlaced))
     iDecoderPts = pts;
diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.h b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
index 3c3e007..6ae3860 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.h
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.h
@@ -50,6 +50,7 @@ class CDroppingStats
   double m_totalGain;
   double m_lastDecoderPts;
   double m_lastRenderPts;
+  double m_lastPts;
   unsigned int m_lateFrames;
   unsigned int m_dropRequests;
 };
-- 
1.8.1.6


From 13a147ecc9caadc5933691d90af691b4878303f1 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Fri, 23 Nov 2012 17:41:12 +0100
Subject: [PATCH 087/123] xrandr: fix query for multiple screens

---
 xbmc/windowing/X11/XRandR.cpp | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index 97b1e32..a3d3543 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -57,12 +57,14 @@ bool CXRandR::Query(bool force)
 
   m_outputs.clear();
   // query all screens
+  // we are happy if at least one screen returns results
+  bool success = false;
   for(unsigned int screennum=0; screennum<m_numScreens; ++screennum)
   {
-    if(!Query(force, screennum))
-      return false;
+    if(Query(force, screennum))
+      success = true;
   }
-  return true;
+  return success;
 }
 
 bool CXRandR::Query(bool force, int screennum)
@@ -70,7 +72,7 @@ bool CXRandR::Query(bool force, int screennum)
   CStdString cmd;
   cmd  = getenv("XBMC_BIN_HOME");
   cmd += "/xbmc-xrandr";
-  cmd.append("-q --screen %d", screennum);
+  cmd.AppendFormat(" -q --screen %d", screennum);
 
   FILE* file = popen(cmd.c_str(),"r");
   if (!file)
-- 
1.8.1.6


From 0925b7658bf2ed75cea29963c2a535e7829e5b1a Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 2 Dec 2012 15:46:55 +0100
Subject: [PATCH 088/123] X11: add debug log to print out refresh after xrr
 event

---
 xbmc/windowing/X11/WinSystemX11.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index d2dcccd..7403785 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -683,6 +683,12 @@ void CWinSystemX11::NotifyXRREvent()
   XOutput *out = g_xrandr.GetOutput(currentOutput);
   XMode   mode = g_xrandr.GetCurrentMode(currentOutput);
 
+  if (out)
+    CLog::Log(LOGDEBUG, "%s - current output: %s, mode: %s, refresh: %.3f", __FUNCTION__
+             , out->name.c_str(), mode.id.c_str(), mode.hz);
+  else
+    CLog::Log(LOGWARNING, "%s - output name not set", __FUNCTION__);
+
   RESOLUTION_INFO res;
   unsigned int i;
   bool found(false);
-- 
1.8.1.6


From 9f1759a1b344dbc1b038ce14336381de5dc9dbc1 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Tue, 11 Dec 2012 11:08:13 +0100
Subject: [PATCH 089/123] X11: dont call XCloseDisplay on shutdown, it crashes
 when powered doen by cec on ATI

---
 xbmc/windowing/X11/WinSystemX11.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 7403785..0e39867 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -110,7 +110,8 @@ bool CWinSystemX11::DestroyWindowSystem()
     //we don't call XCloseDisplay() here, since ati keeps a pointer to our m_dpy
     //so instead we just let m_dpy die on exit
     // i have seen core dumps on ATI if the display is not closed here
-    XCloseDisplay(m_dpy);
+    // crashes when shutting down via cec
+//    XCloseDisplay(m_dpy);
   }
 
   // m_SDLSurface is free()'d by SDL_Quit().
-- 
1.8.1.6


From 6e7a31afeb0107b9636ffb0790ce348ef50cad5e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Gr=C3=A9gory=20Coutant?= <gregory.coutant@gmail.com>
Date: Wed, 12 Dec 2012 19:49:47 +0100
Subject: [PATCH 090/123] x11: support for multiple x screens

---
 xbmc/windowing/X11/XRandR.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index a3d3543..8846bc6 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -92,7 +92,7 @@ bool CXRandR::Query(bool force, int screennum)
   pclose(file);
 
   TiXmlElement *pRootElement = xmlDoc.RootElement();
-  if (strcasecmp(pRootElement->Value(), "screen") != screennum)
+  if (atoi(pRootElement->Attribute("id")) != screennum)
   {
     // TODO ERROR
     return false;
-- 
1.8.1.6


From 7876a7ae280e920cf6978e4afa48f4ebdedc3910 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 24 Dec 2012 16:02:42 +0100
Subject: [PATCH 091/123] pvr: increase changes counter of stream on stream
 change, cosmetics after dd307930d39d92f145a01a16600cd00e01ec39be

---
 xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp
index 305ba07..3ad9792 100644
--- a/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp
+++ b/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPVRClient.cpp
@@ -339,9 +339,7 @@ void CDVDDemuxPVRClient::RequestStreams()
       if (stm)
       {
         st = dynamic_cast<CDemuxStreamAudioPVRClient*>(stm);
-        if (!st
-            || (st->codec != (AVCodecID)props.stream[i].iCodecId)
-            || (st->iChannels != props.stream[i].iChannels))
+        if (!st || (st->codec != (AVCodecID)props.stream[i].iCodecId))
           DisposeStream(i);
       }
       if (!m_streams[i])
@@ -358,6 +356,7 @@ void CDVDDemuxPVRClient::RequestStreams()
       st->iBitsPerSample  = props.stream[i].iBitsPerSample;
       m_streams[i] = st;
       st->m_parser_split = true;
+      st->changes++;
     }
     else if (props.stream[i].iCodecType == AVMEDIA_TYPE_VIDEO)
     {
-- 
1.8.1.6


From 7bef6de9b9afa5d67b467fa06612e2eafef9b81e Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 17 Jan 2013 16:03:22 +0100
Subject: [PATCH 092/123] X11: add keymapping for XF86XK_Sleep

---
 xbmc/windowing/WinEventsX11.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index 4a5aab4..da5d412 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -143,6 +143,7 @@
 , {XK_Break, XBMCK_BREAK}
 , {XK_Menu, XBMCK_MENU}
 , {XF86XK_PowerOff, XBMCK_POWER}
+, {XF86XK_Sleep, XBMCK_SLEEP}
 , {XK_EcuSign, XBMCK_EURO}
 , {XK_Undo, XBMCK_UNDO}
   /* Media keys */
-- 
1.8.1.6


From 8511f31601ff6970648ed51204cc55102dafbf1c Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 21 Jan 2013 09:00:19 +0100
Subject: [PATCH 093/123] X11: remove toggle full screen after resume

---
 xbmc/powermanagement/PowerManager.cpp | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/xbmc/powermanagement/PowerManager.cpp b/xbmc/powermanagement/PowerManager.cpp
index f2a063f..f1e3c4f 100644
--- a/xbmc/powermanagement/PowerManager.cpp
+++ b/xbmc/powermanagement/PowerManager.cpp
@@ -260,11 +260,6 @@ void CPowerManager::OnWake()
 #if defined(TARGET_WINDOWS)
     ShowWindow(g_hWnd,SW_RESTORE);
     SetForegroundWindow(g_hWnd);
-#elif !defined(TARGET_DARWIN_OSX)
-    // Hack to reclaim focus, thus rehiding system mouse pointer.
-    // Surely there's a better way?
-    g_graphicsContext.ToggleFullScreenRoot();
-    g_graphicsContext.ToggleFullScreenRoot();
 #endif
   }
   g_application.ResetScreenSaver();
-- 
1.8.1.6


From a0368631b8ed581ae1fa54bd7b51a3cc4323e8c5 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Wed, 23 Jan 2013 17:03:02 +0100
Subject: [PATCH 094/123] xrandr: set screen on mode change command

---
 xbmc/windowing/X11/XRandR.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index 8846bc6..e6d6240 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -246,7 +246,7 @@ bool CXRandR::SetMode(XOutput output, XMode mode)
   m_currentMode = modeFound.id;
   char cmd[255];
   if (getenv("XBMC_BIN_HOME"))
-    snprintf(cmd, sizeof(cmd), "%s/xbmc-xrandr --output %s --mode %s", getenv("XBMC_BIN_HOME"), outputFound.name.c_str(), modeFound.id.c_str());
+    snprintf(cmd, sizeof(cmd), "%s/xbmc-xrandr --screen %d --output %s --mode %s", getenv("XBMC_BIN_HOME"), outputFound.screen, outputFound.name.c_str(), modeFound.id.c_str());
   else
     return false;
   CLog::Log(LOGINFO, "XRANDR: %s", cmd);
-- 
1.8.1.6


From 9071be89472ecbcc05ffa4bb967883a0b53e3a07 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Wed, 23 Jan 2013 17:03:39 +0100
Subject: [PATCH 095/123] X11: recreate glx context when output changes

---
 xbmc/windowing/X11/WinSystemX11.cpp | 6 +++---
 xbmc/windowing/X11/WinSystemX11.h   | 2 +-
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 0e39867..d865cd7 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -407,11 +407,11 @@ bool CWinSystemX11::IsSuitableVisual(XVisualInfo *vInfo)
   return true;
 }
 
-bool CWinSystemX11::RefreshGlxContext()
+bool CWinSystemX11::RefreshGlxContext(bool force)
 {
   bool retVal = false;
 
-  if (m_glContext)
+  if (m_glContext && !force)
   {
     CLog::Log(LOGDEBUG, "CWinSystemX11::RefreshGlxContext: refreshing context");
     glXMakeCurrent(m_dpy, None, NULL);
@@ -928,7 +928,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     }
 
     CDirtyRegionList dr;
-    RefreshGlxContext();
+    RefreshGlxContext(!m_currentOutput.Equals(output));
     XSync(m_dpy, FALSE);
     g_graphicsContext.Clear(0);
     g_graphicsContext.Flip(dr);
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index f479c27..7345c06 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -74,7 +74,7 @@ class CWinSystemX11 : public CWinSystemBase
   void NotifyMouseCoverage(bool covered);
 
 protected:
-  bool RefreshGlxContext();
+  bool RefreshGlxContext(bool force);
   void CheckDisplayEvents();
   void OnLostDevice();
   bool SetWindow(int width, int height, bool fullscreen, const CStdString &output);
-- 
1.8.1.6


From 76daa1b4fa31511125dc2d3532fc510fcd6a1697 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Fri, 14 Dec 2012 14:19:15 +0100
Subject: [PATCH 096/123] pvr: do not show selection dialog for a single menu
 hook

---
 xbmc/pvr/addons/PVRClients.cpp | 19 +++++++++++--------
 1 file changed, 11 insertions(+), 8 deletions(-)

diff --git a/xbmc/pvr/addons/PVRClients.cpp b/xbmc/pvr/addons/PVRClients.cpp
index 2b43bcb..d07f23d 100644
--- a/xbmc/pvr/addons/PVRClients.cpp
+++ b/xbmc/pvr/addons/PVRClients.cpp
@@ -728,16 +728,19 @@ void CPVRClients::ProcessMenuHooks(int iClientID, PVR_MENUHOOK_CAT cat, const CF
   if (GetConnectedClient(iClientID, client) && client->HaveMenuHooks(cat))
   {
     hooks = client->GetMenuHooks();
-    std::vector<int> hookIDs;
+    int selection = 0;
 
-    CGUIDialogSelect* pDialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
-    pDialog->Reset();
-    pDialog->SetHeading(19196);
-    for (unsigned int i = 0; i < hooks->size(); i++)
-      pDialog->Add(client->GetString(hooks->at(i).iLocalizedStringId));
-    pDialog->DoModal();
+    if (hooks->size() > 1)
+    {
+      CGUIDialogSelect* pDialog = (CGUIDialogSelect*)g_windowManager.GetWindow(WINDOW_DIALOG_SELECT);
+      pDialog->Reset();
+      pDialog->SetHeading(19196);
+      for (unsigned int i = 0; i < hooks->size(); i++)
+        pDialog->Add(client->GetString(hooks->at(i).iLocalizedStringId));
+      pDialog->DoModal();
+      selection = pDialog->GetSelectedLabel();
+    }
 
-    int selection = pDialog->GetSelectedLabel();
     if (selection >= 0)
       client->CallMenuHook(hooks->at(selection), item);
   }
-- 
1.8.1.6


From 79107721f0b07baa19fcc25931de6fc5d6c0fecf Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 3 Feb 2013 08:17:16 +0100
Subject: [PATCH 097/123] X11: use default screen parameters if no output
 connected

---
 xbmc/windowing/X11/WinSystemX11.cpp | 55 ++++++++++++++++++++++---------------
 1 file changed, 33 insertions(+), 22 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index d865cd7..97975dd 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -205,25 +205,27 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
   }
  
   XMode   currmode = g_xrandr.GetCurrentMode(out.name);
-
-  // flip h/w when rotated
-  if (m_bIsRotated)
+  if (!currmode.name.empty())
   {
-    int w = mode.w;
-    mode.w = mode.h;
-    mode.h = w;
-  }
+    // flip h/w when rotated
+    if (m_bIsRotated)
+    {
+      int w = mode.w;
+      mode.w = mode.h;
+      mode.h = w;
+    }
 
-  // only call xrandr if mode changes
-  if (currmode.w != mode.w || currmode.h != mode.h ||
-      currmode.hz != mode.hz || currmode.id != mode.id)
-  {
-    CLog::Log(LOGNOTICE, "CWinSystemX11::SetFullScreen - calling xrandr");
-    OnLostDevice();
-    m_bIsInternalXrr = true;
-    g_xrandr.SetMode(out, mode);
-    if (m_glWindow)
-      return true;
+    // only call xrandr if mode changes
+    if (currmode.w != mode.w || currmode.h != mode.h ||
+        currmode.hz != mode.hz || currmode.id != mode.id)
+    {
+      CLog::Log(LOGNOTICE, "CWinSystemX11::SetFullScreen - calling xrandr");
+      OnLostDevice();
+      m_bIsInternalXrr = true;
+      g_xrandr.SetMode(out, mode);
+      if (m_glWindow)
+        return true;
+    }
   }
 #endif
 
@@ -270,9 +272,10 @@ void CWinSystemX11::UpdateResolutions()
   else
 #endif
   {
-    int x11screen = m_nScreen;
-    int w = DisplayWidth(m_dpy, x11screen);
-    int h = DisplayHeight(m_dpy, x11screen);
+    CSettings::Get().SetString("videoscreen.monitor", "Default");
+    m_nScreen = DefaultScreen(m_dpy);
+    int w = DisplayWidth(m_dpy, m_nScreen);
+    int h = DisplayHeight(m_dpy, m_nScreen);
     UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, w, h, 0.0);
   }
 
@@ -817,11 +820,19 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     Colormap cmap;
     XSetWindowAttributes swa;
     XVisualInfo *vi;
+    int x0 = 0;
+    int y0 = 0;
 
     XOutput *out = g_xrandr.GetOutput(output);
     if (!out)
       out = g_xrandr.GetOutput(m_currentOutput);
-    m_nScreen = out->screen;
+    if (out)
+    {
+      m_nScreen = out->screen;
+      x0 = out->x;
+      y0 = out->y;
+    }
+
     vi = glXChooseVisual(m_dpy, m_nScreen, att);
     cmap = XCreateColormap(m_dpy, RootWindow(m_dpy, vi->screen), vi->visual, AllocNone);
 
@@ -840,7 +851,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     unsigned long mask = CWBackPixel | CWBorderPixel | CWColormap | CWOverrideRedirect | CWEventMask;
 
     m_glWindow = XCreateWindow(m_dpy, RootWindow(m_dpy, vi->screen),
-                    out->x, out->y, width, height, 0, vi->depth,
+                    x0, y0, width, height, 0, vi->depth,
                     InputOutput, vi->visual,
                     mask, &swa);
 
-- 
1.8.1.6


From a8e44a830153163fd330b0ceb4dcb5b9554c5a73 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sat, 23 Mar 2013 15:13:32 +0100
Subject: [PATCH 098/123] X11: create parent window

---
 xbmc/windowing/X11/WinSystemX11.cpp | 69 +++++++++++++++++++++++--------------
 xbmc/windowing/X11/WinSystemX11.h   |  2 +-
 2 files changed, 44 insertions(+), 27 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 97975dd..0a3efff 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -53,6 +53,7 @@
   m_glContext = NULL;
   m_dpy = NULL;
   m_glWindow = 0;
+  m_mainWindow = 0;
   m_bWasFullScreenBeforeMinimize = false;
   m_minimized = false;
   m_bIgnoreNextFocusMessage = false;
@@ -130,7 +131,7 @@ bool CWinSystemX11::CreateNewWindow(const CStdString& name, bool fullScreen, RES
 
 bool CWinSystemX11::DestroyWindow()
 {
-  if (!m_glWindow)
+  if (!m_mainWindow)
     return true;
 
   if (m_glContext)
@@ -141,19 +142,21 @@ bool CWinSystemX11::DestroyWindow()
 
   if (m_invisibleCursor)
   {
-    XUndefineCursor(m_dpy, m_glWindow);
+    XUndefineCursor(m_dpy, m_mainWindow);
     XFreeCursor(m_dpy, m_invisibleCursor);
     m_invisibleCursor = 0;
   }
 
   CWinEvents::Quit();
 
-  XUnmapWindow(m_dpy, m_glWindow);
+  XUnmapWindow(m_dpy, m_mainWindow);
   XSync(m_dpy,TRUE);
   XUngrabKeyboard(m_dpy, CurrentTime);
   XUngrabPointer(m_dpy, CurrentTime);
   XDestroyWindow(m_dpy, m_glWindow);
+  XDestroyWindow(m_dpy, m_mainWindow);
   m_glWindow = 0;
+  m_mainWindow = 0;
 
   if (m_icon)
     XFreePixmap(m_dpy, m_icon);
@@ -223,7 +226,7 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
       OnLostDevice();
       m_bIsInternalXrr = true;
       g_xrandr.SetMode(out, mode);
-      if (m_glWindow)
+      if (m_mainWindow)
         return true;
     }
   }
@@ -501,9 +504,9 @@ bool CWinSystemX11::RefreshGlxContext(bool force)
 void CWinSystemX11::ShowOSMouse(bool show)
 {
   if (show)
-    XUndefineCursor(m_dpy,m_glWindow);
+    XUndefineCursor(m_dpy,m_mainWindow);
   else if (m_invisibleCursor)
-    XDefineCursor(m_dpy,m_glWindow, m_invisibleCursor);
+    XDefineCursor(m_dpy,m_mainWindow, m_invisibleCursor);
 }
 
 void CWinSystemX11::ResetOSScreensaver()
@@ -586,10 +589,10 @@ void CWinSystemX11::NotifyMouseCoverage(bool covered)
     int result = -1;
     while (result != GrabSuccess && result != AlreadyGrabbed)
     {
-      result = XGrabPointer(m_dpy, m_glWindow, True, ButtonPressMask, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);
+      result = XGrabPointer(m_dpy, m_mainWindow, True, ButtonPressMask, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);
       XbmcThreads::ThreadSleep(100);
     }
-    XGrabKeyboard(m_dpy, m_glWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
+    XGrabKeyboard(m_dpy, m_mainWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
   }
   else
   {
@@ -607,7 +610,7 @@ bool CWinSystemX11::Minimize()
     g_graphicsContext.ToggleFullScreenRoot();
   }
 
-  XIconifyWindow(m_dpy, m_glWindow, m_nScreen);
+  XIconifyWindow(m_dpy, m_mainWindow, m_nScreen);
 
   m_minimized = true;
   return true;
@@ -618,13 +621,13 @@ bool CWinSystemX11::Restore()
 }
 bool CWinSystemX11::Hide()
 {
-  XUnmapWindow(m_dpy, m_glWindow);
+  XUnmapWindow(m_dpy, m_mainWindow);
   XSync(m_dpy, False);
   return true;
 }
 bool CWinSystemX11::Show(bool raise)
 {
-  XMapWindow(m_dpy, m_glWindow);
+  XMapWindow(m_dpy, m_mainWindow);
   XSync(m_dpy, False);
   m_minimized = false;
   return true;
@@ -774,7 +777,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
   bool mouseActive = false;
   float mouseX, mouseY;
 
-  if (m_glWindow && ((m_bFullScreen != fullscreen) || !m_currentOutput.Equals(output) || m_windowDirty))
+  if (m_mainWindow && ((m_bFullScreen != fullscreen) || !m_currentOutput.Equals(output) || m_windowDirty))
   {
     mouseActive = g_Mouse.IsActive();
     if (mouseActive)
@@ -783,7 +786,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
       int root_x_return, root_y_return;
       int win_x_return, win_y_return;
       unsigned int mask_return;
-      bool isInWin = XQueryPointer(m_dpy, m_glWindow, &root_return, &child_return,
+      bool isInWin = XQueryPointer(m_dpy, m_mainWindow, &root_return, &child_return,
                                    &root_x_return, &root_y_return,
                                    &win_x_return, &win_y_return,
                                    &mask_return);
@@ -802,7 +805,7 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
   }
 
   // create main window
-  if (!m_glWindow)
+  if (!m_mainWindow)
   {
     EnableSystemScreenSaver(false);
 
@@ -843,22 +846,31 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     swa.border_pixel = fullscreen ? 0 : 5;
     swa.background_pixel = def_vis ? BlackPixel(m_dpy, vi->screen) : 0;
     swa.colormap = cmap;
-    swa.background_pixel = def_vis ? BlackPixel(m_dpy, vi->screen) : 0;
     swa.event_mask = FocusChangeMask | KeyPressMask | KeyReleaseMask |
                      ButtonPressMask | ButtonReleaseMask | PointerMotionMask |
                      PropertyChangeMask | StructureNotifyMask | KeymapStateMask |
                      EnterWindowMask | LeaveWindowMask | ExposureMask;
     unsigned long mask = CWBackPixel | CWBorderPixel | CWColormap | CWOverrideRedirect | CWEventMask;
 
-    m_glWindow = XCreateWindow(m_dpy, RootWindow(m_dpy, vi->screen),
+    m_mainWindow = XCreateWindow(m_dpy, RootWindow(m_dpy, vi->screen),
                     x0, y0, width, height, 0, vi->depth,
                     InputOutput, vi->visual,
                     mask, &swa);
 
+    swa.override_redirect = False;
+    swa.border_pixel = 0;
+    swa.event_mask = 0;
+    mask = CWBackPixel | CWBorderPixel | CWColormap | CWOverrideRedirect | CWColormap;
+
+    m_glWindow = XCreateWindow(m_dpy, m_mainWindow,
+                    0, 0, width, height, 0, vi->depth,
+                    InputOutput, vi->visual,
+                    mask, &swa);
+
     if (fullscreen && hasWM)
     {
       Atom fs = XInternAtom(m_dpy, "_NET_WM_STATE_FULLSCREEN", True);
-      XChangeProperty(m_dpy, m_glWindow, XInternAtom(m_dpy, "_NET_WM_STATE", True), XA_ATOM, 32, PropModeReplace, (unsigned char *) &fs, 1);
+      XChangeProperty(m_dpy, m_mainWindow, XInternAtom(m_dpy, "_NET_WM_STATE", True), XA_ATOM, 32, PropModeReplace, (unsigned char *) &fs, 1);
     }
 
     // define invisible cursor
@@ -867,14 +879,14 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     static char noData[] = { 0,0,0,0,0,0,0,0 };
     black.red = black.green = black.blue = 0;
 
-    bitmapNoData = XCreateBitmapFromData(m_dpy, m_glWindow, noData, 8, 8);
+    bitmapNoData = XCreateBitmapFromData(m_dpy, m_mainWindow, noData, 8, 8);
     m_invisibleCursor = XCreatePixmapCursor(m_dpy, bitmapNoData, bitmapNoData,
                                             &black, &black, 0, 0);
     XFreePixmap(m_dpy, bitmapNoData);
-    XDefineCursor(m_dpy,m_glWindow, m_invisibleCursor);
+    XDefineCursor(m_dpy,m_mainWindow, m_invisibleCursor);
 
     //init X11 events
-    CWinEvents::Init(m_dpy, m_glWindow);
+    CWinEvents::Init(m_dpy, m_mainWindow);
 
     changeWindow = true;
     changeSize = true;
@@ -887,13 +899,17 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
 
   if (changeSize || changeWindow)
   {
+    XResizeWindow(m_dpy, m_mainWindow, width, height);
+  }
+
+  if ((width != m_nWidth) || (height != m_nHeight) || changeWindow)
+  {
     XResizeWindow(m_dpy, m_glWindow, width, height);
   }
 
   if (changeWindow)
   {
     m_icon = None;
-    if (!fullscreen)
     {
       CreateIconPixmap();
       XWMHints *wm_hints;
@@ -910,21 +926,22 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
       wm_hints->flags = StateHint | IconPixmapHint;
 
       XSync(m_dpy,False);
-      XSetWMProperties(m_dpy, m_glWindow, &windowName, &iconName,
+      XSetWMProperties(m_dpy, m_mainWindow, &windowName, &iconName,
                             NULL, 0, NULL, wm_hints,
                             NULL);
       XFree(wm_hints);
 
       // register interest in the delete window message
       Atom wmDeleteMessage = XInternAtom(m_dpy, "WM_DELETE_WINDOW", False);
-      XSetWMProtocols(m_dpy, m_glWindow, &wmDeleteMessage, 1);
+      XSetWMProtocols(m_dpy, m_mainWindow, &wmDeleteMessage, 1);
     }
     XMapRaised(m_dpy, m_glWindow);
+    XMapRaised(m_dpy, m_mainWindow);
     XSync(m_dpy,TRUE);
 
     if (changeWindow && mouseActive)
     {
-      XWarpPointer(m_dpy, None, m_glWindow, 0, 0, 0, 0, mouseX*width, mouseY*height);
+      XWarpPointer(m_dpy, None, m_mainWindow, 0, 0, 0, 0, mouseX*width, mouseY*height);
     }
 
     if (fullscreen)
@@ -932,10 +949,10 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
       int result = -1;
       while (result != GrabSuccess && result != AlreadyGrabbed)
       {
-        result = XGrabPointer(m_dpy, m_glWindow, True, ButtonPressMask, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);
+        result = XGrabPointer(m_dpy, m_mainWindow, True, ButtonPressMask, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);
         XbmcThreads::ThreadSleep(100);
       }
-      XGrabKeyboard(m_dpy, m_glWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
+      XGrabKeyboard(m_dpy, m_mainWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
     }
 
     CDirtyRegionList dr;
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 7345c06..770ae84 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -79,7 +79,7 @@ class CWinSystemX11 : public CWinSystemBase
   void OnLostDevice();
   bool SetWindow(int width, int height, bool fullscreen, const CStdString &output);
 
-  Window       m_glWindow;
+  Window       m_glWindow, m_mainWindow;
   GLXContext   m_glContext;
   Display*     m_dpy;
   Cursor       m_invisibleCursor;
-- 
1.8.1.6


From 106ab1d2c77591f37d915727cf0f3ab8c876b523 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 24 Mar 2013 12:30:12 +0100
Subject: [PATCH 099/123] X11: use system key repeat rate instead of hardcoded
 one, taken from 58fd64b194e38b73b5f3132744bab35e994e7441

---
 xbmc/windowing/WinEventsX11.cpp | 58 +++++++++++++----------------------------
 xbmc/windowing/WinEventsX11.h   |  5 +---
 2 files changed, 19 insertions(+), 44 deletions(-)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index da5d412..9caeabf 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -204,7 +204,6 @@ bool CWinEventsX11::Init(Display *dpy, Window win)
   WinEvents->m_wmDeleteMessage = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
   WinEvents->m_structureChanged = false;
   WinEvents->m_xrrEventPending = false;
-  memset(&(WinEvents->m_lastKey), 0, sizeof(XBMC_Event));
 
   // open input method
   char *old_locale = NULL, *old_modifiers = NULL;
@@ -319,20 +318,6 @@ bool CWinEventsX11::MessagePump()
     memset(&xevent, 0, sizeof (XEvent));
     XNextEvent(WinEvents->m_display, &xevent);
 
-    //  ignore events generated by auto-repeat
-    if (xevent.type == KeyRelease && XPending(WinEvents->m_display))
-    {
-      XEvent peekevent;
-      XPeekEvent(WinEvents->m_display, &peekevent);
-      if ((peekevent.type == KeyPress) &&
-          (peekevent.xkey.keycode == xevent.xkey.keycode) &&
-          ((peekevent.xkey.time - xevent.xkey.time) < 2))
-      {
-        XNextEvent(WinEvents->m_display, &peekevent);
-        continue;
-      }
-    }
-
     if (XFilterEvent(&xevent, None))
       continue;
 
@@ -355,7 +340,6 @@ bool CWinEventsX11::MessagePump()
         if (WinEvents->m_xic)
           XSetICFocus(WinEvents->m_xic);
         g_application.m_AppFocused = true;
-        memset(&(WinEvents->m_lastKey), 0, sizeof(XBMC_Event));
         WinEvents->m_keymodState = 0;
         if (serial == xevent.xfocus.serial)
           break;
@@ -368,7 +352,6 @@ bool CWinEventsX11::MessagePump()
         if (WinEvents->m_xic)
           XUnsetICFocus(WinEvents->m_xic);
         g_application.m_AppFocused = false;
-        memset(&(WinEvents->m_lastKey), 0, sizeof(XBMC_Event));
         g_Windowing.NotifyAppFocusChange(g_application.m_AppFocused);
         serial = xevent.xfocus.serial;
         break;
@@ -424,7 +407,7 @@ bool CWinEventsX11::MessagePump()
           {
             newEvent.key.keysym.unicode = keybuf[0];
           }
-          ret |= ProcessKey(newEvent, 500);
+          ret |= ProcessKey(newEvent);
           break;
         }
 
@@ -463,7 +446,7 @@ bool CWinEventsX11::MessagePump()
               newEvent.key.keysym.unicode = keys[i];
               newEvent.key.state = xevent.xkey.state;
               newEvent.key.type = xevent.xkey.type;
-              ret |= ProcessKey(newEvent, 500);
+              ret |= ProcessKey(newEvent);
             }
             if (keys.length() > 0)
             {
@@ -474,7 +457,7 @@ bool CWinEventsX11::MessagePump()
               newEvent.key.state = xevent.xkey.state;
               newEvent.key.type = xevent.xkey.type;
 
-              ret |= ProcessKey(newEvent, 500);
+              ret |= ProcessKey(newEvent);
             }
             break;
           }
@@ -485,7 +468,7 @@ bool CWinEventsX11::MessagePump()
             newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
             newEvent.key.state = xevent.xkey.state;
             newEvent.key.type = xevent.xkey.type;
-            ret |= ProcessKey(newEvent, 500);
+            ret |= ProcessKey(newEvent);
             break;
           }
 
@@ -495,6 +478,18 @@ bool CWinEventsX11::MessagePump()
 
       case KeyRelease:
       {
+        // if we have a queued press directly after, this is a repeat
+        if( XEventsQueued( WinEvents->m_display, QueuedAfterReading ) )
+        {
+          XEvent next_event;
+          XPeekEvent( WinEvents->m_display, &next_event );
+          if(next_event.type == KeyPress
+            && next_event.xkey.window == xevent.xkey.window
+            && next_event.xkey.keycode == xevent.xkey.keycode
+            && (next_event.xkey.time - xevent.xkey.time < 2) )
+            continue;
+        }
+
         XBMC_Event newEvent;
         KeySym xkeysym;
         memset(&newEvent, 0, sizeof(newEvent));
@@ -504,7 +499,7 @@ bool CWinEventsX11::MessagePump()
         newEvent.key.keysym.sym = LookupXbmcKeySym(xkeysym);
         newEvent.key.state = xevent.xkey.state;
         newEvent.key.type = xevent.xkey.type;
-        ret |= ProcessKey(newEvent, 0);
+        ret |= ProcessKey(newEvent);
         break;
       }
 
@@ -580,8 +575,6 @@ bool CWinEventsX11::MessagePump()
 
   }// while
 
-  ret |= ProcessKeyRepeat();
-
 #if defined(HAS_XRANDR)
   if (WinEvents && WinEvents->m_xrrEventPending && WinEvents->m_xrrFailSafeTimer.IsTimePast())
   {
@@ -616,7 +609,7 @@ bool CWinEventsX11::MessagePump()
   return ret;
 }
 
-bool CWinEventsX11::ProcessKey(XBMC_Event &event, int repeatDelay)
+bool CWinEventsX11::ProcessKey(XBMC_Event &event)
 {
   if (event.type == XBMC_KEYDOWN)
   {
@@ -654,8 +647,6 @@ bool CWinEventsX11::ProcessKey(XBMC_Event &event, int repeatDelay)
         break;
     }
     event.key.keysym.mod = (XBMCMod)WinEvents->m_keymodState;
-    memcpy(&(WinEvents->m_lastKey), &event, sizeof(event));
-    WinEvents->m_repeatKeyTimeout.Set(repeatDelay);
 
     bool ret = ProcessShortcuts(event);
     if (ret)
@@ -696,7 +687,6 @@ bool CWinEventsX11::ProcessKey(XBMC_Event &event, int repeatDelay)
         break;
     }
     event.key.keysym.mod = (XBMCMod)WinEvents->m_keymodState;
-    memset(&(WinEvents->m_lastKey), 0, sizeof(event));
   }
 
   return g_application.OnEvent(event);
@@ -719,18 +709,6 @@ bool CWinEventsX11::ProcessShortcuts(XBMC_Event& event)
   return false;
 }
 
-bool CWinEventsX11::ProcessKeyRepeat()
-{
-  if (WinEvents && (WinEvents->m_lastKey.type == XBMC_KEYDOWN))
-  {
-    if (WinEvents->m_repeatKeyTimeout.IsTimePast())
-    {
-      return ProcessKey(WinEvents->m_lastKey, 10);
-    }
-  }
-  return false;
-}
-
 XBMCKey CWinEventsX11::LookupXbmcKeySym(KeySym keysym)
 {
   // try direct mapping first
diff --git a/xbmc/windowing/WinEventsX11.h b/xbmc/windowing/WinEventsX11.h
index 102a076..5b1f3fa 100644
--- a/xbmc/windowing/WinEventsX11.h
+++ b/xbmc/windowing/WinEventsX11.h
@@ -39,8 +39,7 @@ class CWinEventsX11 : public CWinEventsBase
 
 protected:
   static XBMCKey LookupXbmcKeySym(KeySym keysym);
-  static bool ProcessKey(XBMC_Event &event, int repeatDelay);
-  static bool ProcessKeyRepeat();
+  static bool ProcessKey(XBMC_Event &event);
   static bool ProcessShortcuts(XBMC_Event& event);
   static CWinEventsX11 *WinEvents;
   Display *m_display;
@@ -50,8 +49,6 @@ class CWinEventsX11 : public CWinEventsBase
   size_t m_keybuf_len;
   XIM m_xim;
   XIC m_xic;
-  XBMC_Event m_lastKey;
-  XbmcThreads::EndTime m_repeatKeyTimeout;
   std::map<uint32_t,uint32_t> m_symLookupTable;
   int m_keymodState;
   bool m_structureChanged;
-- 
1.8.1.6


From a647eace0d91644e7216187dcb4608df7d2bfa69 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 24 Mar 2013 16:04:48 +0100
Subject: [PATCH 100/123] linux: use CLOCK_MONOTONIC_RAW as this is not subject
 to NTP

---
 xbmc/threads/SystemClock.cpp | 2 +-
 xbmc/utils/TimeUtils.cpp     | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/xbmc/threads/SystemClock.cpp b/xbmc/threads/SystemClock.cpp
index 5a1c3ea..6dea6bf 100644
--- a/xbmc/threads/SystemClock.cpp
+++ b/xbmc/threads/SystemClock.cpp
@@ -42,7 +42,7 @@
     now_time = (uint64_t)timeGetTime();
 #else
     struct timespec ts = {};
-    clock_gettime(CLOCK_MONOTONIC, &ts);
+    clock_gettime(CLOCK_MONOTONIC_RAW, &ts);
     now_time = (ts.tv_sec * 1000) + (ts.tv_nsec / 1000000);
 #endif
     if (!start_time_set)
diff --git a/xbmc/utils/TimeUtils.cpp b/xbmc/utils/TimeUtils.cpp
index 8304ef6..ba27257 100644
--- a/xbmc/utils/TimeUtils.cpp
+++ b/xbmc/utils/TimeUtils.cpp
@@ -43,7 +43,7 @@ int64_t CurrentHostCounter(void)
   return( (int64_t)PerformanceCount.QuadPart );
 #else
   struct timespec now;
-  clock_gettime(CLOCK_MONOTONIC, &now);
+  clock_gettime(CLOCK_MONOTONIC_RAW, &now);
   return( ((int64_t)now.tv_sec * 1000000000L) + now.tv_nsec );
 #endif
 }
-- 
1.8.1.6


From 2cef9ccf704ba1e9144a318044e4cd622a2a4fde Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 28 Mar 2013 15:18:53 +0100
Subject: [PATCH 101/123] OMXPlayer: some caching fixes for pvr

---
 xbmc/cores/omxplayer/OMXPlayer.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/omxplayer/OMXPlayer.cpp b/xbmc/cores/omxplayer/OMXPlayer.cpp
index f20c399..c096f32 100644
--- a/xbmc/cores/omxplayer/OMXPlayer.cpp
+++ b/xbmc/cores/omxplayer/OMXPlayer.cpp
@@ -2459,7 +2459,8 @@ void COMXPlayer::HandleMessages()
           m_messenger.Put(new CDVDMsgPlayerSeek(DVD_TIME_TO_MSEC(m_clock.GetClock()), (speed < 0), true, false, false, true));
 
         m_playSpeed = speed;
-        m_caching = CACHESTATE_DONE;
+        if (m_caching != CACHESTATE_PVR && m_playSpeed != DVD_PLAYSPEED_NORMAL)
+          m_caching = CACHESTATE_DONE;
         m_clock.SetSpeed(speed);
         m_av_clock.OMXSetSpeed(speed);
         m_av_clock.OMXPause();
-- 
1.8.1.6


From 4ed5d6875bd066d4d1ab8518facd02ecb166829c Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 28 Mar 2013 20:50:59 +0100
Subject: [PATCH 102/123] fix incorrect display of fps when dr kicks in

---
 xbmc/Application.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/xbmc/Application.cpp b/xbmc/Application.cpp
index a5603a2..ce0a147 100644
--- a/xbmc/Application.cpp
+++ b/xbmc/Application.cpp
@@ -2142,10 +2142,11 @@ void CApplication::Render()
     if (frameTime < singleFrameTime)
       Sleep(singleFrameTime - frameTime);
   }
-  m_lastFrameTime = XbmcThreads::SystemClockMillis();
 
   if (flip)
     g_graphicsContext.Flip(dirtyRegions);
+
+  m_lastFrameTime = XbmcThreads::SystemClockMillis();
   CTimeUtils::UpdateFrameTime(flip);
 
   g_renderManager.UpdateResolution();
-- 
1.8.1.6


From 9d33e9711b3ff21d18832c2db087e6d5cd04f3c4 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Mon, 8 Apr 2013 11:18:31 +0200
Subject: [PATCH 103/123] squash to dropping control

---
 xbmc/cores/dvdplayer/DVDPlayerVideo.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
index 11e0b26..3f915ce 100644
--- a/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
+++ b/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
@@ -39,6 +39,7 @@
 #include "DVDCodecs/DVDCodecs.h"
 #include "DVDCodecs/Overlay/DVDOverlayCodecCC.h"
 #include "DVDCodecs/Overlay/DVDOverlaySSA.h"
+#include "guilib/GraphicContext.h"
 #include <sstream>
 #include <iomanip>
 #include <numeric>
-- 
1.8.1.6


From 9fa7033fc9da50c54ad133e7ea016eaab89967c9 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Thu, 11 Apr 2013 12:33:46 +0200
Subject: [PATCH 104/123] pvr: try SwtichChannel when selecting a channel via
 EPG

---
 xbmc/pvr/windows/GUIWindowPVRGuide.cpp | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/xbmc/pvr/windows/GUIWindowPVRGuide.cpp b/xbmc/pvr/windows/GUIWindowPVRGuide.cpp
index 6b999e4..256a295 100644
--- a/xbmc/pvr/windows/GUIWindowPVRGuide.cpp
+++ b/xbmc/pvr/windows/GUIWindowPVRGuide.cpp
@@ -427,15 +427,16 @@ bool CGUIWindowPVRGuide::PlayEpgItem(CFileItem *item)
     return false;
 
   CLog::Log(LOGDEBUG, "play channel '%s'", channel->ChannelName().c_str());
-  PlayBackRet ret = g_application.PlayFile(CFileItem(*channel));
-  if (ret == PLAYBACK_FAIL)
+  CFileItem channelItem = CFileItem(*channel);
+  bool bReturn = PlayFile(&channelItem);
+  if (!bReturn)
   {
     CStdString msg;
     msg.Format(g_localizeStrings.Get(19035).c_str(), channel->ChannelName().c_str()); // CHANNELNAME could not be played. Check the log for details.
     CGUIDialogOK::ShowAndGetInput(19033, 0, msg, 0);
   }
 
-  return ret == PLAYBACK_OK;
+  return bReturn;
 }
 
 bool CGUIWindowPVRGuide::OnContextButtonPlay(CFileItem *item, CONTEXT_BUTTON button)
-- 
1.8.1.6


From b807258fddaca8f65a6552633ada3e75412271d4 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sat, 13 Apr 2013 08:32:06 +0200
Subject: [PATCH 105/123] X11: fix mouse coverage

---
 xbmc/windowing/X11/WinSystemX11.cpp | 11 ++++++++---
 xbmc/windowing/X11/WinSystemX11.h   |  1 +
 2 files changed, 9 insertions(+), 3 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 0a3efff..bf95bc7 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -581,10 +581,10 @@ void CWinSystemX11::NotifyAppFocusChange(bool bGaining)
 
 void CWinSystemX11::NotifyMouseCoverage(bool covered)
 {
-  if (!m_bFullScreen)
+  if (!m_bFullScreen || !m_mainWindow)
     return;
 
-  if (covered)
+  if (covered && !m_bIsGrabbed)
   {
     int result = -1;
     while (result != GrabSuccess && result != AlreadyGrabbed)
@@ -593,11 +593,13 @@ void CWinSystemX11::NotifyMouseCoverage(bool covered)
       XbmcThreads::ThreadSleep(100);
     }
     XGrabKeyboard(m_dpy, m_mainWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
+    m_bIsGrabbed = true;
   }
-  else
+  else if (!covered && m_bIsGrabbed)
   {
     XUngrabKeyboard(m_dpy, CurrentTime);
     XUngrabPointer(m_dpy, CurrentTime);
+    m_bIsGrabbed = false;
   }
 }
 
@@ -953,7 +955,10 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
         XbmcThreads::ThreadSleep(100);
       }
       XGrabKeyboard(m_dpy, m_mainWindow, True, GrabModeAsync, GrabModeAsync, CurrentTime);
+      m_bIsGrabbed = true;
     }
+    else
+      m_bIsGrabbed = false;
 
     CDirtyRegionList dr;
     RefreshGlxContext(!m_currentOutput.Equals(output));
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 770ae84..084f546 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -88,6 +88,7 @@ class CWinSystemX11 : public CWinSystemBase
   bool         m_bWasFullScreenBeforeMinimize;
   bool         m_minimized;
   bool         m_bIgnoreNextFocusMessage;
+  bool         m_bIsGrabbed;
   int          m_RREventBase;
   CCriticalSection             m_resourceSection;
   std::vector<IDispResource*>  m_resources;
-- 
1.8.1.6


From 59d09d7e25cc8654a1d89d4e1f55596c8ad3cd16 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Wed, 8 May 2013 13:14:58 +0200
Subject: [PATCH 106/123] X11: fix incorrectly used screen num in desktop
 resolution

---
 xbmc/windowing/X11/WinSystemX11.cpp | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index bf95bc7..0221036 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -266,9 +266,9 @@ void CWinSystemX11::UpdateResolutions()
     XMode mode = g_xrandr.GetCurrentMode(currentMonitor);
     m_bIsRotated = out->isRotated;
     if (!m_bIsRotated)
-      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), out->screen, mode.w, mode.h, mode.hz);
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
     else
-      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), out->screen, mode.h, mode.w, mode.hz);
+      UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.h, mode.w, mode.hz);
     CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId     = mode.id;
     CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = currentMonitor;
   }
@@ -303,6 +303,7 @@ void CWinSystemX11::UpdateResolutions()
       CLog::Log(LOGINFO, "ID:%s Name:%s Refresh:%f Width:%d Height:%d",
                 mode.id.c_str(), mode.name.c_str(), mode.hz, mode.w, mode.h);
       RESOLUTION_INFO res;
+      res.iScreen = 0; // not used by X11
       res.iWidth  = mode.w;
       res.iHeight = mode.h;
       res.iScreenWidth  = mode.w;
-- 
1.8.1.6


From f2fecf3c39f9939bd4504f1148a8d93b9e67eabe Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 9 May 2013 12:07:09 +0200
Subject: [PATCH 107/123] X11: do not overwrite user selected monitor with
 fallback

---
 xbmc/windowing/X11/WinSystemX11.cpp | 31 ++++++++++++++-----------------
 xbmc/windowing/X11/WinSystemX11.h   |  1 +
 2 files changed, 15 insertions(+), 17 deletions(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 0221036..e768c44 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -170,7 +170,7 @@ bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int n
   && m_nHeight == newHeight)
     return true;
 
-  if (!SetWindow(newWidth, newHeight, false, CSettings::Get().GetString("videoscreen.monitor")))
+  if (!SetWindow(newWidth, newHeight, false, m_userOutput))
   {
     return false;
   }
@@ -178,7 +178,7 @@ bool CWinSystemX11::ResizeWindow(int newWidth, int newHeight, int newLeft, int n
   m_nWidth  = newWidth;
   m_nHeight = newHeight;
   m_bFullScreen = false;
-  m_currentOutput = CSettings::Get().GetString("videoscreen.monitor");
+  m_currentOutput = m_userOutput;
 
   return false;
 }
@@ -232,13 +232,13 @@ bool CWinSystemX11::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool bl
   }
 #endif
 
-  if (!SetWindow(res.iWidth, res.iHeight, fullScreen, CSettings::Get().GetString("videoscreen.monitor")))
+  if (!SetWindow(res.iWidth, res.iHeight, fullScreen, m_userOutput))
     return false;
 
   m_nWidth      = res.iWidth;
   m_nHeight     = res.iHeight;
   m_bFullScreen = fullScreen;
-  m_currentOutput = CSettings::Get().GetString("videoscreen.monitor");
+  m_currentOutput = m_userOutput;
 
   return true;
 }
@@ -248,34 +248,32 @@ void CWinSystemX11::UpdateResolutions()
   CWinSystemBase::UpdateResolutions();
 
 #if defined(HAS_XRANDR)
-  CStdString currentMonitor;
   int numScreens = XScreenCount(m_dpy);
   g_xrandr.SetNumScreens(numScreens);
   if(g_xrandr.Query(true))
   {
-    currentMonitor = CSettings::Get().GetString("videoscreen.monitor");
+    m_userOutput = CSettings::Get().GetString("videoscreen.monitor");
     // check if the monitor is connected
-    XOutput *out = g_xrandr.GetOutput(currentMonitor);
+    XOutput *out = g_xrandr.GetOutput(m_userOutput);
     if (!out)
     {
       // choose first output
-      currentMonitor = g_xrandr.GetModes()[0].name;
-      out = g_xrandr.GetOutput(currentMonitor);
-      CSettings::Get().SetString("videoscreen.monitor", currentMonitor);
+      m_userOutput = g_xrandr.GetModes()[0].name;
+      out = g_xrandr.GetOutput(m_userOutput);
     }
-    XMode mode = g_xrandr.GetCurrentMode(currentMonitor);
+    XMode mode = g_xrandr.GetCurrentMode(m_userOutput);
     m_bIsRotated = out->isRotated;
     if (!m_bIsRotated)
       UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
     else
       UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.h, mode.w, mode.hz);
     CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strId     = mode.id;
-    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = currentMonitor;
+    CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP).strOutput = m_userOutput;
   }
   else
 #endif
   {
-    CSettings::Get().SetString("videoscreen.monitor", "Default");
+    m_userOutput = "No Output";
     m_nScreen = DefaultScreen(m_dpy);
     int w = DisplayWidth(m_dpy, m_nScreen);
     int h = DisplayHeight(m_dpy, m_nScreen);
@@ -289,7 +287,7 @@ void CWinSystemX11::UpdateResolutions()
 
   CLog::Log(LOGINFO, "Available videomodes (xrandr):");
 
-  XOutput *out = g_xrandr.GetOutput(currentMonitor);
+  XOutput *out = g_xrandr.GetOutput(m_userOutput);
   string modename = "";
 
   if (out != NULL)
@@ -689,9 +687,8 @@ void CWinSystemX11::NotifyXRREvent()
   }
   m_bIsInternalXrr = false;
 
-  CStdString currentOutput = CSettings::Get().GetString("videoscreen.monitor");
-  XOutput *out = g_xrandr.GetOutput(currentOutput);
-  XMode   mode = g_xrandr.GetCurrentMode(currentOutput);
+  XOutput *out = g_xrandr.GetOutput(m_userOutput);
+  XMode   mode = g_xrandr.GetCurrentMode(m_userOutput);
 
   if (out)
     CLog::Log(LOGDEBUG, "%s - current output: %s, mode: %s, refresh: %.3f", __FUNCTION__
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 084f546..30f5fa0 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -94,6 +94,7 @@ class CWinSystemX11 : public CWinSystemBase
   std::vector<IDispResource*>  m_resources;
   uint64_t                     m_dpyLostTime;
   CStdString                   m_currentOutput;
+  CStdString                   m_userOutput;
   bool                         m_windowDirty;
   bool                         m_bIsInternalXrr;
   bool                         m_newGlContext;
-- 
1.8.1.6


From 80fa9e33ccd53aa00bae4c6750cb91483eab4a70 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 12 May 2013 10:50:30 +0200
Subject: [PATCH 108/123] xrandr: add turn on/off to wrapper

---
 xbmc/windowing/X11/XRandR.cpp | 78 +++++++++++++++++++++++++++++++++++++++----
 xbmc/windowing/X11/XRandR.h   |  6 ++--
 2 files changed, 75 insertions(+), 9 deletions(-)

diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index e6d6240..b76c4f6 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -28,6 +28,7 @@
 #include "PlatformInclude.h"
 #include "utils/XBMCTinyXML.h"
 #include "../xbmc/utils/log.h"
+#include "threads/SystemClock.h"
 
 #if defined(TARGET_FREEBSD)
 #include <sys/types.h>
@@ -44,7 +45,7 @@
     Query();
 }
 
-bool CXRandR::Query(bool force)
+bool CXRandR::Query(bool force, bool ignoreoff)
 {
   if (!force)
     if (m_bInit)
@@ -61,13 +62,13 @@ bool CXRandR::Query(bool force)
   bool success = false;
   for(unsigned int screennum=0; screennum<m_numScreens; ++screennum)
   {
-    if(Query(force, screennum))
+    if(Query(force, screennum, ignoreoff))
       success = true;
   }
   return success;
 }
 
-bool CXRandR::Query(bool force, int screennum)
+bool CXRandR::Query(bool force, int screennum, bool ignoreoff)
 {
   CStdString cmd;
   cmd  = getenv("XBMC_BIN_HOME");
@@ -136,11 +137,9 @@ bool CXRandR::Query(bool force, int screennum)
       xmode.isCurrent = (strcasecmp(mode->Attribute("current"), "true") == 0);
       xoutput.modes.push_back(xmode);
       if (xmode.isCurrent)
-      {
         hascurrent = true;
-      }
     }
-    if (hascurrent)
+    if (hascurrent || !ignoreoff)
       m_outputs.push_back(xoutput);
     else
       CLog::Log(LOGWARNING, "CXRandR::Query - output %s has no current mode, assuming disconnected", xoutput.name.c_str());
@@ -148,6 +147,71 @@ bool CXRandR::Query(bool force, int screennum)
   return m_outputs.size() > 0;
 }
 
+bool CXRandR::TurnOffOutput(CStdString name)
+{
+  CStdString cmd;
+  cmd  = getenv("XBMC_BIN_HOME");
+  cmd += "/xbmc-xrandr";
+  cmd.AppendFormat(" --output %s --off", name.c_str());
+
+  int status = system(cmd.c_str());
+  if (status == -1)
+    return false;
+
+  if (WEXITSTATUS(status) != 0)
+    return false;
+
+  return true;
+}
+
+bool CXRandR::TurnOnOutput(CStdString name)
+{
+  XOutput *output = GetOutput(name);
+  if (!output)
+    return false;
+
+  XMode mode = GetCurrentMode(output->name);
+  if (mode.isCurrent)
+    return true;
+
+  // get preferred mode
+  for (unsigned int j = 0; j < m_outputs.size(); j++)
+  {
+    if (m_outputs[j].name == output->name)
+    {
+      for (unsigned int i = 0; i < m_outputs[j].modes.size(); i++)
+      {
+        if (m_outputs[j].modes[i].isPreferred)
+        {
+          mode = m_outputs[j].modes[i];
+          break;
+        }
+      }
+    }
+  }
+
+  if (!mode.isPreferred)
+    return false;
+
+  if (!SetMode(*output, mode))
+    return false;
+
+  XbmcThreads::EndTime timeout(5000);
+  while (!timeout.IsTimePast())
+  {
+    if (!Query(true))
+      return false;
+
+    output = GetOutput(name);
+    if (output && output->h > 0)
+      return true;
+
+    Sleep(200);
+  }
+
+  return false;
+}
+
 std::vector<XOutput> CXRandR::GetModes(void)
 {
   Query();
@@ -161,7 +225,7 @@ void CXRandR::SaveState()
 
 bool CXRandR::SetMode(XOutput output, XMode mode)
 {
-  if ((output.name == m_currentOutput && mode.id == m_currentMode) || (output.name == "" && mode.id == ""))
+  if ((output.name == "" && mode.id == ""))
     return true;
 
   Query();
diff --git a/xbmc/windowing/X11/XRandR.h b/xbmc/windowing/X11/XRandR.h
index 26c2653..2741879 100644
--- a/xbmc/windowing/X11/XRandR.h
+++ b/xbmc/windowing/X11/XRandR.h
@@ -94,8 +94,8 @@ class CXRandR
 {
 public:
   CXRandR(bool query=false);
-  bool Query(bool force=false);
-  bool Query(bool force, int screennum);
+  bool Query(bool force=false, bool ignoreoff=true);
+  bool Query(bool force, int screennum, bool ignoreoff=true);
   std::vector<XOutput> GetModes(void);
   XMode   GetCurrentMode(CStdString outputName);
   XOutput *GetOutput(CStdString outputName);
@@ -104,6 +104,8 @@ class CXRandR
   void SaveState();
   void SetNumScreens(unsigned int num);
   bool IsOutputConnected(CStdString name);
+  bool TurnOffOutput(CStdString name);
+  bool TurnOnOutput(CStdString name);
   //bool Has1080i();
   //bool Has1080p();
   //bool Has720p();
-- 
1.8.1.6


From 658f7678d3c10cebffeafd04979a6f66929f0a43 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 19 May 2013 12:55:35 +0200
Subject: [PATCH 109/123] xrandr: add GetPreferredMode to wrapper

---
 xbmc/windowing/X11/XRandR.cpp | 23 +++++++++++++++++++++++
 xbmc/windowing/X11/XRandR.h   |  1 +
 2 files changed, 24 insertions(+)

diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index b76c4f6..380a194 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -347,6 +347,29 @@ XMode CXRandR::GetCurrentMode(CStdString outputName)
   return result;
 }
 
+XMode CXRandR::GetPreferredMode(CStdString outputName)
+{
+  Query();
+  XMode result;
+
+  for (unsigned int j = 0; j < m_outputs.size(); j++)
+  {
+    if (m_outputs[j].name == outputName || outputName == "")
+    {
+      for (unsigned int i = 0; i < m_outputs[j].modes.size(); i++)
+      {
+        if (m_outputs[j].modes[i].isPreferred)
+        {
+          result = m_outputs[j].modes[i];
+          break;
+        }
+      }
+    }
+  }
+
+  return result;
+}
+
 void CXRandR::LoadCustomModeLinesToAllOutputs(void)
 {
   Query();
diff --git a/xbmc/windowing/X11/XRandR.h b/xbmc/windowing/X11/XRandR.h
index 2741879..24ad1d0 100644
--- a/xbmc/windowing/X11/XRandR.h
+++ b/xbmc/windowing/X11/XRandR.h
@@ -98,6 +98,7 @@ class CXRandR
   bool Query(bool force, int screennum, bool ignoreoff=true);
   std::vector<XOutput> GetModes(void);
   XMode   GetCurrentMode(CStdString outputName);
+  XMode   GetPreferredMode(CStdString outputName);
   XOutput *GetOutput(CStdString outputName);
   bool SetMode(XOutput output, XMode mode);
   void LoadCustomModeLinesToAllOutputs(void);
-- 
1.8.1.6


From c2d9632a75a8f659f58bd0ad1367242639840b07 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 11 May 2013 17:12:12 +0200
Subject: [PATCH 110/123] X11: multi-head improvement - poll for desired output
 if we do not get an xrr event

---
 language/English/strings.po         |  9 +++-
 system/settings/settings.xml        |  6 +++
 xbmc/settings/DisplaySettings.cpp   |  4 ++
 xbmc/windowing/WinEventsX11.cpp     |  6 +++
 xbmc/windowing/WinEventsX11.h       |  1 +
 xbmc/windowing/X11/WinSystemX11.cpp | 83 +++++++++++++++++++++++++++++++++----
 xbmc/windowing/X11/WinSystemX11.h   |  2 +-
 xbmc/windowing/X11/XRandR.cpp       |  6 ++-
 8 files changed, 105 insertions(+), 12 deletions(-)

diff --git a/language/English/strings.po b/language/English/strings.po
index d603702..79a3996 100644
--- a/language/English/strings.po
+++ b/language/English/strings.po
@@ -6232,7 +6232,7 @@ msgctxt "#14071"
 msgid "Allow file renaming and deletion"
 msgstr ""
 
-#empty strings from id 14072 to 14073
+#empty strings from id 14073 to 14073
 
 msgctxt "#14074"
 msgid "Set timezone"
@@ -6364,7 +6364,12 @@ msgctxt "#14100"
 msgid "Stop ripping CD"
 msgstr ""
 
-#empty strings from id 14101 to 15014
+#: xbmc/settings/settings.xml
+msgctxt "#14101"
+msgid "Swtich off other Monitor"
+msgstr ""
+
+#empty strings from id 14102 to 15014
 
 #: xbmc/dialogs/GUIDialogFavourites.cpp
 msgctxt "#15015"
diff --git a/system/settings/settings.xml b/system/settings/settings.xml
index a863dae..1102691 100644
--- a/system/settings/settings.xml
+++ b/system/settings/settings.xml
@@ -1855,6 +1855,11 @@
           </constraints>
           <control type="spinner" format="string" delayed="true" />
         </setting>
+        <setting id="videoscreen.monitorsingle" type="boolean" label="14101" help="">
+          <visible>HAS_GLX</visible>
+          <level>0</level>
+          <default>false</default>
+        </setting>
         <setting id="videoscreen.screen" type="integer" label="240" help="36351">
           <level>0</level>
           <default>0</default>
@@ -1906,6 +1911,7 @@
           </dependencies>
         </setting>
         <setting id="videoscreen.blankdisplays" type="boolean" label="13130" help="36355">
+          <visible>!HAS_GLX</visible>
           <level>1</level>
           <default>false</default>
           <dependencies>
diff --git a/xbmc/settings/DisplaySettings.cpp b/xbmc/settings/DisplaySettings.cpp
index 203c0f1..dfc1ab8 100644
--- a/xbmc/settings/DisplaySettings.cpp
+++ b/xbmc/settings/DisplaySettings.cpp
@@ -244,6 +244,10 @@ bool CDisplaySettings::OnSettingChanging(const CSetting *setting)
         m_resolutionChangeAborted = false;
     }
   }
+  else if (settingId == "videoscreen.monitorsingle")
+  {
+    g_Windowing.UpdateResolutions();
+  }
 
   return true;
 }
diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index 9caeabf..879d8f2 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -204,6 +204,7 @@ bool CWinEventsX11::Init(Display *dpy, Window win)
   WinEvents->m_wmDeleteMessage = XInternAtom(dpy, "WM_DELETE_WINDOW", False);
   WinEvents->m_structureChanged = false;
   WinEvents->m_xrrEventPending = false;
+  WinEvents->m_xrrPollTimer.Set(3000);
 
   // open input method
   char *old_locale = NULL, *old_modifiers = NULL;
@@ -582,6 +583,11 @@ bool CWinEventsX11::MessagePump()
     g_Windowing.NotifyXRREvent();
     WinEvents->m_xrrEventPending = false;
   }
+  else if (!g_application.IsPlaying() && WinEvents && WinEvents->m_xrrPollTimer.IsTimePast())
+  {
+    g_Windowing.NotifyXRREvent(true);
+    WinEvents->m_xrrPollTimer.Set(3000);
+  }
 #endif
 
 #ifdef HAS_SDL_JOYSTICK
diff --git a/xbmc/windowing/WinEventsX11.h b/xbmc/windowing/WinEventsX11.h
index 5b1f3fa..d4a4b47 100644
--- a/xbmc/windowing/WinEventsX11.h
+++ b/xbmc/windowing/WinEventsX11.h
@@ -54,5 +54,6 @@ class CWinEventsX11 : public CWinEventsBase
   bool m_structureChanged;
   int m_RREventBase;
   XbmcThreads::EndTime m_xrrFailSafeTimer;
+  XbmcThreads::EndTime m_xrrPollTimer;
   bool m_xrrEventPending;
 };
diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index e768c44..6b1ed87 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -250,18 +250,62 @@ void CWinSystemX11::UpdateResolutions()
 #if defined(HAS_XRANDR)
   int numScreens = XScreenCount(m_dpy);
   g_xrandr.SetNumScreens(numScreens);
-  if(g_xrandr.Query(true))
+
+  bool switchOnOff = CSettings::Get().GetBool("videoscreen.monitorsingle");
+  m_userOutput = CSettings::Get().GetString("videoscreen.monitor");
+  if (m_userOutput.Equals("Default"))
+    switchOnOff = false;
+
+  if(g_xrandr.Query(true, !switchOnOff))
   {
-    m_userOutput = CSettings::Get().GetString("videoscreen.monitor");
     // check if the monitor is connected
-    XOutput *out = g_xrandr.GetOutput(m_userOutput);
+    // might take a while when connected to a receiver
+    XbmcThreads::EndTime timeout(3000);
+    XOutput *out = NULL;
+    while (!m_userOutput.Equals("Default") && !timeout.IsTimePast())
+    {
+      out = g_xrandr.GetOutput(m_userOutput);
+      if (out)
+      {
+        XMode mode = g_xrandr.GetCurrentMode(m_userOutput);
+        if (mode.isCurrent || switchOnOff)
+          break;
+        else
+        {
+          out = NULL;
+          break;
+        }
+      }
+
+      Sleep(500);
+      if (!g_xrandr.Query(true, !switchOnOff))
+        break;
+    }
     if (!out)
     {
-      // choose first output
       m_userOutput = g_xrandr.GetModes()[0].name;
       out = g_xrandr.GetOutput(m_userOutput);
     }
+
+    // switch on output
+    if(switchOnOff)
+      g_xrandr.TurnOnOutput(m_userOutput);
+
+    // switch off other outputs if desired
+    if (switchOnOff)
+    {
+      std::vector<XOutput> outputs = g_xrandr.GetModes();
+      for (int i=0; i<outputs.size(); i++)
+      {
+        if (outputs[i].name.Equals(m_userOutput))
+          continue;
+        g_xrandr.TurnOffOutput(outputs[i].name);
+      }
+    }
+
     XMode mode = g_xrandr.GetCurrentMode(m_userOutput);
+    if (mode.id.empty())
+      mode = g_xrandr.GetPreferredMode(m_userOutput);
     m_bIsRotated = out->isRotated;
     if (!m_bIsRotated)
       UpdateDesktopResolution(CDisplaySettings::Get().GetResolutionInfo(RES_DESKTOP), 0, mode.w, mode.h, mode.hz);
@@ -380,7 +424,9 @@ bool CWinSystemX11::HasCalibration(const RESOLUTION_INFO &resInfo)
 void CWinSystemX11::GetConnectedOutputs(std::vector<CStdString> *outputs)
 {
   vector<XOutput> outs;
+  g_xrandr.Query(true);
   outs = g_xrandr.GetModes();
+  outputs->push_back("Default");
   for(unsigned int i=0; i<outs.size(); ++i)
   {
     outputs->push_back(outs[i].name);
@@ -667,14 +713,34 @@ void CWinSystemX11::CheckDisplayEvents()
 #endif
 }
 
-void CWinSystemX11::NotifyXRREvent()
+void CWinSystemX11::NotifyXRREvent(bool poll)
 {
-  CLog::Log(LOGDEBUG, "%s - notify display reset event", __FUNCTION__);
+  // we may not get an event if desired monitor becomes available
+  // hence we need to poll
+  if (poll)
+  {
+    CStdString output = CSettings::Get().GetString("videoscreen.monitor");
+    if (output.Equals(m_currentOutput) || m_userOutput.Equals("Default"))
+      return;
+
+    int numScreens = XScreenCount(m_dpy);
+    g_xrandr.SetNumScreens(numScreens);
+    g_xrandr.Query(true);
+    if (!g_xrandr.IsOutputConnected(output))
+      return;
+
+    // if output is turned off by user, respect it
+    XMode mode = g_xrandr.GetCurrentMode(output);
+    if (!mode.isCurrent)
+      return;
+  }
+
+  CLog::Log(LOGDEBUG, "%s - notify display reset event, poll: %d", __FUNCTION__, poll);
   m_windowDirty = true;
 
   CSingleLock lock(g_graphicsContext);
 
-  if (!g_xrandr.Query(true))
+  if (!g_xrandr.Query(!poll))
   {
     CLog::Log(LOGERROR, "WinSystemX11::RefreshWindow - failed to query xrandr");
     return;
@@ -701,7 +767,8 @@ void CWinSystemX11::NotifyXRREvent()
   bool found(false);
   for (i = RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); ++i)
   {
-    if (CDisplaySettings::Get().GetResolutionInfo(i).strId == mode.id)
+    res = CDisplaySettings::Get().GetResolutionInfo(i);
+    if (CDisplaySettings::Get().GetResolutionInfo(i).strId.Equals(mode.id))
     {
       found = true;
       break;
diff --git a/xbmc/windowing/X11/WinSystemX11.h b/xbmc/windowing/X11/WinSystemX11.h
index 30f5fa0..9c7ecdd 100644
--- a/xbmc/windowing/X11/WinSystemX11.h
+++ b/xbmc/windowing/X11/WinSystemX11.h
@@ -68,7 +68,7 @@ class CWinSystemX11 : public CWinSystemBase
   Display*  GetDisplay() { return m_dpy; }
   GLXWindow GetWindow() { return m_glWindow; }
   GLXContext GetGlxContext() { return m_glContext; }
-  void NotifyXRREvent();
+  void NotifyXRREvent(bool poll = false);
   void GetConnectedOutputs(std::vector<CStdString> *outputs);
   bool IsCurrentOutput(CStdString output);
   void NotifyMouseCoverage(bool covered);
diff --git a/xbmc/windowing/X11/XRandR.cpp b/xbmc/windowing/X11/XRandR.cpp
index 380a194..650a6ef 100644
--- a/xbmc/windowing/X11/XRandR.cpp
+++ b/xbmc/windowing/X11/XRandR.cpp
@@ -149,10 +149,14 @@ bool CXRandR::Query(bool force, int screennum, bool ignoreoff)
 
 bool CXRandR::TurnOffOutput(CStdString name)
 {
+  XOutput *output = GetOutput(name);
+  if (!output)
+    return false;
+
   CStdString cmd;
   cmd  = getenv("XBMC_BIN_HOME");
   cmd += "/xbmc-xrandr";
-  cmd.AppendFormat(" --output %s --off", name.c_str());
+  cmd.AppendFormat(" --screen %d --output %s --off", output->screen, name.c_str());
 
   int status = system(cmd.c_str());
   if (status == -1)
-- 
1.8.1.6


From e3f99b95970e08f6e36867152534378b3e064e1d Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Wed, 15 May 2013 09:14:34 +0200
Subject: [PATCH 111/123] X11: ignore mouse move event form other windows

---
 xbmc/windowing/WinEventsX11.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index 879d8f2..2ec9b6f 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -319,7 +319,7 @@ bool CWinEventsX11::MessagePump()
     memset(&xevent, 0, sizeof (XEvent));
     XNextEvent(WinEvents->m_display, &xevent);
 
-    if (XFilterEvent(&xevent, None))
+    if (XFilterEvent(&xevent, WinEvents->m_window))
       continue;
 
     switch (xevent.type)
@@ -520,6 +520,8 @@ bool CWinEventsX11::MessagePump()
 
       case MotionNotify:
       {
+        if (xevent.xmotion.window != WinEvents->m_window)
+          break;
         XBMC_Event newEvent;
         memset(&newEvent, 0, sizeof(newEvent));
         newEvent.type = XBMC_MOUSEMOTION;
-- 
1.8.1.6


From b3ec49babe443c5c1e0156e86992dcc39ac29dec Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 2 Jun 2013 14:53:45 +0200
Subject: [PATCH 112/123] vdpau: fix segfault caused by uninitialized member

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index fc4c030..9bafdd7 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -90,6 +90,7 @@
   m_vdpauConfig.videoSurfaceSec = &m_videoSurfaceSec;
 
   m_vdpauConfigured = false;
+  m_hwContext.bitstream_buffers_allocated = 0;
   m_DisplayState = VDPAU_OPEN;
 }
 
-- 
1.8.1.6


From 4ffa47f4352b8ddc59242615c86115781e5412ea Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 11 Jun 2013 16:13:45 +0200
Subject: [PATCH 113/123] vdpau: sync video mixer

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 9bafdd7..55ef4dc 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -2350,6 +2350,21 @@ void CMixer::ProcessPicture()
                                 NULL);
   CheckStatus(vdp_st, __LINE__);
 
+  // sync mixer, read blocks until output surface is written
+  {
+    uint32_t data[16];
+    VdpRect rect;
+    rect.x0 = rect.y0 = 0;
+    rect.x1 = rect.y1 = 1;
+    uint32_t *pdata[] = {data};
+    uint32_t pitches[] = {4};
+
+    vdp_st = m_config.vdpProcs.vdp_output_surface_get_bits_native(m_processPicture.outputSurface,
+                                                             &rect,
+                                                             (void**)pdata,
+                                                             pitches);
+  }
+
   if (m_mixerfield != VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME)
   {
     // in order to clip top and bottom lines when de-interlacing
-- 
1.8.1.6


From 890c33ae9afbca2659b1244aa7c039279f454ea1 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Tue, 11 Jun 2013 16:20:29 +0200
Subject: [PATCH 114/123] renderer: allow some lateness within vblank interval

---
 xbmc/cores/VideoRenderers/RenderManager.cpp | 12 ++++++++++--
 xbmc/cores/VideoRenderers/RenderManager.h   |  1 +
 2 files changed, 11 insertions(+), 2 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/RenderManager.cpp b/xbmc/cores/VideoRenderers/RenderManager.cpp
index f94760c..83a824a 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.cpp
+++ b/xbmc/cores/VideoRenderers/RenderManager.cpp
@@ -398,6 +398,8 @@ void CXBMCRenderManager::FrameFinish()
   if(g_graphicsContext.IsFullScreenVideo())
     WaitPresentTime(m.timestamp);
 
+  m_clock_framefinish = GetPresentTime();
+
   { CSingleLock lock(m_presentlock);
 
     if(m_presentstep == PRESENT_FRAME)
@@ -1043,6 +1045,12 @@ void CXBMCRenderManager::PrepareNextRender()
 
   double clocktime = GetPresentTime();
   double frametime = 1.0 / GetMaximumFPS();
+  double correction = 0.0;
+  int fps = g_VideoReferenceClock.GetRefreshRate();
+  if((fps > 0) && g_graphicsContext.IsFullScreenVideo() && (clocktime != m_clock_framefinish))
+  {
+    correction = frametime;
+  }
 
   /* see if any future queued frames are already due */
   std::deque<int>::reverse_iterator curr, prev;
@@ -1051,8 +1059,8 @@ void CXBMCRenderManager::PrepareNextRender()
   ++prev;
   while (prev != m_queued.rend())
   {
-    if(clocktime > m_Queue[*prev].timestamp                 /* previous frame is late */
-    && clocktime > m_Queue[*curr].timestamp - frametime)    /* selected frame is close to it's display time */
+    if(clocktime > m_Queue[*prev].timestamp + correction                 /* previous frame is late */
+    && clocktime > m_Queue[*curr].timestamp - frametime + correction)    /* selected frame is close to it's display time */
       break;
     ++curr;
     ++prev;
diff --git a/xbmc/cores/VideoRenderers/RenderManager.h b/xbmc/cores/VideoRenderers/RenderManager.h
index 7a3a530..480e4dc 100644
--- a/xbmc/cores/VideoRenderers/RenderManager.h
+++ b/xbmc/cores/VideoRenderers/RenderManager.h
@@ -251,6 +251,7 @@ class CXBMCRenderManager
   XbmcThreads::ConditionVariable  m_presentevent;
   CCriticalSection m_presentlock;
   CEvent     m_flushEvent;
+  double     m_clock_framefinish;
 
 
   OVERLAY::CRenderer m_overlays;
-- 
1.8.1.6


From 28912445572715df8588111eba8848d283f12233 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 14 Jun 2013 09:23:22 +0200
Subject: [PATCH 115/123] vdpau: calculate timestamp of second field when doing
 deinterlacing

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 55ef4dc..27d63f5 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -2314,7 +2314,9 @@ void CMixer::ProcessPicture()
       futu_surfaces[0] = m_mixerInput[1].render->surface;
       futu_surfaces[1] = m_mixerInput[1].render->surface;
 
-      m_processPicture.DVDPic.pts = DVD_NOPTS_VALUE;
+      m_processPicture.DVDPic.pts = m_mixerInput[1].DVDPic.pts +
+                                   (m_mixerInput[0].DVDPic.pts -
+                                    m_mixerInput[1].DVDPic.pts) / 2;
       m_processPicture.DVDPic.dts = DVD_NOPTS_VALUE;
     }
     m_processPicture.DVDPic.iRepeatPicture = 0.0;
-- 
1.8.1.6


From 2eb311f322f2b671218447472a89ca1125707801 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 14 Jun 2013 10:46:58 +0200
Subject: [PATCH 116/123] vdpau: comment debug log: long decoding time

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 27d63f5..593f96c 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -874,7 +874,7 @@ void CDecoder::FFDrawSlice(struct AVCodecContext *s,
       return;
   }
 
-  uint64_t startTime = CurrentHostCounter();
+//  uint64_t startTime = CurrentHostCounter();
   uint16_t decoded, processed, rend;
   vdp->m_bufferStats.Get(decoded, processed, rend);
   vdp_st = vdp->m_vdpauConfig.vdpProcs.vdp_decoder_render(vdp->m_vdpauConfig.vdpDecoder,
@@ -883,9 +883,9 @@ void CDecoder::FFDrawSlice(struct AVCodecContext *s,
                                    vdp->m_hwContext.bitstream_buffers_used,
                                    vdp->m_hwContext.bitstream_buffers);
   vdp->CheckStatus(vdp_st, __LINE__);
-  uint64_t diff = CurrentHostCounter() - startTime;
-  if (diff*1000/CurrentHostFrequency() > 30)
-    CLog::Log(LOGWARNING,"CVDPAU::DrawSlice - VdpDecoderRender long decoding: %d ms, dec: %d, proc: %d, rend: %d", (int)((diff*1000)/CurrentHostFrequency()), decoded, processed, rend);
+//  uint64_t diff = CurrentHostCounter() - startTime;
+//  if (diff*1000/CurrentHostFrequency() > 30)
+//    CLog::Log(LOGWARNING,"CVDPAU::DrawSlice - VdpDecoderRender long decoding: %d ms, dec: %d, proc: %d, rend: %d", (int)((diff*1000)/CurrentHostFrequency()), decoded, processed, rend);
 
 }
 
-- 
1.8.1.6


From 686e6da18cec2138c1543fa402296eb92c7daadc Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 16 Jun 2013 13:22:58 +0200
Subject: [PATCH 117/123] X11: another fix for mouse coverage

---
 xbmc/windowing/WinEventsX11.cpp | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/xbmc/windowing/WinEventsX11.cpp b/xbmc/windowing/WinEventsX11.cpp
index 2ec9b6f..4ed978c 100644
--- a/xbmc/windowing/WinEventsX11.cpp
+++ b/xbmc/windowing/WinEventsX11.cpp
@@ -506,14 +506,16 @@ bool CWinEventsX11::MessagePump()
 
       case EnterNotify:
       {
-        g_Windowing.NotifyMouseCoverage(true);
+        if (xevent.xcrossing.mode ==  NotifyNormal)
+          g_Windowing.NotifyMouseCoverage(true);
         break;
       }
 
       // lose mouse coverage
       case LeaveNotify:
       {
-        g_Windowing.NotifyMouseCoverage(false);
+        if (xevent.xcrossing.mode ==  NotifyNormal)
+          g_Windowing.NotifyMouseCoverage(false);
         g_Mouse.SetActive(false);
         break;
       }
-- 
1.8.1.6


From 1814ed1f05d82067956c1eaec459f7eeace006c9 Mon Sep 17 00:00:00 2001
From: xbmc <fernetmenta@online.de>
Date: Sun, 16 Jun 2013 13:23:19 +0200
Subject: [PATCH 118/123] renderer: delete fence on uninit

---
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index c663423..858d39d 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -1164,7 +1164,12 @@ void CLinuxRendererGL::UnInit()
 
   // YV12 textures
   for (int i = 0; i < NUM_BUFFERS; ++i)
+  {
     (this->*m_textureDelete)(i);
+    if (m_buffers[i].fence)
+      glDeleteSync(m_buffers[i].fence);
+    m_buffers[i].fence = None;
+  }
 
   // cleanup framebuffer object if it was in use
   m_fbo.fbo.Cleanup();
-- 
1.8.1.6


From 90727fe2c507dccd7dfc308a094a492a301ef763 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sun, 16 Jun 2013 14:28:01 +0200
Subject: [PATCH 119/123] renderer: limit fence to vdpau

---
 xbmc/cores/VideoRenderers/LinuxRendererGL.cpp | 15 +++++++++------
 1 file changed, 9 insertions(+), 6 deletions(-)

diff --git a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
index 858d39d..bb198f3 100644
--- a/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
+++ b/xbmc/cores/VideoRenderers/LinuxRendererGL.cpp
@@ -1254,14 +1254,17 @@ void CLinuxRendererGL::Render(DWORD flags, int renderBuffer)
     VerifyGLState();
   }
 
-  // set fence in order to determine when buffer is ready for reuse
-  // this is the case when the gl has finished processing
-  if(m_buffers[renderBuffer].fence)
+  if (m_format == RENDER_FMT_VDPAU || m_format == RENDER_FMT_VDPAU_420)
   {
-    glDeleteSync(m_buffers[renderBuffer].fence);
-    m_buffers[renderBuffer].fence = None;
+    // set fence in order to determine when buffer is ready for reuse
+    // this is the case when the gl has finished processing
+    if(m_buffers[renderBuffer].fence)
+    {
+      glDeleteSync(m_buffers[renderBuffer].fence);
+      m_buffers[renderBuffer].fence = None;
+    }
+    m_buffers[renderBuffer].fence = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
   }
-  m_buffers[renderBuffer].fence = glFenceSync(GL_SYNC_GPU_COMMANDS_COMPLETE, 0);
 }
 
 void CLinuxRendererGL::RenderSinglePass(int index, int field)
-- 
1.8.1.6


From 6d8df3121b0e0b4f8e70ef454b04dd36783fbbf7 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Thu, 4 Jul 2013 16:38:26 +0200
Subject: [PATCH 120/123] XVBA: replace CODEC_IS with AV_CODEC_ID

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp
index 54d7aea..5845dbf 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/XVBA.cpp
@@ -389,7 +389,7 @@ bool CDecoder::Open(AVCodecContext* avctx, const enum PixelFormat fmt, unsigned
   }
 
   int match = -1;
-  if (avctx->codec_id == CODEC_ID_H264)
+  if (avctx->codec_id == AV_CODEC_ID_H264)
   {
     // search for profile high
     for (unsigned int i = 0; i < capOutput->num_of_decodecaps; ++i)
@@ -406,7 +406,7 @@ bool CDecoder::Open(AVCodecContext* avctx, const enum PixelFormat fmt, unsigned
       CLog::Log(LOGNOTICE, "(XVBA::Open) - profile XVBA_H264_HIGH not found");
     }
   }
-  else if (avctx->codec_id == CODEC_ID_VC1)
+  else if (avctx->codec_id == AV_CODEC_ID_VC1)
   {
     // search for profile advanced
     for (unsigned int i = 0; i < capOutput->num_of_decodecaps; ++i)
@@ -423,7 +423,7 @@ bool CDecoder::Open(AVCodecContext* avctx, const enum PixelFormat fmt, unsigned
       CLog::Log(LOGNOTICE, "(XVBA::Open) - profile XVBA_VC1_ADVANCED not found");
     }
   }
-  else if (avctx->codec_id == CODEC_ID_MPEG2VIDEO)
+  else if (avctx->codec_id == AV_CODEC_ID_MPEG2VIDEO)
   {
     // search for profile high
     for (unsigned int i = 0; i < capOutput->num_of_decodecaps; ++i)
@@ -440,7 +440,7 @@ bool CDecoder::Open(AVCodecContext* avctx, const enum PixelFormat fmt, unsigned
       CLog::Log(LOGNOTICE, "(XVBA::Open) - profile XVBA_MPEG2_VLD not found");
     }
   }
-  else if (avctx->codec_id == CODEC_ID_WMV3)
+  else if (avctx->codec_id == AV_CODEC_ID_WMV3)
   {
     // search for profile high
     for (unsigned int i = 0; i < capOutput->num_of_decodecaps; ++i)
@@ -967,7 +967,7 @@ void CDecoder::FFDrawSlice(struct AVCodecContext *avctx,
   picInput.buffer_list = list;
   list[0] = xvba->m_xvbaBufferPool.picture_descriptor_buffer;
   picInput.num_of_buffers_in_list = 1;
-  if (avctx->codec_id == CODEC_ID_H264)
+  if (avctx->codec_id == AV_CODEC_ID_H264)
   {
     list[1] = xvba->m_xvbaBufferPool.iq_matrix_buffer;
     picInput.num_of_buffers_in_list = 2;
@@ -991,13 +991,13 @@ void CDecoder::FFDrawSlice(struct AVCodecContext *avctx,
   {
     int startCodeSize = 0;
     uint8_t startCode[] = {0x00,0x00,0x01};
-    if (avctx->codec_id == CODEC_ID_H264)
+    if (avctx->codec_id == AV_CODEC_ID_H264)
     {
       startCodeSize = 3;
       memcpy((uint8_t*)xvba->m_xvbaBufferPool.data_buffer->bufferXVBA+location,
           startCode, 3);
     }
-    else if (avctx->codec_id == CODEC_ID_VC1 &&
+    else if (avctx->codec_id == AV_CODEC_ID_VC1 &&
         (memcmp(render->buffers[j].buffer, startCode, 3) != 0))
     {
       startCodeSize = 4;
-- 
1.8.1.6


From aca51d06f3589e934dbb49d44b45a81a08e29d52 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Fri, 5 Jul 2013 12:14:00 +0200
Subject: [PATCH 121/123] X11: set windows class name

---
 xbmc/windowing/X11/WinSystemX11.cpp | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/xbmc/windowing/X11/WinSystemX11.cpp b/xbmc/windowing/X11/WinSystemX11.cpp
index 6b1ed87..30eff67 100644
--- a/xbmc/windowing/X11/WinSystemX11.cpp
+++ b/xbmc/windowing/X11/WinSystemX11.cpp
@@ -980,8 +980,10 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
     {
       CreateIconPixmap();
       XWMHints *wm_hints;
+      XClassHint *class_hints;
       XTextProperty windowName, iconName;
       std::string titleString = "XBMC Media Center";
+      std::string classString = "xbmc.bin";
       char *title = (char*)titleString.c_str();
 
       XStringListToTextProperty(&title, 1, &windowName);
@@ -992,10 +994,15 @@ bool CWinSystemX11::SetWindow(int width, int height, bool fullscreen, const CStd
       wm_hints->icon_pixmap = m_icon;
       wm_hints->flags = StateHint | IconPixmapHint;
 
+      class_hints = XAllocClassHint();
+      class_hints->res_class = (char*)classString.c_str();
+      class_hints->res_name = (char*)classString.c_str();
+
       XSync(m_dpy,False);
       XSetWMProperties(m_dpy, m_mainWindow, &windowName, &iconName,
                             NULL, 0, NULL, wm_hints,
-                            NULL);
+                            class_hints);
+      XFree(class_hints);
       XFree(wm_hints);
 
       // register interest in the delete window message
-- 
1.8.1.6


From 18f918782577c79e8cb1cef6ad0650c2668baa92 Mon Sep 17 00:00:00 2001
From: Rainer Hochecker <fernetmenta@online.de>
Date: Sat, 13 Jul 2013 20:00:45 +0200
Subject: [PATCH 122/123] VDPAU: revert sync mixer, does a busy wait

---
 xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp | 31 +++++++++++++-------------
 1 file changed, 16 insertions(+), 15 deletions(-)

diff --git a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
index 593f96c..f630bcb 100644
--- a/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
+++ b/xbmc/cores/dvdplayer/DVDCodecs/Video/VDPAU.cpp
@@ -1139,7 +1139,7 @@ void CVdpauRenderPicture::ReturnUnused()
 // Mixer
 //-----------------------------------------------------------------------------
 CMixer::CMixer(CEvent *inMsgEvent) :
-  CThread("Vdpau Mixer Thread"),
+  CThread("Vdpau Mixer"),
   m_controlPort("ControlPort", inMsgEvent, &m_outMsgEvent),
   m_dataPort("DataPort", inMsgEvent, &m_outMsgEvent)
 {
@@ -2353,19 +2353,20 @@ void CMixer::ProcessPicture()
   CheckStatus(vdp_st, __LINE__);
 
   // sync mixer, read blocks until output surface is written
-  {
-    uint32_t data[16];
-    VdpRect rect;
-    rect.x0 = rect.y0 = 0;
-    rect.x1 = rect.y1 = 1;
-    uint32_t *pdata[] = {data};
-    uint32_t pitches[] = {4};
-
-    vdp_st = m_config.vdpProcs.vdp_output_surface_get_bits_native(m_processPicture.outputSurface,
-                                                             &rect,
-                                                             (void**)pdata,
-                                                             pitches);
-  }
+  // this does a busy wait :(
+//  {
+//    uint32_t data[16];
+//    VdpRect rect;
+//    rect.x0 = rect.y0 = 0;
+//    rect.x1 = rect.y1 = 1;
+//    uint32_t *pdata[] = {data};
+//    uint32_t pitches[] = {4};
+//
+//    vdp_st = m_config.vdpProcs.vdp_output_surface_get_bits_native(m_processPicture.outputSurface,
+//                                                             &rect,
+//                                                             (void**)pdata,
+//                                                             pitches);
+//  }
 
   if (m_mixerfield != VDP_VIDEO_MIXER_PICTURE_STRUCTURE_FRAME)
   {
@@ -2410,7 +2411,7 @@ bool CMixer::CheckStatus(VdpStatus vdp_st, int line)
 // Output
 //-----------------------------------------------------------------------------
 COutput::COutput(CEvent *inMsgEvent) :
-  CThread("Vdpau Output Thread"),
+  CThread("Vdpau Output"),
   m_controlPort("OutputControlPort", inMsgEvent, &m_outMsgEvent),
   m_dataPort("OutputDataPort", inMsgEvent, &m_outMsgEvent),
   m_mixer(&m_outMsgEvent)
-- 
1.8.1.6


From da1ff12885a9aec8e6cc1eb7a060e9a3f6dcc2e4 Mon Sep 17 00:00:00 2001
From: fritsch <peter.fruehberger@gmail.com>
Date: Sun, 14 Jul 2013 14:21:52 +0200
Subject: [PATCH 123/123] ActiveAE: Make ActiveAE default Audio Engine to get
 it tested via ppa

---
 xbmc/cores/AudioEngine/AEFactory.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/xbmc/cores/AudioEngine/AEFactory.cpp b/xbmc/cores/AudioEngine/AEFactory.cpp
index d5517f3..07b4095 100644
--- a/xbmc/cores/AudioEngine/AEFactory.cpp
+++ b/xbmc/cores/AudioEngine/AEFactory.cpp
@@ -97,7 +97,7 @@ bool CAEFactory::LoadEngine()
     loaded = CAEFactory::LoadEngine(AE_ENGINE_COREAUDIO);
 #else
   if (!loaded)
-    loaded = CAEFactory::LoadEngine(AE_ENGINE_SOFT);
+    loaded = CAEFactory::LoadEngine(AE_ENGINE_ACTIVE);
 #endif
 
   return loaded;
-- 
1.8.1.6

