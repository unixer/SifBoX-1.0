diff -urN vdr-1.7.38/channels.h vdr-1.7.38-pa/channels.h
--- vdr-1.7.38/channels.h	2013-02-21 22:26:57.318776693 +0100
+++ vdr-1.7.38-pa/channels.h	2013-02-21 22:24:13.246773877 +0100
@@ -14,6 +14,7 @@
 #include "sources.h"
 #include "thread.h"
 #include "tools.h"
+#include <vector>
 
 #define ISTRANSPONDER(f1, f2)  (abs((f1) - (f2)) < 4) //XXX
 
@@ -101,6 +102,9 @@
   friend class cSchedules;
   friend class cMenuEditChannel;
   friend class cDvbSourceParam;
+  friend class cMenuMyEditChannel;
+  friend class cMenuMyBouquets;
+  friend class cMenuEditBouquet;
 private:
   static cString ToText(const cChannel *Channel);
   char *name;
@@ -191,6 +195,7 @@
   int Number(void) const { return number; }
   void SetNumber(int Number) { number = Number; }
   bool GroupSep(void) const { return groupSep; }
+  void SetGroupSep(bool GroupSep) { groupSep=GroupSep; }
   const char *Parameters(void) const { return parameters; }
   const cLinkChannels* LinkChannels(void) const { return linkChannels; }
   const cChannel *RefChannel(void) const { return refChannel; }
@@ -228,6 +233,7 @@
 public:
   cChannels(void);
   bool Load(const char *FileName, bool AllowComments = false, bool MustExist = false);
+  bool Reload(const char *FileName, bool AllowComments = false, bool MustExist = false);
   void HashChannel(cChannel *Channel);
   void UnhashChannel(cChannel *Channel);
   int GetNextGroup(int Idx);   // Get next channel group
diff -urN vdr-1.7.38/config.c vdr-1.7.38-pa/config.c
--- vdr-1.7.38/config.c	2013-02-21 22:26:57.318776693 +0100
+++ vdr-1.7.38-pa/config.c	2013-02-21 22:25:20.526775031 +0100
@@ -478,6 +478,16 @@
   ChannelsWrap = 0;
   ShowChannelNamesWithSource = 0;
   EmergencyExit = 1;
+  ExpertOptions  = 0;
+  AddNewChannels = 0;
+  UseBouquetList = 1;
+  OnlyRadioChannels = 0;
+  OnlyEncryptedChannels = 0;
+  OnlyHDChannels = 0;
+  ExpertNavi     = 0;
+  WantChListOnOk = 1;
+  ChannelUpDownKeyMode = 0; // 0 Normal, kChanUp and kChanDn jumps channel
+                            // 1 opens bouquet / channellist
   JumpSeconds = 60;
   JumpSecondsSlow = 10;
 }
@@ -585,6 +595,15 @@
 bool cSetup::Parse(const char *Name, const char *Value)
 {
   if      (!strcasecmp(Name, "OSDLanguage"))       { strn0cpy(OSDLanguage, Value, sizeof(OSDLanguage)); I18nSetLocale(OSDLanguage); }
+  else if (!strcasecmp(Name, "ExpertOptions"))       ExpertOptions      = atoi(Value);
+  else if (!strcasecmp(Name, "AddNewChannels"))      AddNewChannels     = atoi(Value);
+  else if (!strcasecmp(Name, "UseBouquetList"))      UseBouquetList     = atoi(Value);
+  else if (!strcasecmp(Name, "OnlyRadioChannels"))   OnlyRadioChannels  = atoi(Value);
+  else if (!strcasecmp(Name, "OnlyEncryptedChannels"))OnlyEncryptedChannels = atoi(Value);
+  else if (!strcasecmp(Name, "OnlyHDChannels"))      OnlyHDChannels       = atoi(Value);
+  else if (!strcasecmp(Name, "ExpertNavi"))          ExpertNavi         = atoi(Value);
+  else if (!strcasecmp(Name, "WantChListOnOk"))      WantChListOnOk     = atoi(Value);
+  else if (!strcasecmp(Name, "ChannelUpDownKeyMode"))  ChannelUpDownKeyMode = atoi(Value);
   else if (!strcasecmp(Name, "OSDSkin"))             Utf8Strn0Cpy(OSDSkin, Value, MaxSkinName);
   else if (!strcasecmp(Name, "OSDTheme"))            Utf8Strn0Cpy(OSDTheme, Value, MaxThemeName);
   else if (!strcasecmp(Name, "WarEagleIcons"))       WarEagleIcons      = atoi(Value);
@@ -804,6 +823,15 @@
   Store("ChannelsWrap",       ChannelsWrap);
   Store("ShowChannelNamesWithSource", ShowChannelNamesWithSource);
   Store("EmergencyExit",      EmergencyExit);
+  Store("ExpertOptions",      ExpertOptions);
+  Store("AddNewChannels",     AddNewChannels);
+  Store("UseBouquetList",     UseBouquetList);
+  Store("OnlyRadioChannels",  OnlyRadioChannels);
+  Store("OnlyEncryptedChannels", OnlyEncryptedChannels);
+  Store("OnlyHDChannels", OnlyHDChannels);
+  Store("ExpertNavi",         ExpertNavi);
+  Store("WantChListOnOk",     WantChListOnOk);
+  Store("ChannelUpDownKeyMode", ChannelUpDownKeyMode);
   Store("LastReplayed",       cReplayControl::LastReplayed());
   Store("JumpSeconds",        JumpSeconds);
   Store("JumpSecondsSlow",    JumpSecondsSlow);
diff -urN vdr-1.7.38/config.h vdr-1.7.38-pa/config.h
--- vdr-1.7.38/config.h	2013-02-21 22:26:57.326776693 +0100
+++ vdr-1.7.38-pa/config.h	2013-02-21 22:26:12.678775925 +0100
@@ -14,6 +14,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <string>
 #include <time.h>
 #include <unistd.h>
 #include "i18n.h"
@@ -347,6 +348,17 @@
   int ChannelsWrap;
   int ShowChannelNamesWithSource;
   int EmergencyExit;
+  int ExpertOptions;
+  int AddNewChannels;
+  int UseBouquetList;
+  int OnlyRadioChannels;
+  int OnlyEncryptedChannels;
+  int OnlyHDChannels;
+  int ExpertNavi;
+  int WantChListOnOk;
+  int ChannelUpDownKeyMode; // 0 Normal, jumps to next or previous channel
+                            // 1 opens bouquet / channel list
+  bool UseZonedChannelList;
   int JumpSeconds;
   int JumpSecondsSlow;
   int __EndData__;
diff -urN vdr-1.7.38/config.h.orig vdr-1.7.38-pa/config.h.orig
--- vdr-1.7.38/config.h.orig	2013-02-21 22:26:57.326776693 +0100
+++ vdr-1.7.38-pa/config.h.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,361 +0,0 @@
-/*
- * config.h: Configuration file handling
- *
- * See the main source file 'vdr.c' for copyright information and
- * how to reach the author.
- *
- * $Id: config.h 2.67 2013/02/14 15:13:59 kls Exp $
- */
-
-#ifndef __CONFIG_H
-#define __CONFIG_H
-
-#include <arpa/inet.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <unistd.h>
-#include "i18n.h"
-#include "font.h"
-#include "tools.h"
-
-// VDR's own version number:
-
-#define VDRVERSION  "1.7.38"
-#define VDRVERSNUM   10738  // Version * 10000 + Major * 100 + Minor
-
-// The plugin API's version number:
-
-#define APIVERSION  "1.7.38"
-#define APIVERSNUM   10738  // Version * 10000 + Major * 100 + Minor
-
-// When loading plugins, VDR searches them by their APIVERSION, which
-// may be smaller than VDRVERSION in case there have been no changes to
-// VDR header files since the last APIVERSION. This allows compiled
-// plugins to work with newer versions of the core VDR as long as no
-// VDR header files have changed.
-
-#define JUMPPLAYVERSNUM 110
-
-// The MainMenuHook Patch's version number:
-#define MAINMENUHOOKSVERSION "1.0.1"
-#define MAINMENUHOOKSVERSNUM 10001  // Version * 10000 + Major * 100 + Minor
-
-#define REMOTEINSTANTVERSION 1.0
-
-#define MAXPRIORITY       99
-#define MINPRIORITY       (-MAXPRIORITY)
-#define LIVEPRIORITY      0                  // priority used when selecting a device for live viewing
-#define TRANSFERPRIORITY  (LIVEPRIORITY - 1) // priority used for actual local Transfer Mode
-#define IDLEPRIORITY      (MINPRIORITY - 1)  // priority of an idle device
-#define MAXLIFETIME       99
-#define DEFINSTRECTIME    180 // default instant recording time (minutes)
-
-#define TIMERMACRO_TITLE    "TITLE"
-#define TIMERMACRO_EPISODE  "EPISODE"
-
-#define MINOSDWIDTH   480
-#define MAXOSDWIDTH  1920
-#define MINOSDHEIGHT  324
-#define MAXOSDHEIGHT 1200
-
-#define MaxFileName NAME_MAX // obsolete - use NAME_MAX directly instead!
-#define MaxSkinName 16
-#define MaxThemeName 16
-
-// Basically VDR works according to the DVB standard, but there are countries/providers
-// that use other standards, which in some details deviate from the DVB standard.
-// This makes it necessary to handle things differently in some areas, depending on
-// which standard is actually used. The following macros are used to distinguish
-// these cases (make sure to adjust cMenuSetupDVB::standardComplianceTexts accordingly
-// when adding a new standard):
-
-#define STANDARD_DVB       0
-#define STANDARD_ANSISCTE  1
-
-typedef uint32_t in_addr_t; //XXX from /usr/include/netinet/in.h (apparently this is not defined on systems with glibc < 2.2)
-
-class cSVDRPhost : public cListObject {
-private:
-  struct in_addr addr;
-  in_addr_t mask;
-public:
-  cSVDRPhost(void);
-  bool Parse(const char *s);
-  bool IsLocalhost(void);
-  bool Accepts(in_addr_t Address);
-  };
-
-class cSatCableNumbers {
-private:
-  int size;
-  int *array;
-public:
-  cSatCableNumbers(int Size, const char *s = NULL);
-  ~cSatCableNumbers();
-  int Size(void) const { return size; }
-  int *Array(void) { return array; }
-  bool FromString(const char *s);
-  cString ToString(void);
-  int FirstDeviceIndex(int DeviceIndex) const;
-      ///< Returns the first device index (starting at 0) that uses the same
-      ///< sat cable number as the device with the given DeviceIndex.
-      ///< If the given device does not use the same sat cable as any other device,
-      ///< or if the resulting value would be the same as DeviceIndex,
-      ///< or if DeviceIndex is out of range, -1 is returned.
-  };
-
-template<class T> class cConfig : public cList<T> {
-private:
-  char *fileName;
-  bool allowComments;
-  void Clear(void)
-  {
-    free(fileName);
-    fileName = NULL;
-    cList<T>::Clear();
-  }
-public:
-  cConfig(void) { fileName = NULL; }
-  virtual ~cConfig() { free(fileName); }
-  const char *FileName(void) { return fileName; }
-  bool Load(const char *FileName = NULL, bool AllowComments = false, bool MustExist = false)
-  {
-    cConfig<T>::Clear();
-    if (FileName) {
-       free(fileName);
-       fileName = strdup(FileName);
-       allowComments = AllowComments;
-       }
-    bool result = !MustExist;
-    if (fileName && access(fileName, F_OK) == 0) {
-       isyslog("loading %s", fileName);
-       FILE *f = fopen(fileName, "r");
-       if (f) {
-          char *s;
-          int line = 0;
-          cReadLine ReadLine;
-          result = true;
-          while ((s = ReadLine.Read(f)) != NULL) {
-                line++;
-                if (allowComments) {
-                   char *p = strchr(s, '#');
-                   if (p)
-                      *p = 0;
-                   }
-                stripspace(s);
-                if (!isempty(s)) {
-                   T *l = new T;
-                   if (l->Parse(s))
-                      this->Add(l);
-                   else {
-                      esyslog("ERROR: error in %s, line %d", fileName, line);
-                      delete l;
-                      result = false;
-                      }
-                   }
-                }
-          fclose(f);
-          }
-       else {
-          LOG_ERROR_STR(fileName);
-          result = false;
-          }
-       }
-    if (!result)
-       fprintf(stderr, "vdr: error while reading '%s'\n", fileName);
-    return result;
-  }
-  bool Save(void)
-  {
-    bool result = true;
-    T *l = (T *)this->First();
-    cSafeFile f(fileName);
-    if (f.Open()) {
-       while (l) {
-             if (!l->Save(f)) {
-                result = false;
-                break;
-                }
-             l = (T *)l->Next();
-             }
-       if (!f.Close())
-          result = false;
-       }
-    else
-       result = false;
-    return result;
-  }
-  };
-
-class cNestedItem : public cListObject {
-private:
-  char *text;
-  cList<cNestedItem> *subItems;
-public:
-  cNestedItem(const char *Text, bool WithSubItems = false);
-  virtual ~cNestedItem();
-  virtual int Compare(const cListObject &ListObject) const;
-  const char *Text(void) const { return text; }
-  cList<cNestedItem> *SubItems(void) { return subItems; }
-  void AddSubItem(cNestedItem *Item);
-  void SetText(const char *Text);
-  void SetSubItems(bool On);
-  };
-
-class cNestedItemList : public cList<cNestedItem> {
-private:
-  char *fileName;
-  bool Parse(FILE *f, cList<cNestedItem> *List, int &Line);
-  bool Write(FILE *f, cList<cNestedItem> *List, int Indent = 0);
-public:
-  cNestedItemList(void);
-  virtual ~cNestedItemList();
-  void Clear(void);
-  bool Load(const char *FileName);
-  bool Save(void);
-  };
-
-class cSVDRPhosts : public cConfig<cSVDRPhost> {
-public:
-  bool LocalhostOnly(void);
-  bool Acceptable(in_addr_t Address);
-  };
-
-extern cNestedItemList Folders;
-extern cNestedItemList Commands;
-extern cNestedItemList RecordingCommands;
-extern cSVDRPhosts SVDRPhosts;
-
-class cSetupLine : public cListObject {
-private:
-  char *plugin;
-  char *name;
-  char *value;
-public:
-  cSetupLine(void);
-  cSetupLine(const char *Name, const char *Value, const char *Plugin = NULL);
-  virtual ~cSetupLine();
-  virtual int Compare(const cListObject &ListObject) const;
-  const char *Plugin(void) { return plugin; }
-  const char *Name(void) { return name; }
-  const char *Value(void) { return value; }
-  bool Parse(char *s);
-  bool Save(FILE *f);
-  };
-
-class cSetup : public cConfig<cSetupLine> {
-  friend class cPlugin; // needs to be able to call Store()
-private:
-  void StoreLanguages(const char *Name, int *Values);
-  bool ParseLanguages(const char *Value, int *Values);
-  bool Parse(const char *Name, const char *Value);
-  cSetupLine *Get(const char *Name, const char *Plugin = NULL);
-  void Store(const char *Name, const char *Value, const char *Plugin = NULL, bool AllowMultiple = false);
-  void Store(const char *Name, int Value, const char *Plugin = NULL);
-  void Store(const char *Name, double &Value, const char *Plugin = NULL);
-public:
-  // Also adjust cMenuSetup (menu.c) when adding parameters here!
-  int __BeginData__;
-  char OSDLanguage[I18N_MAX_LOCALE_LEN];
-  char OSDSkin[MaxSkinName];
-  char OSDTheme[MaxThemeName];
-  int WarEagleIcons;
-  int PrimaryDVB;
-  int ShowInfoOnChSwitch;
-  int TimeoutRequChInfo;
-  int MenuScrollPage;
-  int MenuScrollWrap;
-  int MenuKeyCloses;
-  int MarkInstantRecord;
-  char NameInstantRecord[NAME_MAX];
-  int InstantRecordTime;
-  int LnbSLOF;
-  int LnbFrequLo;
-  int LnbFrequHi;
-  int DiSEqC;
-  int SetSystemTime;
-  int TimeSource;
-  int TimeTransponder;
-  int StandardCompliance;
-  int MarginStart, MarginStop;
-  int AudioLanguages[I18N_MAX_LANGUAGES + 1];
-  int DisplaySubtitles;
-  int SupportTeletext;
-  int SubtitleLanguages[I18N_MAX_LANGUAGES + 1];
-  int SubtitleOffset;
-  int SubtitleFgTransparency, SubtitleBgTransparency;
-  int EPGLanguages[I18N_MAX_LANGUAGES + 1];
-  int EPGScanTimeout;
-  int EPGBugfixLevel;
-  int EPGLinger;
-  int SVDRPTimeout;
-  int ZapTimeout;
-  int ChannelEntryTimeout;
-  int RcRepeatDelay;
-  int RcRepeatDelta;
-  int DefaultPriority, DefaultLifetime;
-  int PausePriority, PauseLifetime;
-  int PauseKeyHandling;
-  int UseSubtitle;
-  int UseVps;
-  int VpsMargin;
-  int RecordingDirs;
-  int FoldersInTimerMenu;
-  int NumberKeysForChars;
-  int ColorKey0, ColorKey1, ColorKey2, ColorKey3;
-  int VideoDisplayFormat;
-  int VideoFormat;
-  int UpdateChannels;
-  int UseDolbyDigital;
-  int ChannelInfoPos;
-  int ChannelInfoTime;
-  double OSDLeftP, OSDTopP, OSDWidthP, OSDHeightP;
-  int OSDLeft, OSDTop, OSDWidth, OSDHeight;
-  double OSDAspect;
-  int OSDMessageTime;
-  int UseSmallFont;
-  int AntiAlias;
-  char FontOsd[MAXFONTNAME];
-  char FontSml[MAXFONTNAME];
-  char FontFix[MAXFONTNAME];
-  double FontOsdSizeP;
-  double FontSmlSizeP;
-  double FontFixSizeP;
-  int FontOsdSize;
-  int FontSmlSize;
-  int FontFixSize;
-  int MaxVideoFileSize;
-  int SplitEditedFiles;
-  int DelTimeshiftRec;
-  int MinEventTimeout, MinUserInactivity;
-  time_t NextWakeupTime;
-  int MultiSpeedMode;
-  int ShowReplayMode;
-  int ShowRemainingTime;
-  int ProgressDisplayTime;
-  int PauseOnMarkSet;
-  int ResumeID;
-  int JumpPlay;
-  int PlayJump;
-  int PauseLastMark;
-  int CurrentChannel;
-  int CurrentVolume;
-  int CurrentDolby;
-  int InitialVolume;
-  int ChannelsWrap;
-  int ShowChannelNamesWithSource;
-  int EmergencyExit;
-  int __EndData__;
-  cString InitialChannel;
-  cString DeviceBondings;
-  cSetup(void);
-  cSetup& operator= (const cSetup &s);
-  bool Load(const char *FileName);
-  bool Save(void);
-  };
-
-extern cSetup Setup;
-
-#endif //__CONFIG_H
I file binari vdr-1.7.38/.config.h.rej.swp e vdr-1.7.38-pa/.config.h.rej.swp sono diversi
diff -urN vdr-1.7.38/debug.h vdr-1.7.38-pa/debug.h
--- vdr-1.7.38/debug.h	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.7.38-pa/debug.h	2013-02-21 22:24:13.250773878 +0100
@@ -0,0 +1,44 @@
+
+#ifndef DEBUG_H
+#define DEBUG_H
+#include <assert.h>
+
+#ifdef DBG
+  #undef DBG
+  #undef DERR
+  #undef DLOG
+  #undef PRINTF
+#endif
+
+
+#if defined DEBUG
+    #ifdef PLUGIN_NAME_I18N
+        #define CONTEXT PLUGIN_NAME_I18N
+    #else
+        #define CONTEXT "VDR"
+    #endif
+
+    // standard debug macro
+    #define DDD(x...) { printf("["CONTEXT": %s +%d, %s()]: ",__FILE__, __LINE__, __FUNCTION__); \
+                         printf(x); printf("\n"); }
+
+    // standard error macro (red background)
+    #define DERR(x...) { printf("\033[0;37m\033[1;41m["CONTEXT"]: "x); printf("\033[0m\n"); }
+
+    // special macro: logs to syslog AND console
+    #define DLOG(x...) { printf("["CONTEXT"]: "x); printf("\n"); dsyslog("["CONTEXT"]: "x); }
+
+    // for automatic conversion of printf's - i.e. use sed s/" printf"/" PRINTF"/
+    #define PRINTF(x...) printf("["CONTEXT"]: "x)
+#else
+    #define DDD(x...)
+    #define DERR(x...)
+    #define DLOG(x...)
+    #define PRINTF(x...)
+#endif
+
+//only here for compatibility reasons, don't use any more
+#define ERR "Error"
+#define DBG(x...)
+
+#endif /* DEBUG_H */
diff -urN vdr-1.7.38/device.c.orig vdr-1.7.38-pa/device.c.orig
--- vdr-1.7.38/device.c.orig	2013-02-21 22:26:57.330776693 +0100
+++ vdr-1.7.38-pa/device.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,1807 +0,0 @@
-/*
- * device.c: The basic device interface
- *
- * See the main source file 'vdr.c' for copyright information and
- * how to reach the author.
- *
- * $Id: device.c 2.73 2013/02/16 14:39:30 kls Exp $
- */
-
-#include "device.h"
-#include <errno.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include "audio.h"
-#include "channels.h"
-#include "i18n.h"
-#include "player.h"
-#include "receiver.h"
-#include "status.h"
-#include "transfer.h"
-#include "vdrttxtsubshooks.h"
-
-// --- cLiveSubtitle ---------------------------------------------------------
-
-class cLiveSubtitle : public cReceiver {
-protected:
-  virtual void Receive(uchar *Data, int Length);
-public:
-  cLiveSubtitle(int SPid);
-  virtual ~cLiveSubtitle();
-  };
-
-cLiveSubtitle::cLiveSubtitle(int SPid)
-{
-  AddPid(SPid);
-}
-
-cLiveSubtitle::~cLiveSubtitle()
-{
-  cReceiver::Detach();
-}
-
-void cLiveSubtitle::Receive(uchar *Data, int Length)
-{
-  if (cDevice::PrimaryDevice())
-     cDevice::PrimaryDevice()->PlayTs(Data, Length);
-}
-
-// --- cDeviceHook -----------------------------------------------------------
-
-cDeviceHook::cDeviceHook(void)
-{
-  cDevice::deviceHooks.Add(this);
-}
-
-bool cDeviceHook::DeviceProvidesTransponder(const cDevice *Device, const cChannel *Channel) const
-{
-  return true;
-}
-
-// --- cDevice ---------------------------------------------------------------
-
-// The minimum number of unknown PS1 packets to consider this a "pre 1.3.19 private stream":
-#define MIN_PRE_1_3_19_PRIVATESTREAM 10
-
-int cDevice::numDevices = 0;
-int cDevice::useDevice = 0;
-int cDevice::nextCardIndex = 0;
-int cDevice::currentChannel = 1;
-cDevice *cDevice::device[MAXDEVICES] = { NULL };
-cDevice *cDevice::primaryDevice = NULL;
-cList<cDeviceHook> cDevice::deviceHooks;
-
-cDevice::cDevice(void)
-:patPmtParser(true)
-{
-  cardIndex = nextCardIndex++;
-  dsyslog("new device number %d", CardIndex() + 1);
-
-  SetDescription("receiver on device %d", CardIndex() + 1);
-
-  mute = false;
-  volume = Setup.CurrentVolume;
-
-  sectionHandler = NULL;
-  eitFilter = NULL;
-  patFilter = NULL;
-  sdtFilter = NULL;
-  nitFilter = NULL;
-
-  camSlot = NULL;
-  startScrambleDetection = 0;
-
-  occupiedTimeout = 0;
-
-  player = NULL;
-  isPlayingVideo = false;
-  ClrAvailableTracks();
-  currentAudioTrack = ttNone;
-  currentAudioTrackMissingCount = 0;
-  currentSubtitleTrack = ttNone;
-  keepTracks = false;
-  liveSubtitle = NULL;
-  dvbSubtitleConverter = NULL;
-  autoSelectPreferredSubtitleLanguage = true;
-
-  for (int i = 0; i < MAXRECEIVERS; i++)
-      receiver[i] = NULL;
-
-  if (numDevices < MAXDEVICES)
-     device[numDevices++] = this;
-  else
-     esyslog("ERROR: too many devices!");
-}
-
-cDevice::~cDevice()
-{
-  Detach(player);
-  DetachAllReceivers();
-  delete liveSubtitle;
-  delete dvbSubtitleConverter;
-}
-
-bool cDevice::WaitForAllDevicesReady(int Timeout)
-{
-  for (time_t t0 = time(NULL); time(NULL) - t0 < Timeout; ) {
-      bool ready = true;
-      for (int i = 0; i < numDevices; i++) {
-          if (device[i] && !device[i]->Ready()) {
-             ready = false;
-             cCondWait::SleepMs(100);
-             }
-          }
-      if (ready)
-         return true;
-      }
-  return false;
-}
-
-void cDevice::SetUseDevice(int n)
-{
-  if (n < MAXDEVICES)
-     useDevice |= (1 << n);
-}
-
-int cDevice::NextCardIndex(int n)
-{
-  if (n > 0) {
-     nextCardIndex += n;
-     if (nextCardIndex >= MAXDEVICES)
-        esyslog("ERROR: nextCardIndex too big (%d)", nextCardIndex);
-     }
-  else if (n < 0)
-     esyslog("ERROR: invalid value in nextCardIndex(%d)", n);
-  return nextCardIndex;
-}
-
-int cDevice::DeviceNumber(void) const
-{
-  for (int i = 0; i < numDevices; i++) {
-      if (device[i] == this)
-         return i;
-      }
-  return -1;
-}
-
-cString cDevice::DeviceType(void) const
-{
-  return "";
-}
-
-cString cDevice::DeviceName(void) const
-{
-  return "";
-}
-
-void cDevice::MakePrimaryDevice(bool On)
-{
-  if (!On) {
-     DELETENULL(liveSubtitle);
-     DELETENULL(dvbSubtitleConverter);
-     }
-}
-
-bool cDevice::SetPrimaryDevice(int n)
-{
-  n--;
-  if (0 <= n && n < numDevices && device[n]) {
-     isyslog("setting primary device to %d", n + 1);
-     if (primaryDevice)
-        primaryDevice->MakePrimaryDevice(false);
-     primaryDevice = device[n];
-     primaryDevice->MakePrimaryDevice(true);
-     primaryDevice->SetVideoFormat(Setup.VideoFormat);
-     primaryDevice->SetVolumeDevice(Setup.CurrentVolume);
-     return true;
-     }
-  esyslog("ERROR: invalid primary device number: %d", n + 1);
-  return false;
-}
-
-bool cDevice::HasDecoder(void) const
-{
-  return false;
-}
-
-cSpuDecoder *cDevice::GetSpuDecoder(void)
-{
-  return NULL;
-}
-
-cDevice *cDevice::ActualDevice(void)
-{
-  cDevice *d = cTransferControl::ReceiverDevice();
-  if (!d)
-     d = PrimaryDevice();
-  return d;
-}
-
-cDevice *cDevice::GetDevice(int Index)
-{
-  return (0 <= Index && Index < numDevices) ? device[Index] : NULL;
-}
-
-static int GetClippedNumProvidedSystems(int AvailableBits, cDevice *Device)
-{
-  int MaxNumProvidedSystems = (1 << AvailableBits) - 1;
-  int NumProvidedSystems = Device->NumProvidedSystems();
-  if (NumProvidedSystems > MaxNumProvidedSystems) {
-     esyslog("ERROR: device %d supports %d modulation systems but cDevice::GetDevice() currently only supports %d delivery systems which should be fixed", Device->CardIndex() + 1, NumProvidedSystems, MaxNumProvidedSystems);
-     NumProvidedSystems = MaxNumProvidedSystems;
-     }
-  else if (NumProvidedSystems <= 0) {
-     esyslog("ERROR: device %d reported an invalid number (%d) of supported delivery systems - assuming 1", Device->CardIndex() + 1, NumProvidedSystems);
-     NumProvidedSystems = 1;
-     }
-  return NumProvidedSystems;
-}
-
-cDevice *cDevice::GetDevice(const cChannel *Channel, int Priority, bool LiveView, bool Query)
-{
-  // Collect the current priorities of all CAM slots that can decrypt the channel:
-  int NumCamSlots = CamSlots.Count();
-  int SlotPriority[NumCamSlots];
-  int NumUsableSlots = 0;
-  bool InternalCamNeeded = false;
-  if (Channel->Ca() >= CA_ENCRYPTED_MIN) {
-     for (cCamSlot *CamSlot = CamSlots.First(); CamSlot; CamSlot = CamSlots.Next(CamSlot)) {
-         SlotPriority[CamSlot->Index()] = MAXPRIORITY + 1; // assumes it can't be used
-         if (CamSlot->ModuleStatus() == msReady) {
-            if (CamSlot->ProvidesCa(Channel->Caids())) {
-               if (!ChannelCamRelations.CamChecked(Channel->GetChannelID(), CamSlot->SlotNumber())) {
-                  SlotPriority[CamSlot->Index()] = CamSlot->Priority();
-                  NumUsableSlots++;
-                  }
-               }
-            }
-         }
-     if (!NumUsableSlots)
-        InternalCamNeeded = true; // no CAM is able to decrypt this channel
-     }
-
-  bool NeedsDetachReceivers = false;
-  cDevice *d = NULL;
-  cCamSlot *s = NULL;
-
-  uint32_t Impact = 0xFFFFFFFF; // we're looking for a device with the least impact
-  for (int j = 0; j < NumCamSlots || !NumUsableSlots; j++) {
-      if (NumUsableSlots && SlotPriority[j] > MAXPRIORITY)
-         continue; // there is no CAM available in this slot
-      for (int i = 0; i < numDevices; i++) {
-          if (Channel->Ca() && Channel->Ca() <= CA_DVB_MAX && Channel->Ca() != device[i]->CardIndex() + 1)
-             continue; // a specific card was requested, but not this one
-          bool HasInternalCam = device[i]->HasInternalCam();
-          if (InternalCamNeeded && !HasInternalCam)
-             continue; // no CAM is able to decrypt this channel and the device uses vdr handled CAMs
-          if (NumUsableSlots && !HasInternalCam && !CamSlots.Get(j)->Assign(device[i], true))
-             continue; // CAM slot can't be used with this device
-          bool ndr;
-          if (device[i]->ProvidesChannel(Channel, Priority, &ndr)) { // this device is basically able to do the job
-             if (NumUsableSlots && !HasInternalCam && device[i]->CamSlot() && device[i]->CamSlot() != CamSlots.Get(j))
-                ndr = true; // using a different CAM slot requires detaching receivers
-             // Put together an integer number that reflects the "impact" using
-             // this device would have on the overall system. Each condition is represented
-             // by one bit in the number (or several bits, if the condition is actually
-             // a numeric value). The sequence in which the conditions are listed corresponds
-             // to their individual severity, where the one listed first will make the most
-             // difference, because it results in the most significant bit of the result.
-             uint32_t imp = 0;
-             imp <<= 1; imp |= LiveView ? !device[i]->IsPrimaryDevice() || ndr : 0;                                  // prefer the primary device for live viewing if we don't need to detach existing receivers
-             imp <<= 1; imp |= !device[i]->Receiving() && (device[i] != cTransferControl::ReceiverDevice() || device[i]->IsPrimaryDevice()) || ndr; // use receiving devices if we don't need to detach existing receivers, but avoid primary device in local transfer mode
-             imp <<= 1; imp |= device[i]->Receiving();                                                               // avoid devices that are receiving
-             imp <<= 4; imp |= GetClippedNumProvidedSystems(4, device[i]) - 1;                                       // avoid cards which support multiple delivery systems
-             imp <<= 1; imp |= device[i] == cTransferControl::ReceiverDevice();                                      // avoid the Transfer Mode receiver device
-             imp <<= 8; imp |= device[i]->Priority() - IDLEPRIORITY;                                                 // use the device with the lowest priority (- IDLEPRIORITY to assure that values -100..99 can be used)
-             imp <<= 8; imp |= ((NumUsableSlots && !HasInternalCam) ? SlotPriority[j] : IDLEPRIORITY) - IDLEPRIORITY;// use the CAM slot with the lowest priority (- IDLEPRIORITY to assure that values -100..99 can be used)
-             imp <<= 1; imp |= ndr;                                                                                  // avoid devices if we need to detach existing receivers
-             imp <<= 1; imp |= (NumUsableSlots || InternalCamNeeded) ? 0 : device[i]->HasCi();                       // avoid cards with Common Interface for FTA channels
-             imp <<= 1; imp |= device[i]->AvoidRecording();                                                          // avoid SD full featured cards
-             imp <<= 1; imp |= (NumUsableSlots && !HasInternalCam) ? !ChannelCamRelations.CamDecrypt(Channel->GetChannelID(), j + 1) : 0; // prefer CAMs that are known to decrypt this channel
-             imp <<= 1; imp |= device[i]->IsPrimaryDevice();                                                         // avoid the primary device
-             if (imp < Impact) {
-                // This device has less impact than any previous one, so we take it.
-                Impact = imp;
-                d = device[i];
-                NeedsDetachReceivers = ndr;
-                if (NumUsableSlots && !HasInternalCam)
-                   s = CamSlots.Get(j);
-                }
-             }
-          }
-      if (!NumUsableSlots)
-         break; // no CAM necessary, so just one loop over the devices
-      }
-  if (d && !Query) {
-     if (NeedsDetachReceivers)
-        d->DetachAllReceivers();
-     if (s) {
-        if (s->Device() != d) {
-           if (s->Device())
-              s->Device()->DetachAllReceivers();
-           if (d->CamSlot())
-              d->CamSlot()->Assign(NULL);
-           s->Assign(d);
-           }
-        }
-     else if (d->CamSlot() && !d->CamSlot()->IsDecrypting())
-        d->CamSlot()->Assign(NULL);
-     }
-  return d;
-}
-
-cDevice *cDevice::GetDeviceForTransponder(const cChannel *Channel, int Priority)
-{
-  cDevice *Device = NULL;
-  for (int i = 0; i < cDevice::NumDevices(); i++) {
-      if (cDevice *d = cDevice::GetDevice(i)) {
-         if (d->IsTunedToTransponder(Channel))
-            return d; // if any device is tuned to the transponder, we're done
-         if (d->ProvidesTransponder(Channel)) {
-            if (d->MaySwitchTransponder(Channel))
-               Device = d; // this device may switch to the transponder without disturbing any receiver or live view
-            else if (!d->Occupied() && d->MaySwitchTransponder(Channel)) { // MaySwitchTransponder() implicitly calls Occupied()
-               if (d->Priority() < Priority && (!Device || d->Priority() < Device->Priority()))
-                  Device = d; // use this one only if no other with less impact can be found
-               }
-            }
-         }
-      }
-  return Device;
-}
-
-bool cDevice::HasCi(void)
-{
-  return false;
-}
-
-void cDevice::SetCamSlot(cCamSlot *CamSlot)
-{
-  camSlot = CamSlot;
-}
-
-void cDevice::Shutdown(void)
-{
-  deviceHooks.Clear();
-  primaryDevice = NULL;
-  for (int i = 0; i < numDevices; i++) {
-      delete device[i];
-      device[i] = NULL;
-      }
-}
-
-uchar *cDevice::GrabImage(int &Size, bool Jpeg, int Quality, int SizeX, int SizeY)
-{
-  return NULL;
-}
-
-bool cDevice::GrabImageFile(const char *FileName, bool Jpeg, int Quality, int SizeX, int SizeY)
-{
-  int result = 0;
-  int fd = open(FileName, O_WRONLY | O_CREAT | O_NOFOLLOW | O_TRUNC, DEFFILEMODE);
-  if (fd >= 0) {
-     int ImageSize;
-     uchar *Image = GrabImage(ImageSize, Jpeg, Quality, SizeX, SizeY);
-     if (Image) {
-        if (safe_write(fd, Image, ImageSize) == ImageSize)
-           isyslog("grabbed image to %s", FileName);
-        else {
-           LOG_ERROR_STR(FileName);
-           result |= 1;
-           }
-        free(Image);
-        }
-     else
-        result |= 1;
-     close(fd);
-     }
-  else {
-     LOG_ERROR_STR(FileName);
-     result |= 1;
-     }
-  return result == 0;
-}
-
-void cDevice::SetVideoDisplayFormat(eVideoDisplayFormat VideoDisplayFormat)
-{
-  cSpuDecoder *spuDecoder = GetSpuDecoder();
-  if (spuDecoder) {
-     if (Setup.VideoFormat)
-        spuDecoder->setScaleMode(cSpuDecoder::eSpuNormal);
-     else {
-        switch (VideoDisplayFormat) {
-               case vdfPanAndScan:
-                    spuDecoder->setScaleMode(cSpuDecoder::eSpuPanAndScan);
-                    break;
-               case vdfLetterBox:
-                    spuDecoder->setScaleMode(cSpuDecoder::eSpuLetterBox);
-                    break;
-               case vdfCenterCutOut:
-                    spuDecoder->setScaleMode(cSpuDecoder::eSpuNormal);
-                    break;
-               default: esyslog("ERROR: invalid value for VideoDisplayFormat '%d'", VideoDisplayFormat);
-               }
-        }
-     }
-}
-
-void cDevice::SetVideoFormat(bool VideoFormat16_9)
-{
-}
-
-eVideoSystem cDevice::GetVideoSystem(void)
-{
-  return vsPAL;
-}
-
-void cDevice::GetVideoSize(int &Width, int &Height, double &VideoAspect)
-{
-  Width = 0;
-  Height = 0;
-  VideoAspect = 1.0;
-}
-
-void cDevice::GetOsdSize(int &Width, int &Height, double &PixelAspect)
-{
-  Width = 720;
-  Height = 480;
-  PixelAspect = 1.0;
-}
-
-//#define PRINTPIDS(s) { char b[500]; char *q = b; q += sprintf(q, "%d %s ", CardIndex(), s); for (int i = 0; i < MAXPIDHANDLES; i++) q += sprintf(q, " %s%4d %d", i == ptOther ? "* " : "", pidHandles[i].pid, pidHandles[i].used); dsyslog("%s", b); }
-#define PRINTPIDS(s)
-
-bool cDevice::HasPid(int Pid) const
-{
-  for (int i = 0; i < MAXPIDHANDLES; i++) {
-      if (pidHandles[i].pid == Pid)
-         return true;
-      }
-  return false;
-}
-
-bool cDevice::AddPid(int Pid, ePidType PidType, int StreamType)
-{
-  if (Pid || PidType == ptPcr) {
-     int n = -1;
-     int a = -1;
-     if (PidType != ptPcr) { // PPID always has to be explicit
-        for (int i = 0; i < MAXPIDHANDLES; i++) {
-            if (i != ptPcr) {
-               if (pidHandles[i].pid == Pid)
-                  n = i;
-               else if (a < 0 && i >= ptOther && !pidHandles[i].used)
-                  a = i;
-               }
-            }
-        }
-     if (n >= 0) {
-        // The Pid is already in use
-        if (++pidHandles[n].used == 2 && n <= ptTeletext) {
-           // It's a special PID that may have to be switched into "tap" mode
-           PRINTPIDS("A");
-           if (!SetPid(&pidHandles[n], n, true)) {
-              esyslog("ERROR: can't set PID %d on device %d", Pid, CardIndex() + 1);
-              if (PidType <= ptTeletext)
-                 DetachAll(Pid);
-              DelPid(Pid, PidType);
-              return false;
-              }
-           if (camSlot)
-              camSlot->SetPid(Pid, true);
-           }
-        PRINTPIDS("a");
-        return true;
-        }
-     else if (PidType < ptOther) {
-        // The Pid is not yet in use and it is a special one
-        n = PidType;
-        }
-     else if (a >= 0) {
-        // The Pid is not yet in use and we have a free slot
-        n = a;
-        }
-     else {
-        esyslog("ERROR: no free slot for PID %d on device %d", Pid, CardIndex() + 1);
-        return false;
-        }
-     if (n >= 0) {
-        pidHandles[n].pid = Pid;
-        pidHandles[n].streamType = StreamType;
-        pidHandles[n].used = 1;
-        PRINTPIDS("C");
-        if (!SetPid(&pidHandles[n], n, true)) {
-           esyslog("ERROR: can't set PID %d on device %d", Pid, CardIndex() + 1);
-           if (PidType <= ptTeletext)
-              DetachAll(Pid);
-           DelPid(Pid, PidType);
-           return false;
-           }
-        if (camSlot)
-           camSlot->SetPid(Pid, true);
-        }
-     }
-  return true;
-}
-
-void cDevice::DelPid(int Pid, ePidType PidType)
-{
-  if (Pid || PidType == ptPcr) {
-     int n = -1;
-     if (PidType == ptPcr)
-        n = PidType; // PPID always has to be explicit
-     else {
-        for (int i = 0; i < MAXPIDHANDLES; i++) {
-            if (pidHandles[i].pid == Pid) {
-               n = i;
-               break;
-               }
-            }
-        }
-     if (n >= 0 && pidHandles[n].used) {
-        PRINTPIDS("D");
-        if (--pidHandles[n].used < 2) {
-           SetPid(&pidHandles[n], n, false);
-           if (pidHandles[n].used == 0) {
-              pidHandles[n].handle = -1;
-              pidHandles[n].pid = 0;
-              if (camSlot)
-                 camSlot->SetPid(Pid, false);
-              }
-           }
-        PRINTPIDS("E");
-        }
-     }
-}
-
-bool cDevice::SetPid(cPidHandle *Handle, int Type, bool On)
-{
-  return false;
-}
-
-void cDevice::DelLivePids(void)
-{
-  for (int i = ptAudio; i < ptOther; i++) {
-      if (pidHandles[i].pid)
-         DelPid(pidHandles[i].pid, ePidType(i));
-      }
-}
-
-void cDevice::StartSectionHandler(void)
-{
-  if (!sectionHandler) {
-     sectionHandler = new cSectionHandler(this);
-     AttachFilter(eitFilter = new cEitFilter);
-     AttachFilter(patFilter = new cPatFilter);
-     AttachFilter(sdtFilter = new cSdtFilter(patFilter));
-     AttachFilter(nitFilter = new cNitFilter);
-     }
-}
-
-void cDevice::StopSectionHandler(void)
-{
-  if (sectionHandler) {
-     delete nitFilter;
-     delete sdtFilter;
-     delete patFilter;
-     delete eitFilter;
-     delete sectionHandler;
-     nitFilter = NULL;
-     sdtFilter = NULL;
-     patFilter = NULL;
-     eitFilter = NULL;
-     sectionHandler = NULL;
-     }
-}
-
-int cDevice::OpenFilter(u_short Pid, u_char Tid, u_char Mask)
-{
-  return -1;
-}
-
-int cDevice::ReadFilter(int Handle, void *Buffer, size_t Length)
-{
-  return safe_read(Handle, Buffer, Length);
-}
-
-void cDevice::CloseFilter(int Handle)
-{
-  close(Handle);
-}
-
-void cDevice::AttachFilter(cFilter *Filter)
-{
-  if (sectionHandler)
-     sectionHandler->Attach(Filter);
-}
-
-void cDevice::Detach(cFilter *Filter)
-{
-  if (sectionHandler)
-     sectionHandler->Detach(Filter);
-}
-
-bool cDevice::ProvidesSource(int Source) const
-{
-  return false;
-}
-
-bool cDevice::DeviceHooksProvidesTransponder(const cChannel *Channel) const
-{
-  cDeviceHook *Hook = deviceHooks.First();
-  while (Hook) {
-        if (!Hook->DeviceProvidesTransponder(this, Channel))
-           return false;
-        Hook = deviceHooks.Next(Hook);
-        }
-  return true;
-}
-
-bool cDevice::ProvidesTransponder(const cChannel *Channel) const
-{
-  return false;
-}
-
-bool cDevice::ProvidesTransponderExclusively(const cChannel *Channel) const
-{
-  for (int i = 0; i < numDevices; i++) {
-      if (device[i] && device[i] != this && device[i]->ProvidesTransponder(Channel))
-         return false;
-      }
-  return true;
-}
-
-bool cDevice::ProvidesChannel(const cChannel *Channel, int Priority, bool *NeedsDetachReceivers) const
-{
-  return false;
-}
-
-bool cDevice::ProvidesEIT(void) const
-{
-  return false;
-}
-
-int cDevice::NumProvidedSystems(void) const
-{
-  return 0;
-}
-
-int cDevice::SignalStrength(void) const
-{
-  return -1;
-}
-
-int cDevice::SignalQuality(void) const
-{
-  return -1;
-}
-
-const cChannel *cDevice::GetCurrentlyTunedTransponder(void) const
-{
-  return NULL;
-}
-
-bool cDevice::IsTunedToTransponder(const cChannel *Channel) const
-{
-  return false;
-}
-
-bool cDevice::MaySwitchTransponder(const cChannel *Channel) const
-{
-  return time(NULL) > occupiedTimeout && !Receiving() && !(pidHandles[ptAudio].pid || pidHandles[ptVideo].pid || pidHandles[ptDolby].pid);
-}
-
-bool cDevice::SwitchChannel(const cChannel *Channel, bool LiveView)
-{
-  if (LiveView) {
-     isyslog("switching to channel %d", Channel->Number());
-     cControl::Shutdown(); // prevents old channel from being shown too long if GetDevice() takes longer
-     }
-  for (int i = 3; i--;) {
-      switch (SetChannel(Channel, LiveView)) {
-        case scrOk:           return true;
-        case scrNotAvailable: Skins.Message(mtInfo, tr("Channel not available!"));
-                              return false;
-        case scrNoTransfer:   Skins.Message(mtError, tr("Can't start Transfer Mode!"));
-                              return false;
-        case scrFailed:       break; // loop will retry
-        default:              esyslog("ERROR: invalid return value from SetChannel");
-        }
-      esyslog("retrying");
-      }
-  return false;
-}
-
-bool cDevice::SwitchChannel(int Direction)
-{
-  bool result = false;
-  Direction = sgn(Direction);
-  if (Direction) {
-     cControl::Shutdown(); // prevents old channel from being shown too long if GetDevice() takes longer
-     int n = CurrentChannel() + Direction;
-     int first = n;
-     cChannel *channel;
-     while ((channel = Channels.GetByNumber(n, Direction)) != NULL) {
-           // try only channels which are currently available
-           if (GetDevice(channel, LIVEPRIORITY, true, true))
-              break;
-           n = channel->Number() + Direction;
-           }
-     if (channel) {
-        int d = n - first;
-        if (abs(d) == 1)
-           dsyslog("skipped channel %d", first);
-        else if (d)
-           dsyslog("skipped channels %d..%d", first, n - sgn(d));
-        if (PrimaryDevice()->SwitchChannel(channel, true))
-           result = true;
-        }
-     else if (n != first)
-        Skins.Message(mtError, tr("Channel not available!"));
-     }
-  return result;
-}
-
-eSetChannelResult cDevice::SetChannel(const cChannel *Channel, bool LiveView)
-{
-  cStatus::MsgChannelSwitch(this, 0, LiveView);
-
-  if (LiveView) {
-     StopReplay();
-     DELETENULL(liveSubtitle);
-     DELETENULL(dvbSubtitleConverter);
-     }
-
-  cDevice *Device = (LiveView && IsPrimaryDevice()) ? GetDevice(Channel, LIVEPRIORITY, true) : this;
-
-  bool NeedsTransferMode = Device != this;
-
-  eSetChannelResult Result = scrOk;
-
-  // If this DVB card can't receive this channel, let's see if we can
-  // use the card that actually can receive it and transfer data from there:
-
-  if (NeedsTransferMode) {
-     if (Device && CanReplay()) {
-        if (Device->SetChannel(Channel, false) == scrOk) // calling SetChannel() directly, not SwitchChannel()!
-           cControl::Launch(new cTransferControl(Device, Channel));
-        else
-           Result = scrNoTransfer;
-        }
-     else
-        Result = scrNotAvailable;
-     }
-  else {
-     Channels.Lock(false);
-     // Stop section handling:
-     if (sectionHandler) {
-        sectionHandler->SetStatus(false);
-        sectionHandler->SetChannel(NULL);
-        }
-     // Tell the camSlot about the channel switch and add all PIDs of this
-     // channel to it, for possible later decryption:
-     if (camSlot)
-        camSlot->AddChannel(Channel);
-     if (SetChannelDevice(Channel, LiveView)) {
-        // Start section handling:
-        if (sectionHandler) {
-           sectionHandler->SetChannel(Channel);
-           sectionHandler->SetStatus(true);
-           }
-        // Start decrypting any PIDs that might have been set in SetChannelDevice():
-        if (camSlot)
-           camSlot->StartDecrypting();
-        }
-     else
-        Result = scrFailed;
-     Channels.Unlock();
-     }
-
-  if (Result == scrOk) {
-     if (LiveView && IsPrimaryDevice()) {
-        currentChannel = Channel->Number();
-        // Set the available audio tracks:
-        ClrAvailableTracks();
-        for (int i = 0; i < MAXAPIDS; i++)
-            SetAvailableTrack(ttAudio, i, Channel->Apid(i), Channel->Alang(i));
-        if (Setup.UseDolbyDigital) {
-           for (int i = 0; i < MAXDPIDS; i++)
-               SetAvailableTrack(ttDolby, i, Channel->Dpid(i), Channel->Dlang(i));
-           }
-        for (int i = 0; i < MAXSPIDS; i++)
-            SetAvailableTrack(ttSubtitle, i, Channel->Spid(i), Channel->Slang(i));
-        if (!NeedsTransferMode)
-           EnsureAudioTrack(true);
-        EnsureSubtitleTrack();
-        }
-     cStatus::MsgChannelSwitch(this, Channel->Number(), LiveView); // only report status if channel switch successful
-     }
-
-  return Result;
-}
-
-void cDevice::ForceTransferMode(void)
-{
-  if (!cTransferControl::ReceiverDevice()) {
-     cChannel *Channel = Channels.GetByNumber(CurrentChannel());
-     if (Channel)
-        SetChannelDevice(Channel, false); // this implicitly starts Transfer Mode
-     }
-}
-
-int cDevice::Occupied(void) const
-{
-  int Seconds = occupiedTimeout - time(NULL);
-  return Seconds > 0 ? Seconds : 0;
-}
-
-void cDevice::SetOccupied(int Seconds)
-{
-  if (Seconds >= 0)
-     occupiedTimeout = time(NULL) + min(Seconds, MAXOCCUPIEDTIMEOUT);
-}
-
-bool cDevice::SetChannelDevice(const cChannel *Channel, bool LiveView)
-{
-  return false;
-}
-
-bool cDevice::HasLock(int TimeoutMs) const
-{
-  return true;
-}
-
-bool cDevice::HasProgramme(void) const
-{
-  return Replaying() || pidHandles[ptAudio].pid || pidHandles[ptVideo].pid;
-}
-
-int cDevice::GetAudioChannelDevice(void)
-{
-  return 0;
-}
-
-void cDevice::SetAudioChannelDevice(int AudioChannel)
-{
-}
-
-void cDevice::SetVolumeDevice(int Volume)
-{
-}
-
-void cDevice::SetDigitalAudioDevice(bool On)
-{
-}
-
-void cDevice::SetAudioTrackDevice(eTrackType Type)
-{
-}
-
-void cDevice::SetSubtitleTrackDevice(eTrackType Type)
-{
-}
-
-bool cDevice::ToggleMute(void)
-{
-  int OldVolume = volume;
-  mute = !mute;
-  //XXX why is it necessary to use different sequences???
-  if (mute) {
-     SetVolume(0, true);
-     Audios.MuteAudio(mute); // Mute external audio after analog audio
-     }
-  else {
-     Audios.MuteAudio(mute); // Enable external audio before analog audio
-     SetVolume(OldVolume, true);
-     }
-  volume = OldVolume;
-  return mute;
-}
-
-int cDevice::GetAudioChannel(void)
-{
-  int c = GetAudioChannelDevice();
-  return (0 <= c && c <= 2) ? c : 0;
-}
-
-void cDevice::SetAudioChannel(int AudioChannel)
-{
-  if (0 <= AudioChannel && AudioChannel <= 2)
-     SetAudioChannelDevice(AudioChannel);
-}
-
-void cDevice::SetVolume(int Volume, bool Absolute)
-{
-  int OldVolume = volume;
-  volume = constrain(Absolute ? Volume : volume + Volume, 0, MAXVOLUME);
-  SetVolumeDevice(volume);
-  Absolute |= mute;
-  cStatus::MsgSetVolume(Absolute ? volume : volume - OldVolume, Absolute);
-  if (volume > 0) {
-     mute = false;
-     Audios.MuteAudio(mute);
-     }
-}
-
-void cDevice::ClrAvailableTracks(bool DescriptionsOnly, bool IdsOnly)
-{
-  if (keepTracks)
-     return;
-  if (DescriptionsOnly) {
-     for (int i = ttNone; i < ttMaxTrackTypes; i++)
-         *availableTracks[i].description = 0;
-     }
-  else {
-     if (IdsOnly) {
-        for (int i = ttNone; i < ttMaxTrackTypes; i++)
-            availableTracks[i].id = 0;
-        }
-     else
-        memset(availableTracks, 0, sizeof(availableTracks));
-     pre_1_3_19_PrivateStream = 0;
-     SetAudioChannel(0); // fall back to stereo
-     currentAudioTrackMissingCount = 0;
-     currentAudioTrack = ttNone;
-     currentSubtitleTrack = ttNone;
-     }
-}
-
-bool cDevice::SetAvailableTrack(eTrackType Type, int Index, uint16_t Id, const char *Language, const char *Description)
-{
-  eTrackType t = eTrackType(Type + Index);
-  if (Type == ttAudio && IS_AUDIO_TRACK(t) ||
-      Type == ttDolby && IS_DOLBY_TRACK(t) ||
-      Type == ttSubtitle && IS_SUBTITLE_TRACK(t)) {
-     if (Language)
-        strn0cpy(availableTracks[t].language, Language, sizeof(availableTracks[t].language));
-     if (Description)
-        Utf8Strn0Cpy(availableTracks[t].description, Description, sizeof(availableTracks[t].description));
-     if (Id) {
-        availableTracks[t].id = Id; // setting 'id' last to avoid the need for extensive locking
-        if (Type == ttAudio || Type == ttDolby) {
-           int numAudioTracks = NumAudioTracks();
-           if (!availableTracks[currentAudioTrack].id && numAudioTracks && currentAudioTrackMissingCount++ > numAudioTracks * 10)
-              EnsureAudioTrack();
-           else if (t == currentAudioTrack)
-              currentAudioTrackMissingCount = 0;
-           }
-        else if (Type == ttSubtitle && autoSelectPreferredSubtitleLanguage)
-           EnsureSubtitleTrack();
-        }
-     return true;
-     }
-  else
-     esyslog("ERROR: SetAvailableTrack called with invalid Type/Index (%d/%d)", Type, Index);
-  return false;
-}
-
-const tTrackId *cDevice::GetTrack(eTrackType Type)
-{
-  return (ttNone < Type && Type < ttMaxTrackTypes) ? &availableTracks[Type] : NULL;
-}
-
-int cDevice::NumTracks(eTrackType FirstTrack, eTrackType LastTrack) const
-{
-  int n = 0;
-  for (int i = FirstTrack; i <= LastTrack; i++) {
-      if (availableTracks[i].id)
-         n++;
-      }
-  return n;
-}
-
-int cDevice::NumAudioTracks(void) const
-{
-  return NumTracks(ttAudioFirst, ttDolbyLast);
-}
-
-int cDevice::NumSubtitleTracks(void) const
-{
-  return NumTracks(ttSubtitleFirst, ttSubtitleLast);
-}
-
-bool cDevice::SetCurrentAudioTrack(eTrackType Type)
-{
-  if (ttNone < Type && Type <= ttDolbyLast) {
-     cMutexLock MutexLock(&mutexCurrentAudioTrack);
-     if (IS_DOLBY_TRACK(Type))
-        SetDigitalAudioDevice(true);
-     currentAudioTrack = Type;
-     if (player)
-        player->SetAudioTrack(currentAudioTrack, GetTrack(currentAudioTrack));
-     else
-        SetAudioTrackDevice(currentAudioTrack);
-     if (IS_AUDIO_TRACK(Type))
-        SetDigitalAudioDevice(false);
-     return true;
-     }
-  return false;
-}
-
-bool cDevice::SetCurrentSubtitleTrack(eTrackType Type, bool Manual)
-{
-  if (Type == ttNone || IS_SUBTITLE_TRACK(Type)) {
-     currentSubtitleTrack = Type;
-     autoSelectPreferredSubtitleLanguage = !Manual;
-     if (dvbSubtitleConverter)
-        dvbSubtitleConverter->Reset();
-     if (Type == ttNone && dvbSubtitleConverter) {
-        cMutexLock MutexLock(&mutexCurrentSubtitleTrack);
-        DELETENULL(dvbSubtitleConverter);
-        }
-     DELETENULL(liveSubtitle);
-     if (player)
-        player->SetSubtitleTrack(currentSubtitleTrack, GetTrack(currentSubtitleTrack));
-     else
-        SetSubtitleTrackDevice(currentSubtitleTrack);
-     if (currentSubtitleTrack != ttNone && !Replaying() && !Transferring()) {
-        const tTrackId *TrackId = GetTrack(currentSubtitleTrack);
-        if (TrackId && TrackId->id) {
-           liveSubtitle = new cLiveSubtitle(TrackId->id);
-           AttachReceiver(liveSubtitle);
-           }
-        }
-     return true;
-     }
-  return false;
-}
-
-void cDevice::EnsureAudioTrack(bool Force)
-{
-  if (keepTracks)
-     return;
-  if (Force || !availableTracks[currentAudioTrack].id) {
-     eTrackType PreferredTrack = ttAudioFirst;
-     int PreferredAudioChannel = 0;
-     int LanguagePreference = -1;
-     int StartCheck = Setup.CurrentDolby ? ttDolbyFirst : ttAudioFirst;
-     int EndCheck = ttDolbyLast;
-     for (int i = StartCheck; i <= EndCheck; i++) {
-         const tTrackId *TrackId = GetTrack(eTrackType(i));
-         int pos = 0;
-         if (TrackId && TrackId->id && I18nIsPreferredLanguage(Setup.AudioLanguages, TrackId->language, LanguagePreference, &pos)) {
-            PreferredTrack = eTrackType(i);
-            PreferredAudioChannel = pos;
-            }
-         if (Setup.CurrentDolby && i == ttDolbyLast) {
-            i = ttAudioFirst - 1;
-            EndCheck = ttAudioLast;
-            }
-         }
-     // Make sure we're set to an available audio track:
-     const tTrackId *Track = GetTrack(GetCurrentAudioTrack());
-     if (Force || !Track || !Track->id || PreferredTrack != GetCurrentAudioTrack()) {
-        if (!Force) // only log this for automatic changes
-           dsyslog("setting audio track to %d (%d)", PreferredTrack, PreferredAudioChannel);
-        SetCurrentAudioTrack(PreferredTrack);
-        SetAudioChannel(PreferredAudioChannel);
-        }
-     }
-}
-
-void cDevice::EnsureSubtitleTrack(void)
-{
-  if (keepTracks)
-     return;
-  if (Setup.DisplaySubtitles) {
-     eTrackType PreferredTrack = ttNone;
-     int LanguagePreference = INT_MAX; // higher than the maximum possible value
-     for (int i = ttSubtitleFirst; i <= ttSubtitleLast; i++) {
-         const tTrackId *TrackId = GetTrack(eTrackType(i));
-         if (TrackId && TrackId->id && (I18nIsPreferredLanguage(Setup.SubtitleLanguages, TrackId->language, LanguagePreference) ||
-            (i == ttSubtitleFirst + 8 && !*TrackId->language && LanguagePreference == INT_MAX))) // compatibility mode for old subtitles plugin
-            PreferredTrack = eTrackType(i);
-         }
-     // Make sure we're set to an available subtitle track:
-     const tTrackId *Track = GetTrack(GetCurrentSubtitleTrack());
-     if (!Track || !Track->id || PreferredTrack != GetCurrentSubtitleTrack())
-        SetCurrentSubtitleTrack(PreferredTrack);
-     }
-  else
-     SetCurrentSubtitleTrack(ttNone);
-}
-
-bool cDevice::CanReplay(void) const
-{
-  return HasDecoder();
-}
-
-bool cDevice::SetPlayMode(ePlayMode PlayMode)
-{
-  return false;
-}
-
-int64_t cDevice::GetSTC(void)
-{
-  return -1;
-}
-
-void cDevice::TrickSpeed(int Speed)
-{
-}
-
-void cDevice::Clear(void)
-{
-  Audios.ClearAudio();
-  if (dvbSubtitleConverter)
-     dvbSubtitleConverter->Reset();
-}
-
-void cDevice::Play(void)
-{
-  Audios.MuteAudio(mute);
-  if (dvbSubtitleConverter)
-     dvbSubtitleConverter->Freeze(false);
-}
-
-void cDevice::Freeze(void)
-{
-  Audios.MuteAudio(true);
-  if (dvbSubtitleConverter)
-     dvbSubtitleConverter->Freeze(true);
-}
-
-void cDevice::Mute(void)
-{
-  Audios.MuteAudio(true);
-}
-
-void cDevice::StillPicture(const uchar *Data, int Length)
-{
-  if (Data[0] == 0x47) {
-     // TS data
-     cTsToPes TsToPes;
-     uchar *buf = NULL;
-     int Size = 0;
-     while (Length >= TS_SIZE) {
-           int Pid = TsPid(Data);
-           if (Pid == PATPID)
-              patPmtParser.ParsePat(Data, TS_SIZE);
-           else if (patPmtParser.IsPmtPid(Pid))
-              patPmtParser.ParsePmt(Data, TS_SIZE);
-           else if (Pid == patPmtParser.Vpid()) {
-              if (TsPayloadStart(Data)) {
-                 int l;
-                 while (const uchar *p = TsToPes.GetPes(l)) {
-                       int Offset = Size;
-                       int NewSize = Size + l;
-                       if (uchar *NewBuffer = (uchar *)realloc(buf, NewSize)) {
-                          Size = NewSize;
-                          buf = NewBuffer;
-                          memcpy(buf + Offset, p, l);
-                          }
-                       else {
-                          LOG_ERROR_STR("out of memory");
-                          free(buf);
-                          return;
-                          }
-                       }
-                 TsToPes.Reset();
-                 }
-              TsToPes.PutTs(Data, TS_SIZE);
-              }
-           Length -= TS_SIZE;
-           Data += TS_SIZE;
-           }
-     int l;
-     while (const uchar *p = TsToPes.GetPes(l)) {
-           int Offset = Size;
-           int NewSize = Size + l;
-           if (uchar *NewBuffer = (uchar *)realloc(buf, NewSize)) {
-              Size = NewSize;
-              buf = NewBuffer;
-              memcpy(buf + Offset, p, l);
-              }
-           else {
-              esyslog("ERROR: out of memory");
-              free(buf);
-              return;
-              }
-           }
-     if (buf) {
-        StillPicture(buf, Size);
-        free(buf);
-        }
-     }
-}
-
-bool cDevice::Replaying(void) const
-{
-  return player != NULL;
-}
-
-bool cDevice::Transferring(void) const
-{
-  return cTransferControl::ReceiverDevice() != NULL;
-}
-
-bool cDevice::AttachPlayer(cPlayer *Player)
-{
-  if (CanReplay()) {
-     if (player)
-        Detach(player);
-     DELETENULL(liveSubtitle);
-     DELETENULL(dvbSubtitleConverter);
-     patPmtParser.Reset();
-     player = Player;
-     if (!Transferring())
-        ClrAvailableTracks(false, true);
-     SetPlayMode(player->playMode);
-     player->device = this;
-     player->Activate(true);
-     return true;
-     }
-  return false;
-}
-
-void cDevice::Detach(cPlayer *Player)
-{
-  if (Player && player == Player) {
-     cPlayer *p = player;
-     player = NULL; // avoids recursive calls to Detach()
-     p->Activate(false);
-     p->device = NULL;
-     cMutexLock MutexLock(&mutexCurrentSubtitleTrack);
-     delete dvbSubtitleConverter;
-     dvbSubtitleConverter = NULL;
-     SetPlayMode(pmNone);
-     SetVideoDisplayFormat(eVideoDisplayFormat(Setup.VideoDisplayFormat));
-     PlayTs(NULL, 0);
-     patPmtParser.Reset();
-     Audios.ClearAudio();
-     isPlayingVideo = false;
-     }
-}
-
-void cDevice::StopReplay(void)
-{
-  if (player) {
-     Detach(player);
-     if (IsPrimaryDevice())
-        cControl::Shutdown();
-     }
-}
-
-bool cDevice::Poll(cPoller &Poller, int TimeoutMs)
-{
-  return false;
-}
-
-bool cDevice::Flush(int TimeoutMs)
-{
-  return true;
-}
-
-int cDevice::PlayVideo(const uchar *Data, int Length)
-{
-  return -1;
-}
-
-int cDevice::PlayAudio(const uchar *Data, int Length, uchar Id)
-{
-  return -1;
-}
-
-int cDevice::PlaySubtitle(const uchar *Data, int Length)
-{
-  if (!dvbSubtitleConverter)
-     dvbSubtitleConverter = new cDvbSubtitleConverter;
-  return dvbSubtitleConverter->ConvertFragments(Data, Length);
-}
-
-int cDevice::PlayPesPacket(const uchar *Data, int Length, bool VideoOnly)
-{
-  cMutexLock MutexLock(&mutexCurrentAudioTrack);
-  bool FirstLoop = true;
-  uchar c = Data[3];
-  const uchar *Start = Data;
-  const uchar *End = Start + Length;
-  while (Start < End) {
-        int d = End - Start;
-        int w = d;
-        switch (c) {
-          case 0xBE:          // padding stream, needed for MPEG1
-          case 0xE0 ... 0xEF: // video
-               isPlayingVideo = true;
-               w = PlayVideo(Start, d);
-               break;
-          case 0xC0 ... 0xDF: // audio
-               SetAvailableTrack(ttAudio, c - 0xC0, c);
-               if ((!VideoOnly || HasIBPTrickSpeed()) && c == availableTracks[currentAudioTrack].id) {
-                  w = PlayAudio(Start, d, c);
-                  if (FirstLoop)
-                     Audios.PlayAudio(Data, Length, c);
-                  }
-               break;
-          case 0xBD: { // private stream 1
-               // EBU Teletext data, ETSI EN 300 472
-               // if PES data header length = 24 and data_identifier = 0x10..0x1F (EBU Data)
-               if (Data[8] == 0x24 && Data[45] >= 0x10 && Data[45] < 0x20) {
-                  cVDRTtxtsubsHookListener::Hook()->PlayerTeletextData((uint8_t*)Data, Length);
-                  break;
-                  }
-
-               int PayloadOffset = Data[8] + 9;
-
-               // Compatibility mode for old subtitles plugin:
-               if ((Data[7] & 0x01) && (Data[PayloadOffset - 3] & 0x81) == 0x01 && Data[PayloadOffset - 2] == 0x81)
-                  PayloadOffset--;
-
-               uchar SubStreamId = Data[PayloadOffset];
-               uchar SubStreamType = SubStreamId & 0xF0;
-               uchar SubStreamIndex = SubStreamId & 0x1F;
-
-               // Compatibility mode for old VDR recordings, where 0xBD was only AC3:
-pre_1_3_19_PrivateStreamDetected:
-               if (pre_1_3_19_PrivateStream > MIN_PRE_1_3_19_PRIVATESTREAM) {
-                  SubStreamId = c;
-                  SubStreamType = 0x80;
-                  SubStreamIndex = 0;
-                  }
-               else if (pre_1_3_19_PrivateStream)
-                  pre_1_3_19_PrivateStream--; // every known PS1 packet counts down towards 0 to recover from glitches...
-               switch (SubStreamType) {
-                 case 0x20: // SPU
-                 case 0x30: // SPU
-                      SetAvailableTrack(ttSubtitle, SubStreamIndex, SubStreamId);
-                      if ((!VideoOnly || HasIBPTrickSpeed()) && currentSubtitleTrack != ttNone && SubStreamId == availableTracks[currentSubtitleTrack].id)
-                         w = PlaySubtitle(Start, d);
-                      break;
-                 case 0x80: // AC3 & DTS
-                      if (Setup.UseDolbyDigital) {
-                         SetAvailableTrack(ttDolby, SubStreamIndex, SubStreamId);
-                         if ((!VideoOnly || HasIBPTrickSpeed()) && SubStreamId == availableTracks[currentAudioTrack].id) {
-                            w = PlayAudio(Start, d, SubStreamId);
-                            if (FirstLoop)
-                               Audios.PlayAudio(Data, Length, SubStreamId);
-                            }
-                         }
-                      break;
-                 case 0xA0: // LPCM
-                      SetAvailableTrack(ttAudio, SubStreamIndex, SubStreamId);
-                      if ((!VideoOnly || HasIBPTrickSpeed()) && SubStreamId == availableTracks[currentAudioTrack].id) {
-                         w = PlayAudio(Start, d, SubStreamId);
-                         if (FirstLoop)
-                            Audios.PlayAudio(Data, Length, SubStreamId);
-                         }
-                      break;
-                 default:
-                      // Compatibility mode for old VDR recordings, where 0xBD was only AC3:
-                      if (pre_1_3_19_PrivateStream <= MIN_PRE_1_3_19_PRIVATESTREAM) {
-                         dsyslog("unknown PS1 packet, substream id = %02X (counter is at %d)", SubStreamId, pre_1_3_19_PrivateStream);
-                         pre_1_3_19_PrivateStream += 2; // ...and every unknown PS1 packet counts up (the very first one counts twice, but that's ok)
-                         if (pre_1_3_19_PrivateStream > MIN_PRE_1_3_19_PRIVATESTREAM) {
-                            dsyslog("switching to pre 1.3.19 Dolby Digital compatibility mode - substream id = %02X", SubStreamId);
-                            ClrAvailableTracks();
-                            pre_1_3_19_PrivateStream = MIN_PRE_1_3_19_PRIVATESTREAM + 1;
-                            goto pre_1_3_19_PrivateStreamDetected;
-                            }
-                         }
-                 }
-               }
-               break;
-          default:
-               ;//esyslog("ERROR: unexpected packet id %02X", c);
-          }
-        if (w > 0)
-           Start += w;
-        else {
-           if (Start != Data)
-              esyslog("ERROR: incomplete PES packet write!");
-           return Start == Data ? w : Start - Data;
-           }
-        FirstLoop = false;
-        }
-  return Length;
-}
-
-int cDevice::PlayPes(const uchar *Data, int Length, bool VideoOnly)
-{
-  if (!Data) {
-     if (dvbSubtitleConverter)
-        dvbSubtitleConverter->Reset();
-     return 0;
-     }
-  int i = 0;
-  while (i <= Length - 6) {
-        if (Data[i] == 0x00 && Data[i + 1] == 0x00 && Data[i + 2] == 0x01) {
-           int l = PesLength(Data + i);
-           if (i + l > Length) {
-              esyslog("ERROR: incomplete PES packet!");
-              return Length;
-              }
-           int w = PlayPesPacket(Data + i, l, VideoOnly);
-           if (w > 0)
-              i += l;
-           else
-              return i == 0 ? w : i;
-           }
-        else
-           i++;
-        }
-  if (i < Length)
-     esyslog("ERROR: leftover PES data!");
-  return Length;
-}
-
-int cDevice::PlayTsVideo(const uchar *Data, int Length)
-{
-  // Video PES has no explicit length, so we can only determine the end of
-  // a PES packet when the next TS packet that starts a payload comes in:
-  if (TsPayloadStart(Data)) {
-     int l;
-     while (const uchar *p = tsToPesVideo.GetPes(l)) {
-           int w = PlayVideo(p, l);
-           if (w <= 0) {
-              tsToPesVideo.SetRepeatLast();
-              return w;
-              }
-           }
-     tsToPesVideo.Reset();
-     }
-  tsToPesVideo.PutTs(Data, Length);
-  return Length;
-}
-
-int cDevice::PlayTsAudio(const uchar *Data, int Length)
-{
-  // Audio PES always has an explicit length and consists of single packets:
-  int l;
-  if (const uchar *p = tsToPesAudio.GetPes(l)) {
-     int w = PlayAudio(p, l, p[3]);
-     if (w <= 0) {
-        tsToPesAudio.SetRepeatLast();
-        return w;
-        }
-     tsToPesAudio.Reset();
-     }
-  tsToPesAudio.PutTs(Data, Length);
-  return Length;
-}
-
-int cDevice::PlayTsSubtitle(const uchar *Data, int Length)
-{
-  if (!dvbSubtitleConverter)
-     dvbSubtitleConverter = new cDvbSubtitleConverter;
-  tsToPesSubtitle.PutTs(Data, Length);
-  int l;
-  if (const uchar *p = tsToPesSubtitle.GetPes(l)) {
-     dvbSubtitleConverter->Convert(p, l);
-     tsToPesSubtitle.Reset();
-     }
-  return Length;
-}
-
-//TODO detect and report continuity errors?
-int cDevice::PlayTs(const uchar *Data, int Length, bool VideoOnly)
-{
-  int Played = 0;
-  if (Data == NULL) {
-     tsToPesVideo.Reset();
-     tsToPesAudio.Reset();
-     tsToPesSubtitle.Reset();
-     tsToPesTeletext.Reset();
-     }
-  else if (Length < TS_SIZE) {
-     esyslog("ERROR: skipped %d bytes of TS fragment", Length);
-     return Length;
-     }
-  else {
-     cMutexLock MutexLock(&mutexCurrentAudioTrack);
-     while (Length >= TS_SIZE) {
-           if (Data[0] != TS_SYNC_BYTE) {
-              int Skipped = 1;
-              while (Skipped < Length && (Data[Skipped] != TS_SYNC_BYTE || Length - Skipped > TS_SIZE && Data[Skipped + TS_SIZE] != TS_SYNC_BYTE))
-                    Skipped++;
-              esyslog("ERROR: skipped %d bytes to sync on start of TS packet", Skipped);
-              return Played + Skipped;
-              }
-           int Pid = TsPid(Data);
-           if (TsHasPayload(Data)) { // silently ignore TS packets w/o payload
-              int PayloadOffset = TsPayloadOffset(Data);
-              if (PayloadOffset < TS_SIZE) {
-                 if (Pid == PATPID)
-                    patPmtParser.ParsePat(Data, TS_SIZE);
-                 else if (patPmtParser.IsPmtPid(Pid))
-                    patPmtParser.ParsePmt(Data, TS_SIZE);
-                 else if (Pid == patPmtParser.Vpid()) {
-                    isPlayingVideo = true;
-                    int w = PlayTsVideo(Data, TS_SIZE);
-                    if (w < 0)
-                       return Played ? Played : w;
-                    if (w == 0)
-                       break;
-                    }
-                 else if (Pid == availableTracks[currentAudioTrack].id) {
-                    if (!VideoOnly || HasIBPTrickSpeed()) {
-                       int w = PlayTsAudio(Data, TS_SIZE);
-                       if (w < 0)
-                          return Played ? Played : w;
-                       if (w == 0)
-                          break;
-                       Audios.PlayTsAudio(Data, TS_SIZE);
-                       }
-                    }
-                 else if (Pid == availableTracks[currentSubtitleTrack].id) {
-                    if (!VideoOnly || HasIBPTrickSpeed())
-                       PlayTsSubtitle(Data, TS_SIZE);
-                    }
-                 else if (Pid == patPmtParser.Tpid()) {
-                    if (!VideoOnly || HasIBPTrickSpeed()) {
-                       int l;
-                       tsToPesTeletext.PutTs(Data, Length);
-                       if (const uchar *p = tsToPesTeletext.GetPes(l)) {
-                          if ((l > 45) && (p[0] == 0x00) && (p[1] == 0x00) && (p[2] == 0x01) && (p[3] == 0xbd) && (p[8] == 0x24) && (p[45] >= 0x10) && (p[45] < 0x20))
-                             cVDRTtxtsubsHookListener::Hook()->PlayerTeletextData((uchar *)p, l, false, patPmtParser.TeletextSubtitlePages(), patPmtParser.TotalTeletextSubtitlePages());
-                          tsToPesTeletext.Reset();
-                          }
-                       }
-                    }
-                 }
-              }
-           else if (Pid == patPmtParser.Ppid()) {
-              int w = PlayTsVideo(Data, TS_SIZE);
-              if (w < 0)
-                 return Played ? Played : w;
-              if (w == 0)
-                 break;
-              }
-           Played += TS_SIZE;
-           Length -= TS_SIZE;
-           Data += TS_SIZE;
-           }
-     }
-  return Played;
-}
-
-int cDevice::Priority(void) const
-{
-  int priority = IDLEPRIORITY;
-  if (IsPrimaryDevice() && !Replaying() && HasProgramme())
-     priority = TRANSFERPRIORITY; // we use the same value here, no matter whether it's actual Transfer Mode or real live viewing
-  cMutexLock MutexLock(&mutexReceiver);
-  for (int i = 0; i < MAXRECEIVERS; i++) {
-      if (receiver[i])
-         priority = max(receiver[i]->priority, priority);
-      }
-  return priority;
-}
-
-bool cDevice::Ready(void)
-{
-  return true;
-}
-
-bool cDevice::Receiving(bool Dummy) const
-{
-  cMutexLock MutexLock(&mutexReceiver);
-  for (int i = 0; i < MAXRECEIVERS; i++) {
-      if (receiver[i])
-         return true;
-      }
-  return false;
-}
-
-#define TS_SCRAMBLING_TIMEOUT     3 // seconds to wait until a TS becomes unscrambled
-#define TS_SCRAMBLING_TIME_OK    10 // seconds before a Channel/CAM combination is marked as known to decrypt
-
-void cDevice::Action(void)
-{
-  if (Running() && OpenDvr()) {
-     while (Running()) {
-           // Read data from the DVR device:
-           uchar *b = NULL;
-           if (GetTSPacket(b)) {
-              if (b) {
-                 int Pid = TsPid(b);
-                 // Check whether the TS packets are scrambled:
-                 bool DetachReceivers = false;
-                 bool DescramblingOk = false;
-                 int CamSlotNumber = 0;
-                 if (startScrambleDetection) {
-                    cCamSlot *cs = CamSlot();
-                    CamSlotNumber = cs ? cs->SlotNumber() : 0;
-                    if (CamSlotNumber) {
-                       bool Scrambled = b[3] & TS_SCRAMBLING_CONTROL;
-                       int t = time(NULL) - startScrambleDetection;
-                       if (Scrambled) {
-                          if (t > TS_SCRAMBLING_TIMEOUT)
-                             DetachReceivers = true;
-                          }
-                       else if (t > TS_SCRAMBLING_TIME_OK) {
-                          DescramblingOk = true;
-                          startScrambleDetection = 0;
-                          }
-                       }
-                    }
-                 // Distribute the packet to all attached receivers:
-                 Lock();
-                 for (int i = 0; i < MAXRECEIVERS; i++) {
-                     if (receiver[i] && receiver[i]->WantsPid(Pid)) {
-                        if (DetachReceivers) {
-                           ChannelCamRelations.SetChecked(receiver[i]->ChannelID(), CamSlotNumber);
-                           Detach(receiver[i]);
-                           }
-                        else
-                           receiver[i]->Receive(b, TS_SIZE);
-                        if (DescramblingOk)
-                           ChannelCamRelations.SetDecrypt(receiver[i]->ChannelID(), CamSlotNumber);
-                        }
-                     }
-                 Unlock();
-                 }
-              }
-           else
-              break;
-           }
-     CloseDvr();
-     }
-}
-
-bool cDevice::OpenDvr(void)
-{
-  return false;
-}
-
-void cDevice::CloseDvr(void)
-{
-}
-
-bool cDevice::GetTSPacket(uchar *&Data)
-{
-  return false;
-}
-
-bool cDevice::AttachReceiver(cReceiver *Receiver)
-{
-  if (!Receiver)
-     return false;
-  if (Receiver->device == this)
-     return true;
-// activate the following line if you need it - actually the driver should be fixed!
-//#define WAIT_FOR_TUNER_LOCK
-#ifdef WAIT_FOR_TUNER_LOCK
-#define TUNER_LOCK_TIMEOUT 5000 // ms
-  if (!HasLock(TUNER_LOCK_TIMEOUT)) {
-     esyslog("ERROR: device %d has no lock, can't attach receiver!", CardIndex() + 1);
-     return false;
-     }
-#endif
-  cMutexLock MutexLock(&mutexReceiver);
-  for (int i = 0; i < MAXRECEIVERS; i++) {
-      if (!receiver[i]) {
-         for (int n = 0; n < Receiver->numPids; n++) {
-             if (!AddPid(Receiver->pids[n])) {
-                for ( ; n-- > 0; )
-                    DelPid(Receiver->pids[n]);
-                return false;
-                }
-             }
-         Receiver->Activate(true);
-         Lock();
-         Receiver->device = this;
-         receiver[i] = Receiver;
-         Unlock();
-         if (camSlot) {
-            camSlot->StartDecrypting();
-            startScrambleDetection = time(NULL);
-            }
-         Start();
-         return true;
-         }
-      }
-  esyslog("ERROR: no free receiver slot!");
-  return false;
-}
-
-void cDevice::Detach(cReceiver *Receiver)
-{
-  if (!Receiver || Receiver->device != this)
-     return;
-  bool receiversLeft = false;
-  cMutexLock MutexLock(&mutexReceiver);
-  for (int i = 0; i < MAXRECEIVERS; i++) {
-      if (receiver[i] == Receiver) {
-         Lock();
-         receiver[i] = NULL;
-         Receiver->device = NULL;
-         Unlock();
-         Receiver->Activate(false);
-         for (int n = 0; n < Receiver->numPids; n++)
-             DelPid(Receiver->pids[n]);
-         }
-      else if (receiver[i])
-         receiversLeft = true;
-      }
-  if (camSlot)
-     camSlot->StartDecrypting();
-  if (!receiversLeft)
-     Cancel(-1);
-}
-
-void cDevice::DetachAll(int Pid)
-{
-  if (Pid) {
-     cMutexLock MutexLock(&mutexReceiver);
-     for (int i = 0; i < MAXRECEIVERS; i++) {
-         cReceiver *Receiver = receiver[i];
-         if (Receiver && Receiver->WantsPid(Pid))
-            Detach(Receiver);
-         }
-     }
-}
-
-void cDevice::DetachAllReceivers(void)
-{
-  cMutexLock MutexLock(&mutexReceiver);
-  for (int i = 0; i < MAXRECEIVERS; i++)
-      Detach(receiver[i]);
-}
-
-// --- cTSBuffer -------------------------------------------------------------
-
-cTSBuffer::cTSBuffer(int File, int Size, int CardIndex)
-{
-  SetDescription("TS buffer on device %d", CardIndex);
-  f = File;
-  cardIndex = CardIndex;
-  delivered = false;
-  ringBuffer = new cRingBufferLinear(Size, TS_SIZE, true, "TS");
-  ringBuffer->SetTimeouts(100, 100);
-  ringBuffer->SetIoThrottle();
-  Start();
-}
-
-cTSBuffer::~cTSBuffer()
-{
-  Cancel(3);
-  delete ringBuffer;
-}
-
-void cTSBuffer::Action(void)
-{
-  if (ringBuffer) {
-     bool firstRead = true;
-     cPoller Poller(f);
-     while (Running()) {
-           if (firstRead || Poller.Poll(100)) {
-              firstRead = false;
-              int r = ringBuffer->Read(f);
-              if (r < 0 && FATALERRNO) {
-                 if (errno == EOVERFLOW)
-                    esyslog("ERROR: driver buffer overflow on device %d", cardIndex);
-                 else {
-                    LOG_ERROR;
-                    break;
-                    }
-                 }
-              }
-           }
-     }
-}
-
-uchar *cTSBuffer::Get(void)
-{
-  int Count = 0;
-  if (delivered) {
-     ringBuffer->Del(TS_SIZE);
-     delivered = false;
-     }
-  uchar *p = ringBuffer->Get(Count);
-  if (p && Count >= TS_SIZE) {
-     if (*p != TS_SYNC_BYTE) {
-        for (int i = 1; i < Count; i++) {
-            if (p[i] == TS_SYNC_BYTE) {
-               Count = i;
-               break;
-               }
-            }
-        ringBuffer->Del(Count);
-        esyslog("ERROR: skipped %d bytes to sync on TS packet on device %d", Count, cardIndex);
-        return NULL;
-        }
-     delivered = true;
-     return p;
-     }
-  return NULL;
-}
diff -urN vdr-1.7.38/dvbdevice.c.orig vdr-1.7.38-pa/dvbdevice.c.orig
--- vdr-1.7.38/dvbdevice.c.orig	2013-02-21 22:26:57.334776693 +0100
+++ vdr-1.7.38-pa/dvbdevice.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,1763 +0,0 @@
-/*
- * dvbdevice.c: The DVB device tuner interface
- *
- * See the main source file 'vdr.c' for copyright information and
- * how to reach the author.
- *
- * $Id: dvbdevice.c 2.80 2013/02/17 13:17:33 kls Exp $
- */
-
-#include "dvbdevice.h"
-#include <ctype.h>
-#include <errno.h>
-#include <limits.h>
-#include <linux/dvb/dmx.h>
-#include <linux/dvb/frontend.h>
-#include <sys/ioctl.h>
-#include <sys/mman.h>
-#include "channels.h"
-#include "diseqc.h"
-#include "dvbci.h"
-#include "menuitems.h"
-#include "sourceparams.h"
-
-#if (DVB_API_VERSION << 8 | DVB_API_VERSION_MINOR) < 0x0508
-#define DTV_STREAM_ID DTV_DVBT2_PLP_ID
-#endif
-
-#define DVBS_TUNE_TIMEOUT  9000 //ms
-#define DVBS_LOCK_TIMEOUT  2000 //ms
-#define DVBC_TUNE_TIMEOUT  9000 //ms
-#define DVBC_LOCK_TIMEOUT  2000 //ms
-#define DVBT_TUNE_TIMEOUT  9000 //ms
-#define DVBT_LOCK_TIMEOUT  2000 //ms
-#define ATSC_TUNE_TIMEOUT  9000 //ms
-#define ATSC_LOCK_TIMEOUT  2000 //ms
-
-#define SCR_RANDOM_TIMEOUT  500 // ms (add random value up to this when tuning SCR device to avoid lockups)
-
-// --- DVB Parameter Maps ----------------------------------------------------
-
-const tDvbParameterMap InversionValues[] = {
-  {   0, INVERSION_OFF,  trNOOP("off") },
-  {   1, INVERSION_ON,   trNOOP("on") },
-  { 999, INVERSION_AUTO, trNOOP("auto") },
-  {  -1, 0, NULL }
-  };
-
-const tDvbParameterMap BandwidthValues[] = {
-  {    5,  5000000, "5 MHz" },
-  {    6,  6000000, "6 MHz" },
-  {    7,  7000000, "7 MHz" },
-  {    8,  8000000, "8 MHz" },
-  {   10, 10000000, "10 MHz" },
-  { 1712,  1712000, "1.712 MHz" },
-  {  -1, 0, NULL }
-  };
-
-const tDvbParameterMap CoderateValues[] = {
-  {   0, FEC_NONE, trNOOP("none") },
-  {  12, FEC_1_2,  "1/2" },
-  {  23, FEC_2_3,  "2/3" },
-  {  34, FEC_3_4,  "3/4" },
-  {  35, FEC_3_5,  "3/5" },
-  {  45, FEC_4_5,  "4/5" },
-  {  56, FEC_5_6,  "5/6" },
-  {  67, FEC_6_7,  "6/7" },
-  {  78, FEC_7_8,  "7/8" },
-  {  89, FEC_8_9,  "8/9" },
-  { 910, FEC_9_10, "9/10" },
-  { 999, FEC_AUTO, trNOOP("auto") },
-  {  -1, 0, NULL }
-  };
-
-const tDvbParameterMap ModulationValues[] = {
-  {  16, QAM_16,   "QAM16" },
-  {  32, QAM_32,   "QAM32" },
-  {  64, QAM_64,   "QAM64" },
-  { 128, QAM_128,  "QAM128" },
-  { 256, QAM_256,  "QAM256" },
-  {   2, QPSK,     "QPSK" },
-  {   5, PSK_8,    "8PSK" },
-  {   6, APSK_16,  "16APSK" },
-  {   7, APSK_32,  "32APSK" },
-  {  10, VSB_8,    "VSB8" },
-  {  11, VSB_16,   "VSB16" },
-  {  12, DQPSK,    "DQPSK" },
-  { 999, QAM_AUTO, trNOOP("auto") },
-  {  -1, 0, NULL }
-  };
-
-#define DVB_SYSTEM_1 0 // see also nit.c
-#define DVB_SYSTEM_2 1
-
-const tDvbParameterMap SystemValuesSat[] = {
-  {   0, DVB_SYSTEM_1, "DVB-S" },
-  {   1, DVB_SYSTEM_2, "DVB-S2" },
-  {  -1, 0, NULL }
-  };
-
-const tDvbParameterMap SystemValuesTerr[] = {
-  {   0, DVB_SYSTEM_1, "DVB-T" },
-  {   1, DVB_SYSTEM_2, "DVB-T2" },
-  {  -1, 0, NULL }
-  };
-
-const tDvbParameterMap TransmissionValues[] = {
-  {   1, TRANSMISSION_MODE_1K,   "1K" },
-  {   2, TRANSMISSION_MODE_2K,   "2K" },
-  {   4, TRANSMISSION_MODE_4K,   "4K" },
-  {   8, TRANSMISSION_MODE_8K,   "8K" },
-  {  16, TRANSMISSION_MODE_16K,  "16K" },
-  {  32, TRANSMISSION_MODE_32K,  "32K" },
-  { 999, TRANSMISSION_MODE_AUTO, trNOOP("auto") },
-  {  -1, 0, NULL }
-  };
-
-const tDvbParameterMap GuardValues[] = {
-  {     4, GUARD_INTERVAL_1_4,    "1/4" },
-  {     8, GUARD_INTERVAL_1_8,    "1/8" },
-  {    16, GUARD_INTERVAL_1_16,   "1/16" },
-  {    32, GUARD_INTERVAL_1_32,   "1/32" },
-  {   128, GUARD_INTERVAL_1_128,  "1/128" },
-  { 19128, GUARD_INTERVAL_19_128, "19/128" },
-  { 19256, GUARD_INTERVAL_19_256, "19/256" },
-  {   999, GUARD_INTERVAL_AUTO,   trNOOP("auto") },
-  {  -1, 0, NULL }
-  };
-
-const tDvbParameterMap HierarchyValues[] = {
-  {   0, HIERARCHY_NONE, trNOOP("none") },
-  {   1, HIERARCHY_1,    "1" },
-  {   2, HIERARCHY_2,    "2" },
-  {   4, HIERARCHY_4,    "4" },
-  { 999, HIERARCHY_AUTO, trNOOP("auto") },
-  {  -1, 0, NULL }
-  };
-
-const tDvbParameterMap RollOffValues[] = {
-  {   0, ROLLOFF_AUTO, trNOOP("auto") },
-  {  20, ROLLOFF_20, "0.20" },
-  {  25, ROLLOFF_25, "0.25" },
-  {  35, ROLLOFF_35, "0.35" },
-  {  -1, 0, NULL }
-  };
-
-int UserIndex(int Value, const tDvbParameterMap *Map)
-{
-  const tDvbParameterMap *map = Map;
-  while (map && map->userValue != -1) {
-        if (map->userValue == Value)
-           return map - Map;
-        map++;
-        }
-  return -1;
-}
-
-int DriverIndex(int Value, const tDvbParameterMap *Map)
-{
-  const tDvbParameterMap *map = Map;
-  while (map && map->userValue != -1) {
-        if (map->driverValue == Value)
-           return map - Map;
-        map++;
-        }
-  return -1;
-}
-
-int MapToUser(int Value, const tDvbParameterMap *Map, const char **String)
-{
-  int n = DriverIndex(Value, Map);
-  if (n >= 0) {
-     if (String)
-        *String = tr(Map[n].userString);
-     return Map[n].userValue;
-     }
-  return -1;
-}
-
-const char *MapToUserString(int Value, const tDvbParameterMap *Map)
-{
-  int n = DriverIndex(Value, Map);
-  if (n >= 0)
-     return Map[n].userString;
-  return "???";
-}
-
-int MapToDriver(int Value, const tDvbParameterMap *Map)
-{
-  int n = UserIndex(Value, Map);
-  if (n >= 0)
-     return Map[n].driverValue;
-  return -1;
-}
-
-// --- cDvbTransponderParameters ---------------------------------------------
-
-cDvbTransponderParameters::cDvbTransponderParameters(const char *Parameters)
-{
-  polarization = 0;
-  inversion    = INVERSION_AUTO;
-  bandwidth    = 8000000;
-  coderateH    = FEC_AUTO;
-  coderateL    = FEC_AUTO;
-  modulation   = QPSK;
-  system       = DVB_SYSTEM_1;
-  transmission = TRANSMISSION_MODE_AUTO;
-  guard        = GUARD_INTERVAL_AUTO;
-  hierarchy    = HIERARCHY_AUTO;
-  rollOff      = ROLLOFF_AUTO;
-  plpId        = 0;
-  Parse(Parameters);
-}
-
-int cDvbTransponderParameters::PrintParameter(char *p, char Name, int Value) const
-{
-  return Value >= 0 && Value != 999 ? sprintf(p, "%c%d", Name, Value) : 0;
-}
-
-cString cDvbTransponderParameters::ToString(char Type) const
-{
-#define ST(s) if (strchr(s, Type) && (strchr(s, '0' + system + 1) || strchr(s, '*')))
-  char buffer[64];
-  char *q = buffer;
-  *q = 0;
-  ST("  S *")  q += sprintf(q, "%c", polarization);
-  ST("   T*")  q += PrintParameter(q, 'B', MapToUser(bandwidth, BandwidthValues));
-  ST(" CST*")  q += PrintParameter(q, 'C', MapToUser(coderateH, CoderateValues));
-  ST("   T*")  q += PrintParameter(q, 'D', MapToUser(coderateL, CoderateValues));
-  ST("   T*")  q += PrintParameter(q, 'G', MapToUser(guard, GuardValues));
-  ST("ACST*")  q += PrintParameter(q, 'I', MapToUser(inversion, InversionValues));
-  ST("ACST*")  q += PrintParameter(q, 'M', MapToUser(modulation, ModulationValues));
-  ST("  S 2")  q += PrintParameter(q, 'O', MapToUser(rollOff, RollOffValues));
-  ST("   T2")  q += PrintParameter(q, 'P', plpId);
-  ST("  ST*")  q += PrintParameter(q, 'S', MapToUser(system, SystemValuesSat)); // we only need the numerical value, so Sat or Terr doesn't matter
-  ST("   T*")  q += PrintParameter(q, 'T', MapToUser(transmission, TransmissionValues));
-  ST("   T*")  q += PrintParameter(q, 'Y', MapToUser(hierarchy, HierarchyValues));
-  return buffer;
-}
-
-const char *cDvbTransponderParameters::ParseParameter(const char *s, int &Value, const tDvbParameterMap *Map)
-{
-  if (*++s) {
-     char *p = NULL;
-     errno = 0;
-     int n = strtol(s, &p, 10);
-     if (!errno && p != s) {
-        Value = Map ? MapToDriver(n, Map) : n;
-        if (Value >= 0)
-           return p;
-        }
-     }
-  esyslog("ERROR: invalid value for parameter '%c'", *(s - 1));
-  return NULL;
-}
-
-bool cDvbTransponderParameters::Parse(const char *s)
-{
-  while (s && *s) {
-        switch (toupper(*s)) {
-          case 'B': s = ParseParameter(s, bandwidth, BandwidthValues); break;
-          case 'C': s = ParseParameter(s, coderateH, CoderateValues); break;
-          case 'D': s = ParseParameter(s, coderateL, CoderateValues); break;
-          case 'G': s = ParseParameter(s, guard, GuardValues); break;
-          case 'H': polarization = 'H'; s++; break;
-          case 'I': s = ParseParameter(s, inversion, InversionValues); break;
-          case 'L': polarization = 'L'; s++; break;
-          case 'M': s = ParseParameter(s, modulation, ModulationValues); break;
-          case 'O': s = ParseParameter(s, rollOff, RollOffValues); break;
-          case 'P': s = ParseParameter(s, plpId); break;
-          case 'R': polarization = 'R'; s++; break;
-          case 'S': s = ParseParameter(s, system, SystemValuesSat); break; // we only need the numerical value, so Sat or Terr doesn't matter
-          case 'T': s = ParseParameter(s, transmission, TransmissionValues); break;
-          case 'V': polarization = 'V'; s++; break;
-          case 'Y': s = ParseParameter(s, hierarchy, HierarchyValues); break;
-          default: esyslog("ERROR: unknown parameter key '%c'", *s);
-                   return false;
-          }
-        }
-  return true;
-}
-
-// --- cDvbTuner -------------------------------------------------------------
-
-#define TUNER_POLL_TIMEOUT  10 // ms
-
-class cDvbTuner : public cThread {
-private:
-  static cMutex bondMutex;
-  enum eTunerStatus { tsIdle, tsSet, tsTuned, tsLocked };
-  bool SendDiseqc;
-  int frontendType;
-  const cDvbDevice *device;
-  mutable int fd_frontend;
-  int adapter, frontend;
-  uint32_t subsystemId;
-  int tuneTimeout;
-  int lockTimeout;
-  time_t lastTimeoutReport;
-  cChannel channel;
-  const cDiseqc *lastDiseqc;
-  const cScr *scr;
-  bool lnbPowerTurnedOn;
-  eTunerStatus tunerStatus;
-  mutable cMutex mutex;
-  cCondVar locked;
-  cCondVar newSet;
-  dvb_diseqc_master_cmd diseqc_cmd;
-  cDvbTuner *bondedTuner;
-  bool bondedMaster;
-  bool SetFrontendType(const cChannel *Channel);
-  cString GetBondingParams(const cChannel *Channel = NULL) const;
-  void ClearEventQueue(void) const;
-  bool GetFrontendStatus(fe_status_t &Status) const;
-  void ExecuteDiseqc(const cDiseqc *Diseqc, unsigned int *Frequency);
-  void ResetToneAndVoltage(void);
-  bool SetFrontend(void);
-  virtual void Action(void);
-
-  mutable bool isIdle;
-  bool OpenFrontend(void) const;
-  bool CloseFrontend(void);
-public:
-  cDvbTuner(const cDvbDevice *Device, int Fd_Frontend, int Adapter, int Frontend);
-  virtual ~cDvbTuner();
-  int FrontendType(void) const { return frontendType; }
-  bool Bond(cDvbTuner *Tuner);
-  void UnBond(void);
-  bool BondingOk(const cChannel *Channel, bool ConsiderOccupied = false) const;
-  cDvbTuner *GetBondedMaster(void);
-  const cChannel *GetTransponder(void) const { return &channel; }
-  uint32_t SubsystemId(void) const { return subsystemId; }
-  bool IsTunedTo(const cChannel *Channel) const;
-  void SetChannel(const cChannel *Channel);
-  bool Locked(int TimeoutMs = 0);
-  int GetSignalStrength(void) const;
-  int GetSignalQuality(void) const;
-  bool SendDiseqcCmd(dvb_diseqc_master_cmd cmd);
-  bool SetIdle(bool Idle);
-  bool IsIdle(void) const { return isIdle; }
-private:
-  int GetCurrentDeliverySystem(void);
-  };
-
-cMutex cDvbTuner::bondMutex;
-
-cDvbTuner::cDvbTuner(const cDvbDevice *Device, int Fd_Frontend, int Adapter, int Frontend)
-{
-  SendDiseqc = false;
-  frontendType = SYS_UNDEFINED;
-  device = Device;
-  fd_frontend = Fd_Frontend;
-  adapter = Adapter;
-  frontend = Frontend;
-  subsystemId = cDvbDeviceProbe::GetSubsystemId(adapter, frontend);
-  tuneTimeout = 0;
-  lockTimeout = 0;
-  lastTimeoutReport = 0;
-  lastDiseqc = NULL;
-  scr = NULL;
-  lnbPowerTurnedOn = false;
-  tunerStatus = tsIdle;
-  bondedTuner = NULL;
-  bondedMaster = false;
-  isIdle = false;
-  SetDescription("tuner on frontend %d/%d", adapter, frontend);
-  Start();
-}
-
-cDvbTuner::~cDvbTuner()
-{
-  tunerStatus = tsIdle;
-  newSet.Broadcast();
-  locked.Broadcast();
-  Cancel(3);
-  UnBond();
-  /* looks like this irritates the SCR switch, so let's leave it out for now
-  if (lastDiseqc && lastDiseqc->IsScr()) {
-     unsigned int Frequency = 0;
-     ExecuteDiseqc(lastDiseqc, &Frequency);
-     }
-  */
-  if (device && device->IsSubDevice())
-     CloseFrontend();
-}
-
-bool cDvbTuner::Bond(cDvbTuner *Tuner)
-{
-  cMutexLock MutexLock(&bondMutex);
-  if (!bondedTuner) {
-     ResetToneAndVoltage();
-     bondedMaster = false; // makes sure we don't disturb an existing master
-     bondedTuner = Tuner->bondedTuner ? Tuner->bondedTuner : Tuner;
-     Tuner->bondedTuner = this;
-     dsyslog("tuner %d/%d bonded with tuner %d/%d", adapter, frontend, bondedTuner->adapter, bondedTuner->frontend);
-     return true;
-     }
-  else
-     esyslog("ERROR: tuner %d/%d already bonded with tuner %d/%d, can't bond with tuner %d/%d", adapter, frontend, bondedTuner->adapter, bondedTuner->frontend, Tuner->adapter, Tuner->frontend);
-  return false;
-}
-
-void cDvbTuner::UnBond(void)
-{
-  cMutexLock MutexLock(&bondMutex);
-  if (cDvbTuner *t = bondedTuner) {
-     dsyslog("tuner %d/%d unbonded from tuner %d/%d", adapter, frontend, bondedTuner->adapter, bondedTuner->frontend);
-     while (t->bondedTuner != this)
-           t = t->bondedTuner;
-     if (t == bondedTuner)
-        t->bondedTuner = NULL;
-     else
-        t->bondedTuner = bondedTuner;
-     bondedMaster = false; // another one will automatically become master whenever necessary
-     bondedTuner = NULL;
-     }
-}
-
-cString cDvbTuner::GetBondingParams(const cChannel *Channel) const
-{
-  if (!Channel)
-     Channel = &channel;
-  cDvbTransponderParameters dtp(Channel->Parameters());
-  if (Setup.DiSEqC) {
-     if (const cDiseqc *diseqc = Diseqcs.Get(device->CardIndex() + 1, Channel->Source(), Channel->Frequency(), dtp.Polarization(), NULL))
-        return diseqc->Commands();
-     }
-  else {
-     bool ToneOff = Channel->Frequency() < Setup.LnbSLOF;
-     bool VoltOff = dtp.Polarization() == 'V' || dtp.Polarization() == 'R';
-     return cString::sprintf("%c %c", ToneOff ? 't' : 'T', VoltOff ? 'v' : 'V');
-     }
-  return "";
-}
-
-bool cDvbTuner::BondingOk(const cChannel *Channel, bool ConsiderOccupied) const
-{
-  cMutexLock MutexLock(&bondMutex);
-  if (cDvbTuner *t = bondedTuner) {
-     cString BondingParams = GetBondingParams(Channel);
-     do {
-        if (t->device->Priority() > IDLEPRIORITY || ConsiderOccupied && t->device->Occupied()) {
-           if (strcmp(BondingParams, t->GetBondingParams()) != 0)
-              return false;
-           }
-        t = t->bondedTuner;
-        } while (t != bondedTuner);
-     }
-  return true;
-}
-
-cDvbTuner *cDvbTuner::GetBondedMaster(void)
-{
-  if (!bondedTuner)
-     return this; // an unbonded tuner is always "master"
-  cMutexLock MutexLock(&bondMutex);
-  if (bondedMaster)
-     return this;
-  // This tuner is bonded, but it's not the master, so let's see if there is a master at all:
-  if (cDvbTuner *t = bondedTuner) {
-     while (t != this) {
-           if (t->bondedMaster)
-              return t;
-           t = t->bondedTuner;
-           }
-     }
-  // None of the other bonded tuners is master, so make this one the master:
-  bondedMaster = true;
-  dsyslog("tuner %d/%d is now bonded master", adapter, frontend);
-  return this;
-}
-
-bool cDvbTuner::IsTunedTo(const cChannel *Channel) const
-{
-  if (tunerStatus == tsIdle)
-     return false; // not tuned to
-  if (channel.Source() != Channel->Source() || channel.Transponder() != Channel->Transponder())
-     return false; // sufficient mismatch
-  // Polarization is already checked as part of the Transponder.
-  return strcmp(channel.Parameters(), Channel->Parameters()) == 0;
-}
-
-void cDvbTuner::SetChannel(const cChannel *Channel)
-{
-  if (Channel) {
-     if (bondedTuner) {
-        cMutexLock MutexLock(&bondMutex);
-        cDvbTuner *BondedMaster = GetBondedMaster();
-        if (BondedMaster == this) {
-           if (strcmp(GetBondingParams(Channel), GetBondingParams()) != 0) {
-              // switching to a completely different band, so set all others to idle:
-              for (cDvbTuner *t = bondedTuner; t && t != this; t = t->bondedTuner)
-                  t->SetChannel(NULL);
-              }
-           }
-        else if (strcmp(GetBondingParams(Channel), BondedMaster->GetBondingParams()) != 0)
-           BondedMaster->SetChannel(Channel);
-        }
-     cMutexLock MutexLock(&mutex);
-     if (!IsTunedTo(Channel))
-        tunerStatus = tsSet;
-     channel = *Channel;
-     lastTimeoutReport = 0;
-     newSet.Broadcast();
-     }
-  else {
-     cMutexLock MutexLock(&mutex);
-     tunerStatus = tsIdle;
-     ResetToneAndVoltage();
-     }
-  if (bondedTuner && device->IsPrimaryDevice())
-     cDevice::PrimaryDevice()->DelLivePids(); // 'device' is const, so we must do it this way
-}
-
-bool cDvbTuner::Locked(int TimeoutMs)
-{
-  bool isLocked = (tunerStatus >= tsLocked);
-  if (isLocked || !TimeoutMs)
-     return isLocked;
-
-  cMutexLock MutexLock(&mutex);
-  if (TimeoutMs && tunerStatus < tsLocked)
-     locked.TimedWait(mutex, TimeoutMs);
-  return tunerStatus >= tsLocked;
-}
-
-void cDvbTuner::ClearEventQueue(void) const
-{
-  if (!OpenFrontend())
-     return;
-  cPoller Poller(fd_frontend);
-  if (Poller.Poll(TUNER_POLL_TIMEOUT)) {
-     dvb_frontend_event Event;
-     while (ioctl(fd_frontend, FE_GET_EVENT, &Event) == 0)
-           ; // just to clear the event queue - we'll read the actual status below
-     }
-}
-
-bool cDvbTuner::GetFrontendStatus(fe_status_t &Status) const
-{
-  ClearEventQueue();
-  while (1) {
-        if (ioctl(fd_frontend, FE_READ_STATUS, &Status) != -1)
-           return true;
-        if (errno != EINTR)
-           break;
-        }
-  return false;
-}
-
-//#define DEBUG_SIGNALSTRENGTH
-//#define DEBUG_SIGNALQUALITY
-
-int cDvbTuner::GetSignalStrength(void) const
-{
-  ClearEventQueue();
-  uint16_t Signal;
-  while (1) {
-        if (ioctl(fd_frontend, FE_READ_SIGNAL_STRENGTH, &Signal) != -1)
-           break;
-        if (errno != EINTR)
-           return -1;
-        }
-  uint16_t MaxSignal = 0xFFFF; // Let's assume the default is using the entire range.
-  // Use the subsystemId to identify individual devices in case they need
-  // special treatment to map their Signal value into the range 0...0xFFFF.
-  switch (subsystemId) {
-    case 0x13C21019: MaxSignal = 670; break; // TT-budget S2-3200 (DVB-S/DVB-S2)
-    }
-  int s = int(Signal) * 100 / MaxSignal;
-  if (s > 100)
-     s = 100;
-#ifdef DEBUG_SIGNALSTRENGTH
-  fprintf(stderr, "FE %d/%d: %08X S = %04X %04X %3d%%\n", adapter, frontend, subsystemId, MaxSignal, Signal, s);
-#endif
-  return s;
-}
-
-#define LOCK_THRESHOLD 5 // indicates that all 5 FE_HAS_* flags are set
-
-int cDvbTuner::GetSignalQuality(void) const
-{
-  fe_status_t Status;
-  if (GetFrontendStatus(Status)) {
-     // Actually one would expect these checks to be done from FE_HAS_SIGNAL to FE_HAS_LOCK, but some drivers (like the stb0899) are broken, so FE_HAS_LOCK is the only one that (hopefully) is generally reliable...
-     if ((Status & FE_HAS_LOCK) == 0) {
-        if ((Status & FE_HAS_SIGNAL) == 0)
-           return 0;
-        if ((Status & FE_HAS_CARRIER) == 0)
-           return 1;
-        if ((Status & FE_HAS_VITERBI) == 0)
-           return 2;
-        if ((Status & FE_HAS_SYNC) == 0)
-           return 3;
-        return 4;
-        }
-#ifdef DEBUG_SIGNALQUALITY
-     bool HasSnr = true;
-#endif
-     uint16_t Snr;
-     while (1) {
-           if (ioctl(fd_frontend, FE_READ_SNR, &Snr) != -1)
-              break;
-           if (errno != EINTR) {
-              Snr = 0xFFFF;
-#ifdef DEBUG_SIGNALQUALITY
-              HasSnr = false;
-#endif
-              break;
-              }
-           }
-#ifdef DEBUG_SIGNALQUALITY
-     bool HasBer = true;
-#endif
-     uint32_t Ber;
-     while (1) {
-           if (ioctl(fd_frontend, FE_READ_BER, &Ber) != -1)
-              break;
-           if (errno != EINTR) {
-              Ber = 0;
-#ifdef DEBUG_SIGNALQUALITY
-              HasBer = false;
-#endif
-              break;
-              }
-           }
-#ifdef DEBUG_SIGNALQUALITY
-     bool HasUnc = true;
-#endif
-     uint32_t Unc;
-     while (1) {
-           if (ioctl(fd_frontend, FE_READ_UNCORRECTED_BLOCKS, &Unc) != -1)
-              break;
-           if (errno != EINTR) {
-              Unc = 0;
-#ifdef DEBUG_SIGNALQUALITY
-              HasUnc = false;
-#endif
-              break;
-              }
-           }
-     uint16_t MaxSnr = 0xFFFF; // Let's assume the default is using the entire range.
-     // Use the subsystemId to identify individual devices in case they need
-     // special treatment to map their Snr value into the range 0...0xFFFF.
-     switch (subsystemId) {
-       case 0x13C21019: MaxSnr = 200; break; // TT-budget S2-3200 (DVB-S/DVB-S2)
-       case 0x20130245:                      // PCTV Systems PCTV 73ESE
-       case 0x2013024F: MaxSnr = 255; break; // PCTV Systems nanoStick T2 290e
-       }
-     int a = int(Snr) * 100 / MaxSnr;
-     int b = 100 - (Unc * 10 + (Ber / 256) * 5);
-     if (b < 0)
-        b = 0;
-     int q = LOCK_THRESHOLD + a * b * (100 - LOCK_THRESHOLD) / 100 / 100;
-     if (q > 100)
-        q = 100;
-#ifdef DEBUG_SIGNALQUALITY
-     fprintf(stderr, "FE %d/%d: %08X Q = %04X %04X %d %5d %5d %3d%%\n", adapter, frontend, subsystemId, MaxSnr, Snr, HasSnr, HasBer ? int(Ber) : -1, HasUnc ? int(Unc) : -1, q);
-#endif
-     return q;
-     }
-  return -1;
-}
-
-int cDvbTuner::GetCurrentDeliverySystem()
-{
-  dtv_property Frontend[1];
-  memset(&Frontend, 0, sizeof(Frontend));
-  dtv_properties CmdSeq;
-  memset(&CmdSeq, 0, sizeof(CmdSeq));
-  CmdSeq.props = Frontend;
-  Frontend[0].cmd = DTV_DELIVERY_SYSTEM;
-  Frontend[0].u.data = 0;
-  if (ioctl(fd_frontend, FE_GET_PROPERTY, &CmdSeq) < 0) {
-     esyslog("ERROR: frontend %d/%d: %m", adapter, frontend);
-     return SYS_UNDEFINED;
-     }
-  return Frontend[0].u.data;
-}
-
-bool cDvbTuner::SendDiseqcCmd(dvb_diseqc_master_cmd cmd)
-{
-  cMutexLock MutexLock(&mutex);
-  int frontendType = GetCurrentDeliverySystem();
-  if ((frontendType != SYS_DVBS && frontendType != SYS_DVBS2) || SendDiseqc)
-    return false;
-  diseqc_cmd=cmd;
-  SendDiseqc=true;
-  newSet.Broadcast();
-  return true;
-}
-
-
-static unsigned int FrequencyToHz(unsigned int f)
-{
-  while (f && f < 1000000)
-        f *= 1000;
-  return f;
-}
-
-void cDvbTuner::ExecuteDiseqc(const cDiseqc *Diseqc, unsigned int *Frequency)
-{
-  if (!lnbPowerTurnedOn) {
-     CHECK(ioctl(fd_frontend, FE_SET_VOLTAGE, SEC_VOLTAGE_13)); // must explicitly turn on LNB power
-     lnbPowerTurnedOn = true;
-     }
-  static cMutex Mutex;
-  if (Diseqc->IsScr())
-     Mutex.Lock();
-  struct dvb_diseqc_master_cmd cmd;
-  const char *CurrentAction = NULL;
-  for (;;) {
-      cmd.msg_len = sizeof(cmd.msg);
-      cDiseqc::eDiseqcActions da = Diseqc->Execute(&CurrentAction, cmd.msg, &cmd.msg_len, scr, Frequency);
-      if (da == cDiseqc::daNone)
-         break;
-      switch (da) {
-        case cDiseqc::daToneOff:   CHECK(ioctl(fd_frontend, FE_SET_TONE, SEC_TONE_OFF)); break;
-        case cDiseqc::daToneOn:    CHECK(ioctl(fd_frontend, FE_SET_TONE, SEC_TONE_ON)); break;
-        case cDiseqc::daVoltage13: CHECK(ioctl(fd_frontend, FE_SET_VOLTAGE, SEC_VOLTAGE_13)); break;
-        case cDiseqc::daVoltage18: CHECK(ioctl(fd_frontend, FE_SET_VOLTAGE, SEC_VOLTAGE_18)); break;
-        case cDiseqc::daMiniA:     CHECK(ioctl(fd_frontend, FE_DISEQC_SEND_BURST, SEC_MINI_A)); break;
-        case cDiseqc::daMiniB:     CHECK(ioctl(fd_frontend, FE_DISEQC_SEND_BURST, SEC_MINI_B)); break;
-        case cDiseqc::daCodes:     CHECK(ioctl(fd_frontend, FE_DISEQC_SEND_MASTER_CMD, &cmd)); break;
-        default: esyslog("ERROR: unknown diseqc command %d", da);
-        }
-      }
-  if (scr)
-     ResetToneAndVoltage(); // makes sure we don't block the bus!
-  if (Diseqc->IsScr())
-     Mutex.Unlock();
-}
-
-void cDvbTuner::ResetToneAndVoltage(void)
-{
-  CHECK(ioctl(fd_frontend, FE_SET_VOLTAGE, SEC_VOLTAGE_13));
-  CHECK(ioctl(fd_frontend, FE_SET_TONE, SEC_TONE_OFF));
-}
-
-static int GetRequiredDeliverySystem(const cChannel *Channel, const cDvbTransponderParameters *Dtp)
-{
-  int ds = SYS_UNDEFINED;
-  if (Channel->IsAtsc())
-     ds = SYS_ATSC;
-  else if (Channel->IsCable())
-     ds = SYS_DVBC_ANNEX_AC;
-  else if (Channel->IsSat())
-     ds = Dtp->System() == DVB_SYSTEM_1 ? SYS_DVBS : SYS_DVBS2;
-  else if (Channel->IsTerr())
-     ds = Dtp->System() == DVB_SYSTEM_1 ? SYS_DVBT : SYS_DVBT2;
-  else
-     esyslog("ERROR: can't determine frontend type for channel %d", Channel->Number());
-  return ds;
-}
-
-bool cDvbTuner::SetFrontend(void)
-{
-  if (!OpenFrontend())
-     return false;
-#define MAXFRONTENDCMDS 16
-#define SETCMD(c, d) { Frontend[CmdSeq.num].cmd = (c);\
-                       Frontend[CmdSeq.num].u.data = (d);\
-                       if (CmdSeq.num++ > MAXFRONTENDCMDS) {\
-                          esyslog("ERROR: too many tuning commands on frontend %d/%d", adapter, frontend);\
-                          return false;\
-                          }\
-                     }
-  dtv_property Frontend[MAXFRONTENDCMDS];
-  memset(&Frontend, 0, sizeof(Frontend));
-  dtv_properties CmdSeq;
-  memset(&CmdSeq, 0, sizeof(CmdSeq));
-  CmdSeq.props = Frontend;
-  SETCMD(DTV_CLEAR, 0);
-  if (ioctl(fd_frontend, FE_SET_PROPERTY, &CmdSeq) < 0) {
-     esyslog("ERROR: frontend %d/%d: %m", adapter, frontend);
-     return false;
-     }
-  CmdSeq.num = 0;
-
-  cDvbTransponderParameters dtp(channel.Parameters());
-
-  // Determine the required frontend type:
-  frontendType = GetRequiredDeliverySystem(&channel, &dtp);
-  if (frontendType == SYS_UNDEFINED)
-     return false;
-
-  SETCMD(DTV_DELIVERY_SYSTEM, frontendType);
-  if (frontendType == SYS_DVBS || frontendType == SYS_DVBS2) {
-     unsigned int frequency = channel.Frequency();
-     if (Setup.DiSEqC) {
-        if (const cDiseqc *diseqc = Diseqcs.Get(device->CardIndex() + 1, channel.Source(), frequency, dtp.Polarization(), &scr)) {
-           frequency -= diseqc->Lof();
-           if (diseqc != lastDiseqc || diseqc->IsScr()) {
-              if (GetBondedMaster() == this) {
-                 ExecuteDiseqc(diseqc, &frequency);
-                 if (frequency == 0)
-                    return false;
-                 }
-              else
-                 ResetToneAndVoltage();
-              lastDiseqc = diseqc;
-              }
-           }
-        else {
-           esyslog("ERROR: no DiSEqC parameters found for channel %d", channel.Number());
-           return false;
-           }
-        }
-     else {
-        int tone = SEC_TONE_OFF;
-        if (frequency < (unsigned int)Setup.LnbSLOF) {
-           frequency -= Setup.LnbFrequLo;
-           tone = SEC_TONE_OFF;
-           }
-        else {
-           frequency -= Setup.LnbFrequHi;
-           tone = SEC_TONE_ON;
-           }
-        int volt = (dtp.Polarization() == 'V' || dtp.Polarization() == 'R') ? SEC_VOLTAGE_13 : SEC_VOLTAGE_18;
-        if (GetBondedMaster() != this) {
-           tone = SEC_TONE_OFF;
-           volt = SEC_VOLTAGE_13;
-           }
-        CHECK(ioctl(fd_frontend, FE_SET_VOLTAGE, volt));
-        CHECK(ioctl(fd_frontend, FE_SET_TONE, tone));
-        }
-     frequency = abs(frequency); // Allow for C-band, where the frequency is less than the LOF
-
-     // DVB-S/DVB-S2 (common parts)
-     SETCMD(DTV_FREQUENCY, frequency * 1000UL);
-     SETCMD(DTV_MODULATION, dtp.Modulation());
-     SETCMD(DTV_SYMBOL_RATE, channel.Srate() * 1000UL);
-     SETCMD(DTV_INNER_FEC, dtp.CoderateH());
-     SETCMD(DTV_INVERSION, dtp.Inversion());
-     if (frontendType == SYS_DVBS2) {
-        // DVB-S2
-        SETCMD(DTV_PILOT, PILOT_AUTO);
-        SETCMD(DTV_ROLLOFF, dtp.RollOff());
-        }
-     else {
-        // DVB-S
-        SETCMD(DTV_ROLLOFF, ROLLOFF_35); // DVB-S always has a ROLLOFF of 0.35
-        }
-
-     tuneTimeout = DVBS_TUNE_TIMEOUT;
-     lockTimeout = DVBS_LOCK_TIMEOUT;
-     }
-  else if (frontendType == SYS_DVBC_ANNEX_AC || frontendType == SYS_DVBC_ANNEX_B) {
-     // DVB-C
-     SETCMD(DTV_FREQUENCY, FrequencyToHz(channel.Frequency()));
-     SETCMD(DTV_INVERSION, dtp.Inversion());
-     SETCMD(DTV_SYMBOL_RATE, channel.Srate() * 1000UL);
-     SETCMD(DTV_INNER_FEC, dtp.CoderateH());
-     SETCMD(DTV_MODULATION, dtp.Modulation());
-
-     tuneTimeout = DVBC_TUNE_TIMEOUT;
-     lockTimeout = DVBC_LOCK_TIMEOUT;
-     }
-  else if (frontendType == SYS_DVBT || frontendType == SYS_DVBT2) {
-     // DVB-T/DVB-T2 (common parts)
-     SETCMD(DTV_FREQUENCY, FrequencyToHz(channel.Frequency()));
-     SETCMD(DTV_INVERSION, dtp.Inversion());
-     SETCMD(DTV_BANDWIDTH_HZ, dtp.Bandwidth());
-     SETCMD(DTV_CODE_RATE_HP, dtp.CoderateH());
-     SETCMD(DTV_CODE_RATE_LP, dtp.CoderateL());
-     SETCMD(DTV_MODULATION, dtp.Modulation());
-     SETCMD(DTV_TRANSMISSION_MODE, dtp.Transmission());
-     SETCMD(DTV_GUARD_INTERVAL, dtp.Guard());
-     SETCMD(DTV_HIERARCHY, dtp.Hierarchy());
-     if (frontendType == SYS_DVBT2) {
-        // DVB-T2
-        SETCMD(DTV_STREAM_ID, dtp.PlpId());
-        }
-
-     tuneTimeout = DVBT_TUNE_TIMEOUT;
-     lockTimeout = DVBT_LOCK_TIMEOUT;
-     }
-  else if (frontendType == SYS_ATSC) {
-     // ATSC
-     SETCMD(DTV_FREQUENCY, FrequencyToHz(channel.Frequency()));
-     SETCMD(DTV_INVERSION, dtp.Inversion());
-     SETCMD(DTV_MODULATION, dtp.Modulation());
-
-     tuneTimeout = ATSC_TUNE_TIMEOUT;
-     lockTimeout = ATSC_LOCK_TIMEOUT;
-     }
-  else {
-     esyslog("ERROR: attempt to set channel with unknown DVB frontend type");
-     return false;
-     }
-  SETCMD(DTV_TUNE, 0);
-  if (ioctl(fd_frontend, FE_SET_PROPERTY, &CmdSeq) < 0) {
-     esyslog("ERROR: frontend %d/%d: %m", adapter, frontend);
-     return false;
-     }
-  return true;
-}
-
-void cDvbTuner::Action(void)
-{
-  cTimeMs Timer;
-  bool LostLock = false;
-  fe_status_t Status = (fe_status_t)0;
-  while (Running()) {
-        if (!isIdle) {
-           fe_status_t NewStatus;
-           if (GetFrontendStatus(NewStatus))
-              Status = NewStatus;
-           }
-        cMutexLock MutexLock(&mutex);
-        if (SendDiseqc) {
-           CHECK(ioctl(fd_frontend, FE_DISEQC_SEND_MASTER_CMD, &diseqc_cmd));
-           SendDiseqc=false;
-           }
-        int WaitTime = 1000;
-        switch (tunerStatus) {
-          case tsIdle:
-               break;
-          case tsSet:
-               tunerStatus = SetFrontend() ? tsTuned : tsIdle;
-               Timer.Set(tuneTimeout + (scr ? rand() % SCR_RANDOM_TIMEOUT : 0));
-               continue;
-          case tsTuned:
-               if (Timer.TimedOut()) {
-                  tunerStatus = tsSet;
-                  lastDiseqc = NULL;
-                  if (time(NULL) - lastTimeoutReport > 60) { // let's not get too many of these
-                     isyslog("frontend %d/%d timed out while tuning to channel %d, tp %d", adapter, frontend, channel.Number(), channel.Transponder());
-                     lastTimeoutReport = time(NULL);
-                     }
-                  continue;
-                  }
-               WaitTime = 100; // allows for a quick change from tsTuned to tsLocked
-          case tsLocked:
-               if (Status & FE_REINIT) {
-                  tunerStatus = tsSet;
-                  lastDiseqc = NULL;
-                  isyslog("frontend %d/%d was reinitialized", adapter, frontend);
-                  lastTimeoutReport = 0;
-                  continue;
-                  }
-               else if (Status & FE_HAS_LOCK) {
-                  if (LostLock) {
-                     isyslog("frontend %d/%d regained lock on channel %d, tp %d", adapter, frontend, channel.Number(), channel.Transponder());
-                     LostLock = false;
-                     }
-                  tunerStatus = tsLocked;
-                  locked.Broadcast();
-                  lastTimeoutReport = 0;
-                  }
-               else if (tunerStatus == tsLocked) {
-                  LostLock = true;
-                  isyslog("frontend %d/%d lost lock on channel %d, tp %d", adapter, frontend, channel.Number(), channel.Transponder());
-                  tunerStatus = tsTuned;
-                  Timer.Set(lockTimeout);
-                  lastTimeoutReport = 0;
-                  continue;
-                  }
-               break;
-          default: esyslog("ERROR: unknown tuner status %d", tunerStatus);
-          }
-        newSet.TimedWait(mutex, WaitTime);
-        }
-}
-
-bool cDvbTuner::SetIdle(bool Idle)
-{
-  if (isIdle == Idle)
-     return true;
-  isIdle = Idle;
-  if (Idle)
-     return CloseFrontend();
-  return OpenFrontend();
-}
-
-bool cDvbTuner::OpenFrontend(void) const
-{
-  if (fd_frontend >= 0)
-     return true;
-  cMutexLock MutexLock(&mutex);
-  fd_frontend = cDvbDevice::DvbOpen(DEV_DVB_FRONTEND, adapter, frontend, O_RDWR | O_NONBLOCK);
-  if (fd_frontend < 0)
-     return false;
-  isIdle = false;
-  return true;
-}
-
-bool cDvbTuner::CloseFrontend(void)
-{
-  if (fd_frontend < 0)
-     return true;
-  cMutexLock MutexLock(&mutex);
-  tunerStatus = tsIdle;
-  newSet.Broadcast();
-  close(fd_frontend);
-  fd_frontend = -1;
-  return true;
-}
-
-// --- cDvbSourceParam -------------------------------------------------------
-
-class cDvbSourceParam : public cSourceParam {
-private:
-  int param;
-  int srate;
-  cDvbTransponderParameters dtp;
-public:
-  cDvbSourceParam(char Source, const char *Description);
-  virtual void SetData(cChannel *Channel);
-  virtual void GetData(cChannel *Channel);
-  virtual cOsdItem *GetOsdItem(void);
-  };
-
-cDvbSourceParam::cDvbSourceParam(char Source, const char *Description)
-:cSourceParam(Source, Description)
-{
-  param = 0;
-  srate = 0;
-}
-
-void cDvbSourceParam::SetData(cChannel *Channel)
-{
-  srate = Channel->Srate();
-  dtp.Parse(Channel->Parameters());
-  param = 0;
-}
-
-void cDvbSourceParam::GetData(cChannel *Channel)
-{
-  Channel->SetTransponderData(Channel->Source(), Channel->Frequency(), srate, dtp.ToString(Source()), true);
-}
-
-cOsdItem *cDvbSourceParam::GetOsdItem(void)
-{
-  char type = Source();
-  const tDvbParameterMap *SystemValues = type == 'S' ? SystemValuesSat : SystemValuesTerr;
-#undef ST
-#define ST(s) if (strchr(s, type))
-  switch (param++) {
-    case  0: ST("  S ")  return new cMenuEditChrItem( tr("Polarization"), &dtp.polarization, "HVLR");             else return GetOsdItem();
-    case  1: ST("  ST")  return new cMenuEditMapItem( tr("System"),       &dtp.system,       SystemValues);       else return GetOsdItem();
-    case  2: ST(" CS ")  return new cMenuEditIntItem( tr("Srate"),        &srate);                                else return GetOsdItem();
-    case  3: ST("ACST")  return new cMenuEditMapItem( tr("Inversion"),    &dtp.inversion,    InversionValues);    else return GetOsdItem();
-    case  4: ST(" CST")  return new cMenuEditMapItem( tr("CoderateH"),    &dtp.coderateH,    CoderateValues);     else return GetOsdItem();
-    case  5: ST("   T")  return new cMenuEditMapItem( tr("CoderateL"),    &dtp.coderateL,    CoderateValues);     else return GetOsdItem();
-    case  6: ST("ACST")  return new cMenuEditMapItem( tr("Modulation"),   &dtp.modulation,   ModulationValues);   else return GetOsdItem();
-    case  7: ST("   T")  return new cMenuEditMapItem( tr("Bandwidth"),    &dtp.bandwidth,    BandwidthValues);    else return GetOsdItem();
-    case  8: ST("   T")  return new cMenuEditMapItem( tr("Transmission"), &dtp.transmission, TransmissionValues); else return GetOsdItem();
-    case  9: ST("   T")  return new cMenuEditMapItem( tr("Guard"),        &dtp.guard,        GuardValues);        else return GetOsdItem();
-    case 10: ST("   T")  return new cMenuEditMapItem( tr("Hierarchy"),    &dtp.hierarchy,    HierarchyValues);    else return GetOsdItem();
-    case 11: ST("  S ")  return new cMenuEditMapItem( tr("Rolloff"),      &dtp.rollOff,      RollOffValues);      else return GetOsdItem();
-    case 12: ST("   T")  return new cMenuEditIntItem( tr("PlpId"),        &dtp.plpId,        0, 255);             else return GetOsdItem();
-    default: return NULL;
-    }
-  return NULL;
-}
-
-// --- cDvbDevice ------------------------------------------------------------
-
-int cDvbDevice::setTransferModeForDolbyDigital = 1;
-cMutex cDvbDevice::bondMutex;
-
-const char *DeliverySystemNames[] = {
-  "",
-  "DVB-C",
-  "DVB-C",
-  "DVB-T",
-  "DSS",
-  "DVB-S",
-  "DVB-S2",
-  "DVB-H",
-  "ISDBT",
-  "ISDBS",
-  "ISDBC",
-  "ATSC",
-  "ATSCMH",
-  "DMBTH",
-  "CMMB",
-  "DAB",
-  "DVB-T2",
-  "TURBO",
-  NULL
-  };
-
-cDvbDevice::cDvbDevice(int Adapter, int Frontend, cDevice *ParentDevice)
-:cDevice(ParentDevice)
-{
-  adapter = Adapter;
-  frontend = Frontend;
-  ciAdapter = NULL;
-  dvbTuner = NULL;
-  numDeliverySystems = 0;
-  numModulations = 0;
-  bondedDevice = NULL;
-  needsDetachBondedReceivers = false;
-  tsBuffer = NULL;
-
-  // Devices that are present on all card types:
-
-  int fd_frontend = DvbOpen(DEV_DVB_FRONTEND, adapter, frontend, O_RDWR | O_NONBLOCK);
-
-  // Common Interface:
-
-  fd_ca = DvbOpen(DEV_DVB_CA, adapter, frontend, O_RDWR);
-  if (fd_ca >= 0)
-     ciAdapter = cDvbCiAdapter::CreateCiAdapter(parentDevice ? parentDevice : this, fd_ca, adapter, frontend);
-
-  // The DVR device (will be opened and closed as needed):
-
-  fd_dvr = -1;
-
-  // We only check the devices that must be present - the others will be checked before accessing them://XXX
-
-  if (fd_frontend >= 0) {
-     if (QueryDeliverySystems(fd_frontend))
-        dvbTuner = new cDvbTuner(this, fd_frontend, adapter, frontend);
-     }
-  else
-     esyslog("ERROR: can't open DVB device %d/%d", adapter, frontend);
-
-  StartSectionHandler();
-}
-
-cDvbDevice::~cDvbDevice()
-{
-  StopSectionHandler();
-  delete dvbTuner;
-  delete ciAdapter;
-  UnBond();
-  // We're not explicitly closing any device files here, since this sometimes
-  // caused segfaults. Besides, the program is about to terminate anyway...
-}
-
-cString cDvbDevice::DvbName(const char *Name, int Adapter, int Frontend)
-{
-  return cString::sprintf("%s/%s%d/%s%d", DEV_DVB_BASE, DEV_DVB_ADAPTER, Adapter, Name, Frontend);
-}
-
-int cDvbDevice::DvbOpen(const char *Name, int Adapter, int Frontend, int Mode, bool ReportError)
-{
-  cString FileName = DvbName(Name, Adapter, Frontend);
-  int fd = open(FileName, Mode);
-  if (fd < 0 && ReportError)
-     LOG_ERROR_STR(*FileName);
-  return fd;
-}
-
-bool cDvbDevice::Exists(int Adapter, int Frontend)
-{
-  cString FileName = DvbName(DEV_DVB_FRONTEND, Adapter, Frontend);
-  if (access(FileName, F_OK) == 0) {
-     int f = open(FileName, O_RDONLY);
-     if (f >= 0) {
-        close(f);
-        return true;
-        }
-     else if (errno != ENODEV && errno != EINVAL)
-        LOG_ERROR_STR(*FileName);
-     }
-  else if (errno != ENOENT)
-     LOG_ERROR_STR(*FileName);
-  return false;
-}
-
-bool cDvbDevice::Probe(int Adapter, int Frontend)
-{
-  cString FileName = DvbName(DEV_DVB_FRONTEND, Adapter, Frontend);
-  dsyslog("probing %s", *FileName);
-  for (cDvbDeviceProbe *dp = DvbDeviceProbes.First(); dp; dp = DvbDeviceProbes.Next(dp)) {
-      if (dp->Probe(Adapter, Frontend))
-         return true; // a plugin has created the actual device
-      }
-  dsyslog("creating cDvbDevice");
-  new cDvbDevice(Adapter, Frontend); // it's a "budget" device
-  return true;
-}
-
-cString cDvbDevice::DeviceType(void) const
-{
-  if (dvbTuner) {
-     if (dvbTuner->FrontendType() != SYS_UNDEFINED)
-        return DeliverySystemNames[dvbTuner->FrontendType()];
-     if (numDeliverySystems)
-        return DeliverySystemNames[deliverySystems[0]]; // to have some reasonable default
-     }
-  return "";
-}
-
-cString cDvbDevice::DeviceName(void) const
-{
-  return frontendInfo.name;
-}
-
-bool cDvbDevice::Initialize(void)
-{
-  new cDvbSourceParam('A', "ATSC");
-  new cDvbSourceParam('C', "DVB-C");
-  new cDvbSourceParam('S', "DVB-S");
-  new cDvbSourceParam('T', "DVB-T");
-  cStringList Nodes;
-  cReadDir DvbDir(DEV_DVB_BASE);
-  if (DvbDir.Ok()) {
-     struct dirent *a;
-     while ((a = DvbDir.Next()) != NULL) {
-           if (strstr(a->d_name, DEV_DVB_ADAPTER) == a->d_name) {
-              int Adapter = strtol(a->d_name + strlen(DEV_DVB_ADAPTER), NULL, 10);
-              cReadDir AdapterDir(AddDirectory(DEV_DVB_BASE, a->d_name));
-              if (AdapterDir.Ok()) {
-                 struct dirent *f;
-                 while ((f = AdapterDir.Next()) != NULL) {
-                       if (strstr(f->d_name, DEV_DVB_FRONTEND) == f->d_name) {
-                          int Frontend = strtol(f->d_name + strlen(DEV_DVB_FRONTEND), NULL, 10);
-                          Nodes.Append(strdup(cString::sprintf("%2d %2d", Adapter, Frontend)));
-                          }
-                       }
-                 }
-              }
-           }
-     }
-  int Checked = 0;
-  int Found = 0;
-  if (Nodes.Size() > 0) {
-     Nodes.Sort();
-     for (int i = 0; i < Nodes.Size(); i++) {
-         int Adapter;
-         int Frontend;
-         if (2 == sscanf(Nodes[i], "%d %d", &Adapter, &Frontend)) {
-            if (Exists(Adapter, Frontend)) {
-               if (Checked++ < MAXDVBDEVICES) {
-                  if (UseDevice(NextCardIndex())) {
-                     if (Probe(Adapter, Frontend))
-                        Found++;
-                     }
-                  else
-                     NextCardIndex(1); // skips this one
-                  }
-               }
-            }
-         }
-     }
-  NextCardIndex(MAXDVBDEVICES - Checked); // skips the rest
-  if (Found > 0)
-     isyslog("found %d DVB device%s", Found, Found > 1 ? "s" : "");
-  else
-     isyslog("no DVB device found");
-  return Found > 0;
-}
-
-bool cDvbDevice::QueryDeliverySystems(int fd_frontend)
-{
-  numDeliverySystems = 0;
-  if (ioctl(fd_frontend, FE_GET_INFO, &frontendInfo) < 0) {
-     LOG_ERROR;
-     return false;
-     }
-#if (DVB_API_VERSION << 8 | DVB_API_VERSION_MINOR) >= 0x0505
-  dtv_property Frontend[1];
-  memset(&Frontend, 0, sizeof(Frontend));
-  dtv_properties CmdSeq;
-  memset(&CmdSeq, 0, sizeof(CmdSeq));
-  CmdSeq.props = Frontend;
-  SETCMD(DTV_ENUM_DELSYS, 0);
-  int Result = ioctl(fd_frontend, FE_GET_PROPERTY, &CmdSeq);
-  if (Result == 0) {
-     for (uint i = 0; i < Frontend[0].u.buffer.len; i++) {
-         if (numDeliverySystems >= MAXDELIVERYSYSTEMS) {
-            esyslog("ERROR: too many delivery systems on frontend %d/%d", adapter, frontend);
-            break;
-            }
-         deliverySystems[numDeliverySystems++] = Frontend[0].u.buffer.data[i];
-         }
-     }
-  else {
-     esyslog("ERROR: can't query delivery systems on frontend %d/%d - falling back to legacy mode", adapter, frontend);
-#else
-     {
-#endif
-     // Legacy mode (DVB-API < 5.5):
-     switch (frontendInfo.type) {
-       case FE_QPSK: deliverySystems[numDeliverySystems++] = SYS_DVBS;
-                     if (frontendInfo.caps & FE_CAN_2G_MODULATION)
-                        deliverySystems[numDeliverySystems++] = SYS_DVBS2;
-                     break;
-       case FE_OFDM: deliverySystems[numDeliverySystems++] = SYS_DVBT;
-                     if (frontendInfo.caps & FE_CAN_2G_MODULATION)
-                        deliverySystems[numDeliverySystems++] = SYS_DVBT2;
-                     break;
-       case FE_QAM:  deliverySystems[numDeliverySystems++] = SYS_DVBC_ANNEX_AC; break;
-       case FE_ATSC: deliverySystems[numDeliverySystems++] = SYS_ATSC; break;
-       default: esyslog("ERROR: unknown frontend type %d on frontend %d/%d", frontendInfo.type, adapter, frontend);
-       }
-     }
-  if (numDeliverySystems > 0) {
-     cString ds("");
-     for (int i = 0; i < numDeliverySystems; i++)
-         ds = cString::sprintf("%s%s%s", *ds, i ? "," : "", DeliverySystemNames[deliverySystems[i]]);
-     cString ms("");
-     if (frontendInfo.caps & FE_CAN_QPSK)      { numModulations++; ms = cString::sprintf("%s%s%s", *ms, **ms ? "," : "", MapToUserString(QPSK, ModulationValues)); }
-     if (frontendInfo.caps & FE_CAN_QAM_16)    { numModulations++; ms = cString::sprintf("%s%s%s", *ms, **ms ? "," : "", MapToUserString(QAM_16, ModulationValues)); }
-     if (frontendInfo.caps & FE_CAN_QAM_32)    { numModulations++; ms = cString::sprintf("%s%s%s", *ms, **ms ? "," : "", MapToUserString(QAM_32, ModulationValues)); }
-     if (frontendInfo.caps & FE_CAN_QAM_64)    { numModulations++; ms = cString::sprintf("%s%s%s", *ms, **ms ? "," : "", MapToUserString(QAM_64, ModulationValues)); }
-     if (frontendInfo.caps & FE_CAN_QAM_128)   { numModulations++; ms = cString::sprintf("%s%s%s", *ms, **ms ? "," : "", MapToUserString(QAM_128, ModulationValues)); }
-     if (frontendInfo.caps & FE_CAN_QAM_256)   { numModulations++; ms = cString::sprintf("%s%s%s", *ms, **ms ? "," : "", MapToUserString(QAM_256, ModulationValues)); }
-     if (frontendInfo.caps & FE_CAN_8VSB)      { numModulations++; ms = cString::sprintf("%s%s%s", *ms, **ms ? "," : "", MapToUserString(VSB_8, ModulationValues)); }
-     if (frontendInfo.caps & FE_CAN_16VSB)     { numModulations++; ms = cString::sprintf("%s%s%s", *ms, **ms ? "," : "", MapToUserString(VSB_16, ModulationValues)); }
-     if (frontendInfo.caps & FE_CAN_TURBO_FEC) { numModulations++; ms = cString::sprintf("%s%s%s", *ms, **ms ? "," : "", "TURBO_FEC"); }
-     if (!**ms)
-        ms = "unknown modulations";
-     isyslog("frontend %d/%d provides %s with %s (\"%s\")", adapter, frontend, *ds, *ms, frontendInfo.name);
-     return true;
-     }
-  else
-     esyslog("ERROR: frontend %d/%d doesn't provide any delivery systems", adapter, frontend);
-  return false;
-}
-
-bool cDvbDevice::Ready(void)
-{
-  if (ciAdapter)
-     return ciAdapter->Ready();
-  return true;
-}
-
-bool cDvbDevice::BondDevices(const char *Bondings)
-{
-  UnBondDevices();
-  if (Bondings) {
-     cSatCableNumbers SatCableNumbers(MAXDEVICES, Bondings);
-     for (int i = 0; i < cDevice::NumDevices(); i++) {
-         int d = SatCableNumbers.FirstDeviceIndex(i);
-         if (d >= 0) {
-            int ErrorDevice = 0;
-            if (cDevice *Device1 = cDevice::GetDevice(i)) {
-               if (Device1->HasSubDevice())
-                  Device1 = Device1->SubDevice();
-               if (cDevice *Device2 = cDevice::GetDevice(d)) {
-                  if (Device2->HasSubDevice())
-                     Device2 = Device2->SubDevice();
-                  if (cDvbDevice *DvbDevice1 = dynamic_cast<cDvbDevice *>(Device1)) {
-                     if (cDvbDevice *DvbDevice2 = dynamic_cast<cDvbDevice *>(Device2)) {
-                        if (!DvbDevice1->Bond(DvbDevice2))
-                           return false; // Bond() has already logged the error
-                        }
-                     else
-                        ErrorDevice = d + 1;
-                     }
-                  else
-                     ErrorDevice = i + 1;
-                  if (ErrorDevice) {
-                     esyslog("ERROR: device '%d' in device bondings '%s' is not a cDvbDevice", ErrorDevice, Bondings);
-                     return false;
-                     }
-                  }
-               else
-                  ErrorDevice = d + 1;
-               }
-            else
-               ErrorDevice = i + 1;
-            if (ErrorDevice) {
-               esyslog("ERROR: unknown device '%d' in device bondings '%s'", ErrorDevice, Bondings);
-               return false;
-               }
-            }
-         }
-     }
-  return true;
-}
-
-void cDvbDevice::UnBondDevices(void)
-{
-  for (int i = 0; i < cDevice::NumDevices(); i++) {
-      cDevice *dev = cDevice::GetDevice(i);
-      if (dev && dev->HasSubDevice())
-         dev = dev->SubDevice();
-      if (cDvbDevice *d = dynamic_cast<cDvbDevice *>(dev))
-         d->UnBond();
-      }
-}
-
-bool cDvbDevice::Bond(cDvbDevice *Device)
-{
-  cMutexLock MutexLock(&bondMutex);
-  if (!bondedDevice) {
-     if (Device != this) {
-        if ((ProvidesDeliverySystem(SYS_DVBS) || ProvidesDeliverySystem(SYS_DVBS2)) && (Device->ProvidesDeliverySystem(SYS_DVBS) || Device->ProvidesDeliverySystem(SYS_DVBS2))) {
-           if (dvbTuner && Device->dvbTuner && dvbTuner->Bond(Device->dvbTuner)) {
-              bondedDevice = Device->bondedDevice ? Device->bondedDevice : Device;
-              Device->bondedDevice = this;
-              dsyslog("device %d bonded with device %d", CardIndex() + 1, bondedDevice->CardIndex() + 1);
-              return true;
-              }
-           }
-        else
-           esyslog("ERROR: can't bond device %d with device %d (only DVB-S(2) devices can be bonded)", CardIndex() + 1, Device->CardIndex() + 1);
-        }
-     else
-        esyslog("ERROR: can't bond device %d with itself", CardIndex() + 1);
-     }
-  else
-     esyslog("ERROR: device %d already bonded with device %d, can't bond with device %d", CardIndex() + 1, bondedDevice->CardIndex() + 1, Device->CardIndex() + 1);
-  return false;
-}
-
-void cDvbDevice::UnBond(void)
-{
-  cMutexLock MutexLock(&bondMutex);
-  if (cDvbDevice *d = bondedDevice) {
-     if (dvbTuner)
-        dvbTuner->UnBond();
-     dsyslog("device %d unbonded from device %d", CardIndex() + 1, bondedDevice->CardIndex() + 1);
-     while (d->bondedDevice != this)
-           d = d->bondedDevice;
-     if (d == bondedDevice)
-        d->bondedDevice = NULL;
-     else
-        d->bondedDevice = bondedDevice;
-     bondedDevice = NULL;
-     }
-}
-
-bool cDvbDevice::BondingOk(const cChannel *Channel, bool ConsiderOccupied) const
-{
-  cMutexLock MutexLock(&bondMutex);
-  if (bondedDevice)
-     return dvbTuner && dvbTuner->BondingOk(Channel, ConsiderOccupied);
-  return true;
-}
-
-bool cDvbDevice::SetIdleDevice(bool Idle, bool TestOnly)
-{
-  if (TestOnly) {
-     if (ciAdapter)
-        return ciAdapter->SetIdle(Idle, true);
-     return true;
-     }
-  if (!dvbTuner->SetIdle(Idle))
-     return false;
-  if (ciAdapter && !ciAdapter->SetIdle(Idle, false)) {
-     dvbTuner->SetIdle(!Idle);
-     return false;
-     }
-  if (Idle)
-     StopSectionHandler();
-  else
-     StartSectionHandler();
-  return true;
-}
-
-bool cDvbDevice::HasCi(void)
-{
-  return ciAdapter;
-}
-
-bool cDvbDevice::SetPid(cPidHandle *Handle, int Type, bool On)
-{
-  if (Handle->pid) {
-     dmx_pes_filter_params pesFilterParams;
-     memset(&pesFilterParams, 0, sizeof(pesFilterParams));
-     if (On) {
-        if (Handle->handle < 0) {
-           Handle->handle = DvbOpen(DEV_DVB_DEMUX, adapter, frontend, O_RDWR | O_NONBLOCK, true);
-           if (Handle->handle < 0) {
-              LOG_ERROR;
-              return false;
-              }
-           }
-        pesFilterParams.pid     = Handle->pid;
-        pesFilterParams.input   = DMX_IN_FRONTEND;
-        pesFilterParams.output  = DMX_OUT_TS_TAP;
-        pesFilterParams.pes_type= DMX_PES_OTHER;
-        pesFilterParams.flags   = DMX_IMMEDIATE_START;
-        if (ioctl(Handle->handle, DMX_SET_PES_FILTER, &pesFilterParams) < 0) {
-           LOG_ERROR;
-           return false;
-           }
-        }
-     else if (!Handle->used) {
-        CHECK(ioctl(Handle->handle, DMX_STOP));
-        if (Type <= ptTeletext) {
-           pesFilterParams.pid     = 0x1FFF;
-           pesFilterParams.input   = DMX_IN_FRONTEND;
-           pesFilterParams.output  = DMX_OUT_DECODER;
-           pesFilterParams.pes_type= DMX_PES_OTHER;
-           pesFilterParams.flags   = DMX_IMMEDIATE_START;
-           CHECK(ioctl(Handle->handle, DMX_SET_PES_FILTER, &pesFilterParams));
-           }
-        close(Handle->handle);
-        Handle->handle = -1;
-        }
-     }
-  return true;
-}
-
-int cDvbDevice::OpenFilter(u_short Pid, u_char Tid, u_char Mask)
-{
-  cString FileName = DvbName(DEV_DVB_DEMUX, adapter, frontend);
-  int f = open(FileName, O_RDWR | O_NONBLOCK);
-  if (f >= 0) {
-     dmx_sct_filter_params sctFilterParams;
-     memset(&sctFilterParams, 0, sizeof(sctFilterParams));
-     sctFilterParams.pid = Pid;
-     sctFilterParams.timeout = 0;
-     sctFilterParams.flags = DMX_IMMEDIATE_START;
-     sctFilterParams.filter.filter[0] = Tid;
-     sctFilterParams.filter.mask[0] = Mask;
-     if (ioctl(f, DMX_SET_FILTER, &sctFilterParams) >= 0)
-        return f;
-     else {
-        esyslog("ERROR: can't set filter (pid=%d, tid=%02X, mask=%02X): %m", Pid, Tid, Mask);
-        close(f);
-        }
-     }
-  else
-     esyslog("ERROR: can't open filter handle on '%s'", *FileName);
-  return -1;
-}
-
-void cDvbDevice::CloseFilter(int Handle)
-{
-  close(Handle);
-}
-
-bool cDvbDevice::ProvidesDeliverySystem(int DeliverySystem) const
-{
-  for (int i = 0; i < numDeliverySystems; i++) {
-      if (deliverySystems[i] == DeliverySystem)
-         return true;
-      }
-  return false;
-}
-
-bool cDvbDevice::ProvidesSource(int Source) const
-{
-  int type = Source & cSource::st_Mask;
-  return type == cSource::stNone
-      || type == cSource::stAtsc  && ProvidesDeliverySystem(SYS_ATSC)
-      || type == cSource::stCable && (ProvidesDeliverySystem(SYS_DVBC_ANNEX_AC) || ProvidesDeliverySystem(SYS_DVBC_ANNEX_B))
-      || type == cSource::stSat   && (ProvidesDeliverySystem(SYS_DVBS) || ProvidesDeliverySystem(SYS_DVBS2))
-      || type == cSource::stTerr  && (ProvidesDeliverySystem(SYS_DVBT) || ProvidesDeliverySystem(SYS_DVBT2));
-}
-
-bool cDvbDevice::ProvidesTransponder(const cChannel *Channel) const
-{
-  if (!ProvidesSource(Channel->Source()))
-     return false; // doesn't provide source
-  cDvbTransponderParameters dtp(Channel->Parameters());
-  if (!ProvidesDeliverySystem(GetRequiredDeliverySystem(Channel, &dtp)) ||
-     dtp.Modulation() == QPSK     && !(frontendInfo.caps & FE_CAN_QPSK) ||
-     dtp.Modulation() == QAM_16   && !(frontendInfo.caps & FE_CAN_QAM_16) ||
-     dtp.Modulation() == QAM_32   && !(frontendInfo.caps & FE_CAN_QAM_32) ||
-     dtp.Modulation() == QAM_64   && !(frontendInfo.caps & FE_CAN_QAM_64) ||
-     dtp.Modulation() == QAM_128  && !(frontendInfo.caps & FE_CAN_QAM_128) ||
-     dtp.Modulation() == QAM_256  && !(frontendInfo.caps & FE_CAN_QAM_256) ||
-     dtp.Modulation() == QAM_AUTO && !(frontendInfo.caps & FE_CAN_QAM_AUTO) ||
-     dtp.Modulation() == VSB_8    && !(frontendInfo.caps & FE_CAN_8VSB) ||
-     dtp.Modulation() == VSB_16   && !(frontendInfo.caps & FE_CAN_16VSB) ||
-     dtp.Modulation() == PSK_8    && !(frontendInfo.caps & FE_CAN_TURBO_FEC) && dtp.System() == SYS_DVBS) // "turbo fec" is a non standard FEC used by North American broadcasters - this is a best guess to determine this condition
-     return false; // requires modulation system which frontend doesn't provide
-  if (!cSource::IsSat(Channel->Source()) ||
-     (!Setup.DiSEqC || Diseqcs.Get(CardIndex() + 1, Channel->Source(), Channel->Frequency(), dtp.Polarization(), NULL)))
-     return DeviceHooksProvidesTransponder(Channel);
-  return false;
-}
-
-bool cDvbDevice::ProvidesChannel(const cChannel *Channel, int Priority, bool *NeedsDetachReceivers) const
-{
-  bool result = false;
-  bool hasPriority = Priority == IDLEPRIORITY || Priority > this->Priority();
-  bool needsDetachReceivers = false;
-  needsDetachBondedReceivers = false;
-
-  if (dvbTuner && ProvidesTransponder(Channel)) {
-     result = hasPriority;
-     if (Priority > IDLEPRIORITY) {
-        if (Receiving()) {
-           if (dvbTuner->IsTunedTo(Channel)) {
-              if (Channel->Vpid() && !HasPid(Channel->Vpid()) || Channel->Apid(0) && !HasPid(Channel->Apid(0)) || Channel->Dpid(0) && !HasPid(Channel->Dpid(0))) {
-                 if (CamSlot() && Channel->Ca() >= CA_ENCRYPTED_MIN) {
-                    if (CamSlot()->CanDecrypt(Channel))
-                       result = true;
-                    else
-                       needsDetachReceivers = true;
-                    }
-                 else
-                    result = true;
-                 }
-              else
-                 result = true;
-              }
-           else
-              needsDetachReceivers = Receiving();
-           }
-        if (result) {
-           if (!BondingOk(Channel)) {
-              // This device is bonded, so we need to check the priorities of the others:
-              for (cDvbDevice *d = bondedDevice; d && d != this; d = d->bondedDevice) {
-                  if (d->Priority() >= Priority) {
-                     result = false;
-                     break;
-                     }
-                  }
-              needsDetachBondedReceivers = true;
-              needsDetachReceivers = Receiving();
-              }
-           }
-        }
-     }
-  if (NeedsDetachReceivers)
-     *NeedsDetachReceivers = needsDetachReceivers;
-  return result;
-}
-
-bool cDvbDevice::ProvidesEIT(void) const
-{
-  return !IsIdle() && (dvbTuner != NULL) && !dvbTuner->IsIdle() && ((ciAdapter == NULL) || !ciAdapter->IsIdle());
-}
-
-int cDvbDevice::NumProvidedSystems(void) const
-{
-  return numDeliverySystems + numModulations;
-}
-
-int cDvbDevice::SignalStrength(void) const
-{
-  return dvbTuner ? dvbTuner->GetSignalStrength() : -1;
-}
-
-int cDvbDevice::SignalQuality(void) const
-{
-  return dvbTuner ? dvbTuner->GetSignalQuality() : -1;
-}
-
-const cChannel *cDvbDevice::GetCurrentlyTunedTransponder(void) const
-{
-  return dvbTuner ? dvbTuner->GetTransponder() : NULL;
-}
-
-bool cDvbDevice::IsTunedToTransponder(const cChannel *Channel) const
-{
-  return dvbTuner ? dvbTuner->IsTunedTo(Channel) : false;
-}
-
-bool cDvbDevice::MaySwitchTransponder(const cChannel *Channel) const
-{
-  return BondingOk(Channel, true) && cDevice::MaySwitchTransponder(Channel);
-}
-
-bool cDvbDevice::SetChannelDevice(const cChannel *Channel, bool LiveView)
-{
-  if (dvbTuner)
-     dvbTuner->SetChannel(Channel);
-  return true;
-}
-
-bool cDvbDevice::HasLock(int TimeoutMs) const
-{
-  return dvbTuner ? dvbTuner->Locked(TimeoutMs) : false;
-}
-
-bool cDvbDevice::SendDiseqcCmd(dvb_diseqc_master_cmd cmd)
-{
-  return dvbTuner->SendDiseqcCmd(cmd);
-}
-
-void cDvbDevice::SetTransferModeForDolbyDigital(int Mode)
-{
-  setTransferModeForDolbyDigital = Mode;
-}
-
-bool cDvbDevice::OpenDvr(void)
-{
-  CloseDvr();
-  fd_dvr = DvbOpen(DEV_DVB_DVR, adapter, frontend, O_RDONLY | O_NONBLOCK, true);
-  if (fd_dvr >= 0)
-     tsBuffer = new cTSBuffer(fd_dvr, MEGABYTE(5), CardIndex() + 1);
-  return fd_dvr >= 0;
-}
-
-void cDvbDevice::CloseDvr(void)
-{
-  if (fd_dvr >= 0) {
-     delete tsBuffer;
-     tsBuffer = NULL;
-     close(fd_dvr);
-     fd_dvr = -1;
-     }
-}
-
-bool cDvbDevice::GetTSPacket(uchar *&Data)
-{
-  if (tsBuffer) {
-     Data = tsBuffer->Get();
-     return true;
-     }
-  return false;
-}
-
-void cDvbDevice::DetachAllReceivers(void)
-{
-  cMutexLock MutexLock(&bondMutex);
-  cDvbDevice *d = this;
-  do {
-     d->cDevice::DetachAllReceivers();
-     d = d->bondedDevice;
-     } while (d && d != this && needsDetachBondedReceivers);
-  needsDetachBondedReceivers = false;
-}
-
-// --- cDvbDeviceProbe -------------------------------------------------------
-
-cList<cDvbDeviceProbe> DvbDeviceProbes;
-
-cDvbDeviceProbe::cDvbDeviceProbe(void)
-{
-  DvbDeviceProbes.Add(this);
-}
-
-cDvbDeviceProbe::~cDvbDeviceProbe()
-{
-  DvbDeviceProbes.Del(this, false);
-}
-
-uint32_t cDvbDeviceProbe::GetSubsystemId(int Adapter, int Frontend)
-{
-  uint32_t SubsystemId = 0;
-  cString FileName = cString::sprintf("/dev/dvb/adapter%d/frontend%d", Adapter, Frontend);
-  struct stat st;
-  if (stat(FileName, &st) == 0) {
-     cReadDir d("/sys/class/dvb");
-     if (d.Ok()) {
-        struct dirent *e;
-        while ((e = d.Next()) != NULL) {
-              if (strstr(e->d_name, "frontend")) {
-                 FileName = cString::sprintf("/sys/class/dvb/%s/dev", e->d_name);
-                 if (FILE *f = fopen(FileName, "r")) {
-                    cReadLine ReadLine;
-                    char *s = ReadLine.Read(f);
-                    fclose(f);
-                    unsigned Major;
-                    unsigned Minor;
-                    if (s && 2 == sscanf(s, "%u:%u", &Major, &Minor)) {
-                       if (((Major << 8) | Minor) == st.st_rdev) {
-                          FileName = cString::sprintf("/sys/class/dvb/%s/device/subsystem_vendor", e->d_name);
-                          if ((f = fopen(FileName, "r")) != NULL) {
-                             if (char *s = ReadLine.Read(f))
-                                SubsystemId = strtoul(s, NULL, 0) << 16;
-                             fclose(f);
-                             }
-                          FileName = cString::sprintf("/sys/class/dvb/%s/device/subsystem_device", e->d_name);
-                          if ((f = fopen(FileName, "r")) != NULL) {
-                             if (char *s = ReadLine.Read(f))
-                                SubsystemId |= strtoul(s, NULL, 0);
-                             fclose(f);
-                             }
-                          break;
-                          }
-                       }
-                    }
-                 }
-              }
-        }
-     }
-  return SubsystemId;
-}
diff -urN vdr-1.7.38/keys.c vdr-1.7.38-pa/keys.c
--- vdr-1.7.38/keys.c	2013-02-21 22:26:57.330776693 +0100
+++ vdr-1.7.38-pa/keys.c	2013-02-21 22:24:13.250773878 +0100
@@ -57,6 +57,9 @@
                     { kRecordings,    trNOOP("Key$Recordings")  },
                     { kSetup,         trNOOP("Key$Setup")       },
                     { kCommands,      trNOOP("Key$Commands")    },
+                    { kGreater,       trNOOP("Key$Greater")     },
+                    { kLess,          trNOOP("Key$Less")        },
+                    { k2digit,        trNOOP("Key$2digit")      },
                     { kUser0,         trNOOP("Key$User0")       },
                     { kUser1,         trNOOP("Key$User1")       },
                     { kUser2,         trNOOP("Key$User2")       },
diff -urN vdr-1.7.38/keys.h vdr-1.7.38-pa/keys.h
--- vdr-1.7.38/keys.h	2013-02-21 22:26:57.326776693 +0100
+++ vdr-1.7.38-pa/keys.h	2013-02-21 22:24:13.250773878 +0100
@@ -51,6 +51,7 @@
              kRecordings,
              kSetup,
              kCommands,
+             kGreater, kLess, k2digit,
              kUser0, kUser1, kUser2, kUser3, kUser4, kUser5, kUser6, kUser7, kUser8, kUser9,
              kNone,
              kKbd,
diff -urN vdr-1.7.38/Make.common vdr-1.7.38-pa/Make.common
--- vdr-1.7.38/Make.common	1970-01-01 01:00:00.000000000 +0100
+++ vdr-1.7.38-pa/Make.common	2013-02-21 22:24:13.250773878 +0100
@@ -0,0 +1,156 @@
+
+
+### The version number of this plugin (taken from the main source file):
+
+VERSION = $(shell grep 'static const char \*VERSION *=' $(PLUGIN).c | awk '{ print $$6 }' | sed -e 's/[";]//g')
+
+
+### The version number of VDR (taken from VDR's "config.h"):
+
+APIVERSION = $(shell grep 'define APIVERSION ' $(VDRDIR)/config.h | awk '{ print $$3 }' | sed -e 's/"//g')
+APIVERSNUM = $(shell grep 'define APIVERSNUM ' $(VDRDIR)/config.h | awk '{ print $$3 }' | sed -e 's/"//g' )
+
+VDRLOCALE = $(shell grep '^LOCALEDIR' $(VDRDIR)/Makefile)
+
+
+### The name of the distribution archive:
+
+ARCHIVE = $(PLUGIN)-$(VERSION)
+PACKAGE = vdr-$(ARCHIVE)
+
+
+### Includes and Defines (add further entries here):
+
+INCLUDES += -I$(VDRDIR)/include -I$(DVBDIR)/include
+DEFINES  += -D_GNU_SOURCE -D_LARGEFILE_SOURCE
+DEFINES  += -D_FILE_OFFSET_BITS=64 -D_LARGEFILE64_SOURCE -DAPIVERSNUM=$(APIVERSNUM)
+
+#ifdef DEBUG
+#  DEFINES += -DDEBUG
+#  CXXFLAGS += -g
+#endif
+
+#ifdef RBLITE
+#  DEFINES += -DRBLITE
+#endif
+
+#ifdef RBMINI
+#  DEFINES += -DRBMINI
+#endif
+
+#ifdef REELVDR
+#  DEFINES += -DREELVDR
+#endif
+
+### Targets:
+
+plug: libvdr-$(PLUGIN).so
+
+all: libvdr-$(PLUGIN).so i18n
+
+### Implicit rules:
+
+%.o: %.c
+	$(CXX) $(CXXFLAGS) -c $(DEFINES) -DPLUGIN_NAME='"$(PLUGIN)"' -DPLUGIN_NAME_I18N='"$(PLUGIN)"' $(INCLUDES) -o $@ $<
+
+# Dependencies:
+
+MAKEDEP = $(CXX) -MM -MG
+DEPFILE = .dependencies
+$(DEPFILE): Makefile
+	@$(MAKEDEP) $(DEFINES) $(INCLUDES) $(OBJS:%.o=%.c)   > $@
+
+-include $(DEPFILE)
+
+
+### Internationalization (I18N):
+ifneq ($(strip $(VDRLOCALE)),)
+### do gettext based i18n stuff
+
+PODIR     = po
+LOCALEDIR = $(VDRDIR)/locale
+I18Npo    = $(wildcard $(PODIR)/*.po)
+I18Nmsgs  = $(addprefix $(LOCALEDIR)/, $(addsuffix /LC_MESSAGES/vdr-$(PLUGIN).mo, \
+		$(notdir $(foreach file, $(I18Npo), $(basename $(file))))))
+I18Npot   = $(PODIR)/$(PLUGIN).pot
+
+#%.mo: %.po
+#	msgfmt -c -o $@ $<
+
+.PHONY: $(I18Npot)-rule
+$(I18Npot): $(wildcard *.c $(PLUGIN).h $(EXTRA_I18N))
+	@echo "making: $@"
+	@#echo $(I18Nmsgs)
+	xgettext -C -cTRANSLATORS --no-wrap --no-location -k -ktr -ktrNOOP --from-code=utf-8 --msgid-bugs-address='<reelbox-devel@mailings.reelbox.org>' $^ -o $(I18Npot)
+
+%.po:
+#%.po: $(I18Npot)
+	@echo "making: $@"
+	msgmerge -U --no-wrap --no-location --backup=none -q $@ $<
+	@touch $@
+
+$(I18Nmsgs): $(LOCALEDIR)/%/LC_MESSAGES/vdr-$(PLUGIN).mo: $(PODIR)/%.po
+	@echo "making: $@"
+	@mkdir -p $(dir $@)
+	msgfmt -c -o $@ $<
+
+.PHONY: i18n
+i18n: $(I18Npot) i18n-pofiles $(I18Nmsgs)
+
+i18n-pofiles: $(I18Npot)
+	@echo "making: $@"
+	@for i in $(I18Npo) ; do \
+		echo msgmerge -U --no-wrap --no-location --backup=none -q $$i $(I18Npot) ;\
+		msgmerge -U -N --no-wrap --no-location --backup=none -q $$i $(I18Npot) ;\
+	done
+
+i18n-dist: $(I18Nmsgs)
+
+#i18n-dist:
+#	@echo "making: $@"
+#	for i in `ls po/*.po` ; do \
+#		odir=`echo $$i | cut -b4-8` ;\
+#		msgfmt -c -o $(LOCALEDIR)/$$odir/LC_MESSAGES/vdr-$(PLUGIN).mo $$i ;\
+#	done
+
+else ### do i18n.c based i18n stuff
+
+i18n:
+	@### nothing to do
+
+#i18n compatibility generator:
+i18n.c: i18n-template.c po2i18n.pl $(I18Npo)
+	./po2i18n.pl < i18n-template.c > i18n.c
+
+endif
+
+
+libvdr-$(PLUGIN).so: $(OBJS)
+	$(CXX) $(CXXFLAGS) -shared $(OBJS) $(LDFLAGS) $(LIBS) -o $@
+	@cp $@ $(LIBDIR)/$@.$(APIVERSION)
+
+dist: distclean
+	@rm -rf $(TMPDIR)/$(ARCHIVE)
+	@mkdir $(TMPDIR)/$(ARCHIVE)
+	@cp -a * $(TMPDIR)/$(ARCHIVE)
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevelop
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevelop.filelist
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevelop.pcs
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevses
+	@rm -rf $(TMPDIR)/$(ARCHIVE)/CVS
+	@rm -rf $(TMPDIR)/$(ARCHIVE)/Examples/CVS
+	@rm -rf $(TMPDIR)/$(ARCHIVE)/Patch/CVS
+	@ln -s $(ARCHIVE) $(TMPDIR)/$(PLUGIN)
+	@tar czf $(PACKAGE).tgz -C $(TMPDIR) $(ARCHIVE) $(PLUGIN)
+	@rm -rf $(TMPDIR)/$(ARCHIVE) $(TMPDIR)/$(PLUGIN)
+	@echo Distribution package created as $(PACKAGE).tgz
+
+clean:
+	@-rm -f $(PODIR)/*.mo
+	@-rm -f $(OBJS) $(MAIN) $(DEPFILE) *.so *.tgz core* *~
+	@-rm -f $(LIBDIR)/libvdr-$(PLUGIN).so.$(APIVERSION)
+
+distclean: clean
+	@-rm -f $(PODIR)/*.pot
+
+MAKECOMMON_IS_SOURCED = 1
diff -urN vdr-1.7.38/menu.c vdr-1.7.38-pa/menu.c
--- vdr-1.7.38/menu.c	2013-02-21 22:26:57.318776693 +0100
+++ vdr-1.7.38-pa/menu.c	2013-02-21 22:24:13.254773877 +0100
@@ -99,15 +99,6 @@
 
 // --- cMenuEditSrcItem ------------------------------------------------------
 
-class cMenuEditSrcItem : public cMenuEditIntItem {
-private:
-  const cSource *source;
-protected:
-  virtual void Set(void);
-public:
-  cMenuEditSrcItem(const char *Name, int *Value);
-  eOSState ProcessKey(eKeys Key);
-  };
 
 cMenuEditSrcItem::cMenuEditSrcItem(const char *Name, int *Value)
 :cMenuEditIntItem(Name, Value, 0)
@@ -4392,6 +4383,7 @@
          else
             return osEnd;
          break;
+    case kInfo: return osEnd; break;
     default:
          if ((Key & (k_Repeat | k_Release)) == 0) {
             cRemote::Put(Key);
diff -urN vdr-1.7.38/menu.c.orig vdr-1.7.38-pa/menu.c.orig
--- vdr-1.7.38/menu.c.orig	2013-02-21 22:26:57.318776693 +0100
+++ vdr-1.7.38-pa/menu.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,5613 +0,0 @@
-/*
- * menu.c: The actual menu implementations
- *
- * See the main source file 'vdr.c' for copyright information and
- * how to reach the author.
- *
- * $Id: menu.c 2.79 2013/02/17 13:17:49 kls Exp $
- */
-
-#include "menu.h"
-#include "iconpatch.h"
-#include <ctype.h>
-#include <limits.h>
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "channels.h"
-#include "config.h"
-#include "cutter.h"
-#include "eitscan.h"
-#include "filetransfer.h"
-#include "i18n.h"
-#include "interface.h"
-#include "plugin.h"
-#include "recording.h"
-#include "remote.h"
-#include "shutdown.h"
-#include "sourceparams.h"
-#include "sources.h"
-#include "status.h"
-#include "themes.h"
-#include "timers.h"
-#include "transfer.h"
-#include "videodir.h"
-#include "menuorgpatch.h"
-
-#include "remotetimers.h"
-
-#define MAXWAIT4EPGINFO   3 // seconds
-#define MODETIMEOUT       3 // seconds
-#define NEWTIMERLIMIT   120 // seconds until the start time of a new timer created from the Schedule menu,
-                            // within which it will go directly into the "Edit timer" menu to allow
-                            // further parameter settings
-#define DEFERTIMER       60 // seconds by which a timer is deferred in case of problems
-
-#define MAXRECORDCONTROLS (MAXDEVICES * MAXRECEIVERS)
-#define MAXINSTANTRECTIME (24 * 60 - 1) // 23:59 hours
-#define MAXWAITFORCAMMENU  10 // seconds to wait for the CAM menu to open
-#define CAMMENURETYTIMEOUT  3 // seconds after which opening the CAM menu is retried
-#define CAMRESPONSETIMEOUT  5 // seconds to wait for a response from a CAM
-#define MINFREEDISK       300 // minimum free disk space (in MB) required to start recording
-#define NODISKSPACEDELTA  300 // seconds between "Not enough disk space to start recording!" messages
-#define MAXCHNAMWIDTH      16 // maximum number of characters of channels' short names shown in schedules menus
-
-#define CHNUMWIDTH  (numdigits(Channels.MaxNumber()) + 1)
-#define CHNAMWIDTH  (min(MAXCHNAMWIDTH, Channels.MaxShortChannelNameLength() + 1))
-
-// --- cMenuEditCaItem -------------------------------------------------------
-
-class cMenuEditCaItem : public cMenuEditIntItem {
-protected:
-  virtual void Set(void);
-public:
-  cMenuEditCaItem(const char *Name, int *Value);
-  eOSState ProcessKey(eKeys Key);
-  };
-
-cMenuEditCaItem::cMenuEditCaItem(const char *Name, int *Value)
-:cMenuEditIntItem(Name, Value, 0)
-{
-  Set();
-}
-
-void cMenuEditCaItem::Set(void)
-{
-  if (*value == CA_FTA)
-     SetValue(tr("Free To Air"));
-  else if (*value >= CA_ENCRYPTED_MIN)
-     SetValue(tr("encrypted"));
-  else
-     cMenuEditIntItem::Set();
-}
-
-eOSState cMenuEditCaItem::ProcessKey(eKeys Key)
-{
-  eOSState state = cMenuEditItem::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     if (NORMALKEY(Key) == kLeft && *value >= CA_ENCRYPTED_MIN)
-        *value = CA_FTA;
-     else
-        return cMenuEditIntItem::ProcessKey(Key);
-     Set();
-     state = osContinue;
-     }
-  return state;
-}
-
-// --- cMenuEditSrcItem ------------------------------------------------------
-
-class cMenuEditSrcItem : public cMenuEditIntItem {
-private:
-  const cSource *source;
-protected:
-  virtual void Set(void);
-public:
-  cMenuEditSrcItem(const char *Name, int *Value);
-  eOSState ProcessKey(eKeys Key);
-  };
-
-cMenuEditSrcItem::cMenuEditSrcItem(const char *Name, int *Value)
-:cMenuEditIntItem(Name, Value, 0)
-{
-  source = Sources.Get(*Value);
-  Set();
-}
-
-void cMenuEditSrcItem::Set(void)
-{
-  if (source)
-     SetValue(cString::sprintf("%s - %s", *cSource::ToString(source->Code()), source->Description()));
-  else
-     cMenuEditIntItem::Set();
-}
-
-eOSState cMenuEditSrcItem::ProcessKey(eKeys Key)
-{
-  eOSState state = cMenuEditItem::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     bool IsRepeat = Key & k_Repeat;
-     Key = NORMALKEY(Key);
-     if (Key == kLeft) { // TODO might want to increase the delta if repeated quickly?
-        if (source) {
-           if (source->Prev())
-              source = (cSource *)source->Prev();
-           else if (!IsRepeat)
-              source = Sources.Last();
-           *value = source->Code();
-           }
-        }
-     else if (Key == kRight) {
-        if (source) {
-           if (source->Next())
-              source = (cSource *)source->Next();
-           else if (!IsRepeat)
-              source = Sources.First();
-           }
-        else
-           source = Sources.First();
-        if (source)
-           *value = source->Code();
-        }
-     else
-        return state; // we don't call cMenuEditIntItem::ProcessKey(Key) here since we don't accept numerical input
-     Set();
-     state = osContinue;
-     }
-  return state;
-}
-
-// --- cMenuEditChannel ------------------------------------------------------
-
-class cMenuEditChannel : public cOsdMenu {
-private:
-  cChannel *channel;
-  cChannel data;
-  cSourceParam *sourceParam;
-  char name[256];
-  void Setup(void);
-public:
-  cMenuEditChannel(cChannel *Channel, bool New = false);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuEditChannel"; }
-  };
-
-cMenuEditChannel::cMenuEditChannel(cChannel *Channel, bool New)
-:cOsdMenu(tr("Edit channel"), 16)
-{
-  SetMenuCategory(mcChannelEdit);
-  channel = Channel;
-  sourceParam = NULL;
-  *name = 0;
-  if (channel) {
-     data = *channel;
-     strn0cpy(name, data.name, sizeof(name));
-     if (New) {
-        channel = NULL;
-        data.nid = 0;
-        data.tid = 0;
-        data.rid = 0;
-        }
-     }
-  Setup();
-}
-
-void cMenuEditChannel::Setup(void)
-{
-  int current = Current();
-
-  Clear();
-
-  // Parameters for all types of sources:
-  Add(new cMenuEditStrItem( tr("Name"),          name, sizeof(name)));
-  Add(new cMenuEditSrcItem( tr("Source"),       &data.source));
-  Add(new cMenuEditIntItem( tr("Frequency"),    &data.frequency));
-  Add(new cMenuEditIntItem( tr("Vpid"),         &data.vpid,  0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Ppid"),         &data.ppid,  0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Apid1"),        &data.apids[0], 0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Apid2"),        &data.apids[1], 0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Dpid1"),        &data.dpids[0], 0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Dpid2"),        &data.dpids[1], 0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Spid1"),        &data.spids[0], 0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Spid2"),        &data.spids[1], 0, 0x1FFF));
-  Add(new cMenuEditIntItem( tr("Tpid"),         &data.tpid,  0, 0x1FFF));
-  Add(new cMenuEditCaItem(  tr("CA"),           &data.caids[0]));
-  Add(new cMenuEditIntItem( tr("Sid"),          &data.sid, 1, 0xFFFF));
-  /* XXX not yet used
-  Add(new cMenuEditIntItem( tr("Nid"),          &data.nid, 0));
-  Add(new cMenuEditIntItem( tr("Tid"),          &data.tid, 0));
-  Add(new cMenuEditIntItem( tr("Rid"),          &data.rid, 0));
-  XXX*/
-  // Parameters for specific types of sources:
-  sourceParam = SourceParams.Get(**cSource::ToString(data.source));
-  if (sourceParam) {
-     sourceParam->SetData(&data);
-     cOsdItem *Item;
-     while ((Item = sourceParam->GetOsdItem()) != NULL)
-           Add(Item);
-     }
-
-  SetCurrent(Get(current));
-  Display();
-}
-
-eOSState cMenuEditChannel::ProcessKey(eKeys Key)
-{
-  int oldSource = data.source;
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     if (Key == kOk) {
-        if (sourceParam)
-           sourceParam->GetData(&data);
-        if (Channels.HasUniqueChannelID(&data, channel)) {
-           data.name = strcpyrealloc(data.name, name);
-           if (channel) {
-              *channel = data;
-              isyslog("edited channel %d %s", channel->Number(), *data.ToText());
-              state = osBack;
-              }
-           else {
-              channel = new cChannel;
-              *channel = data;
-              Channels.Add(channel);
-              Channels.ReNumber();
-              isyslog("added channel %d %s", channel->Number(), *data.ToText());
-              state = osUser1;
-              }
-           Channels.SetModified(true);
-           }
-        else {
-           Skins.Message(mtError, tr("Channel settings are not unique!"));
-           state = osContinue;
-           }
-        }
-     }
-  if (Key != kNone && (data.source & cSource::st_Mask) != (oldSource & cSource::st_Mask)) {
-     if (sourceParam)
-        sourceParam->GetData(&data);
-     Setup();
-     }
-  return state;
-}
-
-// --- cMenuChannelItem ------------------------------------------------------
-
-class cMenuChannelItem : public cOsdItem {
-public:
-  enum eChannelSortMode { csmNumber, csmName, csmProvider };
-private:
-  static eChannelSortMode sortMode;
-  cChannel *channel;
-public:
-  cMenuChannelItem(cChannel *Channel);
-  static void SetSortMode(eChannelSortMode SortMode) { sortMode = SortMode; }
-  static void IncSortMode(void) { sortMode = eChannelSortMode((sortMode == csmProvider) ? csmNumber : sortMode + 1); }
-  static eChannelSortMode SortMode(void) { return sortMode; }
-  virtual int Compare(const cListObject &ListObject) const;
-  virtual void Set(void);
-  cChannel *Channel(void) { return channel; }
-  virtual void SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable);
-  };
-
-cMenuChannelItem::eChannelSortMode cMenuChannelItem::sortMode = csmNumber;
-
-cMenuChannelItem::cMenuChannelItem(cChannel *Channel)
-{
-  channel = Channel;
-  if (channel->GroupSep())
-     SetSelectable(false);
-  Set();
-}
-
-int cMenuChannelItem::Compare(const cListObject &ListObject) const
-{
-  cMenuChannelItem *p = (cMenuChannelItem *)&ListObject;
-  int r = -1;
-  if (sortMode == csmProvider)
-     r = strcoll(channel->Provider(), p->channel->Provider());
-  if (sortMode == csmName || r == 0)
-     r = strcoll(channel->Name(), p->channel->Name());
-  if (sortMode == csmNumber || r == 0)
-     r = channel->Number() - p->channel->Number();
-  return r;
-}
-
-void cMenuChannelItem::Set(void)
-{
-  cString buffer;
-  if (!channel->GroupSep()) {
-     if (sortMode == csmProvider)
-        buffer = cString::sprintf("%d\t%s - %s", channel->Number(), channel->Provider(), channel->Name());
-        else if (Setup.WarEagleIcons) {
-           if (channel->Vpid() == 1 || channel->Vpid() == 0)
-              buffer = cString::sprintf("%d\t%s %-30s", channel->Number(), IsLangUtf8() ? ICON_RADIO_UTF8 : ICON_RADIO, channel->Name());
-           else if (channel->Ca() == 0)
-              buffer = cString::sprintf("%d\t%s %-30s", channel->Number(), IsLangUtf8() ? ICON_TV_UTF8 : ICON_TV, channel->Name());
-        else
-           buffer = cString::sprintf("%d\t%s %-30s", channel->Number(), IsLangUtf8() ? ICON_TV_CRYPTED_UTF8 : ICON_TV_CRYPTED, channel->Name());
-        }
-     else
-        buffer = cString::sprintf("%d\t%s", channel->Number(), channel->Name());
-     }
-  else
-     buffer = cString::sprintf("---\t%s ----------------------------------------------------------------", channel->Name());
-  SetText(buffer);
-}
-
-void cMenuChannelItem::SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable)
-{
-  if (!DisplayMenu->SetItemChannel(channel, Index, Current, Selectable, sortMode == csmProvider))
-     DisplayMenu->SetItem(Text(), Index, Current, Selectable);
-}
-
-// --- cMenuChannels ---------------------------------------------------------
-
-#define CHANNELNUMBERTIMEOUT 1000 //ms
-
-class cMenuChannels : public cOsdMenu {
-private:
-  int number;
-  cTimeMs numberTimer;
-  void Setup(void);
-  cChannel *GetChannel(int Index);
-  void Propagate(void);
-protected:
-  eOSState Number(eKeys Key);
-  eOSState Switch(void);
-  eOSState Edit(void);
-  eOSState New(void);
-  eOSState Delete(void);
-  virtual void Move(int From, int To);
-public:
-  cMenuChannels(void);
-  ~cMenuChannels();
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuChannels"; }
-  };
-
-cMenuChannels::cMenuChannels(void)
-:cOsdMenu(tr("Channels"), CHNUMWIDTH)
-{
-  SetMenuCategory(mcChannel);
-  number = 0;
-  Setup();
-  Channels.IncBeingEdited();
-}
-
-cMenuChannels::~cMenuChannels()
-{
-  Channels.DecBeingEdited();
-}
-
-void cMenuChannels::Setup(void)
-{
-  cChannel *currentChannel = GetChannel(Current());
-  if (!currentChannel)
-     currentChannel = Channels.GetByNumber(cDevice::CurrentChannel());
-  cMenuChannelItem *currentItem = NULL;
-  Clear();
-  for (cChannel *channel = Channels.First(); channel; channel = Channels.Next(channel)) {
-      if (!channel->GroupSep() || cMenuChannelItem::SortMode() == cMenuChannelItem::csmNumber && *channel->Name()) {
-         cMenuChannelItem *item = new cMenuChannelItem(channel);
-         Add(item);
-         if (channel == currentChannel)
-            currentItem = item;
-         }
-      }
-  if (cMenuChannelItem::SortMode() != cMenuChannelItem::csmNumber)
-     Sort();
-  SetCurrent(currentItem);
-  SetHelp(tr("Button$Edit"), tr("Button$New"), tr("Button$Delete"), tr("Button$Mark"));
-  Display();
-}
-
-cChannel *cMenuChannels::GetChannel(int Index)
-{
-  cMenuChannelItem *p = (cMenuChannelItem *)Get(Index);
-  return p ? (cChannel *)p->Channel() : NULL;
-}
-
-void cMenuChannels::Propagate(void)
-{
-  Channels.ReNumber();
-  for (cMenuChannelItem *ci = (cMenuChannelItem *)First(); ci; ci = (cMenuChannelItem *)ci->Next())
-      ci->Set();
-  Display();
-  Channels.SetModified(true);
-}
-
-eOSState cMenuChannels::Number(eKeys Key)
-{
-  if (HasSubMenu())
-     return osContinue;
-  if (numberTimer.TimedOut())
-     number = 0;
-  if (!number && Key == k0) {
-     cMenuChannelItem::IncSortMode();
-     Setup();
-     }
-  else {
-     number = number * 10 + Key - k0;
-     for (cMenuChannelItem *ci = (cMenuChannelItem *)First(); ci; ci = (cMenuChannelItem *)ci->Next()) {
-         if (!ci->Channel()->GroupSep() && ci->Channel()->Number() == number) {
-            SetCurrent(ci);
-            Display();
-            break;
-            }
-         }
-     numberTimer.Set(CHANNELNUMBERTIMEOUT);
-     }
-  return osContinue;
-}
-
-eOSState cMenuChannels::Switch(void)
-{
-  if (HasSubMenu())
-     return osContinue;
-  cChannel *ch = GetChannel(Current());
-  if (ch)
-     return cDevice::PrimaryDevice()->SwitchChannel(ch, true) ? osEnd : osContinue;
-  return osEnd;
-}
-
-eOSState cMenuChannels::Edit(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cChannel *ch = GetChannel(Current());
-  if (ch)
-     return AddSubMenu(new cMenuEditChannel(ch));
-  return osContinue;
-}
-
-eOSState cMenuChannels::New(void)
-{
-  if (HasSubMenu())
-     return osContinue;
-  return AddSubMenu(new cMenuEditChannel(GetChannel(Current()), true));
-}
-
-eOSState cMenuChannels::Delete(void)
-{
-  if (!HasSubMenu() && Count() > 0) {
-     int CurrentChannelNr = cDevice::CurrentChannel();
-     cChannel *CurrentChannel = Channels.GetByNumber(CurrentChannelNr);
-     int Index = Current();
-     cChannel *channel = GetChannel(Current());
-     int DeletedChannel = channel->Number();
-     // Check if there is a timer using this channel:
-     if (channel->HasTimer()) {
-        Skins.Message(mtError, tr("Channel is being used by a timer!"));
-        return osContinue;
-        }
-     if (Interface->Confirm(tr("Delete channel?"))) {
-        if (CurrentChannel && channel == CurrentChannel) {
-           int n = Channels.GetNextNormal(CurrentChannel->Index());
-           if (n < 0)
-              n = Channels.GetPrevNormal(CurrentChannel->Index());
-           CurrentChannel = Channels.Get(n);
-           CurrentChannelNr = 0; // triggers channel switch below
-           }
-        Channels.Del(channel);
-        cOsdMenu::Del(Index);
-        Propagate();
-        Channels.SetModified(true);
-        isyslog("channel %d deleted", DeletedChannel);
-        if (CurrentChannel && CurrentChannel->Number() != CurrentChannelNr) {
-           if (!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring())
-              Channels.SwitchTo(CurrentChannel->Number());
-           else
-              cDevice::SetCurrentChannel(CurrentChannel);
-           }
-        }
-     }
-  return osContinue;
-}
-
-void cMenuChannels::Move(int From, int To)
-{
-  int CurrentChannelNr = cDevice::CurrentChannel();
-  cChannel *CurrentChannel = Channels.GetByNumber(CurrentChannelNr);
-  cChannel *FromChannel = GetChannel(From);
-  cChannel *ToChannel = GetChannel(To);
-  if (FromChannel && ToChannel) {
-     int FromNumber = FromChannel->Number();
-     int ToNumber = ToChannel->Number();
-     Channels.Move(FromChannel, ToChannel);
-     cOsdMenu::Move(From, To);
-     Propagate();
-     Channels.SetModified(true);
-     isyslog("channel %d moved to %d", FromNumber, ToNumber);
-     if (CurrentChannel && CurrentChannel->Number() != CurrentChannelNr) {
-        if (!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring())
-           Channels.SwitchTo(CurrentChannel->Number());
-        else
-           cDevice::SetCurrentChannel(CurrentChannel);
-        }
-     }
-}
-
-eOSState cMenuChannels::ProcessKey(eKeys Key)
-{
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  switch (state) {
-    case osUser1: {
-         cChannel *channel = Channels.Last();
-         if (channel) {
-            Add(new cMenuChannelItem(channel), true);
-            return CloseSubMenu();
-            }
-         }
-         break;
-    default:
-         if (state == osUnknown) {
-            switch (Key) {
-              case k0 ... k9:
-                            return Number(Key);
-              case kOk:     return Switch();
-              case kRed:    return Edit();
-              case kGreen:  return New();
-              case kYellow: return Delete();
-              case kBlue:   if (!HasSubMenu())
-                               Mark();
-                            break;
-              default: break;
-              }
-            }
-    }
-  return state;
-}
-
-// --- cMenuText -------------------------------------------------------------
-
-cMenuText::cMenuText(const char *Title, const char *Text, eDvbFont Font)
-:cOsdMenu(Title)
-{
-  SetMenuCategory(mcText);
-  text = NULL;
-  font = Font;
-  SetText(Text);
-}
-
-cMenuText::~cMenuText()
-{
-  free(text);
-}
-
-void cMenuText::SetText(const char *Text)
-{
-  free(text);
-  text = Text ? strdup(Text) : NULL;
-}
-
-void cMenuText::Display(void)
-{
-  cOsdMenu::Display();
-  DisplayMenu()->SetText(text, font == fontFix); //XXX define control character in text to choose the font???
-  if (text)
-     cStatus::MsgOsdTextItem(text);
-}
-
-eOSState cMenuText::ProcessKey(eKeys Key)
-{
-  switch (int(Key)) {
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-    case kLeft|k_Repeat:
-    case kLeft:
-    case kRight|k_Repeat:
-    case kRight:
-                  DisplayMenu()->Scroll(NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft, NORMALKEY(Key) == kLeft || NORMALKEY(Key) == kRight);
-                  cStatus::MsgOsdTextItem(NULL, NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft);
-                  return osContinue;
-    default: break;
-    }
-
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kOk: return osBack;
-       default:  state = osContinue;
-       }
-     }
-  return state;
-}
-
-// --- cMenuFolderItem -------------------------------------------------------
-
-class cMenuFolderItem : public cOsdItem {
-private:
-  cNestedItem *folder;
-public:
-  cMenuFolderItem(cNestedItem *Folder);
-  cNestedItem *Folder(void) { return folder; }
-  };
-
-cMenuFolderItem::cMenuFolderItem(cNestedItem *Folder)
-:cOsdItem(Folder->Text())
-{
-  folder = Folder;
-  if (folder->SubItems())
-     SetText(cString::sprintf("%s...", folder->Text()));
-}
-
-// --- cMenuEditFolder -------------------------------------------------------
-
-class cMenuEditFolder : public cOsdMenu {
-private:
-  cList<cNestedItem> *list;
-  cNestedItem *folder;
-  char name[PATH_MAX];
-  int subFolder;
-  eOSState Confirm(void);
-public:
-  cMenuEditFolder(const char *Dir, cList<cNestedItem> *List, cNestedItem *Folder = NULL);
-  cString GetFolder(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  };
-
-cMenuEditFolder::cMenuEditFolder(const char *Dir, cList<cNestedItem> *List, cNestedItem *Folder)
-:cOsdMenu(Folder ? tr("Edit folder") : tr("New folder"), 12)
-{
-  SetMenuCategory(mcFolder);
-  list = List;
-  folder = Folder;
-  if (folder) {
-     strn0cpy(name, folder->Text(), sizeof(name));
-     subFolder = folder->SubItems() != NULL;
-     }
-  else {
-     *name = 0;
-     subFolder = 0;
-     cRemote::Put(kRight, true); // go right into string editing mode
-     }
-  if (!isempty(Dir)) {
-     cOsdItem *DirItem = new cOsdItem(Dir);
-     DirItem->SetSelectable(false);
-     Add(DirItem);
-     }
-  Add(new cMenuEditStrItem( tr("Name"), name, sizeof(name)));
-  Add(new cMenuEditBoolItem(tr("Sub folder"), &subFolder));
-}
-
-cString cMenuEditFolder::GetFolder(void)
-{
-  return folder ? folder->Text() : "";
-}
-
-eOSState cMenuEditFolder::Confirm(void)
-{
-  if (!folder || strcmp(folder->Text(), name) != 0) {
-     // each name may occur only once in a folder list
-     for (cNestedItem *Folder = list->First(); Folder; Folder = list->Next(Folder)) {
-         if (strcmp(Folder->Text(), name) == 0) {
-            Skins.Message(mtError, tr("Folder name already exists!"));
-            return osContinue;
-            }
-         }
-     char *p = strpbrk(name, "\\{}#~"); // FOLDERDELIMCHAR
-     if (p) {
-        Skins.Message(mtError, cString::sprintf(tr("Folder name must not contain '%c'!"), *p));
-        return osContinue;
-        }
-     }
-  if (folder) {
-     folder->SetText(name);
-     folder->SetSubItems(subFolder);
-     }
-  else
-     list->Add(folder = new cNestedItem(name, subFolder));
-  return osEnd;
-}
-
-eOSState cMenuEditFolder::ProcessKey(eKeys Key)
-{
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kOk:     return Confirm();
-       case kRed:
-       case kGreen:
-       case kYellow:
-       case kBlue:   return osContinue;
-       default: break;
-       }
-     }
-  return state;
-}
-
-// --- cMenuFolder -----------------------------------------------------------
-
-cMenuFolder::cMenuFolder(const char *Title, cNestedItemList *NestedItemList, const char *Path)
-:cOsdMenu(Title)
-{
-  SetMenuCategory(mcFolder);
-  list = nestedItemList = NestedItemList;
-  firstFolder = NULL;
-  editing = false;
-  Set();
-  SetHelpKeys();
-  DescendPath(Path);
-}
-
-cMenuFolder::cMenuFolder(const char *Title, cList<cNestedItem> *List, cNestedItemList *NestedItemList, const char *Dir, const char *Path)
-:cOsdMenu(Title)
-{
-  SetMenuCategory(mcFolder);
-  list = List;
-  nestedItemList = NestedItemList;
-  dir = Dir;
-  firstFolder = NULL;
-  editing = false;
-  Set();
-  SetHelpKeys();
-  DescendPath(Path);
-}
-
-void cMenuFolder::SetHelpKeys(void)
-{
-  SetHelp(firstFolder ? tr("Button$Select") : NULL, tr("Button$New"), firstFolder ? tr("Button$Delete") : NULL, firstFolder ? tr("Button$Edit") : NULL);
-}
-
-void cMenuFolder::Set(const char *CurrentFolder)
-{
-  firstFolder = NULL;
-  Clear();
-  if (!isempty(dir)) {
-     cOsdItem *DirItem = new cOsdItem(dir);
-     DirItem->SetSelectable(false);
-     Add(DirItem);
-     }
-  list->Sort();
-  for (cNestedItem *Folder = list->First(); Folder; Folder = list->Next(Folder)) {
-      cOsdItem *FolderItem = new cMenuFolderItem(Folder);
-      Add(FolderItem, CurrentFolder ? strcmp(Folder->Text(), CurrentFolder) == 0 : false);
-      if (!firstFolder)
-         firstFolder = FolderItem;
-      }
-}
-
-void cMenuFolder::DescendPath(const char *Path)
-{
-  if (Path) {
-     const char *p = strchr(Path, FOLDERDELIMCHAR);
-     if (p) {
-        for (cMenuFolderItem *Folder = (cMenuFolderItem *)firstFolder; Folder; Folder = (cMenuFolderItem *)Next(Folder)) {
-            if (strncmp(Folder->Folder()->Text(), Path, p - Path) == 0) {
-               SetCurrent(Folder);
-               if (Folder->Folder()->SubItems())
-                  AddSubMenu(new cMenuFolder(Title(), Folder->Folder()->SubItems(), nestedItemList, !isempty(dir) ? *cString::sprintf("%s%c%s", *dir, FOLDERDELIMCHAR, Folder->Folder()->Text()) : Folder->Folder()->Text(), p + 1));
-               break;
-               }
-            }
-        }
-    }
-}
-
-eOSState cMenuFolder::Select(void)
-{
-  if (firstFolder) {
-     cMenuFolderItem *Folder = (cMenuFolderItem *)Get(Current());
-     if (Folder) {
-        if (Folder->Folder()->SubItems())
-           return AddSubMenu(new cMenuFolder(Title(), Folder->Folder()->SubItems(), nestedItemList, !isempty(dir) ? *cString::sprintf("%s%c%s", *dir, FOLDERDELIMCHAR, Folder->Folder()->Text()) : Folder->Folder()->Text()));
-        else
-           return osEnd;
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuFolder::New(void)
-{
-  editing = true;
-  return AddSubMenu(new cMenuEditFolder(dir, list));
-}
-
-eOSState cMenuFolder::Delete(void)
-{
-  if (!HasSubMenu() && firstFolder) {
-     cMenuFolderItem *Folder = (cMenuFolderItem *)Get(Current());
-     if (Folder && Interface->Confirm(Folder->Folder()->SubItems() ? tr("Delete folder and all sub folders?") : tr("Delete folder?"))) {
-        list->Del(Folder->Folder());
-        Del(Folder->Index());
-        firstFolder = Get(isempty(dir) ? 0 : 1);
-        Display();
-        SetHelpKeys();
-        nestedItemList->Save();
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuFolder::Edit(void)
-{
-  if (!HasSubMenu() && firstFolder) {
-     cMenuFolderItem *Folder = (cMenuFolderItem *)Get(Current());
-     if (Folder) {
-        editing = true;
-        return AddSubMenu(new cMenuEditFolder(dir, list, Folder->Folder()));
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuFolder::SetFolder(void)
-{
-  cMenuEditFolder *mef = (cMenuEditFolder *)SubMenu();
-  if (mef) {
-     Set(mef->GetFolder());
-     SetHelpKeys();
-     Display();
-     nestedItemList->Save();
-     }
-  return CloseSubMenu();
-}
-
-cString cMenuFolder::GetFolder(void)
-{
-  if (firstFolder) {
-     cMenuFolderItem *Folder = (cMenuFolderItem *)Get(Current());
-     if (Folder) {
-        cMenuFolder *mf = (cMenuFolder *)SubMenu();
-        if (mf)
-           return cString::sprintf("%s%c%s", Folder->Folder()->Text(), FOLDERDELIMCHAR, *mf->GetFolder());
-        return Folder->Folder()->Text();
-        }
-     }
-  return "";
-}
-
-eOSState cMenuFolder::ProcessKey(eKeys Key)
-{
-  if (!HasSubMenu())
-     editing = false;
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kOk:
-       case kRed:    return Select();
-       case kGreen:  return New();
-       case kYellow: return Delete();
-       case kBlue:   return Edit();
-       default:      state = osContinue;
-       }
-     }
-  else if (state == osEnd && HasSubMenu() && editing)
-     state = SetFolder();
-  return state;
-}
-
-// --- cMenuEditTimer --------------------------------------------------------
-
-cMenuEditTimer::cMenuEditTimer(cTimer *Timer, bool New)
-:cOsdMenu(tr("Edit timer"), 12)
-{
-  SetMenuCategory(mcTimerEdit);
-  file = NULL;
-  day = firstday = NULL;
-  timer = Timer;
-  addIfConfirmed = New;
-  if (timer) {
-     data = *timer;
-     if (New)
-        data.SetFlags(tfActive);
-     channel = data.Channel()->Number();
-     Add(new cMenuEditBitItem( tr("Active"),       &data.flags, tfActive));
-     Add(new cMenuEditChanItem(tr("Channel"),      &channel));
-     Add(day = new cMenuEditDateItem(tr("Day"),    &data.day, &data.weekdays));
-     Add(new cMenuEditTimeItem(tr("Start"),        &data.start));
-     Add(new cMenuEditTimeItem(tr("Stop"),         &data.stop));
-     Add(new cMenuEditBitItem( tr("VPS"),          &data.flags, tfVps));
-     Add(new cMenuEditIntItem( tr("Priority"),     &data.priority, 0, MAXPRIORITY));
-     Add(new cMenuEditIntItem( tr("Lifetime"),     &data.lifetime, 0, MAXLIFETIME));
-
-     // PIN PATCH
-     if (cOsd::pinValid || !data.fskProtection) Add(new cMenuEditBoolItem(tr("Childlock"),&data.fskProtection));
-     else {
-        char* buf = 0;
-        asprintf(&buf, "%s\t%s", tr("Childlock"), data.fskProtection ? tr("yes") : tr("no"));
-        Add(new cOsdItem(buf));
-        free(buf);
-        }
-
-     Add(file = new cMenuEditStrItem( tr("File"),   data.file, sizeof(data.file)));
-     SetFirstDayItem();
-     }
-  SetHelpKeys();
-  Timers.IncBeingEdited();
-}
-
-cMenuEditTimer::~cMenuEditTimer()
-{
-  if (timer && addIfConfirmed)
-     delete timer; // apparently it wasn't confirmed
-  Timers.DecBeingEdited();
-}
-
-void cMenuEditTimer::SetHelpKeys(void)
-{
-  SetHelp(tr("Button$Folder"), data.weekdays ? tr("Button$Single") : tr("Button$Repeating"));
-}
-
-void cMenuEditTimer::SetFirstDayItem(void)
-{
-  if (!firstday && !data.IsSingleEvent()) {
-     Add(firstday = new cMenuEditDateItem(tr("First day"), &data.day));
-     Display();
-     }
-  else if (firstday && data.IsSingleEvent()) {
-     Del(firstday->Index());
-     firstday = NULL;
-     Display();
-     }
-}
-
-eOSState cMenuEditTimer::SetFolder(void)
-{
-  cMenuFolder *mf = (cMenuFolder *)SubMenu();
-  if (mf) {
-     cString Folder = mf->GetFolder();
-     char *p = strrchr(data.file, FOLDERDELIMCHAR);
-     if (p)
-        p++;
-     else
-        p = data.file;
-     if (!isempty(*Folder))
-        strn0cpy(data.file, cString::sprintf("%s%c%s", *Folder, FOLDERDELIMCHAR, p), sizeof(data.file));
-     else if (p != data.file)
-        memmove(data.file, p, strlen(p) + 1);
-     SetCurrent(file);
-     Display();
-     }
-  return CloseSubMenu();
-}
-
-eOSState cMenuEditTimer::ProcessKey(eKeys Key)
-{
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kOk:     {
-                       cChannel *ch = Channels.GetByNumber(channel);
-                       if (ch)
-                          data.channel = ch;
-                       else {
-                          Skins.Message(mtError, tr("*** Invalid Channel ***"));
-                          break;
-                          }
-                       if (!*data.file)
-                          strcpy(data.file, data.Channel()->ShortName(true));
-                       if (timer) {
-                          if (memcmp(timer, &data, sizeof(data)) != 0)
-                             *timer = data;
-                          if (addIfConfirmed)
-                             Timers.Add(timer);
-                          timer->SetEventFromSchedule();
-                          timer->Matches();
-                          Timers.SetModified();
-                          isyslog("timer %s %s (%s)", *timer->ToDescr(), addIfConfirmed ? "added" : "modified", timer->HasFlags(tfActive) ? "active" : "inactive");
-                          addIfConfirmed = false;
-                          }
-                     }
-                     return osBack;
-       case kRed:    return AddSubMenu(new cMenuFolder(tr("Select folder"), &Folders, data.file));
-       case kGreen:  if (day) {
-                        day->ToggleRepeating();
-                        SetCurrent(day);
-                        SetFirstDayItem();
-                        SetHelpKeys();
-                        Display();
-                        }
-                     return osContinue;
-       case kYellow:
-       case kBlue:   return osContinue;
-       default: break;
-       }
-     }
-  else if (state == osEnd && HasSubMenu())
-     state = SetFolder();
-  if (Key != kNone)
-     SetFirstDayItem();
-  return state;
-}
-
-// --- cMenuTimerItem --------------------------------------------------------
-
-class cMenuTimerItem : public cOsdItem {
-private:
-  cTimer *timer;
-  char diskStatus;
-public:
-  cMenuTimerItem(cTimer *Timer);
-  void SetDiskStatus(char DiskStatus);
-  virtual int Compare(const cListObject &ListObject) const;
-  virtual void Set(void);
-  cTimer *Timer(void) { return timer; }
-  virtual void SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable);
-  };
-
-cMenuTimerItem::cMenuTimerItem(cTimer *Timer)
-{
-  timer = Timer;
-  diskStatus = ' ';
-  Set();
-}
-
-int cMenuTimerItem::Compare(const cListObject &ListObject) const
-{
-  return timer->Compare(*((cMenuTimerItem *)&ListObject)->timer);
-}
-
-void cMenuTimerItem::Set(void)
-{
-  cString day, name("");
-  if (timer->WeekDays())
-     day = timer->PrintDay(0, timer->WeekDays(), false);
-  else if (timer->Day() - time(NULL) < 28 * SECSINDAY) {
-     day = itoa(timer->GetMDay(timer->Day()));
-     name = WeekDayName(timer->Day());
-     }
-  else {
-     struct tm tm_r;
-     time_t Day = timer->Day();
-     localtime_r(&Day, &tm_r);
-     char buffer[16];
-     strftime(buffer, sizeof(buffer), "%Y%m%d", &tm_r);
-     day = buffer;
-     }
-  const char *File = Setup.FoldersInTimerMenu ? NULL : strrchr(timer->File(), FOLDERDELIMCHAR);
-  if (File && strcmp(File + 1, TIMERMACRO_TITLE) && strcmp(File + 1, TIMERMACRO_EPISODE))
-     File++;
-  else
-     File = timer->File();
-  cCharSetConv csc("ISO-8859-1", cCharSetConv::SystemCharacterTable());
-  char diskStatusString[2] = { diskStatus, 0 };
-  SetText(cString::sprintf("%s%s\t%d\t%s%s%s\t%02d:%02d\t%02d:%02d\t%s",
-                    csc.Convert(diskStatusString),
-                    !(timer->HasFlags(tfActive)) ? " " : timer->FirstDay() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_ARROW_UTF8 : ICON_ARROW : "!" : timer->Recording() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_REC_UTF8 : ICON_REC : "#" : Setup.WarEagleIcons ? IsLangUtf8() ? ICON_CLOCK_UTF8 : ICON_CLOCK : ">",
-                    timer->Channel()->Number(),
-                    *name,
-                    *name && **name ? " " : "",
-                    *day,
-                    timer->Start() / 100,
-                    timer->Start() % 100,
-                    timer->Stop() / 100,
-                    timer->Stop() % 100,
-                    File));
-}
-
-void cMenuTimerItem::SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable)
-{
-  if (!DisplayMenu->SetItemTimer(timer, Index, Current, Selectable))
-     DisplayMenu->SetItem(Text(), Index, Current, Selectable);
-}
-
-void cMenuTimerItem::SetDiskStatus(char DiskStatus)
-{
-  diskStatus = DiskStatus;
-  Set();
-}
-
-// --- cTimerEntry -----------------------------------------------------------
-
-class cTimerEntry : public cListObject {
-private:
-  cMenuTimerItem *item;
-  const cTimer *timer;
-  time_t start;
-public:
-  cTimerEntry(cMenuTimerItem *item) : item(item), timer(item->Timer()), start(timer->StartTime()) {}
-  cTimerEntry(const cTimer *timer, time_t start) : item(NULL), timer(timer), start(start) {}
-  virtual int Compare(const cListObject &ListObject) const;
-  bool active(void) const { return timer->HasFlags(tfActive); }
-  time_t startTime(void) const { return start; }
-  int priority(void) const { return timer->Priority(); }
-  int duration(void) const;
-  bool repTimer(void) const { return !timer->IsSingleEvent(); }
-  bool isDummy(void) const { return item == NULL; }
-  const cTimer *Timer(void) const { return timer; }
-  void SetDiskStatus(char DiskStatus);
-  };
-
-int cTimerEntry::Compare(const cListObject &ListObject) const
-{
-  cTimerEntry *entry = (cTimerEntry *)&ListObject;
-  int r = startTime() - entry->startTime();
-  if (r == 0)
-     r = entry->priority() - priority();
-  return r;
-}
-
-int cTimerEntry::duration(void) const
-{
-  int dur = (timer->Stop()  / 100 * 60 + timer->Stop()  % 100) -
-            (timer->Start() / 100 * 60 + timer->Start() % 100);
-  if (dur < 0)
-     dur += 24 * 60;
-  return dur;
-}
-
-void cTimerEntry::SetDiskStatus(char DiskStatus)
-{
-  if (item)
-     item->SetDiskStatus(DiskStatus);
-}
-
-// --- cMenuTimers -----------------------------------------------------------
-
-class cMenuTimers : public cOsdMenu {
-private:
-  int helpKeys;
-  eOSState Edit(void);
-  eOSState New(void);
-  eOSState Delete(void);
-  eOSState OnOff(void);
-  eOSState Info(void);
-  cTimer *CurrentTimer(void);
-  void SetHelpKeys(void);
-  void ActualiseDiskStatus(void);
-  bool actualiseDiskStatus;
-public:
-  cMenuTimers(void);
-  virtual ~cMenuTimers();
-  virtual void Display(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuTimers"; }
-  };
-
-cMenuTimers::cMenuTimers(void)
-:cOsdMenu(tr("Timers"), 3, CHNUMWIDTH, 10, 6, 6)
-{
-  SetMenuCategory(mcTimer);
-  helpKeys = -1;
-  for (cTimer *timer = Timers.First(); timer; timer = Timers.Next(timer)) {
-      timer->SetEventFromSchedule(); // make sure the event is current
-      Add(new cMenuTimerItem(timer));
-      }
-  Sort();
-  SetCurrent(First());
-  SetHelpKeys();
-  Timers.IncBeingEdited();
-  actualiseDiskStatus = true;
-}
-
-cMenuTimers::~cMenuTimers()
-{
-  Timers.DecBeingEdited();
-}
-
-cTimer *cMenuTimers::CurrentTimer(void)
-{
-  cMenuTimerItem *item = (cMenuTimerItem *)Get(Current());
-  return item ? item->Timer() : NULL;
-}
-
-void cMenuTimers::SetHelpKeys(void)
-{
-  int NewHelpKeys = 0;
-  cTimer *timer = CurrentTimer();
-  if (timer) {
-     if (timer->Event())
-        NewHelpKeys = 2;
-     else
-        NewHelpKeys = 1;
-     }
-  if (NewHelpKeys != helpKeys) {
-     helpKeys = NewHelpKeys;
-     SetHelp(helpKeys > 0 ? tr("Button$On/Off") : NULL, tr("Button$New"), helpKeys > 0 ? tr("Button$Delete") : NULL, helpKeys == 2 ? tr("Button$Info") : NULL);
-     }
-}
-
-eOSState cMenuTimers::OnOff(void)
-{
-  if (HasSubMenu())
-     return osContinue;
-  cTimer *timer = CurrentTimer();
-  if (timer) {
-     timer->OnOff();
-     timer->SetEventFromSchedule();
-     RefreshCurrent();
-     Display();
-     if (timer->FirstDay())
-        isyslog("timer %s first day set to %s", *timer->ToDescr(), *timer->PrintFirstDay());
-     else
-        isyslog("timer %s %sactivated", *timer->ToDescr(), timer->HasFlags(tfActive) ? "" : "de");
-     Timers.SetModified();
-     }
-  return osContinue;
-}
-
-eOSState cMenuTimers::Edit(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  isyslog("editing timer %s", *CurrentTimer()->ToDescr());
-  return AddSubMenu(new cMenuEditTimer(CurrentTimer()));
-}
-
-eOSState cMenuTimers::New(void)
-{
-  if (HasSubMenu())
-     return osContinue;
-  return AddSubMenu(new cMenuEditTimer(new cTimer, true));
-}
-
-eOSState cMenuTimers::Delete(void)
-{
-  // Check if this timer is active:
-  cTimer *ti = CurrentTimer();
-  if (ti) {
-     if (Interface->Confirm(tr("Delete timer?"))) {
-        if (ti->Recording()) {
-           if (Interface->Confirm(tr("Timer still recording - really delete?"))) {
-              ti->Skip();
-              cRecordControls::Process(time(NULL));
-              }
-           else
-              return osContinue;
-           }
-        isyslog("deleting timer %s", *ti->ToDescr());
-        Timers.Del(ti);
-        cOsdMenu::Del(Current());
-        Timers.SetModified();
-        Display();
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuTimers::Info(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cTimer *ti = CurrentTimer();
-  if (ti && ti->Event())
-     return AddSubMenu(new cMenuEvent(ti->Event()));
-  return osContinue;
-}
-
-void cMenuTimers::ActualiseDiskStatus(void)
-{
-  if (!actualiseDiskStatus || !Count())
-     return;
-
-  // compute free disk space
-  int freeMB, freeMinutes, runshortMinutes;
-  VideoDiskSpace(&freeMB);
-  freeMinutes = int(double(freeMB) * 1.1 / 25.75); // overestimate by 10 percent
-  runshortMinutes = freeMinutes / 5; // 20 Percent
-
-  // fill entries list
-  cTimerEntry *entry;
-  cList<cTimerEntry> entries;
-  for (cOsdItem *item = First(); item; item = Next(item))
-     entries.Add(new cTimerEntry((cMenuTimerItem *)item));
-
-  // search last start time
-  time_t last = 0;
-  for (entry = entries.First(); entry; entry = entries.Next(entry))
-     last = max(entry->startTime(), last);
-
-  // add entries for repeating timers
-  for (entry = entries.First(); entry; entry = entries.Next(entry))
-     if (entry->repTimer() && !entry->isDummy())
-        for (time_t start = cTimer::IncDay(entry->startTime(), 1);
-             start <= last;
-             start = cTimer::IncDay(start, 1))
-           if (entry->Timer()->DayMatches(start))
-              entries.Add(new cTimerEntry(entry->Timer(), start));
-
-  // set the disk-status
-  entries.Sort();
-  for (entry = entries.First(); entry; entry = entries.Next(entry)) {
-     char status = ' ';
-     if (entry->active()) {
-        freeMinutes -= entry->duration();
-        status = freeMinutes > runshortMinutes ? '+' : freeMinutes > 0 ? 177 /* +/- */ : '-';
-        }
-     entry->SetDiskStatus(status);
-#ifdef DEBUG_TIMER_INFO
-     dsyslog("timer-info: %c | %d | %s | %s | %3d | %+5d -> %+5d",
-             status,
-             entry->startTime(),
-             entry->active() ? "aktiv " : "n.akt.",
-             entry->repTimer() ? entry->isDummy() ? "  dummy  " : "mehrmalig" : "einmalig ",
-             entry->duration(),
-             entry->active() ? freeMinutes + entry->duration() : freeMinutes,
-             freeMinutes);
-#endif
-     }
-
-  actualiseDiskStatus = false;
-}
-
-void cMenuTimers::Display(void)
-{
-  ActualiseDiskStatus();
-  cOsdMenu::Display();
-}
-
-eOSState cMenuTimers::ProcessKey(eKeys Key)
-{
-  int TimerNumber = HasSubMenu() ? Count() : -1;
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kOk:     return Edit();
-       case kRed:    actualiseDiskStatus = true;
-                     state = OnOff(); break; // must go through SetHelpKeys()!
-       case kGreen:  return New();
-       case kYellow: actualiseDiskStatus = true;
-                     state = Delete(); break;
-       case kInfo:
-       case kBlue:   return Info();
-                     break;
-       default: break;
-       }
-     }
-  if (TimerNumber >= 0 && !HasSubMenu()) {
-     if (Timers.Get(TimerNumber)) // a newly created timer was confirmed with Ok
-        Add(new cMenuTimerItem(Timers.Get(TimerNumber)), true);
-     Sort();
-     actualiseDiskStatus = true;
-     Display();
-     }
-  if (Key != kNone)
-     SetHelpKeys();
-  return state;
-}
-
-// --- cMenuEvent ------------------------------------------------------------
-
-cMenuEvent::cMenuEvent(const cEvent *Event, bool CanSwitch, bool Buttons)
-:cOsdMenu(tr("Event"))
-{
-  SetMenuCategory(mcEvent);
-  event = Event;
-  if (event) {
-     cChannel *channel = Channels.GetByChannelID(event->ChannelID(), true);
-     if (channel) {
-        SetTitle(channel->Name());
-        eTimerMatch TimerMatch = tmNone;
-        Timers.GetMatch(event, &TimerMatch);
-        if (Buttons)
-           SetHelp(TimerMatch == tmFull ? tr("Button$Timer") : tr("Button$Record"), NULL, NULL, CanSwitch ? tr("Button$Switch") : NULL);
-        }
-     }
-}
-
-void cMenuEvent::Display(void)
-{
-  cOsdMenu::Display();
-  DisplayMenu()->SetEvent(event);
-  cStatus::MsgOsdSetEvent(event);
-  if (event->Description())
-     cStatus::MsgOsdTextItem(event->Description());
-}
-
-eOSState cMenuEvent::ProcessKey(eKeys Key)
-{
-  switch (int(Key)) {
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-    case kLeft|k_Repeat:
-    case kLeft:
-    case kRight|k_Repeat:
-    case kRight:
-                  DisplayMenu()->Scroll(NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft, NORMALKEY(Key) == kLeft || NORMALKEY(Key) == kRight);
-                  cStatus::MsgOsdTextItem(NULL, NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft);
-                  return osContinue;
-    case kInfo:   return osBack;
-    default: break;
-    }
-
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kGreen:
-       case kYellow: return osContinue;
-       case kOk:     return osBack;
-       default: break;
-       }
-     }
-  return state;
-}
-
-// --- cMenuScheduleItem -----------------------------------------------------
-
-class cMenuScheduleItem : public cOsdItem {
-public:
-  enum eScheduleSortMode { ssmAllThis, ssmThisThis, ssmThisAll, ssmAllAll }; // "which event(s) on which channel(s)"
-private:
-  static eScheduleSortMode sortMode;
-public:
-  const cEvent *event;
-  const cChannel *channel;
-  bool withDate;
-  eTimerMatch timerMatch;
-  cMenuScheduleItem(const cEvent *Event, cChannel *Channel = NULL, bool WithDate = false);
-  static void SetSortMode(eScheduleSortMode SortMode) { sortMode = SortMode; }
-  static void IncSortMode(void) { sortMode = eScheduleSortMode((sortMode == ssmAllAll) ? ssmAllThis : sortMode + 1); }
-  static eScheduleSortMode SortMode(void) { return sortMode; }
-  virtual int Compare(const cListObject &ListObject) const;
-  bool Update(bool Force = false);
-  virtual void SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable);
-  };
-
-cMenuScheduleItem::eScheduleSortMode cMenuScheduleItem::sortMode = ssmAllThis;
-
-cMenuScheduleItem::cMenuScheduleItem(const cEvent *Event, cChannel *Channel, bool WithDate)
-{
-  event = Event;
-  channel = Channel;
-  withDate = WithDate;
-  timerMatch = tmNone;
-  Update(true);
-}
-
-int cMenuScheduleItem::Compare(const cListObject &ListObject) const
-{
-  cMenuScheduleItem *p = (cMenuScheduleItem *)&ListObject;
-  int r = -1;
-  if (sortMode != ssmAllThis)
-     r = strcoll(event->Title(), p->event->Title());
-  if (sortMode == ssmAllThis || r == 0)
-     r = event->StartTime() - p->event->StartTime();
-  return r;
-}
-
-static const char *TimerMatchChars[9] =
-{
-  " ", "t", "T",
-  ICON_BLANK, ICON_CLOCK_UH, ICON_CLOCK,
-  ICON_BLANK_UTF8, ICON_CLOCK_UH_UTF8, ICON_CLOCK_UTF8
-};
-
-bool cMenuScheduleItem::Update(bool Force)
-{
-  bool result = false;
-  eTimerMatch OldTimerMatch = timerMatch;
-  Timers.GetMatch(event, &timerMatch);
-  if (Force || timerMatch != OldTimerMatch) {
-     cString buffer;
-     const char *t = Setup.WarEagleIcons ? IsLangUtf8() ? TimerMatchChars[timerMatch+6] : TimerMatchChars[timerMatch+3] : TimerMatchChars[timerMatch];
-     const char *v = event->Vps() && (event->Vps() - event->StartTime()) ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_VPS_UTF8 : ICON_VPS : "V" : " ";
-     const char *r = event->SeenWithin(30) && event->IsRunning() ? Setup.WarEagleIcons ? IsLangUtf8() ? ICON_RUNNING_UTF8 : ICON_RUNNING : "*" : " ";
-     const char *csn = channel ? channel->ShortName(true) : NULL;
-     cString eds = event->GetDateString();
-     if (channel && withDate)
-        buffer = cString::sprintf("%d\t%.*s\t%.*s\t%s\t%s%s%s\t%s", channel->Number(), Utf8SymChars(csn, 999), csn, Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
-     else if (channel)
-        buffer = cString::sprintf("%d\t%.*s\t%s\t%s%s%s\t%s", channel->Number(), Utf8SymChars(csn, 999), csn, *event->GetTimeString(), t, v, r, event->Title());
-     else
-        buffer = cString::sprintf("%.*s\t%s\t%s%s%s\t%s", Utf8SymChars(eds, 6), *eds, *event->GetTimeString(), t, v, r, event->Title());
-     SetText(buffer);
-     result = true;
-     }
-  return result;
-}
-
-void cMenuScheduleItem::SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable)
-{
-  if (!DisplayMenu->SetItemEvent(event, Index, Current, Selectable, channel, withDate, timerMatch))
-     DisplayMenu->SetItem(Text(), Index, Current, Selectable);
-}
-
-// --- cMenuWhatsOn ----------------------------------------------------------
-
-class cMenuWhatsOn : public cOsdMenu {
-private:
-  bool now;
-  int helpKeys;
-  int timerState;
-  eOSState Record(void);
-  eOSState Switch(void);
-  static int currentChannel;
-  static const cEvent *scheduleEvent;
-  bool Update(void);
-  void SetHelpKeys(void);
-public:
-  cMenuWhatsOn(const cSchedules *Schedules, bool Now, int CurrentChannelNr);
-  static int CurrentChannel(void) { return currentChannel; }
-  static void SetCurrentChannel(int ChannelNr) { currentChannel = ChannelNr; }
-  static const cEvent *ScheduleEvent(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return now ? "MenuWhatsOnNow" : "MenuWhatsOnNext"; }
-  virtual void Display(void);
-  };
-
-int cMenuWhatsOn::currentChannel = 0;
-const cEvent *cMenuWhatsOn::scheduleEvent = NULL;
-
-cMenuWhatsOn::cMenuWhatsOn(const cSchedules *Schedules, bool Now, int CurrentChannelNr)
-:cOsdMenu(Now ? tr("What's on now?") : tr("What's on next?"), CHNUMWIDTH, CHNAMWIDTH, 6, 4)
-{
-  SetMenuCategory(Now ? mcScheduleNow : mcScheduleNext);
-  now = Now;
-  helpKeys = -1;
-  timerState = 0;
-  Timers.Modified(timerState);
-  for (cChannel *Channel = Channels.First(); Channel; Channel = Channels.Next(Channel)) {
-      if (!Channel->GroupSep()) {
-         const cSchedule *Schedule = Schedules->GetSchedule(Channel);
-         if (Schedule) {
-            const cEvent *Event = Now ? Schedule->GetPresentEvent() : Schedule->GetFollowingEvent();
-            if (Event)
-               Add(new cMenuScheduleItem(Event, Channel), Channel->Number() == CurrentChannelNr);
-            }
-         }
-      }
-  currentChannel = CurrentChannelNr;
-  Display();
-  SetHelpKeys();
-}
-
-void cMenuWhatsOn::Display(void)
-{
-   cOsdMenu::Display();
-
-   if (Count() > 0) {
-      int ni = 0;
-      for (cOsdItem *item = First(); item; item = Next(item)) {
-         cStatus::MsgOsdEventItem(((cMenuScheduleItem*)item)->event, item->Text(), ni++, Count());
-      }
-   }
-}
-
-bool cMenuWhatsOn::Update(void)
-{
-  bool result = false;
-  if (Timers.Modified(timerState)) {
-     for (cOsdItem *item = First(); item; item = Next(item)) {
-         if (((cMenuScheduleItem *)item)->Update())
-            result = true;
-         }
-     }
-  return result;
-}
-
-void cMenuWhatsOn::SetHelpKeys(void)
-{
-  cMenuScheduleItem *item = (cMenuScheduleItem *)Get(Current());
-  int NewHelpKeys = 0;
-  if (item) {
-     if (item->timerMatch == tmFull)
-        NewHelpKeys = 2;
-     else
-        NewHelpKeys = 1;
-     }
-  if (NewHelpKeys != helpKeys) {
-     const char *Red[] = { NULL, tr("Button$Record"), tr("Button$Timer") };
-     SetHelp(Red[NewHelpKeys], now ? tr("Button$Next") : tr("Button$Now"), tr("Button$Schedule"), tr("Button$Switch"));
-     helpKeys = NewHelpKeys;
-     }
-}
-
-const cEvent *cMenuWhatsOn::ScheduleEvent(void)
-{
-  const cEvent *ei = scheduleEvent;
-  scheduleEvent = NULL;
-  return ei;
-}
-
-eOSState cMenuWhatsOn::Switch(void)
-{
-  cMenuScheduleItem *item = (cMenuScheduleItem *)Get(Current());
-  if (item) {
-     cChannel *channel = Channels.GetByChannelID(item->event->ChannelID(), true);
-     if (channel && cDevice::PrimaryDevice()->SwitchChannel(channel, true))
-        return osEnd;
-     }
-  Skins.Message(mtError, tr("Can't switch channel!"));
-  return osContinue;
-}
-
-eOSState cMenuWhatsOn::Record(void)
-{
-  cMenuScheduleItem *item = (cMenuScheduleItem *)Get(Current());
-  if (item) {
-     if (item->timerMatch == tmFull) {
-        eTimerMatch tm = tmNone;
-        cTimer *timer = Timers.GetMatch(item->event, &tm);
-        if (timer)
-           return AddSubMenu(new cMenuEditTimer(timer));
-        }
-     cTimer *timer = new cTimer(item->event);
-     cTimer *t = Timers.GetTimer(timer);
-     if (t) {
-        delete timer;
-        timer = t;
-        return AddSubMenu(new cMenuEditTimer(timer));
-        }
-     else {
-        Timers.Add(timer);
-        Timers.SetModified();
-        isyslog("timer %s added (active)", *timer->ToDescr());
-        if (timer->Matches(0, false, NEWTIMERLIMIT))
-           return AddSubMenu(new cMenuEditTimer(timer));
-        if (HasSubMenu())
-           CloseSubMenu();
-        if (Update())
-           Display();
-        SetHelpKeys();
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuWhatsOn::ProcessKey(eKeys Key)
-{
-  bool HadSubMenu = HasSubMenu();
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kRecord:
-       case kRed:    return Record();
-       case kYellow: state = osBack;
-                     // continue with kGreen
-       case kGreen:  {
-                       cMenuScheduleItem *mi = (cMenuScheduleItem *)Get(Current());
-                       if (mi) {
-                          scheduleEvent = mi->event;
-                          currentChannel = mi->channel->Number();
-                          }
-                     }
-                     break;
-       case kBlue:   return Switch();
-       case kInfo:
-       case kOk:     if (Count())
-                        return AddSubMenu(new cMenuEvent(((cMenuScheduleItem *)Get(Current()))->event, true, true));
-                     break;
-       default:      break;
-       }
-     }
-  else if (!HasSubMenu()) {
-     if (HadSubMenu && Update())
-        Display();
-     if (Key != kNone)
-        SetHelpKeys();
-     }
-  return state;
-}
-
-// --- cMenuSchedule ---------------------------------------------------------
-
-class cMenuSchedule : public cOsdMenu {
-private:
-  cSchedulesLock schedulesLock;
-  const cSchedules *schedules;
-  bool now, next;
-  int otherChannel;
-  int helpKeys;
-  int timerState;
-  eOSState Number(void);
-  eOSState Record(void);
-  eOSState Switch(void);
-  void PrepareScheduleAllThis(const cEvent *Event, const cChannel *Channel);
-  void PrepareScheduleThisThis(const cEvent *Event, const cChannel *Channel);
-  void PrepareScheduleThisAll(const cEvent *Event, const cChannel *Channel);
-  void PrepareScheduleAllAll(const cEvent *Event, const cChannel *Channel);
-  bool Update(void);
-  void SetHelpKeys(void);
-public:
-  cMenuSchedule(void);
-  virtual ~cMenuSchedule();
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuSchedule"; }
-  virtual void Display(void);
-  };
-
-cMenuSchedule::cMenuSchedule(void)
-:cOsdMenu("")
-{
-  SetMenuCategory(mcSchedule);
-  now = next = false;
-  otherChannel = 0;
-  helpKeys = -1;
-  timerState = 0;
-  Timers.Modified(timerState);
-  cMenuScheduleItem::SetSortMode(cMenuScheduleItem::ssmAllThis);
-  cChannel *channel = Channels.GetByNumber(cDevice::CurrentChannel());
-  if (channel) {
-     cMenuWhatsOn::SetCurrentChannel(channel->Number());
-     schedules = cSchedules::Schedules(schedulesLock);
-     PrepareScheduleAllThis(NULL, channel);
-     SetHelpKeys();
-     }
-}
-
-cMenuSchedule::~cMenuSchedule()
-{
-  cMenuWhatsOn::ScheduleEvent(); // makes sure any posted data is cleared
-}
-
-void cMenuSchedule::Display(void)
-{
-   cOsdMenu::Display();
-
-   if (Count() > 0) {
-      int ni = 0;
-      for (cOsdItem *item = First(); item; item = Next(item)) {
-         cStatus::MsgOsdEventItem(((cMenuScheduleItem*)item)->event, item->Text(), ni++, Count());
-      }
-   }
-}
-
-void cMenuSchedule::PrepareScheduleAllThis(const cEvent *Event, const cChannel *Channel)
-{
-  Clear();
-  SetCols(7, 6, 4);
-  SetTitle(cString::sprintf(tr("Schedule - %s"), Channel->Name()));
-  if (schedules && Channel) {
-     const cSchedule *Schedule = schedules->GetSchedule(Channel);
-     if (Schedule) {
-        const cEvent *PresentEvent = Event ? Event : Schedule->GetPresentEvent();
-        time_t now = time(NULL) - Setup.EPGLinger * 60;
-        for (const cEvent *ev = Schedule->Events()->First(); ev; ev = Schedule->Events()->Next(ev)) {
-            if (ev->EndTime() > now || ev == PresentEvent)
-               Add(new cMenuScheduleItem(ev), ev == PresentEvent);
-            }
-        }
-     }
-}
-
-void cMenuSchedule::PrepareScheduleThisThis(const cEvent *Event, const cChannel *Channel)
-{
-  Clear();
-  SetCols(7, 6, 4);
-  SetTitle(cString::sprintf(tr("This event - %s"), Channel->Name()));
-  if (schedules && Channel && Event) {
-     const cSchedule *Schedule = schedules->GetSchedule(Channel);
-     if (Schedule) {
-        time_t now = time(NULL) - Setup.EPGLinger * 60;
-        for (const cEvent *ev = Schedule->Events()->First(); ev; ev = Schedule->Events()->Next(ev)) {
-            if ((ev->EndTime() > now || ev == Event) && !strcmp(ev->Title(), Event->Title()))
-               Add(new cMenuScheduleItem(ev), ev == Event);
-            }
-        }
-     }
-}
-
-void cMenuSchedule::PrepareScheduleThisAll(const cEvent *Event, const cChannel *Channel)
-{
-  Clear();
-  SetCols(CHNUMWIDTH, CHNAMWIDTH, 7, 6, 4);
-  SetTitle(tr("This event - all channels"));
-  if (schedules && Event) {
-     for (cChannel *ch = Channels.First(); ch; ch = Channels.Next(ch)) {
-         const cSchedule *Schedule = schedules->GetSchedule(ch);
-         if (Schedule) {
-            time_t now = time(NULL) - Setup.EPGLinger * 60;
-            for (const cEvent *ev = Schedule->Events()->First(); ev; ev = Schedule->Events()->Next(ev)) {
-                if ((ev->EndTime() > now || ev == Event) && !strcmp(ev->Title(), Event->Title()))
-                   Add(new cMenuScheduleItem(ev, ch, true), ev == Event && ch == Channel);
-                }
-            }
-         }
-     }
-}
-
-void cMenuSchedule::PrepareScheduleAllAll(const cEvent *Event, const cChannel *Channel)
-{
-  Clear();
-  SetCols(CHNUMWIDTH, CHNAMWIDTH, 7, 6, 4);
-  SetTitle(tr("All events - all channels"));
-  if (schedules) {
-     for (cChannel *ch = Channels.First(); ch; ch = Channels.Next(ch)) {
-         const cSchedule *Schedule = schedules->GetSchedule(ch);
-         if (Schedule) {
-            time_t now = time(NULL) - Setup.EPGLinger * 60;
-            for (const cEvent *ev = Schedule->Events()->First(); ev; ev = Schedule->Events()->Next(ev)) {
-                if (ev->EndTime() > now || ev == Event)
-                   Add(new cMenuScheduleItem(ev, ch, true), ev == Event && ch == Channel);
-                }
-            }
-         }
-     }
-}
-
-bool cMenuSchedule::Update(void)
-{
-  bool result = false;
-  if (Timers.Modified(timerState)) {
-     for (cOsdItem *item = First(); item; item = Next(item)) {
-         if (((cMenuScheduleItem *)item)->Update())
-            result = true;
-         }
-     }
-  return result;
-}
-
-void cMenuSchedule::SetHelpKeys(void)
-{
-  cMenuScheduleItem *item = (cMenuScheduleItem *)Get(Current());
-  int NewHelpKeys = 0;
-  if (item) {
-     if (item->timerMatch == tmFull)
-        NewHelpKeys = 2;
-     else
-        NewHelpKeys = 1;
-     }
-  if (NewHelpKeys != helpKeys) {
-     const char *Red[] = { NULL, tr("Button$Record"), tr("Button$Timer") };
-     SetHelp(Red[NewHelpKeys], tr("Button$Now"), tr("Button$Next"));
-     helpKeys = NewHelpKeys;
-     }
-}
-
-eOSState cMenuSchedule::Number(void)
-{
-  cMenuScheduleItem::IncSortMode();
-  cMenuScheduleItem *CurrentItem = (cMenuScheduleItem *)Get(Current());
-  const cChannel *Channel = NULL;
-  const cEvent *Event = NULL;
-  if (CurrentItem) {
-     Event = CurrentItem->event;
-     Channel = Channels.GetByChannelID(Event->ChannelID(), true);
-     }
-  else
-     Channel = Channels.GetByNumber(cDevice::CurrentChannel());
-  switch (cMenuScheduleItem::SortMode()) {
-    case cMenuScheduleItem::ssmAllThis:  PrepareScheduleAllThis(Event, Channel); break;
-    case cMenuScheduleItem::ssmThisThis: PrepareScheduleThisThis(Event, Channel); break;
-    case cMenuScheduleItem::ssmThisAll:  PrepareScheduleThisAll(Event, Channel); break;
-    case cMenuScheduleItem::ssmAllAll:   PrepareScheduleAllAll(Event, Channel); break;
-    default: esyslog("ERROR: unknown SortMode %d (%s %d)", cMenuScheduleItem::SortMode(), __FUNCTION__, __LINE__);
-    }
-  CurrentItem = (cMenuScheduleItem *)Get(Current());
-  Sort();
-  SetCurrent(CurrentItem);
-  Display();
-  return osContinue;
-}
-
-eOSState cMenuSchedule::Record(void)
-{
-  cMenuScheduleItem *item = (cMenuScheduleItem *)Get(Current());
-  if (item) {
-     if (item->timerMatch == tmFull) {
-        eTimerMatch tm = tmNone;
-        cTimer *timer = Timers.GetMatch(item->event, &tm);
-        if (timer)
-           return AddSubMenu(new cMenuEditTimer(timer));
-        }
-     cTimer *timer = new cTimer(item->event);
-     cTimer *t = Timers.GetTimer(timer);
-     if (t) {
-        delete timer;
-        timer = t;
-        return AddSubMenu(new cMenuEditTimer(timer));
-        }
-     else {
-        Timers.Add(timer);
-        Timers.SetModified();
-        isyslog("timer %s added (active)", *timer->ToDescr());
-        if (timer->Matches(0, false, NEWTIMERLIMIT))
-           return AddSubMenu(new cMenuEditTimer(timer));
-        if (HasSubMenu())
-           CloseSubMenu();
-        if (Update())
-           Display();
-        SetHelpKeys();
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuSchedule::Switch(void)
-{
-  if (otherChannel) {
-     if (Channels.SwitchTo(otherChannel))
-        return osEnd;
-     }
-  Skins.Message(mtError, tr("Can't switch channel!"));
-  return osContinue;
-}
-
-eOSState cMenuSchedule::ProcessKey(eKeys Key)
-{
-  bool HadSubMenu = HasSubMenu();
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case k0:      return Number();
-       case kRecord:
-       case kRed:    return Record();
-       case kGreen:  if (schedules) {
-                        if (!now && !next) {
-                           int ChannelNr = 0;
-                           if (Count()) {
-                              cChannel *channel = Channels.GetByChannelID(((cMenuScheduleItem *)Get(Current()))->event->ChannelID(), true);
-                              if (channel)
-                                 ChannelNr = channel->Number();
-                              }
-                           now = true;
-                           return AddSubMenu(new cMenuWhatsOn(schedules, true, ChannelNr));
-                           }
-                        now = !now;
-                        next = !next;
-                        return AddSubMenu(new cMenuWhatsOn(schedules, now, cMenuWhatsOn::CurrentChannel()));
-                        }
-       case kYellow: if (schedules)
-                        return AddSubMenu(new cMenuWhatsOn(schedules, false, cMenuWhatsOn::CurrentChannel()));
-                     break;
-       case kBlue:   if (Count() && otherChannel)
-                        return Switch();
-                     break;
-       case kInfo:
-       case kOk:     if (Count())
-                        return AddSubMenu(new cMenuEvent(((cMenuScheduleItem *)Get(Current()))->event, otherChannel, true));
-                     break;
-       default:      break;
-       }
-     }
-  else if (!HasSubMenu()) {
-     now = next = false;
-     const cEvent *ei = cMenuWhatsOn::ScheduleEvent();
-     if (ei) {
-        cChannel *channel = Channels.GetByChannelID(ei->ChannelID(), true);
-        if (channel) {
-           cMenuScheduleItem::SetSortMode(cMenuScheduleItem::ssmAllThis);
-           PrepareScheduleAllThis(NULL, channel);
-           if (channel->Number() != cDevice::CurrentChannel()) {
-              otherChannel = channel->Number();
-              SetHelp(Count() ? tr("Button$Record") : NULL, tr("Button$Now"), tr("Button$Next"), tr("Button$Switch"));
-              }
-           Display();
-           }
-        }
-     else if (HadSubMenu && Update())
-        Display();
-     if (Key != kNone)
-        SetHelpKeys();
-     }
-  return state;
-}
-
-// --- cMenuCommands ---------------------------------------------------------
-
-cMenuCommands::cMenuCommands(const char *Title, cList<cNestedItem> *Commands, const char *Parameters)
-:cOsdMenu(Title)
-{
-  SetMenuCategory(mcCommand);
-  result = NULL;
-  SetHasHotkeys();
-  commands = Commands;
-  parameters = Parameters;
-  for (cNestedItem *Command = commands->First(); Command; Command = commands->Next(Command)) {
-      const char *s = Command->Text();
-      if (Command->SubItems())
-         Add(new cOsdItem(hk(cString::sprintf("%s...", s))));
-      else if (Parse(s))
-         Add(new cOsdItem(hk(title)));
-      }
-}
-
-cMenuCommands::~cMenuCommands()
-{
-  free(result);
-}
-
-bool cMenuCommands::Parse(const char *s)
-{
-  const char *p = strchr(s, ':');
-  if (p) {
-     int l = p - s;
-     if (l > 0) {
-        char t[l + 1];
-        stripspace(strn0cpy(t, s, l + 1));
-        l = strlen(t);
-        if (l > 1 && t[l - 1] == '?') {
-           t[l - 1] = 0;
-           confirm = true;
-           }
-        else
-           confirm = false;
-        title = t;
-        command = skipspace(p + 1);
-        return true;
-        }
-     }
-  return false;
-}
-
-eOSState cMenuCommands::Execute(void)
-{
-  cNestedItem *Command = commands->Get(Current());
-  if (Command) {
-     if (Command->SubItems())
-        return AddSubMenu(new cMenuCommands(Title(), Command->SubItems(), parameters));
-     if (Parse(Command->Text())) {
-        if (!confirm || Interface->Confirm(cString::sprintf("%s?", *title))) {
-           Skins.Message(mtStatus, cString::sprintf("%s...", *title));
-           free(result);
-           result = NULL;
-           cString cmdbuf;
-           if (!isempty(parameters))
-              cmdbuf = cString::sprintf("%s %s", *command, *parameters);
-           const char *cmd = *cmdbuf ? *cmdbuf : *command;
-           dsyslog("executing command '%s'", cmd);
-           cPipe p;
-           if (p.Open(cmd, "r")) {
-              int l = 0;
-              int c;
-              while ((c = fgetc(p)) != EOF) {
-                    if (l % 20 == 0) {
-                       if (char *NewBuffer = (char *)realloc(result, l + 21))
-                          result = NewBuffer;
-                       else {
-                          esyslog("ERROR: out of memory");
-                          break;
-                          }
-                       }
-                    result[l++] = char(c);
-                    }
-              if (result)
-                 result[l] = 0;
-              p.Close();
-              }
-           else
-              esyslog("ERROR: can't open pipe for command '%s'", cmd);
-           Skins.Message(mtStatus, NULL);
-           if (result)
-              return AddSubMenu(new cMenuText(title, result, fontFix));
-           return osEnd;
-           }
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuCommands::ProcessKey(eKeys Key)
-{
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kRed:
-       case kGreen:
-       case kYellow:
-       case kBlue:   return osContinue;
-       case kOk:     return Execute();
-       default:      break;
-       }
-     }
-  return state;
-}
-
-// --- cMenuCam --------------------------------------------------------------
-
-static bool CamMenuIsOpen = false;
-
-class cMenuCam : public cOsdMenu {
-private:
-  cCamSlot *camSlot;
-  cCiMenu *ciMenu;
-  cCiEnquiry *ciEnquiry;
-  char *input;
-  int offset;
-  time_t lastCamExchange;
-  void GenerateTitle(const char *s = NULL);
-  void QueryCam(void);
-  void AddMultiLineItem(const char *s);
-  void Set(void);
-  eOSState Select(void);
-public:
-  cMenuCam(cCamSlot *CamSlot);
-  virtual ~cMenuCam();
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuCam"; }
-  };
-
-cMenuCam::cMenuCam(cCamSlot *CamSlot)
-:cOsdMenu("", 1) // tab necessary for enquiry!
-{
-  SetMenuCategory(mcCam);
-  camSlot = CamSlot;
-  ciMenu = NULL;
-  ciEnquiry = NULL;
-  input = NULL;
-  offset = 0;
-  lastCamExchange = time(NULL);
-  SetNeedsFastResponse(true);
-  QueryCam();
-  CamMenuIsOpen = true;
-}
-
-cMenuCam::~cMenuCam()
-{
-  if (ciMenu)
-     ciMenu->Abort();
-  delete ciMenu;
-  if (ciEnquiry)
-     ciEnquiry->Abort();
-  delete ciEnquiry;
-  free(input);
-  CamMenuIsOpen = false;
-}
-
-void cMenuCam::GenerateTitle(const char *s)
-{
-  SetTitle(cString::sprintf("CAM %d - %s", camSlot->SlotNumber(), (s && *s) ? s : camSlot->GetCamName()));
-}
-
-void cMenuCam::QueryCam(void)
-{
-  delete ciMenu;
-  ciMenu = NULL;
-  delete ciEnquiry;
-  ciEnquiry = NULL;
-  if (camSlot->HasUserIO()) {
-     ciMenu = camSlot->GetMenu();
-     ciEnquiry = camSlot->GetEnquiry();
-     }
-  Set();
-}
-
-void cMenuCam::Set(void)
-{
-  if (ciMenu) {
-     Clear();
-     free(input);
-     input = NULL;
-     dsyslog("CAM %d: Menu ------------------", camSlot->SlotNumber());
-     offset = 0;
-     SetHasHotkeys(ciMenu->Selectable());
-     GenerateTitle(ciMenu->TitleText());
-     dsyslog("CAM %d: '%s'", camSlot->SlotNumber(), ciMenu->TitleText());
-     if (*ciMenu->SubTitleText()) {
-        dsyslog("CAM %d: '%s'", camSlot->SlotNumber(), ciMenu->SubTitleText());
-        AddMultiLineItem(ciMenu->SubTitleText());
-        offset = Count();
-        }
-     for (int i = 0; i < ciMenu->NumEntries(); i++) {
-         Add(new cOsdItem(hk(ciMenu->Entry(i)), osUnknown, ciMenu->Selectable()));
-         dsyslog("CAM %d: '%s'", camSlot->SlotNumber(), ciMenu->Entry(i));
-         }
-     if (*ciMenu->BottomText()) {
-        AddMultiLineItem(ciMenu->BottomText());
-        dsyslog("CAM %d: '%s'", camSlot->SlotNumber(), ciMenu->BottomText());
-        }
-     cRemote::TriggerLastActivity();
-     }
-  else if (ciEnquiry) {
-     Clear();
-     int Length = ciEnquiry->ExpectedLength();
-     free(input);
-     input = MALLOC(char, Length + 1);
-     *input = 0;
-     GenerateTitle();
-     Add(new cOsdItem(ciEnquiry->Text(), osUnknown, false));
-     Add(new cOsdItem("", osUnknown, false));
-     Add(new cMenuEditNumItem("", input, Length, ciEnquiry->Blind()));
-     }
-  Display();
-}
-
-void cMenuCam::AddMultiLineItem(const char *s)
-{
-  while (s && *s) {
-        const char *p = strchr(s, '\n');
-        int l = p ? p - s : strlen(s);
-        cOsdItem *item = new cOsdItem;
-        item->SetSelectable(false);
-        item->SetText(strndup(s, l), false);
-        Add(item);
-        s = p ? p + 1 : p;
-        }
-}
-
-eOSState cMenuCam::Select(void)
-{
-  if (ciMenu) {
-     if (ciMenu->Selectable()) {
-        ciMenu->Select(Current() - offset);
-        dsyslog("CAM %d: select %d", camSlot->SlotNumber(), Current() - offset);
-        }
-     else
-        ciMenu->Cancel();
-     }
-  else if (ciEnquiry) {
-     if (ciEnquiry->ExpectedLength() < 0xFF && int(strlen(input)) != ciEnquiry->ExpectedLength()) {
-        char buffer[64];
-        snprintf(buffer, sizeof(buffer), tr("Please enter %d digits!"), ciEnquiry->ExpectedLength());
-        Skins.Message(mtError, buffer);
-        return osContinue;
-        }
-     ciEnquiry->Reply(input);
-     dsyslog("CAM %d: entered '%s'", camSlot->SlotNumber(), ciEnquiry->Blind() ? "****" : input);
-     }
-  QueryCam();
-  return osContinue;
-}
-
-eOSState cMenuCam::ProcessKey(eKeys Key)
-{
-  if (!camSlot->HasMMI())
-     return osBack;
-
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (ciMenu || ciEnquiry) {
-     lastCamExchange = time(NULL);
-     if (state == osUnknown) {
-        switch (Key) {
-          case kOk: return Select();
-          default: break;
-          }
-        }
-     else if (state == osBack) {
-        if (ciMenu)
-           ciMenu->Cancel();
-        if (ciEnquiry)
-           ciEnquiry->Cancel();
-        QueryCam();
-        return osContinue;
-        }
-     if (ciMenu && ciMenu->HasUpdate()) {
-        QueryCam();
-        return osContinue;
-        }
-     }
-  else if (time(NULL) - lastCamExchange < CAMRESPONSETIMEOUT)
-     QueryCam();
-  else {
-     Skins.Message(mtError, tr("CAM not responding!"));
-     return osBack;
-     }
-  return state;
-}
-
-// --- CamControl ------------------------------------------------------------
-
-cOsdObject *CamControl(void)
-{
-  for (cCamSlot *CamSlot = CamSlots.First(); CamSlot; CamSlot = CamSlots.Next(CamSlot)) {
-      if (CamSlot->HasUserIO())
-         return new cMenuCam(CamSlot);
-      }
-  return NULL;
-}
-
-bool CamMenuActive(void)
-{
-  return CamMenuIsOpen;
-}
-
-// --- cMenuRecording --------------------------------------------------------
-
-class cMenuRecording : public cOsdMenu {
-private:
-  const cRecording *recording;
-  bool withButtons;
-public:
-  cMenuRecording(const cRecording *Recording, bool WithButtons = false);
-  virtual void Display(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuRecording"; }
-};
-
-cMenuRecording::cMenuRecording(const cRecording *Recording, bool WithButtons)
-:cOsdMenu(tr("Recording info"))
-{
-  SetMenuCategory(mcRecordingInfo);
-  recording = Recording;
-  withButtons = WithButtons;
-  if (withButtons)
-     SetHelp(tr("Button$Play"), tr("Button$Rewind"));
-}
-
-void cMenuRecording::Display(void)
-{
-  cOsdMenu::Display();
-  DisplayMenu()->SetRecording(recording);
-  cStatus::MsgOsdSetRecording(recording);
-  if (recording->Info()->Description())
-     cStatus::MsgOsdTextItem(recording->Info()->Description());
-}
-
-eOSState cMenuRecording::ProcessKey(eKeys Key)
-{
-  switch (int(Key)) {
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-    case kLeft|k_Repeat:
-    case kLeft:
-    case kRight|k_Repeat:
-    case kRight:
-                  DisplayMenu()->Scroll(NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft, NORMALKEY(Key) == kLeft || NORMALKEY(Key) == kRight);
-                  cStatus::MsgOsdTextItem(NULL, NORMALKEY(Key) == kUp || NORMALKEY(Key) == kLeft);
-                  return osContinue;
-    case kInfo:   return osBack;
-    default: break;
-    }
-
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kRed:    if (withButtons)
-                        Key = kOk; // will play the recording, even if recording commands are defined
-       case kGreen:  if (!withButtons)
-                        break;
-                     cRemote::Put(Key, true);
-                     // continue with osBack to close the info menu and process the key
-       case kOk:     return osBack;
-       default: break;
-       }
-     }
-  return state;
-}
-
-// --- cMenuRecordingItem ----------------------------------------------------
-
-class cMenuRecordingItem : public cOsdItem {
-private:
-  cRecording *recording;
-  int level;
-  char *name;
-  int totalEntries, newEntries;
-public:
-  cMenuRecordingItem(cRecording *Recording, int Level);
-  ~cMenuRecordingItem();
-  void IncrementCounter(bool New);
-  const char *Name(void) { return name; }
-  cRecording *Recording(void) { return recording; }
-  bool IsDirectory(void) { return name != NULL; }
-  virtual void SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable);
-  };
-
-cMenuRecordingItem::cMenuRecordingItem(cRecording *Recording, int Level)
-{
-  recording = Recording;
-  level = Level;
-  name = NULL;
-  totalEntries = newEntries = 0;
-  SetText(Recording->Title('\t', true, Level));
-  if (*Text() == '\t')
-     name = strdup(Text() + 2); // 'Text() + 2' to skip the two '\t'
-}
-
-cMenuRecordingItem::~cMenuRecordingItem()
-{
-  free(name);
-}
-
-void cMenuRecordingItem::IncrementCounter(bool New)
-{
-  totalEntries++;
-  if (New)
-     newEntries++;
-  SetText(cString::sprintf("%d\t\t%d\t%s", totalEntries, newEntries, name));
-}
-
-void cMenuRecordingItem::SetMenuItem(cSkinDisplayMenu *DisplayMenu, int Index, bool Current, bool Selectable)
-{
-  if (!DisplayMenu->SetItemRecording(recording, Index, Current, Selectable, level, totalEntries, newEntries))
-     DisplayMenu->SetItem(Text(), Index, Current, Selectable);
-}
-
-// --- cMenuEditRecording ----------------------------------------------------
-
-class cMenuEditRecording : public cOsdMenu {
-private:
-  char name[MaxFileName];
-  cMenuEditStrItem *file;
-  cOsdItem *marksItem, *resumeItem;
-  bool isResume, isMarks;
-  cRecording *recording;
-  void SetHelpKeys(void);
-  eOSState SetFolder(void);
-public:
-  cMenuEditRecording(cRecording *Recording);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuRenameRecording"; }
-};
-
-cMenuEditRecording::cMenuEditRecording(cRecording *Recording)
-:cOsdMenu(tr("Edit recording"), 14)
-{
-  cMarks marks;
-
-  file = NULL;
-  recording = Recording;
-
-  if (recording) {
-     Utf8Strn0Cpy(name, recording->Name(), sizeof(name));
-     Add(file = new cMenuEditStrItem(tr("File"), name, sizeof(name)));
-
-     Add(new cOsdItem("", osUnknown, false));
-
-     Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Date"), *DayDateTime(recording->Start())), osUnknown, false));
-
-     cChannel *channel = Channels.GetByChannelID(((cRecordingInfo *)recording->Info())->ChannelID());
-     if (channel)
-        Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Channel"), *ChannelString(channel, 0)), osUnknown, false));
-
-     int recLen = recording->LengthInSeconds();
-     if (recLen >= 0)
-        Add(new cOsdItem(cString::sprintf("%s:\t%d:%02d:%02d", tr("Length"), recLen / 3600, recLen / 60 % 60, recLen % 60), osUnknown, false));
-     else
-        recLen = 0;
-
-     int dirSize = DirSizeMB(recording->FileName());
-     cString bitRate = recLen ? cString::sprintf(" (%.2f MBit/s)", 8.0 * dirSize / recLen) : cString("");
-     Add(new cOsdItem(cString::sprintf("%s:\t%s", tr("Format"), recording->IsPesRecording() ? tr("PES") : tr("TS")), osUnknown, false));
-     Add(new cOsdItem((dirSize > 9999) ? cString::sprintf("%s:\t%.2f GB%s", tr("Size"), dirSize / 1024.0, *bitRate) : cString::sprintf("%s:\t%d MB%s", tr("Size"), dirSize, *bitRate), osUnknown, false));
-
-     Add(new cOsdItem("", osUnknown, false));
-
-     isMarks = marks.Load(recording->FileName(), recording->FramesPerSecond(), recording->IsPesRecording()) && marks.Count();
-     marksItem = new cOsdItem(tr("Delete marks information?"), osUser1, isMarks);
-     Add(marksItem);
-
-     cResumeFile ResumeFile(recording->FileName(), recording->IsPesRecording());
-     isResume = (ResumeFile.Read() != -1);
-     resumeItem = new cOsdItem(tr("Delete resume information?"), osUser2, isResume);
-     Add(resumeItem);
-     }
-
-  SetHelpKeys();
-}
-
-void cMenuEditRecording::SetHelpKeys(void)
-{
-  SetHelp(tr("Button$Folder"), tr("Button$Cut"), tr("Button$Copy"), tr("Button$Rename/Move"));
-}
-
-eOSState cMenuEditRecording::SetFolder(void)
-{
-  cMenuFolder *mf = (cMenuFolder *)SubMenu();
-  if (mf) {
-     cString Folder = mf->GetFolder();
-     char *p = strrchr(name, FOLDERDELIMCHAR);
-     if (p)
-        p++;
-     else
-        p = name;
-     if (!isempty(*Folder))
-        strn0cpy(name, cString::sprintf("%s%c%s", *Folder, FOLDERDELIMCHAR, p), sizeof(name));
-     else if (p != name)
-        memmove(name, p, strlen(p) + 1);
-     SetCurrent(file);
-     Display();
-     }
-  return CloseSubMenu();
-}
-
-eOSState cMenuEditRecording::ProcessKey(eKeys Key)
-{
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kRed:
-            return AddSubMenu(new cMenuFolder(tr("Select folder"), &Folders, name));
-            break;
-       case kGreen:
-            if (!cCutter::Active()) {
-               if (!isMarks)
-                  Skins.Message(mtError, tr("No editing marks defined!"));
-               else if (!cCutter::Start(recording->FileName(), strcmp(recording->Name(), name) ? *NewVideoFileName(recording->FileName(), name) : NULL, false))
-                  Skins.Message(mtError, tr("Can't start editing process!"));
-               else
-                  Skins.Message(mtInfo, tr("Editing process started"));
-               }
-            else
-               Skins.Message(mtError, tr("Editing process already active!"));
-            return osContinue;
-       case kYellow:
-       case kBlue:
-            if (strcmp(recording->Name(), name)) {
-               if (!cFileTransfer::Active()) {
-                  if (cFileTransfer::Start(recording, name, (Key == kYellow)))
-                     Skins.Message(mtInfo, tr("File transfer started"));
-                  else
-                     Skins.Message(mtError, tr("Can't start file transfer!"));
-                  }
-               else
-                  Skins.Message(mtError, tr("File transfer already active!"));
-               }
-            return osRecordings;
-       default:
-            break;
-       }
-     return osContinue;
-     }
-  else if (state == osEnd && HasSubMenu())
-     state = SetFolder();
-  else if (state == osUser1) {
-     if (isMarks && Interface->Confirm(tr("Delete marks information?"))) {
-        cMarks marks;
-        marks.Load(recording->FileName(), recording->FramesPerSecond(), recording->IsPesRecording());
-        cMark *mark = marks.First();
-        while (mark) {
-              cMark *nextmark = marks.Next(mark);
-              marks.Del(mark);
-              mark = nextmark;
-              }
-        marks.Save();
-        isMarks = false;
-        marksItem->SetSelectable(isMarks);
-        SetCurrent(First());
-        Display();
-        }
-     return osContinue;
-     }
-  else if (state == osUser2) {
-     if (isResume && Interface->Confirm(tr("Delete resume information?"))) {
-        cResumeFile ResumeFile(recording->FileName(), recording->IsPesRecording());
-        ResumeFile.Delete();
-        isResume = false;
-        resumeItem->SetSelectable(isResume);
-        SetCurrent(First());
-        Display();
-        }
-     return osContinue;
-     }
-
-  return state;
-}
-
-// --- cMenuRecordings -------------------------------------------------------
-
-cMenuRecordings::cMenuRecordings(const char *Base, int Level, bool OpenSubMenus)
-:cOsdMenu(Base ? Base : tr("Recordings"), 9, 6, 6)
-{
-  SetMenuCategory(mcRecording);
-  base = Base ? strdup(Base) : NULL;
-  level = Setup.RecordingDirs ? Level : -1;
-  Recordings.StateChanged(recordingsState); // just to get the current state
-  helpKeys = -1;
-  Display(); // this keeps the higher level menus from showing up briefly when pressing 'Back' during replay
-  Set();
-  if (Current() < 0)
-     SetCurrent(First());
-  else if (OpenSubMenus && cReplayControl::LastReplayed() && Open(true))
-     return;
-  Display();
-  SetHelpKeys();
-}
-
-cMenuRecordings::~cMenuRecordings()
-{
-  helpKeys = -1;
-  free(base);
-}
-
-void cMenuRecordings::SetHelpKeys(void)
-{
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  int NewHelpKeys = 0;
-  if (ri) {
-     if (ri->IsDirectory())
-        NewHelpKeys = 1;
-     else {
-        NewHelpKeys = 2;
-        if (ri->Recording()->Info()->Title())
-           NewHelpKeys = 3;
-        }
-     }
-  if (NewHelpKeys != helpKeys) {
-     switch (NewHelpKeys) {
-       case 0: SetHelp(NULL); break;
-       case 1: SetHelp(tr("Button$Open")); break;
-       case 2:
-       case 3: SetHelp(RecordingCommands.Count() ? tr("Commands") : tr("Button$Play"), tr("Button$Rewind"), tr("Button$Delete"), NewHelpKeys == 3 ? tr("Button$Info") : NULL);
-       default: ;
-       }
-     helpKeys = NewHelpKeys;
-     }
-}
-
-void cMenuRecordings::Set(bool Refresh)
-{
-  const char *CurrentRecording = cReplayControl::LastReplayed();
-  cMenuRecordingItem *LastItem = NULL;
-  cThreadLock RecordingsLock(&Recordings);
-  if (Refresh) {
-     if (cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current()))
-        CurrentRecording = ri->Recording()->FileName();
-     }
-  Clear();
-  GetRecordingsSortMode(DirectoryName());
-  Recordings.Sort();
-  for (cRecording *recording = Recordings.First(); recording; recording = Recordings.Next(recording)) {
-      if (!base || (strstr(recording->Name(), base) == recording->Name() && recording->Name()[strlen(base)] == FOLDERDELIMCHAR)) {
-         cMenuRecordingItem *Item = new cMenuRecordingItem(recording, level);
-         cMenuRecordingItem *LastDir = NULL;
-         if (Item->IsDirectory()) {
-            // Sorting may ignore non-alphanumeric characters, so we need to explicitly handle directories in case they only differ in such characters:
-            for (cMenuRecordingItem *p = LastItem; p; p = dynamic_cast<cMenuRecordingItem *>(p->Prev())) {
-                if (p->Name() && strcmp(p->Name(), Item->Name()) == 0) {
-                   LastDir = p;
-                   break;
-                   }
-                }
-            }
-         if (*Item->Text() && !LastDir
-            && (!cStatus::MsgReplayProtected(Item->Recording(), Item->Name(), base, Item->IsDirectory(), true))) { // PIN PATCH
-            Add(Item);
-            LastItem = Item;
-            if (Item->IsDirectory())
-               LastDir = Item;
-            }
-         else
-            delete Item;
-         if (LastItem) {
-            if (CurrentRecording && strcmp(CurrentRecording, recording->FileName()) == 0)
-               SetCurrent(LastItem);
-            }
-         if (LastDir) {
-            LastDir->IncrementCounter(recording->IsNew());
-            LastItem = LastDir;
-            }
-         }
-      }
-  if (Refresh)
-     Display();
-}
-
-cString cMenuRecordings::DirectoryName(void)
-{
-  cString d(VideoDirectory);
-  if (base) {
-     char *s = ExchangeChars(strdup(base), true);
-     d = AddDirectory(d, s);
-     free(s);
-     }
-  return d;
-}
-
-bool cMenuRecordings::Open(bool OpenSubMenus)
-{
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri && ri->IsDirectory()) {
-     const char *t = ri->Name();
-     cString buffer;
-     if (base) {
-        buffer = cString::sprintf("%s~%s", base, t);
-        t = buffer;
-        }
-     AddSubMenu(new cMenuRecordings(t, level + 1, OpenSubMenus));
-     return true;
-     }
-  return false;
-}
-
-eOSState cMenuRecordings::Play(void)
-{
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri) {
-     if (cStatus::MsgReplayProtected(ri->Recording(), ri->Name(), base,
-                                     ri->IsDirectory()) == true)    // PIN PATCH
-        return osContinue;                                          // PIN PATCH
-     if (ri->IsDirectory())
-        Open();
-     else {
-        cReplayControl::SetRecording(ri->Recording()->FileName());
-        return osReplay;
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuRecordings::Rewind(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri && !ri->IsDirectory()) {
-     cDevice::PrimaryDevice()->StopReplay(); // must do this first to be able to rewind the currently replayed recording
-     cResumeFile ResumeFile(ri->Recording()->FileName(), ri->Recording()->IsPesRecording());
-     ResumeFile.Delete();
-     return Play();
-     }
-  return osContinue;
-}
-
-eOSState cMenuRecordings::Delete(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri && !ri->IsDirectory()) {
-     if (Interface->Confirm(tr("Delete recording?"))) {
-        cRecordControl *rc = cRecordControls::GetRecordControl(ri->Recording()->FileName());
-        if (rc) {
-           if (Interface->Confirm(tr("Timer still recording - really delete?"))) {
-              cTimer *timer = rc->Timer();
-              if (timer) {
-                 timer->Skip();
-                 cRecordControls::Process(time(NULL));
-                 if (timer->IsSingleEvent()) {
-                    isyslog("deleting timer %s", *timer->ToDescr());
-                    Timers.Del(timer);
-                    }
-                 Timers.SetModified();
-                 }
-              }
-           else
-              return osContinue;
-           }
-        cRecording *recording = ri->Recording();
-        cString FileName = recording->FileName();
-        if (cCutter::Active(ri->Recording()->FileName())) {
-           if (Interface->Confirm(tr("Recording is being edited - really delete?"))) {
-              cCutter::Stop();
-              recording = Recordings.GetByName(FileName); // cCutter::Stop() might have deleted it if it was the edited version
-              // we continue with the code below even if recording is NULL,
-              // in order to have the menu updated etc.
-              }
-           else
-              return osContinue;
-           }
-        if (cReplayControl::NowReplaying() && strcmp(cReplayControl::NowReplaying(), FileName) == 0)
-           cControl::Shutdown();
-        if (!recording || recording->Delete()) {
-           cReplayControl::ClearLastReplayed(FileName);
-           Recordings.DelByName(FileName);
-           cOsdMenu::Del(Current());
-           SetHelpKeys();
-           cVideoDiskUsage::ForceCheck();
-           Display();
-           if (!Count())
-              return osBack;
-           }
-        else
-           Skins.Message(mtError, tr("Error while deleting recording!"));
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuRecordings::Info(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri && !ri->IsDirectory() && ri->Recording()->Info()->Title())
-     return AddSubMenu(new cMenuRecording(ri->Recording(), true));
-  return osContinue;
-}
-
-eOSState cMenuRecordings::Commands(eKeys Key)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri && !ri->IsDirectory()) {
-     cMenuCommands *menu;
-     eOSState state = AddSubMenu(menu = new cMenuCommands(tr("Recording commands"), &RecordingCommands, cString::sprintf("\"%s\"", *strescape(ri->Recording()->FileName(), "\\\"$"))));
-     if (Key != kNone)
-        state = menu->ProcessKey(Key);
-     return state;
-     }
-  return osContinue;
-}
-
-eOSState cMenuRecordings::Sort(void)
-{
-  if (HasSubMenu())
-     return osContinue;
-  IncRecordingsSortMode(DirectoryName());
-  Set(true);
-  return osContinue;
-}
-
-eOSState cMenuRecordings::Edit(void)
-{
-  if (HasSubMenu() || Count() == 0)
-     return osContinue;
-  cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current());
-  if (ri && !ri->IsDirectory() && ri->Recording())
-     return AddSubMenu(new cMenuEditRecording(ri->Recording()));
-  return osContinue;
-}
-
-eOSState cMenuRecordings::ProcessKey(eKeys Key)
-{
-  bool HadSubMenu = HasSubMenu();
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  if (state == osUnknown) {
-     switch (Key) {
-       case kPlayPause:
-       case kPlay:
-       case kOk:     return Play();
-       case kRed:    return (helpKeys > 1 && RecordingCommands.Count()) ? Commands() : Play();
-       case kGreen:  return Rewind();
-       case kYellow: return Delete();
-       case kInfo:   return Edit();
-       case kBlue:   return Info();
-       case k0:      return Sort();
-       case k1...k9: return Commands(Key);
-       case kNone:   if (Recordings.StateChanged(recordingsState))
-                        Set(true);
-                     break;
-       default: break;
-       }
-     }
-  if (Key == kYellow && HadSubMenu && !HasSubMenu()) {
-     // the last recording in a subdirectory was deleted, so let's go back up
-     cOsdMenu::Del(Current());
-     if (!Count())
-        return osBack;
-     Display();
-     }
-  if (!HasSubMenu()) {
-     if (Key != kNone)
-        SetHelpKeys();
-     }
-  return state;
-}
-
-// --- cMenuSetupBase --------------------------------------------------------
-
-class cMenuSetupBase : public cMenuSetupPage {
-protected:
-  cSetup data;
-  virtual void Store(void);
-public:
-  cMenuSetupBase(void);
-  };
-
-cMenuSetupBase::cMenuSetupBase(void)
-{
-  data = Setup;
-}
-
-void cMenuSetupBase::Store(void)
-{
-  Setup = data;
-  cOsdProvider::UpdateOsdSize(true);
-  Setup.Save();
-}
-
-// --- cMenuSetupOSD ---------------------------------------------------------
-
-class cMenuSetupOSD : public cMenuSetupBase {
-private:
-  const char *useSmallFontTexts[3];
-  const char *keyColorTexts[4];
-  int osdLanguageIndex;
-  int numSkins;
-  int originalSkinIndex;
-  int skinIndex;
-  const char **skinDescriptions;
-  cThemes themes;
-  int originalThemeIndex;
-  int themeIndex;
-  cStringList fontOsdNames, fontSmlNames, fontFixNames;
-  int fontOsdIndex, fontSmlIndex, fontFixIndex;
-  virtual void Set(void);
-public:
-  cMenuSetupOSD(void);
-  virtual ~cMenuSetupOSD();
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuSetupOsd"; }
-  };
-
-cMenuSetupOSD::cMenuSetupOSD(void)
-{
-  SetMenuCategory(mcSetupOsd);
-  osdLanguageIndex = I18nCurrentLanguage();
-  numSkins = Skins.Count();
-  skinIndex = originalSkinIndex = Skins.Current()->Index();
-  skinDescriptions = new const char*[numSkins];
-  themes.Load(Skins.Current()->Name());
-  themeIndex = originalThemeIndex = Skins.Current()->Theme() ? themes.GetThemeIndex(Skins.Current()->Theme()->Description()) : 0;
-  cFont::GetAvailableFontNames(&fontOsdNames);
-  cFont::GetAvailableFontNames(&fontSmlNames);
-  cFont::GetAvailableFontNames(&fontFixNames, true);
-  fontOsdNames.Insert(strdup(DefaultFontOsd));
-  fontSmlNames.Insert(strdup(DefaultFontSml));
-  fontFixNames.Insert(strdup(DefaultFontFix));
-  fontOsdIndex = max(0, fontOsdNames.Find(Setup.FontOsd));
-  fontSmlIndex = max(0, fontSmlNames.Find(Setup.FontSml));
-  fontFixIndex = max(0, fontFixNames.Find(Setup.FontFix));
-  Set();
-}
-
-cMenuSetupOSD::~cMenuSetupOSD()
-{
-  delete[] skinDescriptions;
-}
-
-void cMenuSetupOSD::Set(void)
-{
-  int current = Current();
-  for (cSkin *Skin = Skins.First(); Skin; Skin = Skins.Next(Skin))
-      skinDescriptions[Skin->Index()] = Skin->Description();
-  useSmallFontTexts[0] = tr("never");
-  useSmallFontTexts[1] = tr("skin dependent");
-  useSmallFontTexts[2] = tr("always");
-  keyColorTexts[0] = tr("Key$Red");
-  keyColorTexts[1] = tr("Key$Green");
-  keyColorTexts[2] = tr("Key$Yellow");
-  keyColorTexts[3] = tr("Key$Blue");
-  Clear();
-  SetSection(tr("OSD"));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Language"),               &osdLanguageIndex, I18nNumLanguagesWithLocale(), &I18nLanguages()->At(0)));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Skin"),                   &skinIndex, numSkins, skinDescriptions));
-  if (themes.NumThemes())
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Theme"),                  &themeIndex, themes.NumThemes(), themes.Descriptions()));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$WarEagle icons"),         &data.WarEagleIcons));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Left (%)"),               &data.OSDLeftP, 0.0, 0.5));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Top (%)"),                &data.OSDTopP, 0.0, 0.5));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Width (%)"),              &data.OSDWidthP, 0.5, 1.0));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Height (%)"),             &data.OSDHeightP, 0.5, 1.0));
-  Add(new cMenuEditIntItem( tr("Setup.OSD$Message time (s)"),       &data.OSDMessageTime, 1, 60));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Use small font"),         &data.UseSmallFont, 3, useSmallFontTexts));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Anti-alias"),             &data.AntiAlias));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Default font"),           &fontOsdIndex, fontOsdNames.Size(), &fontOsdNames[0]));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Small font"),             &fontSmlIndex, fontSmlNames.Size(), &fontSmlNames[0]));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Fixed font"),             &fontFixIndex, fontFixNames.Size(), &fontFixNames[0]));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Default font size (%)"),  &data.FontOsdSizeP, 0.01, 0.1, 1));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Small font size (%)"),    &data.FontSmlSizeP, 0.01, 0.1, 1));
-  Add(new cMenuEditPrcItem( tr("Setup.OSD$Fixed font size (%)"),    &data.FontFixSizeP, 0.01, 0.1, 1));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Channel info position"),  &data.ChannelInfoPos, tr("bottom"), tr("top")));
-  Add(new cMenuEditIntItem( tr("Setup.OSD$Channel info time (s)"),  &data.ChannelInfoTime, 1, 60));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Info on channel switch"), &data.ShowInfoOnChSwitch));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Timeout requested channel info"), &data.TimeoutRequChInfo));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Scroll pages"),           &data.MenuScrollPage));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Scroll wraps"),           &data.MenuScrollWrap));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Menu key closes"),        &data.MenuKeyCloses));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Recording directories"),  &data.RecordingDirs));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Folders in timer menu"),  &data.FoldersInTimerMenu));
-  Add(new cMenuEditBoolItem(tr("Setup.OSD$Number keys for characters"), &data.NumberKeysForChars));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Color key 0"),            &data.ColorKey0, 4, keyColorTexts));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Color key 1"),            &data.ColorKey1, 4, keyColorTexts));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Color key 2"),            &data.ColorKey2, 4, keyColorTexts));
-  Add(new cMenuEditStraItem(tr("Setup.OSD$Color key 3"),            &data.ColorKey3, 4, keyColorTexts));
-  SetCurrent(Get(current));
-  Display();
-}
-
-eOSState cMenuSetupOSD::ProcessKey(eKeys Key)
-{
-  bool ModifiedAppearance = false;
-
-  if (Key == kOk) {
-     I18nSetLocale(data.OSDLanguage);
-     if (skinIndex != originalSkinIndex) {
-        cSkin *Skin = Skins.Get(skinIndex);
-        if (Skin) {
-           Utf8Strn0Cpy(data.OSDSkin, Skin->Name(), sizeof(data.OSDSkin));
-           Skins.SetCurrent(Skin->Name());
-           ModifiedAppearance = true;
-           }
-        }
-     if (themes.NumThemes() && Skins.Current()->Theme()) {
-        Skins.Current()->Theme()->Load(themes.FileName(themeIndex));
-        Utf8Strn0Cpy(data.OSDTheme, themes.Name(themeIndex), sizeof(data.OSDTheme));
-        ModifiedAppearance |= themeIndex != originalThemeIndex;
-        }
-     if (!(DoubleEqual(data.OSDLeftP, Setup.OSDLeftP) && DoubleEqual(data.OSDTopP, Setup.OSDTopP) && DoubleEqual(data.OSDWidthP, Setup.OSDWidthP) && DoubleEqual(data.OSDHeightP, Setup.OSDHeightP)))
-        ModifiedAppearance = true;
-     if (data.UseSmallFont != Setup.UseSmallFont || data.AntiAlias != Setup.AntiAlias)
-        ModifiedAppearance = true;
-     Utf8Strn0Cpy(data.FontOsd, fontOsdNames[fontOsdIndex], sizeof(data.FontOsd));
-     Utf8Strn0Cpy(data.FontSml, fontSmlNames[fontSmlIndex], sizeof(data.FontSml));
-     Utf8Strn0Cpy(data.FontFix, fontFixNames[fontFixIndex], sizeof(data.FontFix));
-     if (strcmp(data.FontOsd, Setup.FontOsd) || !DoubleEqual(data.FontOsdSizeP, Setup.FontOsdSizeP))
-        ModifiedAppearance = true;
-     if (strcmp(data.FontSml, Setup.FontSml) || !DoubleEqual(data.FontSmlSizeP, Setup.FontSmlSizeP))
-        ModifiedAppearance = true;
-     if (strcmp(data.FontFix, Setup.FontFix) || !DoubleEqual(data.FontFixSizeP, Setup.FontFixSizeP))
-        ModifiedAppearance = true;
-     }
-
-  int oldSkinIndex = skinIndex;
-  int oldOsdLanguageIndex = osdLanguageIndex;
-  eOSState state = cMenuSetupBase::ProcessKey(Key);
-
-  if (ModifiedAppearance) {
-     cOsdProvider::UpdateOsdSize(true);
-     SetDisplayMenu();
-     }
-
-  if (osdLanguageIndex != oldOsdLanguageIndex || skinIndex != oldSkinIndex) {
-     strn0cpy(data.OSDLanguage, I18nLocale(osdLanguageIndex), sizeof(data.OSDLanguage));
-     int OriginalOSDLanguage = I18nCurrentLanguage();
-     I18nSetLanguage(osdLanguageIndex);
-
-     cSkin *Skin = Skins.Get(skinIndex);
-     if (Skin) {
-        char *d = themes.NumThemes() ? strdup(themes.Descriptions()[themeIndex]) : NULL;
-        themes.Load(Skin->Name());
-        if (skinIndex != oldSkinIndex)
-           themeIndex = d ? themes.GetThemeIndex(d) : 0;
-        free(d);
-        }
-
-     Set();
-     I18nSetLanguage(OriginalOSDLanguage);
-     }
-  return state;
-}
-
-// --- cMenuSetupEPG ---------------------------------------------------------
-
-class cMenuSetupEPG : public cMenuSetupBase {
-private:
-  int originalNumLanguages;
-  int numLanguages;
-  void Setup(void);
-public:
-  cMenuSetupEPG(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuSetupEpg"; }
-  };
-
-cMenuSetupEPG::cMenuSetupEPG(void)
-{
-  SetMenuCategory(mcSetupEpg);
-  for (numLanguages = 0; numLanguages < I18nLanguages()->Size() && data.EPGLanguages[numLanguages] >= 0; numLanguages++)
-      ;
-  originalNumLanguages = numLanguages;
-  SetSection(tr("EPG"));
-  SetHelp(tr("Button$Scan"));
-  Setup();
-}
-
-void cMenuSetupEPG::Setup(void)
-{
-  int current = Current();
-
-  Clear();
-
-  Add(new cMenuEditIntItem( tr("Setup.EPG$EPG scan timeout (h)"),      &data.EPGScanTimeout));
-  Add(new cMenuEditIntItem( tr("Setup.EPG$EPG bugfix level"),          &data.EPGBugfixLevel, 0, MAXEPGBUGFIXLEVEL));
-  Add(new cMenuEditIntItem( tr("Setup.EPG$EPG linger time (min)"),     &data.EPGLinger, 0));
-  Add(new cMenuEditBoolItem(tr("Setup.EPG$Set system time"),           &data.SetSystemTime));
-  if (data.SetSystemTime)
-     Add(new cMenuEditTranItem(tr("Setup.EPG$Use time from transponder"), &data.TimeTransponder, &data.TimeSource));
-  // TRANSLATORS: note the plural!
-  Add(new cMenuEditIntItem( tr("Setup.EPG$Preferred languages"),       &numLanguages, 0, I18nLanguages()->Size()));
-  for (int i = 0; i < numLanguages; i++)
-      // TRANSLATORS: note the singular!
-      Add(new cMenuEditStraItem(tr("Setup.EPG$Preferred language"),    &data.EPGLanguages[i], I18nLanguages()->Size(), &I18nLanguages()->At(0)));
-
-  SetCurrent(Get(current));
-  Display();
-}
-
-eOSState cMenuSetupEPG::ProcessKey(eKeys Key)
-{
-  if (Key == kOk) {
-     bool Modified = numLanguages != originalNumLanguages;
-     if (!Modified) {
-        for (int i = 0; i < numLanguages; i++) {
-            if (data.EPGLanguages[i] != ::Setup.EPGLanguages[i]) {
-               Modified = true;
-               break;
-               }
-            }
-        }
-     if (Modified)
-        cSchedules::ResetVersions();
-     }
-
-  int oldnumLanguages = numLanguages;
-  int oldSetSystemTime = data.SetSystemTime;
-
-  eOSState state = cMenuSetupBase::ProcessKey(Key);
-  if (Key != kNone) {
-     if (numLanguages != oldnumLanguages || data.SetSystemTime != oldSetSystemTime) {
-        for (int i = oldnumLanguages; i < numLanguages; i++) {
-            data.EPGLanguages[i] = 0;
-            for (int l = 0; l < I18nLanguages()->Size(); l++) {
-                int k;
-                for (k = 0; k < oldnumLanguages; k++) {
-                    if (data.EPGLanguages[k] == l)
-                       break;
-                    }
-                if (k >= oldnumLanguages) {
-                   data.EPGLanguages[i] = l;
-                   break;
-                   }
-                }
-            }
-        data.EPGLanguages[numLanguages] = -1;
-        Setup();
-        }
-     if (Key == kRed) {
-        EITScanner.ForceScan();
-        return osEnd;
-        }
-     }
-  return state;
-}
-
-// --- cMenuSetupDVB ---------------------------------------------------------
-
-class cMenuSetupDVB : public cMenuSetupBase {
-private:
-  int originalNumAudioLanguages;
-  int numAudioLanguages;
-  int originalNumSubtitleLanguages;
-  int numSubtitleLanguages;
-  void Setup(void);
-  const char *videoDisplayFormatTexts[3];
-  const char *updateChannelsTexts[6];
-  const char *standardComplianceTexts[2];
-public:
-  cMenuSetupDVB(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuSetupDvb"; }
-  };
-
-cMenuSetupDVB::cMenuSetupDVB(void)
-{
-  SetMenuCategory(mcSetupDvb);
-  for (numAudioLanguages = 0; numAudioLanguages < I18nLanguages()->Size() && data.AudioLanguages[numAudioLanguages] >= 0; numAudioLanguages++)
-      ;
-  for (numSubtitleLanguages = 0; numSubtitleLanguages < I18nLanguages()->Size() && data.SubtitleLanguages[numSubtitleLanguages] >= 0; numSubtitleLanguages++)
-      ;
-  originalNumAudioLanguages = numAudioLanguages;
-  originalNumSubtitleLanguages = numSubtitleLanguages;
-  videoDisplayFormatTexts[0] = tr("pan&scan");
-  videoDisplayFormatTexts[1] = tr("letterbox");
-  videoDisplayFormatTexts[2] = tr("center cut out");
-  updateChannelsTexts[0] = tr("no");
-  updateChannelsTexts[1] = tr("names only");
-  updateChannelsTexts[2] = tr("PIDs only");
-  updateChannelsTexts[3] = tr("names and PIDs");
-  updateChannelsTexts[4] = tr("add new channels");
-  updateChannelsTexts[5] = tr("add new transponders");
-  standardComplianceTexts[0] = "DVB";
-  standardComplianceTexts[1] = "ANSI/SCTE";
-
-  SetSection(tr("DVB"));
-  SetHelp(NULL, tr("Button$Audio"), tr("Button$Subtitles"), NULL);
-  Setup();
-}
-
-void cMenuSetupDVB::Setup(void)
-{
-  int current = Current();
-
-  Clear();
-
-  Add(new cMenuEditIntItem( tr("Setup.DVB$Primary DVB interface"), &data.PrimaryDVB, 1, cDevice::NumDevices()));
-  Add(new cMenuEditStraItem(tr("Setup.DVB$Standard compliance"),   &data.StandardCompliance, 2, standardComplianceTexts));
-  Add(new cMenuEditBoolItem(tr("Setup.DVB$Video format"),          &data.VideoFormat, "4:3", "16:9"));
-  if (data.VideoFormat == 0)
-     Add(new cMenuEditStraItem(tr("Setup.DVB$Video display format"), &data.VideoDisplayFormat, 3, videoDisplayFormatTexts));
-  Add(new cMenuEditBoolItem(tr("Setup.DVB$Use Dolby Digital"),     &data.UseDolbyDigital));
-  Add(new cMenuEditStraItem(tr("Setup.DVB$Update channels"),       &data.UpdateChannels, 6, updateChannelsTexts));
-  Add(new cMenuEditIntItem( tr("Setup.DVB$Audio languages"),       &numAudioLanguages, 0, I18nLanguages()->Size()));
-  for (int i = 0; i < numAudioLanguages; i++)
-      Add(new cMenuEditStraItem(tr("Setup.DVB$Audio language"),    &data.AudioLanguages[i], I18nLanguages()->Size(), &I18nLanguages()->At(0)));
-  Add(new cMenuEditBoolItem(tr("Setup.DVB$Display subtitles"),     &data.DisplaySubtitles));
-  if (data.DisplaySubtitles) {
-     Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle languages"),    &numSubtitleLanguages, 0, I18nLanguages()->Size()));
-     for (int i = 0; i < numSubtitleLanguages; i++)
-         Add(new cMenuEditStraItem(tr("Setup.DVB$Subtitle language"), &data.SubtitleLanguages[i], I18nLanguages()->Size(), &I18nLanguages()->At(0)));
-     Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle offset"),                  &data.SubtitleOffset,      -100, 100));
-     Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle foreground transparency"), &data.SubtitleFgTransparency, 0, 9));
-     Add(new cMenuEditIntItem( tr("Setup.DVB$Subtitle background transparency"), &data.SubtitleBgTransparency, 0, 10));
-     }
-  Add(new cMenuEditBoolItem(tr("Setup.DVB$Enable teletext support"), &data.SupportTeletext));
-
-  SetCurrent(Get(current));
-  Display();
-}
-
-eOSState cMenuSetupDVB::ProcessKey(eKeys Key)
-{
-  int oldPrimaryDVB = ::Setup.PrimaryDVB;
-  int oldVideoDisplayFormat = ::Setup.VideoDisplayFormat;
-  bool oldVideoFormat = ::Setup.VideoFormat;
-  bool newVideoFormat = data.VideoFormat;
-  bool oldDisplaySubtitles = ::Setup.DisplaySubtitles;
-  bool newDisplaySubtitles = data.DisplaySubtitles;
-  int oldnumAudioLanguages = numAudioLanguages;
-  int oldnumSubtitleLanguages = numSubtitleLanguages;
-  eOSState state = cMenuSetupBase::ProcessKey(Key);
-
-  if (Key != kNone) {
-     switch (Key) {
-       case kGreen:  cRemote::Put(kAudio, true);
-                     state = osEnd;
-                     break;
-       case kYellow: cRemote::Put(kSubtitles, true);
-                     state = osEnd;
-                     break;
-       default: {
-            bool DoSetup = data.VideoFormat != newVideoFormat;
-            DoSetup |= data.DisplaySubtitles != newDisplaySubtitles;
-            if (numAudioLanguages != oldnumAudioLanguages) {
-               for (int i = oldnumAudioLanguages; i < numAudioLanguages; i++) {
-                   data.AudioLanguages[i] = 0;
-                   for (int l = 0; l < I18nLanguages()->Size(); l++) {
-                       int k;
-                       for (k = 0; k < oldnumAudioLanguages; k++) {
-                           if (data.AudioLanguages[k] == l)
-                              break;
-                           }
-                       if (k >= oldnumAudioLanguages) {
-                          data.AudioLanguages[i] = l;
-                          break;
-                          }
-                       }
-                   }
-               data.AudioLanguages[numAudioLanguages] = -1;
-               DoSetup = true;
-               }
-            if (numSubtitleLanguages != oldnumSubtitleLanguages) {
-               for (int i = oldnumSubtitleLanguages; i < numSubtitleLanguages; i++) {
-                   data.SubtitleLanguages[i] = 0;
-                   for (int l = 0; l < I18nLanguages()->Size(); l++) {
-                       int k;
-                       for (k = 0; k < oldnumSubtitleLanguages; k++) {
-                           if (data.SubtitleLanguages[k] == l)
-                              break;
-                           }
-                       if (k >= oldnumSubtitleLanguages) {
-                          data.SubtitleLanguages[i] = l;
-                          break;
-                          }
-                       }
-                   }
-               data.SubtitleLanguages[numSubtitleLanguages] = -1;
-               DoSetup = true;
-               }
-            if (DoSetup)
-               Setup();
-            }
-       }
-     }
-  if (state == osBack && Key == kOk) {
-     if (::Setup.PrimaryDVB != oldPrimaryDVB)
-        state = osSwitchDvb;
-     if (::Setup.VideoDisplayFormat != oldVideoDisplayFormat)
-        cDevice::PrimaryDevice()->SetVideoDisplayFormat(eVideoDisplayFormat(::Setup.VideoDisplayFormat));
-     if (::Setup.VideoFormat != oldVideoFormat)
-        cDevice::PrimaryDevice()->SetVideoFormat(::Setup.VideoFormat);
-     if (::Setup.DisplaySubtitles != oldDisplaySubtitles)
-        cDevice::PrimaryDevice()->EnsureSubtitleTrack();
-     cDvbSubtitleConverter::SetupChanged();
-     }
-  return state;
-}
-
-// --- cMenuSetupLNB ---------------------------------------------------------
-
-class cMenuSetupLNB : public cMenuSetupBase {
-private:
-  cSatCableNumbers satCableNumbers;
-  void Setup(void);
-public:
-  cMenuSetupLNB(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuSetupLnb"; }
-  };
-
-cMenuSetupLNB::cMenuSetupLNB(void)
-:satCableNumbers(MAXDEVICES)
-{
-  SetMenuCategory(mcSetupLnb);
-  satCableNumbers.FromString(data.DeviceBondings);
-  SetSection(tr("LNB"));
-  Setup();
-}
-
-void cMenuSetupLNB::Setup(void)
-{
-  int current = Current();
-
-  Clear();
-
-  Add(new cMenuEditBoolItem(tr("Setup.LNB$Use DiSEqC"),               &data.DiSEqC));
-  if (!data.DiSEqC) {
-     Add(new cMenuEditIntItem( tr("Setup.LNB$SLOF (MHz)"),               &data.LnbSLOF));
-     Add(new cMenuEditIntItem( tr("Setup.LNB$Low LNB frequency (MHz)"),  &data.LnbFrequLo));
-     Add(new cMenuEditIntItem( tr("Setup.LNB$High LNB frequency (MHz)"), &data.LnbFrequHi));
-     }
-
-  int NumSatDevices = 0;
-  for (int i = 0; i < cDevice::NumDevices(); i++) {
-      if (cDevice::GetDevice(i)->ProvidesSource(cSource::stSat))
-         NumSatDevices++;
-      }
-  if (NumSatDevices > 1) {
-     for (int i = 0; i < cDevice::NumDevices(); i++) {
-         if (cDevice::GetDevice(i)->ProvidesSource(cSource::stSat))
-            Add(new cMenuEditIntItem(cString::sprintf(tr("Setup.LNB$Device %d connected to sat cable"), i + 1), &satCableNumbers.Array()[i], 0, NumSatDevices, tr("Setup.LNB$own")));
-         }
-     }
-
-  SetCurrent(Get(current));
-  Display();
-}
-
-eOSState cMenuSetupLNB::ProcessKey(eKeys Key)
-{
-  int oldDiSEqC = data.DiSEqC;
-  bool DeviceBondingsChanged = false;
-  if (Key == kOk) {
-     cString NewDeviceBondings = satCableNumbers.ToString();
-     DeviceBondingsChanged = strcmp(data.DeviceBondings, NewDeviceBondings) != 0;
-     data.DeviceBondings = NewDeviceBondings;
-     }
-  eOSState state = cMenuSetupBase::ProcessKey(Key);
-
-  if (Key != kNone && data.DiSEqC != oldDiSEqC)
-     Setup();
-  else if (DeviceBondingsChanged)
-     cDvbDevice::BondDevices(data.DeviceBondings);
-  return state;
-}
-
-// --- cMenuSetupCAM ---------------------------------------------------------
-
-class cMenuSetupCAMItem : public cOsdItem {
-private:
-  cCamSlot *camSlot;
-public:
-  cMenuSetupCAMItem(cCamSlot *CamSlot);
-  cCamSlot *CamSlot(void) { return camSlot; }
-  bool Changed(void);
-  };
-
-cMenuSetupCAMItem::cMenuSetupCAMItem(cCamSlot *CamSlot)
-{
-  camSlot = CamSlot;
-  SetText("");
-  Changed();
-}
-
-bool cMenuSetupCAMItem::Changed(void)
-{
-  char buffer[32];
-  const char *CamName = camSlot->GetCamName();
-  if (!CamName) {
-     switch (camSlot->ModuleStatus()) {
-       case msReset:   CamName = tr("CAM reset"); break;
-       case msPresent: CamName = tr("CAM present"); break;
-       case msReady:   CamName = tr("CAM ready"); break;
-       default:        CamName = "-"; break;
-       }
-     }
-  snprintf(buffer, sizeof(buffer), " %d %s", camSlot->SlotNumber(), CamName);
-  if (strcmp(buffer, Text()) != 0) {
-     SetText(buffer);
-     return true;
-     }
-  return false;
-}
-
-class cMenuSetupCAM : public cMenuSetupBase {
-private:
-  eOSState Menu(void);
-  eOSState Reset(void);
-public:
-  cMenuSetupCAM(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuSetupCam"; }
-  };
-
-cMenuSetupCAM::cMenuSetupCAM(void)
-{
-  SetMenuCategory(mcSetupCam);
-  SetSection(tr("CAM"));
-  SetCols(15);
-  SetHasHotkeys();
-  for (cCamSlot *CamSlot = CamSlots.First(); CamSlot; CamSlot = CamSlots.Next(CamSlot))
-      Add(new cMenuSetupCAMItem(CamSlot));
-  SetHelp(tr("Button$Menu"), tr("Button$Reset"));
-}
-
-eOSState cMenuSetupCAM::Menu(void)
-{
-  cMenuSetupCAMItem *item = (cMenuSetupCAMItem *)Get(Current());
-  if (item) {
-     if (item->CamSlot()->EnterMenu()) {
-        Skins.Message(mtStatus, tr("Opening CAM menu..."));
-        time_t t0 = time(NULL);
-        time_t t1 = t0;
-        while (time(NULL) - t0 <= MAXWAITFORCAMMENU) {
-              if (item->CamSlot()->HasUserIO())
-                 break;
-              if (time(NULL) - t1 >= CAMMENURETYTIMEOUT) {
-                 dsyslog("CAM %d: retrying to enter CAM menu...", item->CamSlot()->SlotNumber());
-                 item->CamSlot()->EnterMenu();
-                 t1 = time(NULL);
-                 }
-              cCondWait::SleepMs(100);
-              }
-        Skins.Message(mtStatus, NULL);
-        if (item->CamSlot()->HasUserIO())
-           return AddSubMenu(new cMenuCam(item->CamSlot()));
-        }
-     Skins.Message(mtError, tr("Can't open CAM menu!"));
-     }
-  return osContinue;
-}
-
-eOSState cMenuSetupCAM::Reset(void)
-{
-  cMenuSetupCAMItem *item = (cMenuSetupCAMItem *)Get(Current());
-  if (item) {
-     if (!item->CamSlot()->Device() || Interface->Confirm(tr("CAM is in use - really reset?"))) {
-        if (!item->CamSlot()->Reset())
-           Skins.Message(mtError, tr("Can't reset CAM!"));
-        }
-     }
-  return osContinue;
-}
-
-eOSState cMenuSetupCAM::ProcessKey(eKeys Key)
-{
-  eOSState state = HasSubMenu() ? cMenuSetupBase::ProcessKey(Key) : cOsdMenu::ProcessKey(Key);
-
-  if (!HasSubMenu()) {
-     switch (Key) {
-       case kOk:
-       case kRed:    return Menu();
-       case kGreen:  state = Reset(); break;
-       default: break;
-       }
-     for (cMenuSetupCAMItem *ci = (cMenuSetupCAMItem *)First(); ci; ci = (cMenuSetupCAMItem *)ci->Next()) {
-         if (ci->Changed())
-            DisplayItem(ci);
-         }
-     }
-  return state;
-}
-
-// --- cMenuSetupRecord ------------------------------------------------------
-
-class cMenuSetupRecord : public cMenuSetupBase {
-private:
-  const char *pauseKeyHandlingTexts[3];
-  const char *delTimeshiftRecTexts[3];
-public:
-  cMenuSetupRecord(void);
-  };
-
-cMenuSetupRecord::cMenuSetupRecord(void)
-{
-  SetMenuCategory(mcSetupRecord);
-  pauseKeyHandlingTexts[0] = tr("do not pause live video");
-  pauseKeyHandlingTexts[1] = tr("confirm pause live video");
-  pauseKeyHandlingTexts[2] = tr("pause live video");
-  delTimeshiftRecTexts[0] = tr("no");
-  delTimeshiftRecTexts[1] = tr("confirm");
-  delTimeshiftRecTexts[2] = tr("yes");
-  SetSection(tr("Recording"));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Margin at start (min)"),     &data.MarginStart));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Margin at stop (min)"),      &data.MarginStop));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Default priority"),          &data.DefaultPriority, 0, MAXPRIORITY));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Default lifetime (d)"),      &data.DefaultLifetime, 0, MAXLIFETIME));
-  Add(new cMenuEditStraItem(tr("Setup.Recording$Pause key handling"),        &data.PauseKeyHandling, 3, pauseKeyHandlingTexts));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Pause priority"),            &data.PausePriority, 0, MAXPRIORITY));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Pause lifetime (d)"),        &data.PauseLifetime, 0, MAXLIFETIME));
-  Add(new cMenuEditBoolItem(tr("Setup.Recording$Use episode name"),          &data.UseSubtitle));
-  Add(new cMenuEditBoolItem(tr("Setup.Recording$Use VPS"),                   &data.UseVps));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$VPS margin (s)"),            &data.VpsMargin, 0));
-  Add(new cMenuEditBoolItem(tr("Setup.Recording$Mark instant recording"),    &data.MarkInstantRecord));
-  Add(new cMenuEditStrItem( tr("Setup.Recording$Name instant recording"),     data.NameInstantRecord, sizeof(data.NameInstantRecord)));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Instant rec. time (min)"),   &data.InstantRecordTime, 0, MAXINSTANTRECTIME, tr("Setup.Recording$present event")));
-  Add(new cMenuEditIntItem( tr("Setup.Recording$Max. video file size (MB)"), &data.MaxVideoFileSize, MINVIDEOFILESIZE, MAXVIDEOFILESIZETS));
-  Add(new cMenuEditBoolItem(tr("Setup.Recording$Split edited files"),        &data.SplitEditedFiles));
-  Add(new cMenuEditStraItem(tr("Setup.Recording$Delete timeshift recording"),&data.DelTimeshiftRec, 3, delTimeshiftRecTexts));
-}
-
-// --- cMenuSetupReplay ------------------------------------------------------
-
-class cMenuSetupReplay : public cMenuSetupBase {
-protected:
-  virtual void Store(void);
-public:
-  cMenuSetupReplay(void);
-  };
-
-cMenuSetupReplay::cMenuSetupReplay(void)
-{
-  SetMenuCategory(mcSetupReplay);
-  SetSection(tr("Replay"));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Multi speed mode"), &data.MultiSpeedMode));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Show replay mode"), &data.ShowReplayMode));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Show remaining time"), &data.ShowRemainingTime));
-  Add(new cMenuEditIntItem( tr("Setup.Replay$Progress display time (s)"), &data.ProgressDisplayTime, 0, 60));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Pause replay when setting mark"), &data.PauseOnMarkSet));
-  Add(new cMenuEditIntItem(tr("Setup.Replay$Resume ID"), &data.ResumeID, 0, 99));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Jump&Play"), &data.JumpPlay));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Play&Jump"), &data.PlayJump));
-  Add(new cMenuEditBoolItem(tr("Setup.Replay$Pause at last mark"), &data.PauseLastMark));
-}
-
-void cMenuSetupReplay::Store(void)
-{
-  if (Setup.ResumeID != data.ResumeID)
-     Recordings.ResetResume();
-  cMenuSetupBase::Store();
-}
-
-// --- cMenuSetupMisc --------------------------------------------------------
-
-class cMenuSetupMisc : public cMenuSetupBase {
-public:
-  cMenuSetupMisc(void);
-  };
-
-cMenuSetupMisc::cMenuSetupMisc(void)
-{
-  SetMenuCategory(mcSetupMisc);
-  SetSection(tr("Miscellaneous"));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Min. event timeout (min)"),   &data.MinEventTimeout));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Min. user inactivity (min)"), &data.MinUserInactivity));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$SVDRP timeout (s)"),          &data.SVDRPTimeout));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Zap timeout (s)"),            &data.ZapTimeout));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Channel entry timeout (ms)"), &data.ChannelEntryTimeout, 0));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Remote control repeat delay (ms)"), &data.RcRepeatDelay, 0));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Remote control repeat delta (ms)"), &data.RcRepeatDelta, 0));
-  Add(new cMenuEditChanItem(tr("Setup.Miscellaneous$Initial channel"),            &data.InitialChannel, tr("Setup.Miscellaneous$as before")));
-  Add(new cMenuEditIntItem( tr("Setup.Miscellaneous$Initial volume"),             &data.InitialVolume, -1, 255, tr("Setup.Miscellaneous$as before")));
-  Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Channels wrap"),              &data.ChannelsWrap));
-  Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Show channel names with source"), &data.ShowChannelNamesWithSource));
-  Add(new cMenuEditBoolItem(tr("Setup.Miscellaneous$Emergency exit"),             &data.EmergencyExit));
-}
-
-// --- cMenuSetupPluginItem --------------------------------------------------
-
-class cMenuSetupPluginItem : public cOsdItem {
-private:
-  int pluginIndex;
-public:
-  cMenuSetupPluginItem(const char *Name, int Index);
-  int PluginIndex(void) { return pluginIndex; }
-  };
-
-cMenuSetupPluginItem::cMenuSetupPluginItem(const char *Name, int Index)
-:cOsdItem(Name)
-{
-  pluginIndex = Index;
-}
-
-// --- cMenuSetupPlugins -----------------------------------------------------
-
-class cMenuSetupPlugins : public cMenuSetupBase {
-public:
-  cMenuSetupPlugins(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuSetupPlugins"; }
-  };
-
-cMenuSetupPlugins::cMenuSetupPlugins(void)
-{
-  SetMenuCategory(mcSetupPlugins);
-  SetSection(tr("Plugins"));
-  SetHasHotkeys();
-  for (int i = 0; ; i++) {
-      cPlugin *p = cPluginManager::GetPlugin(i);
-      if (p)
-         Add(new cMenuSetupPluginItem(hk(cString::sprintf("%s (%s) - %s", p->Name(), p->Version(), p->Description())), i));
-      else
-         break;
-      }
-}
-
-eOSState cMenuSetupPlugins::ProcessKey(eKeys Key)
-{
-  eOSState state = HasSubMenu() ? cMenuSetupBase::ProcessKey(Key) : cOsdMenu::ProcessKey(Key);
-
-  if (Key == kOk) {
-     if (state == osUnknown) {
-        cMenuSetupPluginItem *item = (cMenuSetupPluginItem *)Get(Current());
-        if (item) {
-           cPlugin *p = cPluginManager::GetPlugin(item->PluginIndex());
-           if (p) {
-              cMenuSetupPage *menu = p->SetupMenu();
-              if (menu) {
-                 menu->SetPlugin(p);
-                 return AddSubMenu(menu);
-                 }
-              Skins.Message(mtInfo, tr("This plugin has no setup parameters!"));
-              }
-           }
-        }
-     else if (state == osContinue) {
-        Store();
-        // Reinitialize OSD and skin, in case any plugin setup change has an influence on these:
-        cOsdProvider::UpdateOsdSize(true);
-        SetDisplayMenu();
-        Display();
-        }
-     }
-  return state;
-}
-
-// --- cMenuSetup ------------------------------------------------------------
-
-class cMenuSetup : public cOsdMenu {
-private:
-  virtual void Set(void);
-  eOSState Restart(void);
-public:
-  cMenuSetup(void);
-  virtual eOSState ProcessKey(eKeys Key);
-  virtual const char* MenuKind() { return "MenuSetup"; }
-  };
-
-cMenuSetup::cMenuSetup(void)
-:cOsdMenu("")
-{
-  SetMenuCategory(mcSetup);
-  Set();
-}
-
-void cMenuSetup::Set(void)
-{
-  Clear();
-  char buffer[64];
-  snprintf(buffer, sizeof(buffer), "%s - VDR %s", tr("Setup"), VDRVERSION);
-  SetTitle(buffer);
-  SetHasHotkeys();
-  Add(new cOsdItem(hk(tr("OSD")),           osUser1));
-  Add(new cOsdItem(hk(tr("EPG")),           osUser2));
-  Add(new cOsdItem(hk(tr("DVB")),           osUser3));
-  Add(new cOsdItem(hk(tr("LNB")),           osUser4));
-  Add(new cOsdItem(hk(tr("CAM")),           osUser5));
-  Add(new cOsdItem(hk(tr("Recording")),     osUser6));
-  Add(new cOsdItem(hk(tr("Replay")),        osUser7));
-  Add(new cOsdItem(hk(tr("Miscellaneous")), osUser8));
-  if (cPluginManager::HasPlugins())
-  Add(new cOsdItem(hk(tr("Plugins")),       osUser9));
-  Add(new cOsdItem(hk(tr("Restart")),       osUser10));
-}
-
-eOSState cMenuSetup::Restart(void)
-{
-  if (Interface->Confirm(tr("Really restart?")) && ShutdownHandler.ConfirmRestart(true)) {
-     ShutdownHandler.Exit(1);
-     return osEnd;
-     }
-  return osContinue;
-}
-
-eOSState cMenuSetup::ProcessKey(eKeys Key)
-{
-  int osdLanguage = I18nCurrentLanguage();
-  eOSState state = cOsdMenu::ProcessKey(Key);
-
-  switch (state) {
-    case osUser1: return AddSubMenu(new cMenuSetupOSD);
-    case osUser2: return AddSubMenu(new cMenuSetupEPG);
-    case osUser3: return AddSubMenu(new cMenuSetupDVB);
-    case osUser4: return AddSubMenu(new cMenuSetupLNB);
-    case osUser5: return AddSubMenu(new cMenuSetupCAM);
-    case osUser6: return AddSubMenu(new cMenuSetupRecord);
-    case osUser7: return AddSubMenu(new cMenuSetupReplay);
-    case osUser8: return AddSubMenu(new cMenuSetupMisc);
-    case osUser9: return AddSubMenu(new cMenuSetupPlugins);
-    case osUser10: return Restart();
-    default: ;
-    }
-  if (I18nCurrentLanguage() != osdLanguage) {
-     Set();
-     if (!HasSubMenu())
-        Display();
-     }
-  return state;
-}
-
-// --- cMenuPluginItem -------------------------------------------------------
-
-class cMenuPluginItem : public cOsdItem {
-private:
-  int pluginIndex;
-public:
-  cMenuPluginItem(const char *Name, int Index);
-  int PluginIndex(void) { return pluginIndex; }
-  };
-
-cMenuPluginItem::cMenuPluginItem(const char *Name, int Index)
-:cOsdItem(Name, osPlugin)
-{
-  pluginIndex = Index;
-}
-
-// --- cMenuMain -------------------------------------------------------------
-
-// TRANSLATORS: note the leading and trailing blanks!
-#define STOP_RECORDING trNOOP(" Stop recording ")
-
-cOsdObject *cMenuMain::pluginOsdObject = NULL;
-
-cMenuMain::cMenuMain(eOSState State)
-:cOsdMenu("")
-{
-  SetMenuCategory(mcMain);
-  replaying = false;
-  stopReplayItem = NULL;
-  cancelEditingItem = NULL;
-  cancelFileTransferItem = NULL;
-  stopRecordingItem = NULL;
-  recordControlsState = 0;
-
-  MenuOrgPatch::EnterRootMenu();
-
-  Set();
-
-  // Initial submenus:
-
-  cOsdObject *menu = NULL;
-  switch (State) {
-    case osSchedule:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osSchedule", &menu))
-            menu = new cMenuSchedule;
-        break;
-    case osChannels:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osChannels", &menu))
-            menu = new cMenuChannels;
-        break;
-    case osTimers:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osTimers", &menu))
-            menu = new cMenuTimers;
-        break;
-    case osRecordings:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osRecordings", &menu))
-            menu = new cMenuRecordings(NULL, 0, true);
-        break;
-    case osSetup:      menu = new cMenuSetup; break;
-    case osCommands:   menu = new cMenuCommands(tr("Commands"), &Commands); break;
-    default: break;
-    }
-  if (menu)
-     if (menu->IsMenu())
-        AddSubMenu((cOsdMenu *) menu);
-}
-
-cOsdObject *cMenuMain::PluginOsdObject(void)
-{
-  cOsdObject *o = pluginOsdObject;
-  pluginOsdObject = NULL;
-  return o;
-}
-
-void cMenuMain::Set(void)
-{
-  Clear();
-  SetTitle("VDR");
-  SetHasHotkeys();
-
-  if (MenuOrgPatch::IsCustomMenuAvailable()) {
-     MenuItemDefinitions* menuItems = MenuOrgPatch::MainMenuItems();
-     for (MenuItemDefinitions::iterator i = menuItems->begin(); i != menuItems->end(); i++) {
-         cOsdItem* osdItem = NULL;
-         if ((*i)->IsCustomOsdItem()) {
-            osdItem = (*i)->CustomOsdItem();
-            if (osdItem &&  !(*i)->IsSeparatorItem())
-                   osdItem->SetText(hk(osdItem->Text()));
-            }
-         else if ((*i)->IsPluginItem()) {
-            const char *item = (*i)->PluginMenuEntry();
-            if (item)
-              osdItem = new cMenuPluginItem(hk(item), (*i)->PluginIndex());
-            }
-         if (osdItem) {
-            Add(osdItem);
-            if ((*i)->IsSelected())
-               SetCurrent(osdItem);
-            }
-         }
-     }
-  else {
-
-  // Basic menu items:
-
-  // PIN PATCH
-  if (!cStatus::MsgMenuItemProtected("Schedule", true))   Add(new cOsdItem(hk(tr("Schedule")),   osSchedule));
-  if (!cStatus::MsgMenuItemProtected("Channels", true))   Add(new cOsdItem(hk(tr("Channels")),   osChannels));
-  if (!cStatus::MsgMenuItemProtected("Timers", true))     Add(new cOsdItem(hk(tr("Timers")),     osTimers));
-  if (!cStatus::MsgMenuItemProtected("Recordings", true)) Add(new cOsdItem(hk(tr("Recordings")), osRecordings));
-
-  // Plugins:
-
-  for (int i = 0; ; i++) {
-      cPlugin *p = cPluginManager::GetPlugin(i);
-      if (p) {
-         if (!cStatus::MsgPluginProtected(p, true)) {          // PIN PATCH
-         const char *item = p->MainMenuEntry();
-         if (item)
-            Add(new cMenuPluginItem(hk(item), i));
-         }
-         }
-      else
-         break;
-      }
-
-  // More basic menu items:
-
-  if (!cStatus::MsgMenuItemProtected("Setup", true)) Add(new cOsdItem(hk(tr("Setup")), osSetup));  // PIN PATCH
-  if (Commands.Count())
-     if (!cStatus::MsgMenuItemProtected("Commands", true))     // PIN PATCH
-     Add(new cOsdItem(hk(tr("Commands")),  osCommands));
-
-  }
-
-  Update(true);
-
-  Display();
-}
-
-bool cMenuMain::Update(bool Force)
-{
-  bool result = false;
-
-  bool NewReplaying = cControl::Control() != NULL;
-  if (Force || NewReplaying != replaying) {
-     replaying = NewReplaying;
-     // Replay control:
-     if (replaying && !stopReplayItem)
-        // TRANSLATORS: note the leading blank!
-        Add(stopReplayItem = new cOsdItem(tr(" Stop replaying"), osStopReplay));
-     else if (stopReplayItem && !replaying) {
-        Del(stopReplayItem->Index());
-        stopReplayItem = NULL;
-        }
-     // Color buttons:
-     SetHelp(!replaying ? tr("Button$Record") : NULL, tr("Button$Audio"), replaying ? NULL : tr("Button$Pause"), replaying ? tr("Button$Stop") : cReplayControl::LastReplayed() ? tr("Button$Resume") : tr("Button$Play"));
-     result = true;
-     }
-
-  // Editing control:
-  bool CutterActive = cCutter::Active();
-  if (CutterActive && !cancelEditingItem) {
-     // TRANSLATORS: note the leading blank!
-     Add(cancelEditingItem = new cOsdItem(tr(" Cancel editing"), osCancelEdit));
-     result = true;
-     }
-  else if (cancelEditingItem && !CutterActive) {
-     Del(cancelEditingItem->Index());
-     cancelEditingItem = NULL;
-     result = true;
-     }
-
-  // File transfer control:
-  bool FileTransferActive = cFileTransfer::Active();
-  if (FileTransferActive && !cancelFileTransferItem) {
-     // TRANSLATORS: note the leading blank!
-     Add(cancelFileTransferItem = new cOsdItem(tr(" Cancel file transfer"), osCancelTransfer));
-     result = true;
-     }
-  else if (cancelFileTransferItem && !FileTransferActive) {
-     Del(cancelFileTransferItem->Index());
-     cancelFileTransferItem = NULL;
-     result = true;
-     }
-
-  // Record control:
-  if (cRecordControls::StateChanged(recordControlsState)) {
-     while (stopRecordingItem) {
-           cOsdItem *it = Next(stopRecordingItem);
-           Del(stopRecordingItem->Index());
-           stopRecordingItem = it;
-           }
-     const char *s = NULL;
-     while ((s = cRecordControls::GetInstantId(s)) != NULL) {
-           cOsdItem *item = new cOsdItem(osStopRecord);
-           item->SetText(cString::sprintf("%s%s", tr(STOP_RECORDING), s));
-           Add(item);
-           if (!stopRecordingItem)
-              stopRecordingItem = item;
-           }
-     result = true;
-     }
-
-  return result;
-}
-
-eOSState cMenuMain::ProcessKey(eKeys Key)
-{
-  bool HadSubMenu = HasSubMenu();
-  int osdLanguage = I18nCurrentLanguage();
-  eOSState state = cOsdMenu::ProcessKey(Key);
-  HadSubMenu |= HasSubMenu();
-
-  // > PIN PATCH
-  cOsdItem* item = Get(Current());
-
-  if (item && item->Text() && state != osContinue && state != osUnknown && state != osBack)
-     if (cStatus::MsgMenuItemProtected(item->Text()))
-        return osContinue;
-  // PIN PATCH <
-
-  cOsdObject *menu = NULL;
-  switch (state) {
-    case osSchedule:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osSchedule", &menu))
-            menu = new cMenuSchedule;
-        else
-            state = osContinue;
-        break;
-    case osChannels:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osChannels", &menu))
-            menu = new cMenuChannels;
-        else
-            state = osContinue;
-        break;
-    case osTimers:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osTimers", &menu))
-            menu = new cMenuTimers;
-        else
-            state = osContinue;
-        break;
-    case osRecordings:
-        if (!cPluginManager::CallFirstService("MainMenuHooksPatch-v1.0::osRecordings", &menu))
-            menu = new cMenuRecordings;
-        else
-            state = osContinue;
-        break;
-    case osSetup:      menu = new cMenuSetup; break;
-    case osCommands:   menu = new cMenuCommands(tr("Commands"), &Commands); break;
-    case osStopRecord: if (Interface->Confirm(tr("Stop recording?"))) {
-                          cOsdItem *item = Get(Current());
-                          if (item) {
-                             cRecordControls::Stop(item->Text() + strlen(tr(STOP_RECORDING)));
-                             return osEnd;
-                             }
-                          }
-                       break;
-    case osCancelEdit: if (Interface->Confirm(tr("Cancel editing?"))) {
-                          cCutter::Stop();
-                          return osEnd;
-                          }
-                       break;
-    case osCancelTransfer:
-                       if (Interface->Confirm(tr("Cancel file transfer?"))) {
-                          cFileTransfer::Stop();
-                          return osEnd;
-                          }
-                       break;
-    case osPlugin:     {
-                         cMenuPluginItem *item = (cMenuPluginItem *)Get(Current());
-                         if (item) {
-                            cPlugin *p = cPluginManager::GetPlugin(item->PluginIndex());
-                            if (p) {
-                               if (!cStatus::MsgPluginProtected(p)) {  // PIN PATCH
-                               cOsdObject *menu = p->MainMenuAction();
-                               if (menu) {
-                                  if (menu->IsMenu())
-                                     return AddSubMenu((cOsdMenu *)menu);
-                                  else {
-                                     pluginOsdObject = menu;
-                                     return osPlugin;
-                                     }
-                                  }
-                               }
-                            }
-                         }
-                         state = osEnd;
-                       }
-                       break;
-    case osBack:       {
-                          if (MenuOrgPatch::IsCustomMenuAvailable())
-                          {
-                            bool leavingMenuSucceeded = MenuOrgPatch::LeaveSubMenu();
-                            Set();
-                            stopReplayItem = NULL;
-                            cancelEditingItem = NULL;
-                            stopRecordingItem = NULL;
-                            recordControlsState = 0;
-                            Update(true);
-                            Display();
-                            if (leavingMenuSucceeded)
-                              return osContinue;
-                            else
-                              return osEnd;
-                          }
-                       }
-                       break;
-    case osUser1:      {
-                          if (MenuOrgPatch::IsCustomMenuAvailable()) {
-                            MenuOrgPatch::EnterSubMenu(Get(Current()));
-                            Set();
-                            return osContinue;
-                          }
-                       }
-                       break;
-    case osUser2:      {
-                          if (MenuOrgPatch::IsCustomMenuAvailable()) {
-                            cOsdMenu* osdMenu = MenuOrgPatch::Execute(Get(Current()));
-                            if (osdMenu)
-                              return AddSubMenu(osdMenu);
-                            return osEnd;
-                          }
-                       }
-                       break;
-    default: switch (Key) {
-               case kRecord:
-               case kRed:    if (!HadSubMenu)
-                                state = replaying ? osContinue : osRecord;
-                             break;
-               case kGreen:  if (!HadSubMenu) {
-                                cRemote::Put(kAudio, true);
-                                state = osEnd;
-                                }
-                             break;
-               case kYellow: if (!HadSubMenu)
-                                state = replaying ? osContinue : osPause;
-                             break;
-               case kBlue:   if (!HadSubMenu)
-                                state = replaying ? osStopReplay : cReplayControl::LastReplayed() ? osReplay : osRecordings;
-                             break;
-               default:      break;
-               }
-    }
-  if (menu) {
-     if (menu->IsMenu())
-        return AddSubMenu((cOsdMenu *) menu);
-     pluginOsdObject = menu;
-     return osPlugin;
-  }
-  if (!HasSubMenu() && Update(HadSubMenu))
-     Display();
-  if (Key != kNone) {
-     if (I18nCurrentLanguage() != osdLanguage) {
-        Set();
-        if (!HasSubMenu())
-           Display();
-        }
-     }
-  return state;
-}
-
-// --- SetTrackDescriptions --------------------------------------------------
-
-static void SetTrackDescriptions(int LiveChannel)
-{
-  cDevice::PrimaryDevice()->ClrAvailableTracks(true);
-  const cComponents *Components = NULL;
-  cSchedulesLock SchedulesLock;
-  if (LiveChannel) {
-     cChannel *Channel = Channels.GetByNumber(LiveChannel);
-     if (Channel) {
-        const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
-        if (Schedules) {
-           const cSchedule *Schedule = Schedules->GetSchedule(Channel);
-           if (Schedule) {
-              const cEvent *Present = Schedule->GetPresentEvent();
-              if (Present)
-                 Components = Present->Components();
-              }
-           }
-        }
-     }
-  else if (cReplayControl::NowReplaying()) {
-     cThreadLock RecordingsLock(&Recordings);
-     cRecording *Recording = Recordings.GetByName(cReplayControl::NowReplaying());
-     if (Recording)
-        Components = Recording->Info()->Components();
-     }
-  if (Components) {
-     int indexAudio = 0;
-     int indexDolby = 0;
-     int indexSubtitle = 0;
-     for (int i = 0; i < Components->NumComponents(); i++) {
-         const tComponent *p = Components->Component(i);
-         switch (p->stream) {
-           case 2: if (p->type == 0x05)
-                      cDevice::PrimaryDevice()->SetAvailableTrack(ttDolby, indexDolby++, 0, LiveChannel ? NULL : p->language, p->description);
-                   else
-                      cDevice::PrimaryDevice()->SetAvailableTrack(ttAudio, indexAudio++, 0, LiveChannel ? NULL : p->language, p->description);
-                   break;
-           case 3: cDevice::PrimaryDevice()->SetAvailableTrack(ttSubtitle, indexSubtitle++, 0, LiveChannel ? NULL : p->language, p->description);
-                   break;
-           case 4: cDevice::PrimaryDevice()->SetAvailableTrack(ttDolby, indexDolby++, 0, LiveChannel ? NULL : p->language, p->description);
-                   break;
-           default: ;
-           }
-         }
-     }
-}
-
-// --- cDisplayChannel -------------------------------------------------------
-
-cDisplayChannel *cDisplayChannel::currentDisplayChannel = NULL;
-
-cDisplayChannel::cDisplayChannel(int Number, bool Switched)
-:cOsdObject(true)
-{
-  currentDisplayChannel = this;
-  group = -1;
-  withInfo = !Switched || Setup.ShowInfoOnChSwitch;
-  displayChannel = Skins.Current()->DisplayChannel(withInfo);
-  number = 0;
-  timeout = Switched || Setup.TimeoutRequChInfo;
-  channel = Channels.GetByNumber(Number);
-  lastPresent = lastFollowing = NULL;
-  if (channel) {
-     DisplayChannel();
-     DisplayInfo();
-     displayChannel->Flush();
-     }
-  lastTime.Set();
-}
-
-cDisplayChannel::cDisplayChannel(eKeys FirstKey)
-:cOsdObject(true)
-{
-  currentDisplayChannel = this;
-  group = -1;
-  number = 0;
-  timeout = true;
-  lastPresent = lastFollowing = NULL;
-  lastTime.Set();
-  withInfo = Setup.ShowInfoOnChSwitch;
-  displayChannel = Skins.Current()->DisplayChannel(withInfo);
-  channel = Channels.GetByNumber(cDevice::CurrentChannel());
-  ProcessKey(FirstKey);
-}
-
-cDisplayChannel::~cDisplayChannel()
-{
-  delete displayChannel;
-  cStatus::MsgOsdClear();
-  currentDisplayChannel = NULL;
-}
-
-void cDisplayChannel::DisplayChannel(void)
-{
-  displayChannel->SetChannel(channel, number);
-  cStatus::MsgOsdChannel(ChannelString(channel, number));
-  lastPresent = lastFollowing = NULL;
-}
-
-void cDisplayChannel::DisplayInfo(void)
-{
-  if (withInfo && channel) {
-     cSchedulesLock SchedulesLock;
-     const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
-     if (Schedules) {
-        const cSchedule *Schedule = Schedules->GetSchedule(channel);
-        if (Schedule) {
-           const cEvent *Present = Schedule->GetPresentEvent();
-           const cEvent *Following = Schedule->GetFollowingEvent();
-           if (Present != lastPresent || Following != lastFollowing) {
-              SetTrackDescriptions(channel->Number());
-              displayChannel->SetEvents(Present, Following);
-              cStatus::MsgOsdProgramme(Present ? Present->StartTime() : 0, Present ? Present->Title() : NULL, Present ? Present->ShortText() : NULL, Following ? Following->StartTime() : 0, Following ? Following->Title() : NULL, Following ? Following->ShortText() : NULL);
-              lastPresent = Present;
-              lastFollowing = Following;
-              }
-           }
-        }
-     }
-}
-
-void cDisplayChannel::Refresh(void)
-{
-  DisplayChannel();
-  displayChannel->SetEvents(NULL, NULL);
-}
-
-cChannel *cDisplayChannel::NextAvailableChannel(cChannel *Channel, int Direction)
-{
-  if (Direction) {
-     while (Channel) {
-           Channel = Direction > 0 ? Channels.Next(Channel) : Channels.Prev(Channel);
-           if (!Channel && Setup.ChannelsWrap)
-              Channel = Direction > 0 ? Channels.First() : Channels.Last();
-           if (!cStatus::MsgChannelProtected(0, Channel))                   // PIN PATCH
-           if (Channel && !Channel->GroupSep() && cDevice::GetDevice(Channel, LIVEPRIORITY, true, true))
-              return Channel;
-           }
-     }
-  return NULL;
-}
-
-eOSState cDisplayChannel::ProcessKey(eKeys Key)
-{
-  cChannel *NewChannel = NULL;
-  if (Key != kNone)
-     lastTime.Set();
-  switch (int(Key)) {
-    case k0:
-         if (number == 0) {
-            // keep the "Toggle channels" function working
-            cRemote::Put(Key);
-            return osEnd;
-            }
-    case k1 ... k9:
-         group = -1;
-         if (number >= 0) {
-            if (number > Channels.MaxNumber())
-               number = Key - k0;
-            else
-               number = number * 10 + Key - k0;
-            channel = Channels.GetByNumber(number);
-            Refresh();
-            withInfo = false;
-            // Lets see if there can be any useful further input:
-            int n = channel ? number * 10 : 0;
-            int m = 10;
-            cChannel *ch = channel;
-            while (ch && (ch = Channels.Next(ch)) != NULL) {
-                  if (!ch->GroupSep()) {
-                     if (n <= ch->Number() && ch->Number() < n + m) {
-                        n = 0;
-                        break;
-                        }
-                     if (ch->Number() > n) {
-                        n *= 10;
-                        m *= 10;
-                        }
-                     }
-                  }
-            if (n > 0) {
-               // This channel is the only one that fits the input, so let's take it right away:
-               NewChannel = channel;
-               withInfo = true;
-               number = 0;
-               Refresh();
-               }
-            }
-         break;
-    case kLeft|k_Repeat:
-    case kLeft:
-    case kRight|k_Repeat:
-    case kRight:
-    case kNext|k_Repeat:
-    case kNext:
-    case kPrev|k_Repeat:
-    case kPrev:
-         withInfo = false;
-         number = 0;
-         if (group < 0) {
-            cChannel *channel = Channels.GetByNumber(cDevice::CurrentChannel());
-            if (channel)
-               group = channel->Index();
-            }
-         if (group >= 0) {
-            int SaveGroup = group;
-            if (NORMALKEY(Key) == kRight || NORMALKEY(Key) == kNext)
-               group = Channels.GetNextGroup(group) ;
-            else
-               group = Channels.GetPrevGroup(group < 1 ? 1 : group);
-            if (group < 0)
-               group = SaveGroup;
-            channel = Channels.Get(group);
-            if (channel) {
-               Refresh();
-               if (!channel->GroupSep())
-                  group = -1;
-               }
-            }
-         break;
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-    case kChanUp|k_Repeat:
-    case kChanUp:
-    case kChanDn|k_Repeat:
-    case kChanDn: {
-         eKeys k = NORMALKEY(Key);
-         cChannel *ch = NextAvailableChannel(channel, (k == kUp || k == kChanUp) ? 1 : -1);
-         if (ch)
-            channel = ch;
-         else if (channel && channel->Number() != cDevice::CurrentChannel())
-            Key = k; // immediately switches channel when hitting the beginning/end of the channel list with k_Repeat
-         }
-         // no break here
-    case kUp|k_Release:
-    case kDown|k_Release:
-    case kChanUp|k_Release:
-    case kChanDn|k_Release:
-    case kNext|k_Release:
-    case kPrev|k_Release:
-         if (!(Key & k_Repeat) && channel && channel->Number() != cDevice::CurrentChannel())
-            NewChannel = channel;
-         withInfo = true;
-         group = -1;
-         number = 0;
-         Refresh();
-         break;
-    case kNone:
-         if (number && Setup.ChannelEntryTimeout && int(lastTime.Elapsed()) > Setup.ChannelEntryTimeout) {
-            channel = Channels.GetByNumber(number);
-            if (channel)
-               NewChannel = channel;
-            withInfo = true;
-            number = 0;
-            Refresh();
-            lastTime.Set();
-            }
-         break;
-    //TODO
-    //XXX case kGreen:  return osEventNow;
-    //XXX case kYellow: return osEventNext;
-    case kOk:
-         if (group >= 0) {
-            channel = Channels.Get(Channels.GetNextNormal(group));
-            if (channel)
-               NewChannel = channel;
-            withInfo = true;
-            group = -1;
-            Refresh();
-            }
-         else if (number > 0) {
-            channel = Channels.GetByNumber(number);
-            if (channel)
-               NewChannel = channel;
-            withInfo = true;
-            number = 0;
-            Refresh();
-            }
-         else
-            return osEnd;
-         break;
-    default:
-         if ((Key & (k_Repeat | k_Release)) == 0) {
-            cRemote::Put(Key);
-            return osEnd;
-            }
-    };
-  if (!timeout || lastTime.Elapsed() < (uint64_t)(Setup.ChannelInfoTime * 1000)) {
-     if (Key == kNone && !number && group < 0 && !NewChannel && channel && channel->Number() != cDevice::CurrentChannel()) {
-        // makes sure a channel switch through the SVDRP CHAN command is displayed
-        channel = Channels.GetByNumber(cDevice::CurrentChannel());
-        Refresh();
-        lastTime.Set();
-        }
-     DisplayInfo();
-     displayChannel->Flush();
-     if (NewChannel) {
-        SetTrackDescriptions(NewChannel->Number()); // to make them immediately visible in the channel display
-        Channels.SwitchTo(NewChannel->Number());
-        SetTrackDescriptions(NewChannel->Number()); // switching the channel has cleared them
-        channel = NewChannel;
-        }
-     return osContinue;
-     }
-  return osEnd;
-}
-
-// --- cDisplayVolume --------------------------------------------------------
-
-#define VOLUMETIMEOUT 1000 //ms
-#define MUTETIMEOUT   5000 //ms
-
-cDisplayVolume *cDisplayVolume::currentDisplayVolume = NULL;
-
-cDisplayVolume::cDisplayVolume(void)
-:cOsdObject(true)
-{
-  currentDisplayVolume = this;
-  timeout.Set(cDevice::PrimaryDevice()->IsMute() ? MUTETIMEOUT : VOLUMETIMEOUT);
-  displayVolume = Skins.Current()->DisplayVolume();
-  Show();
-}
-
-cDisplayVolume::~cDisplayVolume()
-{
-  delete displayVolume;
-  currentDisplayVolume = NULL;
-}
-
-void cDisplayVolume::Show(void)
-{
-  displayVolume->SetVolume(cDevice::CurrentVolume(), MAXVOLUME, cDevice::PrimaryDevice()->IsMute());
-}
-
-cDisplayVolume *cDisplayVolume::Create(void)
-{
-  if (!currentDisplayVolume)
-     new cDisplayVolume;
-  return currentDisplayVolume;
-}
-
-void cDisplayVolume::Process(eKeys Key)
-{
-  if (currentDisplayVolume)
-     currentDisplayVolume->ProcessKey(Key);
-}
-
-eOSState cDisplayVolume::ProcessKey(eKeys Key)
-{
-  switch (int(Key)) {
-    case kVolUp|k_Repeat:
-    case kVolUp:
-    case kVolDn|k_Repeat:
-    case kVolDn:
-         Show();
-         timeout.Set(VOLUMETIMEOUT);
-         break;
-    case kMute:
-         if (cDevice::PrimaryDevice()->IsMute()) {
-            Show();
-            timeout.Set(MUTETIMEOUT);
-            }
-         else
-            timeout.Set();
-         break;
-    case kNone: break;
-    default: if ((Key & k_Release) == 0) {
-                cRemote::Put(Key);
-                return osEnd;
-                }
-    }
-  return timeout.TimedOut() ? osEnd : osContinue;
-}
-
-// --- cDisplayTracks --------------------------------------------------------
-
-#define TRACKTIMEOUT 5000 //ms
-
-cDisplayTracks *cDisplayTracks::currentDisplayTracks = NULL;
-
-cDisplayTracks::cDisplayTracks(void)
-:cOsdObject(true)
-{
-  cDevice::PrimaryDevice()->EnsureAudioTrack();
-  SetTrackDescriptions(!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring() ? cDevice::CurrentChannel() : 0);
-  currentDisplayTracks = this;
-  numTracks = track = 0;
-  audioChannel = cDevice::PrimaryDevice()->GetAudioChannel();
-  eTrackType CurrentAudioTrack = cDevice::PrimaryDevice()->GetCurrentAudioTrack();
-  for (int i = ttAudioFirst; i <= ttDolbyLast; i++) {
-      const tTrackId *TrackId = cDevice::PrimaryDevice()->GetTrack(eTrackType(i));
-      if (TrackId && TrackId->id) {
-         types[numTracks] = eTrackType(i);
-         descriptions[numTracks] = strdup(*TrackId->description ? TrackId->description : *TrackId->language ? TrackId->language : *itoa(i));
-         if (i == CurrentAudioTrack)
-            track = numTracks;
-         numTracks++;
-         }
-      }
-  descriptions[numTracks] = NULL;
-  timeout.Set(TRACKTIMEOUT);
-  displayTracks = Skins.Current()->DisplayTracks(tr("Button$Audio"), numTracks, descriptions);
-  Show();
-}
-
-cDisplayTracks::~cDisplayTracks()
-{
-  delete displayTracks;
-  currentDisplayTracks = NULL;
-  for (int i = 0; i < numTracks; i++)
-      free(descriptions[i]);
-  cStatus::MsgOsdClear();
-}
-
-void cDisplayTracks::Show(void)
-{
-  int ac = IS_AUDIO_TRACK(types[track]) ? audioChannel : -1;
-  displayTracks->SetTrack(track, descriptions);
-  displayTracks->SetAudioChannel(ac);
-  displayTracks->Flush();
-  cStatus::MsgSetAudioTrack(track, descriptions);
-  cStatus::MsgSetAudioChannel(ac);
-}
-
-cDisplayTracks *cDisplayTracks::Create(void)
-{
-  if (cDevice::PrimaryDevice()->NumAudioTracks() > 0) {
-     if (!currentDisplayTracks)
-        new cDisplayTracks;
-     return currentDisplayTracks;
-     }
-  Skins.Message(mtWarning, tr("No audio available!"));
-  return NULL;
-}
-
-void cDisplayTracks::Process(eKeys Key)
-{
-  if (currentDisplayTracks)
-     currentDisplayTracks->ProcessKey(Key);
-}
-
-eOSState cDisplayTracks::ProcessKey(eKeys Key)
-{
-  int oldTrack = track;
-  int oldAudioChannel = audioChannel;
-  switch (int(Key)) {
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-         if (NORMALKEY(Key) == kUp && track > 0)
-            track--;
-         else if (NORMALKEY(Key) == kDown && track < numTracks - 1)
-            track++;
-         timeout.Set(TRACKTIMEOUT);
-         break;
-    case kLeft|k_Repeat:
-    case kLeft:
-    case kRight|k_Repeat:
-    case kRight: if (IS_AUDIO_TRACK(types[track])) {
-                    static int ac[] = { 1, 0, 2 };
-                    audioChannel = ac[cDevice::PrimaryDevice()->GetAudioChannel()];
-                    if (NORMALKEY(Key) == kLeft && audioChannel > 0)
-                       audioChannel--;
-                    else if (NORMALKEY(Key) == kRight && audioChannel < 2)
-                       audioChannel++;
-                    audioChannel = ac[audioChannel];
-                    timeout.Set(TRACKTIMEOUT);
-                    }
-         break;
-    case kAudio|k_Repeat:
-    case kAudio:
-         if (++track >= numTracks)
-            track = 0;
-         timeout.Set(TRACKTIMEOUT);
-         break;
-    case kOk:
-         if (types[track] != cDevice::PrimaryDevice()->GetCurrentAudioTrack())
-            oldTrack = -1; // make sure we explicitly switch to that track
-         timeout.Set();
-         break;
-    case kNone: break;
-    default: if ((Key & k_Release) == 0)
-                return osEnd;
-    }
-  if (track != oldTrack || audioChannel != oldAudioChannel)
-     Show();
-  if (track != oldTrack) {
-     cDevice::PrimaryDevice()->SetCurrentAudioTrack(types[track]);
-     Setup.CurrentDolby = IS_DOLBY_TRACK(types[track]);
-     }
-  if (audioChannel != oldAudioChannel)
-     cDevice::PrimaryDevice()->SetAudioChannel(audioChannel);
-  return timeout.TimedOut() ? osEnd : osContinue;
-}
-
-// --- cDisplaySubtitleTracks ------------------------------------------------
-
-cDisplaySubtitleTracks *cDisplaySubtitleTracks::currentDisplayTracks = NULL;
-
-cDisplaySubtitleTracks::cDisplaySubtitleTracks(void)
-:cOsdObject(true)
-{
-  SetTrackDescriptions(!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring() ? cDevice::CurrentChannel() : 0);
-  currentDisplayTracks = this;
-  numTracks = track = 0;
-  types[numTracks] = ttNone;
-  descriptions[numTracks] = strdup(tr("No subtitles"));
-  numTracks++;
-  eTrackType CurrentSubtitleTrack = cDevice::PrimaryDevice()->GetCurrentSubtitleTrack();
-  for (int i = ttSubtitleFirst; i <= ttSubtitleLast; i++) {
-      const tTrackId *TrackId = cDevice::PrimaryDevice()->GetTrack(eTrackType(i));
-      if (TrackId && TrackId->id) {
-         types[numTracks] = eTrackType(i);
-         descriptions[numTracks] = strdup(*TrackId->description ? TrackId->description : *TrackId->language ? TrackId->language : *itoa(i));
-         if (i == CurrentSubtitleTrack)
-            track = numTracks;
-         numTracks++;
-         }
-      }
-  descriptions[numTracks] = NULL;
-  timeout.Set(TRACKTIMEOUT);
-  displayTracks = Skins.Current()->DisplayTracks(tr("Button$Subtitles"), numTracks, descriptions);
-  Show();
-}
-
-cDisplaySubtitleTracks::~cDisplaySubtitleTracks()
-{
-  delete displayTracks;
-  currentDisplayTracks = NULL;
-  for (int i = 0; i < numTracks; i++)
-      free(descriptions[i]);
-  cStatus::MsgOsdClear();
-}
-
-void cDisplaySubtitleTracks::Show(void)
-{
-  displayTracks->SetTrack(track, descriptions);
-  displayTracks->Flush();
-  cStatus::MsgSetSubtitleTrack(track, descriptions);
-}
-
-cDisplaySubtitleTracks *cDisplaySubtitleTracks::Create(void)
-{
-  if (cDevice::PrimaryDevice()->NumSubtitleTracks() > 0) {
-     if (!currentDisplayTracks)
-        new cDisplaySubtitleTracks;
-     return currentDisplayTracks;
-     }
-  Skins.Message(mtWarning, tr("No subtitles available!"));
-  return NULL;
-}
-
-void cDisplaySubtitleTracks::Process(eKeys Key)
-{
-  if (currentDisplayTracks)
-     currentDisplayTracks->ProcessKey(Key);
-}
-
-eOSState cDisplaySubtitleTracks::ProcessKey(eKeys Key)
-{
-  int oldTrack = track;
-  switch (int(Key)) {
-    case kUp|k_Repeat:
-    case kUp:
-    case kDown|k_Repeat:
-    case kDown:
-         if (NORMALKEY(Key) == kUp && track > 0)
-            track--;
-         else if (NORMALKEY(Key) == kDown && track < numTracks - 1)
-            track++;
-         timeout.Set(TRACKTIMEOUT);
-         break;
-    case kSubtitles|k_Repeat:
-    case kSubtitles:
-         if (++track >= numTracks)
-            track = 0;
-         timeout.Set(TRACKTIMEOUT);
-         break;
-    case kOk:
-         if (types[track] != cDevice::PrimaryDevice()->GetCurrentSubtitleTrack())
-            oldTrack = -1; // make sure we explicitly switch to that track
-         timeout.Set();
-         break;
-    case kNone: break;
-    default: if ((Key & k_Release) == 0)
-                return osEnd;
-    }
-  if (track != oldTrack) {
-     Show();
-     cDevice::PrimaryDevice()->SetCurrentSubtitleTrack(types[track], true);
-     }
-  return timeout.TimedOut() ? osEnd : osContinue;
-}
-
-// --- cRecordControl --------------------------------------------------------
-
-cRecordControl::cRecordControl(cDevice *Device, cTimer *Timer, bool Pause)
-{
-  // Whatever happens here, the timers will be modified in some way...
-  Timers.SetModified();
-  // We're going to manipulate an event here, so we need to prevent
-  // others from modifying any EPG data:
-  cSchedulesLock SchedulesLock;
-  cSchedules::Schedules(SchedulesLock);
-
-  event = NULL;
-  fileName = NULL;
-  recorder = NULL;
-  device = Device;
-  if (!device) device = cDevice::PrimaryDevice();//XXX
-  timer = Timer;
-  if (!timer) {
-     timer = new cTimer(true, Pause);
-     Timers.Add(timer);
-     instantId = cString::sprintf(cDevice::NumDevices() > 1 ? "%s - %d" : "%s", timer->Channel()->Name(), device->CardIndex() + 1);
-     }
-  timer->SetPending(true);
-  timer->SetRecording(true);
-  event = timer->Event();
-
-  if (event || GetEvent())
-     dsyslog("Title: '%s' Subtitle: '%s'", event->Title(), event->ShortText());
-  cRecording Recording(timer, event);
-  fileName = strdup(Recording.FileName());
-
-  // crude attempt to avoid duplicate recordings:
-  if (cRecordControls::GetRecordControl(fileName)) {
-     isyslog("already recording: '%s'", fileName);
-     if (Timer) {
-        timer->SetPending(false);
-        timer->SetRecording(false);
-        timer->OnOff();
-        }
-     else {
-        Timers.Del(timer);
-        if (!cReplayControl::LastReplayed()) // an instant recording, maybe from cRecordControls::PauseLiveVideo()
-           cReplayControl::SetRecording(fileName);
-        }
-     timer = NULL;
-     return;
-     }
-
-  cRecordingUserCommand::InvokeCommand(RUC_BEFORERECORDING, fileName);
-  isyslog("record %s", fileName);
-  if (MakeDirs(fileName, true)) {
-     const cChannel *ch = timer->Channel();
-     recorder = new cRecorder(fileName, ch, timer->Priority());
-     if (device->AttachReceiver(recorder)) {
-        Recording.WriteInfo();
-        cStatus::MsgRecording(device, Recording.Name(), Recording.FileName(), true);
-        if (!Timer && !cReplayControl::LastReplayed()) // an instant recording, maybe from cRecordControls::PauseLiveVideo()
-           cReplayControl::SetRecording(fileName);
-        Recordings.AddByName(fileName);
-        if (Timer && !Timer->IsSingleEvent()) {
-           char *Directory = strdup(fileName);
-           // going up two directory levels to get the series folder
-           if (char *p = strrchr(Directory, '/')) {
-              while (p > Directory && *--p != '/')
-                    ;
-              *p = 0;
-              if (!HasRecordingsSortMode(Directory)) {
-                 dsyslog("setting %s to be sorted by time", Directory);
-                 SetRecordingsSortMode(Directory, rsmTime);
-                 }
-              }
-           free(Directory);
-           }
-        return;
-        }
-     else
-        DELETENULL(recorder);
-     }
-  else
-     timer->SetDeferred(DEFERTIMER);
-  if (!Timer) {
-     Timers.Del(timer);
-     timer = NULL;
-     }
-}
-
-cRecordControl::~cRecordControl()
-{
-  Stop();
-  free(fileName);
-}
-
-#define INSTANT_REC_EPG_LOOKAHEAD 300 // seconds to look into the EPG data for an instant recording
-
-bool cRecordControl::GetEvent(void)
-{
-  const cChannel *channel = timer->Channel();
-  time_t Time = timer->HasFlags(tfInstant) ? timer->StartTime() + INSTANT_REC_EPG_LOOKAHEAD : timer->StartTime() + (timer->StopTime() - timer->StartTime()) / 2;
-  for (int seconds = 0; seconds <= MAXWAIT4EPGINFO; seconds++) {
-      {
-        cSchedulesLock SchedulesLock;
-        const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
-        if (Schedules) {
-           const cSchedule *Schedule = Schedules->GetSchedule(channel);
-           if (Schedule) {
-              event = Schedule->GetEventAround(Time);
-              if (event) {
-                 if (seconds > 0)
-                    dsyslog("got EPG info after %d seconds", seconds);
-                 return true;
-                 }
-              }
-           }
-      }
-      if (seconds == 0)
-         dsyslog("waiting for EPG info...");
-      cCondWait::SleepMs(1000);
-      }
-  dsyslog("no EPG info available");
-  return false;
-}
-
-void cRecordControl::Stop(bool ExecuteUserCommand)
-{
-  if (timer) {
-     DELETENULL(recorder);
-     timer->SetRecording(false);
-     timer = NULL;
-     cStatus::MsgRecording(device, NULL, fileName, false);
-     if (ExecuteUserCommand)
-        cRecordingUserCommand::InvokeCommand(RUC_AFTERRECORDING, fileName);
-     Timers.SetModified();
-     }
-}
-
-bool cRecordControl::Process(time_t t)
-{
-  if (!recorder || !recorder->IsAttached() || !timer || !timer->Matches(t)) {
-     if (timer)
-        timer->SetPending(false);
-     return false;
-     }
-  AssertFreeDiskSpace(timer->Priority());
-  return true;
-}
-
-// --- cRecordControls -------------------------------------------------------
-
-cRecordControl *cRecordControls::RecordControls[MAXRECORDCONTROLS] = { NULL };
-int cRecordControls::state = 0;
-
-bool cRecordControls::Start(cTimer *Timer, bool Pause)
-{
-  if (!Timer) {
-     cTimer *t = new cTimer(true, Pause);
-
-     //get event
-     cSchedulesLock SchedulesLock;
-     const cEvent *event = NULL;;
-     const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
-     if (Schedules) {
-        const cSchedule *Schedule = Schedules->GetSchedule(t->Channel());
-        if (Schedule) {
-           event = Schedule->GetEventAround(t->StartTime() + INSTANT_REC_EPG_LOOKAHEAD);
-        }
-     }
-
-     if (cPluginManager::GetPlugin("timersync")) {
-        // sets the file name
-        cRecording recording(t, event);
-        Timers.Add(t);
-        Timers.SetModified();
-        if (!cReplayControl::LastReplayed())
-           cReplayControl::SetRecording(recording.FileName());
-        return true;
-     }
-     else {
-        RemoteTimers_InstantRecording_v1_0 ir;
-        ir.timer = t;
-        ir.pause = Pause;
-        ir.event = event;
-        ir.name = NULL;
-        ir.fileName = NULL;
-
-        if (cPluginManager::CallFirstService("RemoteTimers::InstantRecording-v1.0", &ir)) {
-           if (!cReplayControl::LastReplayed())
-              cReplayControl::SetRecording(ir.fileName);
- 	  delete t;
- 	  // empty names indicate an error
- 	  return *ir.fileName && *ir.name;
-        }
-        // service disabled or an error occured and the user confirmed local recording
-        // fall through to local instant recording
-     }
-     delete t;
-  }
-
-  static time_t LastNoDiskSpaceMessage = 0;
-  int FreeMB = 0;
-  if (Timer) {
-     AssertFreeDiskSpace(Timer->Priority(), !Timer->Pending());
-     Timer->SetPending(true);
-     }
-  VideoDiskSpace(&FreeMB);
-  if (FreeMB < MINFREEDISK) {
-     if (!Timer || time(NULL) - LastNoDiskSpaceMessage > NODISKSPACEDELTA) {
-        isyslog("not enough disk space to start recording%s%s", Timer ? " timer " : "", Timer ? *Timer->ToDescr() : "");
-        Skins.Message(mtWarning, tr("Not enough disk space to start recording!"));
-        LastNoDiskSpaceMessage = time(NULL);
-        }
-     return false;
-     }
-  LastNoDiskSpaceMessage = 0;
-
-  ChangeState();
-  int ch = Timer ? Timer->Channel()->Number() : cDevice::CurrentChannel();
-  cChannel *channel = Channels.GetByNumber(ch);
-
-  if (channel) {
-     int Priority = Timer ? Timer->Priority() : Pause ? Setup.PausePriority : Setup.DefaultPriority;
-     cDevice *device = cDevice::GetDevice(channel, Priority, false);
-     if (device) {
-        dsyslog("switching device %d to channel %d", device->DeviceNumber() + 1, channel->Number());
-        if (!device->SwitchChannel(channel, false)) {
-           ShutdownHandler.RequestEmergencyExit();
-           return false;
-           }
-        if (!Timer || Timer->Matches()) {
-           for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-               if (!RecordControls[i]) {
-                  RecordControls[i] = new cRecordControl(device, Timer, Pause);
-                  cStatus::MsgRecordingFile(RecordControls[i]->FileName());  // PIN PATCH
-                  return RecordControls[i]->Process(time(NULL));
-                  }
-               }
-           }
-        }
-     else if (!Timer || !Timer->Pending()) {
-        isyslog("no free DVB device to record channel %d!", ch);
-        Skins.Message(mtError, tr("No free DVB device to record!"));
-        }
-     }
-  else
-     esyslog("ERROR: channel %d not defined!", ch);
-  return false;
-}
-
-void cRecordControls::Stop(const char *InstantId)
-{
-  ChangeState();
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-      if (RecordControls[i]) {
-         const char *id = RecordControls[i]->InstantId();
-         if (id && strcmp(id, InstantId) == 0) {
-            cTimer *timer = RecordControls[i]->Timer();
-            RecordControls[i]->Stop();
-            if (timer) {
-               isyslog("deleting timer %s", *timer->ToDescr());
-               Timers.Del(timer);
-               Timers.SetModified();
-               }
-            break;
-            }
-         }
-      }
-}
-
-bool cRecordControls::PauseLiveVideo(void)
-{
-  Skins.Message(mtStatus, tr("Pausing live video..."));
-  cReplayControl::SetRecording(NULL); // make sure the new cRecordControl will set cReplayControl::LastReplayed()
-  if (Start(NULL, true)) {
-     cReplayControl *rc = new cReplayControl(true);
-     cControl::Launch(rc);
-     cControl::Attach();
-     Skins.Message(mtStatus, NULL);
-     return true;
-     }
-  Skins.Message(mtStatus, NULL);
-  return false;
-}
-
-const char *cRecordControls::GetInstantId(const char *LastInstantId)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-      if (RecordControls[i]) {
-         if (!LastInstantId && RecordControls[i]->InstantId())
-            return RecordControls[i]->InstantId();
-         if (LastInstantId && LastInstantId == RecordControls[i]->InstantId())
-            LastInstantId = NULL;
-         }
-      }
-  return NULL;
-}
-
-cRecordControl *cRecordControls::GetRecordControl(const char *FileName)
-{
-  if (FileName) {
-     for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-         if (RecordControls[i] && strcmp(RecordControls[i]->FileName(), FileName) == 0)
-            return RecordControls[i];
-         }
-     }
-  return NULL;
-}
-
-cRecordControl *cRecordControls::GetRecordControl(const cTimer *Timer)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-      if (RecordControls[i] && RecordControls[i]->Timer() == Timer)
-         return RecordControls[i];
-      }
-  return NULL;
-}
-
-void cRecordControls::Process(time_t t)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-      if (RecordControls[i]) {
-         if (!RecordControls[i]->Process(t)) {
-            DELETENULL(RecordControls[i]);
-            ChangeState();
-            }
-         }
-      }
-}
-
-void cRecordControls::ChannelDataModified(cChannel *Channel)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-      if (RecordControls[i]) {
-         if (RecordControls[i]->Timer() && RecordControls[i]->Timer()->Channel() == Channel) {
-            if (RecordControls[i]->Device()->ProvidesTransponder(Channel)) { // avoids retune on devices that don't really access the transponder
-               isyslog("stopping recording due to modification of channel %d", Channel->Number());
-               RecordControls[i]->Stop();
-               // This will restart the recording, maybe even from a different
-               // device in case conditional access has changed.
-               ChangeState();
-               }
-            }
-         }
-      }
-}
-
-bool cRecordControls::Active(void)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++) {
-      if (RecordControls[i])
-         return true;
-      }
-  return false;
-}
-
-void cRecordControls::Shutdown(void)
-{
-  for (int i = 0; i < MAXRECORDCONTROLS; i++)
-      DELETENULL(RecordControls[i]);
-  ChangeState();
-}
-
-bool cRecordControls::StateChanged(int &State)
-{
-  int NewState = state;
-  bool Result = State != NewState;
-  State = state;
-  return Result;
-}
-
-// --- cReplayControl --------------------------------------------------------
-
-#define REPLAYCONTROLSKIPLIMIT   9    // s
-#define REPLAYCONTROLSKIPSECONDS 90   // s
-#define REPLAYCONTROLSKIPTIMEOUT 5000 // ms
-
-cReplayControl *cReplayControl::currentReplayControl = NULL;
-cString cReplayControl::fileName;
-
-cReplayControl::cReplayControl(bool PauseLive)
-:cDvbPlayerControl(fileName, PauseLive)
-{
-  cDevice::PrimaryDevice()->SetKeepTracks(PauseLive);
-  currentReplayControl = this;
-  displayReplay = NULL;
-  marksModified = false;
-  visible = modeOnly = shown = displayFrames = false;
-  lastCurrent = lastTotal = -1;
-  lastPlay = lastForward = false;
-  lastSpeed = -2; // an invalid value
-  lastSkipKey = kNone;
-  lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
-  lastSkipTimeout.Set(0);
-  timeoutShow = 0;
-  timeSearchActive = false;
-  cRecording Recording(fileName);
-  cStatus::MsgReplaying(this, Recording.Name(), Recording.FileName(), true);
-  marks.Load(fileName, Recording.FramesPerSecond(), Recording.IsPesRecording());
-  SetTrackDescriptions(false);
-  if (Setup.ProgressDisplayTime)
-     ShowTimed(Setup.ProgressDisplayTime);
-}
-
-cReplayControl::~cReplayControl()
-{
-  cDevice::PrimaryDevice()->SetKeepTracks(false);
-  Hide();
-  cStatus::MsgReplaying(this, NULL, fileName, false);
-  Stop();
-  if (currentReplayControl == this)
-     currentReplayControl = NULL;
-}
-
-void cReplayControl::Stop(void)
-{
-  if (Setup.DelTimeshiftRec && *fileName) {
-     cRecordControl* rc = cRecordControls::GetRecordControl(fileName);
-     if (rc && rc->InstantId()) {
-        if (Active()) {
-           if (Setup.DelTimeshiftRec == 2 || Interface->Confirm(tr("Delete timeshift recording?"))) {
-              cTimer *timer = rc->Timer();
-              rc->Stop(false); // don't execute user command
-              if (timer) {
-                 isyslog("deleting timer %s", *timer->ToDescr());
-                 Timers.Del(timer);
-                 Timers.SetModified();
-                 }
-              cDvbPlayerControl::Stop();
-              cRecording *recording = Recordings.GetByName(fileName);
-              if (recording) {
-                 if (recording->Delete()) {
-                    Recordings.DelByName(fileName);
-                    ClearLastReplayed(fileName);
-                    }
-                 else
-                    Skins.Message(mtError, tr("Error while deleting recording!"));
-                 }
-              return;
-              }
-           }
-        }
-     }
-  cDvbPlayerControl::Stop();
-}
-
-void cReplayControl::SetRecording(const char *FileName)
-{
-  fileName = FileName;
-}
-
-const char *cReplayControl::NowReplaying(void)
-{
-  return currentReplayControl ? *fileName : NULL;
-}
-
-const char *cReplayControl::LastReplayed(void)
-{
-  return fileName;
-}
-
-void cReplayControl::ClearLastReplayed(const char *FileName)
-{
-  if (*fileName && FileName && strcmp(fileName, FileName) == 0)
-     fileName = NULL;
-}
-
-void cReplayControl::ShowTimed(int Seconds)
-{
-  if (modeOnly)
-     Hide();
-  if (!visible) {
-     shown = ShowProgress(true);
-     timeoutShow = (shown && Seconds > 0) ? time(NULL) + Seconds : 0;
-     }
-  else if (timeoutShow && Seconds > 0)
-     timeoutShow = time(NULL) + Seconds;
-}
-
-void cReplayControl::Show(void)
-{
-  ShowTimed();
-}
-
-void cReplayControl::Hide(void)
-{
-  if (visible) {
-     delete displayReplay;
-     displayReplay = NULL;
-     SetNeedsFastResponse(false);
-     visible = false;
-     modeOnly = false;
-     lastPlay = lastForward = false;
-     lastSpeed = -2; // an invalid value
-     timeSearchActive = false;
-     timeoutShow = 0;
-     }
-  if (marksModified) {
-     marks.Save();
-     marksModified = false;
-     }
-}
-
-void cReplayControl::ShowMode(void)
-{
-  if (visible || Setup.ShowReplayMode && !cOsd::IsOpen()) {
-     bool Play, Forward;
-     int Speed;
-     if (GetReplayMode(Play, Forward, Speed) && (!visible || Play != lastPlay || Forward != lastForward || Speed != lastSpeed)) {
-        bool NormalPlay = (Play && Speed == -1);
-
-        if (!visible) {
-           if (NormalPlay)
-              return; // no need to do indicate ">" unless there was a different mode displayed before
-           visible = modeOnly = true;
-           displayReplay = Skins.Current()->DisplayReplay(modeOnly);
-           }
-
-        if (modeOnly && !timeoutShow && NormalPlay)
-           timeoutShow = time(NULL) + MODETIMEOUT;
-        displayReplay->SetMode(Play, Forward, Speed);
-        lastPlay = Play;
-        lastForward = Forward;
-        lastSpeed = Speed;
-        }
-     }
-}
-
-bool cReplayControl::ShowProgress(bool Initial)
-{
-  int Current, Total;
-
-  if (GetIndex(Current, Total) && Total > 0) {
-     if (!visible) {
-        displayReplay = Skins.Current()->DisplayReplay(modeOnly);
-        displayReplay->SetMarks(&marks);
-        SetNeedsFastResponse(true);
-        visible = true;
-        }
-     if (Initial) {
-        if (*fileName) {
-           if (cRecording *Recording = Recordings.GetByName(fileName))
-              displayReplay->SetRecording(Recording);
-           }
-        lastCurrent = lastTotal = -1;
-        }
-     if (Current != lastCurrent || Total != lastTotal) {
-        if (Setup.ShowRemainingTime || Total != lastTotal) {
-           int Index = Total;
-           if (Setup.ShowRemainingTime)
-              Index = Current - Index;
-           displayReplay->SetTotal(IndexToHMSF(Index, false, FramesPerSecond()));
-           if (!Initial)
-              displayReplay->Flush();
-           }
-        displayReplay->SetProgress(Current, Total);
-        if (!Initial)
-           displayReplay->Flush();
-        displayReplay->SetCurrent(IndexToHMSF(Current, displayFrames, FramesPerSecond()));
-        displayReplay->Flush();
-        lastCurrent = Current;
-        }
-     lastTotal = Total;
-     ShowMode();
-     return true;
-     }
-  return false;
-}
-
-void cReplayControl::TimeSearchDisplay(void)
-{
-  char buf[64];
-  // TRANSLATORS: note the trailing blank!
-  strcpy(buf, tr("Jump: "));
-  int len = strlen(buf);
-  char h10 = '0' + (timeSearchTime >> 24);
-  char h1  = '0' + ((timeSearchTime & 0x00FF0000) >> 16);
-  char m10 = '0' + ((timeSearchTime & 0x0000FF00) >> 8);
-  char m1  = '0' + (timeSearchTime & 0x000000FF);
-  char ch10 = timeSearchPos > 3 ? h10 : '-';
-  char ch1  = timeSearchPos > 2 ? h1  : '-';
-  char cm10 = timeSearchPos > 1 ? m10 : '-';
-  char cm1  = timeSearchPos > 0 ? m1  : '-';
-  sprintf(buf + len, "%c%c:%c%c", ch10, ch1, cm10, cm1);
-  displayReplay->SetJump(buf);
-}
-
-void cReplayControl::TimeSearchProcess(eKeys Key)
-{
-#define STAY_SECONDS_OFF_END 10
-  int Seconds = (timeSearchTime >> 24) * 36000 + ((timeSearchTime & 0x00FF0000) >> 16) * 3600 + ((timeSearchTime & 0x0000FF00) >> 8) * 600 + (timeSearchTime & 0x000000FF) * 60;
-  int Current = int(round(lastCurrent / FramesPerSecond()));
-  int Total = int(round(lastTotal / FramesPerSecond()));
-  switch (Key) {
-    case k0 ... k9:
-         if (timeSearchPos < 4) {
-            timeSearchTime <<= 8;
-            timeSearchTime |= Key - k0;
-            timeSearchPos++;
-            TimeSearchDisplay();
-            }
-         break;
-    case kFastRew:
-    case kLeft:
-    case kFastFwd:
-    case kRight: {
-         int dir = ((Key == kRight || Key == kFastFwd) ? 1 : -1);
-         if (dir > 0)
-            Seconds = min(Total - Current - STAY_SECONDS_OFF_END, Seconds);
-         SkipSeconds(Seconds * dir);
-         timeSearchActive = false;
-         }
-         break;
-    case kPlayPause:
-    case kPlay:
-    case kUp:
-    case kPause:
-    case kDown:
-    case kOk:
-         if (timeSearchPos > 0) {
-            Seconds = min(Total - STAY_SECONDS_OFF_END, Seconds);
-            Goto(SecondsToFrames(Seconds, FramesPerSecond()), Key == kDown || Key == kPause || Key == kOk);
-            }
-         timeSearchActive = false;
-         break;
-    default:
-         if (!(Key & k_Flags)) // ignore repeat/release keys
-            timeSearchActive = false;
-         break;
-    }
-
-  if (!timeSearchActive) {
-     if (timeSearchHide)
-        Hide();
-     else
-        displayReplay->SetJump(NULL);
-     ShowMode();
-     }
-}
-
-void cReplayControl::TimeSearch(void)
-{
-  timeSearchTime = timeSearchPos = 0;
-  timeSearchHide = false;
-  if (modeOnly)
-     Hide();
-  if (!visible) {
-     Show();
-     if (visible)
-        timeSearchHide = true;
-     else
-        return;
-     }
-  timeoutShow = 0;
-  TimeSearchDisplay();
-  timeSearchActive = true;
-}
-
-void cReplayControl::MarkToggle(void)
-{
-  int Current, Total;
-  if (GetIndex(Current, Total, true)) {
-     lastCurrent = -1; // triggers redisplay
-     if (cMark *m = marks.Get(Current))
-        marks.Del(m);
-     else {
-        marks.Add(Current);
-        bool Play, Forward;
-        int Speed;
-        if (Setup.PauseOnMarkSet || GetReplayMode(Play, Forward, Speed) && !Play) {
-           Goto(Current, true);
-           displayFrames = true;
-           }
-        }
-     ShowTimed(2);
-     marksModified = true;
-     }
-}
-
-void cReplayControl::MarkJump(bool Forward)
-{
-  int Current, Total;
-  if (GetIndex(Current, Total)) {
-     if (marks.Count()) {
-        if (cMark *m = Forward ? marks.GetNext(Current) : marks.GetPrev(Current)) {
-           bool Play2, Forward2;
-           int Speed;
-           if (Setup.JumpPlay && GetReplayMode(Play2, Forward2, Speed) &&
-               Play2 && Forward && m->Position() < Total - SecondsToFrames(3, FramesPerSecond())) {
-              Goto(m->Position());
-              Play();
-              }
-           else {
-              Goto(m->Position(), true);
-              displayFrames = true;
-              }
-           return;
-           }
-        }
-     // There are either no marks at all, or we already were at the first or last one,
-     // so jump to the very beginning or end:
-     Goto(Forward ? Total : 0, true);
-     }
-}
-
-void cReplayControl::MarkMove(bool Forward)
-{
-  int Current, Total;
-  if (GetIndex(Current, Total)) {
-     if (cMark *m = marks.Get(Current)) {
-        displayFrames = true;
-        int p = SkipFrames(Forward ? 1 : -1);
-        cMark *m2;
-        if (Forward) {
-           while ((m2 = marks.Next(m)) != NULL && m2->Position() == m->Position())
-                 m = m2;
-           }
-        else {
-           while ((m2 = marks.Prev(m)) != NULL && m2->Position() == m->Position())
-                 m = m2;
-           }
-        m->SetPosition(p);
-        Goto(m->Position(), true);
-        marksModified = true;
-        }
-     }
-}
-
-void cReplayControl::EditCut(void)
-{
-  if (*fileName) {
-     Hide();
-     if (!cCutter::Active()) {
-        if (!marks.Count())
-           Skins.Message(mtError, tr("No editing marks defined!"));
-        else if (!marks.GetNumSequences())
-           Skins.Message(mtError, tr("No editing sequences defined!"));
-        else if (!cCutter::Start(fileName, NULL, false))
-           Skins.Message(mtError, tr("Can't start editing process!"));
-        else
-           Skins.Message(mtInfo, tr("Editing process started"));
-        }
-     else
-        Skins.Message(mtError, tr("Editing process already active!"));
-     ShowMode();
-     }
-}
-
-void cReplayControl::EditTest(void)
-{
-  int Current, Total;
-  if (GetIndex(Current, Total)) {
-     cMark *m = marks.Get(Current);
-     if (!m)
-        m = marks.GetNext(Current);
-     if (m) {
-        if ((m->Index() & 0x01) != 0 && !Setup.PlayJump)
-           m = marks.Next(m);
-        if (m) {
-           Goto(m->Position() - SecondsToFrames(3, FramesPerSecond()));
-           Play();
-           }
-        }
-     }
-}
-
-cOsdObject *cReplayControl::GetInfo(void)
-{
-  cRecording *Recording = Recordings.GetByName(cReplayControl::LastReplayed());
-  if (Recording)
-     return new cMenuRecording(Recording, false);
-  return NULL;
-}
-
-const cRecording *cReplayControl::GetRecording(void)
-{
-  if (const cRecording *Recording = Recordings.GetByName(LastReplayed()))
-     return Recording;
-  return NULL;
-}
-
-eOSState cReplayControl::ProcessKey(eKeys Key)
-{
-  if (!Active())
-     return osEnd;
-  if (Key == kNone && !marksModified)
-     marks.Update();
-  if (visible) {
-     if (timeoutShow && time(NULL) > timeoutShow) {
-        Hide();
-        ShowMode();
-        timeoutShow = 0;
-        }
-     else if (modeOnly)
-        ShowMode();
-     else
-        shown = ShowProgress(!shown) || shown;
-     }
-  bool DisplayedFrames = displayFrames;
-  displayFrames = false;
-  if (timeSearchActive && Key != kNone) {
-     TimeSearchProcess(Key);
-     return osContinue;
-     }
-  if (Key == kPlayPause) {
-     bool Play, Forward;
-     int Speed;
-     GetReplayMode(Play, Forward, Speed);
-     if (Speed >= 0)
-        Key = Play ? kPlay : kPause;
-     else
-        Key = Play ? kPause : kPlay;
-     }
-  bool DoShowMode = true;
-  switch (int(Key)) {
-    // Positioning:
-    case kPlay:
-    case kUp:      Play(); break;
-    case kPause:
-    case kDown:    Pause(); break;
-    case kFastRew|k_Release:
-    case kLeft|k_Release:
-                   if (Setup.MultiSpeedMode) break;
-    case kFastRew:
-    case kLeft:    Backward(); break;
-    case kFastFwd|k_Release:
-    case kRight|k_Release:
-                   if (Setup.MultiSpeedMode) break;
-    case kFastFwd:
-    case kRight:   Forward(); break;
-    case kRed:     TimeSearch(); break;
-    case kGreen|k_Repeat:
-    case kGreen:   SkipSeconds(-60); break;
-    case kYellow|k_Repeat:
-    case kYellow:  SkipSeconds( 60); break;
-    case kPrev|k_Repeat:
-    case kPrev:    if (lastSkipTimeout.TimedOut()) {
-                      lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
-                      lastSkipKey = kPrev;
-                   }
-                   else if (RAWKEY(lastSkipKey) != kPrev && lastSkipSeconds > (2 * REPLAYCONTROLSKIPLIMIT)) {
-                      lastSkipSeconds /= 2;
-                      lastSkipKey = kNone;
-                   }
-                   lastSkipTimeout.Set(REPLAYCONTROLSKIPTIMEOUT);
-                   SkipSeconds(-lastSkipSeconds); break;
-    case kNext|k_Repeat:
-    case kNext:    if (lastSkipTimeout.TimedOut()) {
-                      lastSkipSeconds = REPLAYCONTROLSKIPSECONDS;
-                      lastSkipKey = kNext;
-                   }
-                   else if (RAWKEY(lastSkipKey) != kNext && lastSkipSeconds > (2 * REPLAYCONTROLSKIPLIMIT)) {
-                      lastSkipSeconds /= 2;
-                      lastSkipKey = kNone;
-                   }
-                   lastSkipTimeout.Set(REPLAYCONTROLSKIPTIMEOUT);
-                   SkipSeconds(lastSkipSeconds); break;
-    case kStop:
-    case kBlue:    Hide();
-                   Stop();
-                   return osEnd;
-    default: {
-      bool play, forward;
-      int speed;
-      int Current, Total;
-      cMark *m;
-
-      DoShowMode = false;
-      switch (int(Key)) {
-        // Editing:
-        case k1|k_Repeat:
-        case k1:               if (GetReplayMode(play, forward, speed) && !play && GetIndex(Current, Total) && (m = marks.Get(Current)) != NULL) {
-                                  displayFrames = true;
-                                  int p = SkipFrames(-SecondsToFrames(5, FramesPerSecond()));
-                                  cMark *m2;
-                                  if ((m2 = marks.Prev(m)) != NULL && m2->Position() >= p)
-                                     break;
-                                  m->SetPosition(p); Goto(p, true);
-                                  marks.Save();
-                                  }
-                               else
-                                  SkipSeconds(-20);
-                               break;
-        case k3|k_Repeat:
-        case k3:               if (GetReplayMode(play, forward, speed) && !play && GetIndex(Current, Total) && (m = marks.Get(Current)) != NULL) {
-                                  displayFrames = true;
-                                  int p = SkipFrames(SecondsToFrames(5, FramesPerSecond()));
-                                  cMark *m2;
-                                  if ((m2 = marks.Next(m)) != NULL && m2->Position() <= p)
-                                     break;
-                                  m->SetPosition(p); Goto(p, true);
-                                  marks.Save();
-                                  }
-                               else
-                                  SkipSeconds(20);
-                               break;
-        case kMarkToggle:      if (GetReplayMode(play, forward, speed) && play) {
-                                  displayFrames = true;
-                                  Pause();
-                                  }
-                               MarkToggle();
-                               break;
-        case kMarkJumpBack|k_Repeat:
-        case kMarkJumpBack:    MarkJump(false); break;
-        case kMarkJumpForward|k_Repeat:
-        case kMarkJumpForward: MarkJump(true); break;
-        case kMarkMoveBack|k_Repeat:
-        case kMarkMoveBack:    MarkMove(false); break;
-        case kMarkMoveForward|k_Repeat:
-        case kMarkMoveForward: MarkMove(true); break;
-        case kEditCut:         EditCut(); break;
-        case kEditTest:        EditTest(); break;
-        default: {
-          displayFrames = DisplayedFrames;
-          switch (Key) {
-            // Menu control:
-            case kOk:      if (visible && !modeOnly) {
-                              Hide();
-                              DoShowMode = true;
-                              }
-                           else
-                              Show();
-                           break;
-            case kBack:    if (Setup.DelTimeshiftRec) {
-                              cRecordControl* rc = cRecordControls::GetRecordControl(fileName);
-                              return rc && rc->InstantId() ? osEnd : osRecordings;
-                              }
-                           return osRecordings;
-            default:       return osUnknown;
-            }
-          }
-        }
-      }
-    }
-  if (DoShowMode)
-     ShowMode();
-  return osContinue;
-}
diff -urN vdr-1.7.38/menu.h vdr-1.7.38-pa/menu.h
--- vdr-1.7.38/menu.h	2013-02-21 22:26:57.326776693 +0100
+++ vdr-1.7.38-pa/menu.h	2013-02-21 22:24:13.258773875 +0100
@@ -19,6 +19,17 @@
 #include "recorder.h"
 #include "skins.h"
 
+class cMenuEditSrcItem : public cMenuEditIntItem {
+private:
+  const cSource *source;
+protected:
+  virtual void Set(void);
+public:
+  cMenuEditSrcItem(const char *Name, int *Value);
+  eOSState ProcessKey(eKeys Key);
+  };
+
+
 class cMenuText : public cOsdMenu {
 private:
   char *text;
@@ -99,8 +110,24 @@
   virtual eOSState ProcessKey(eKeys Key);
   virtual const char* MenuKind() { return "MenuEvent"; }
   };
+struct MenuMainHook_Data_V1_0 {
+  eOSState  Function;    /*IN*/
+  cOsdMenu *pResultMenu; /*OUT*/
+};
+#define CREATE_MENU_MAIN(function,menu) {                              \
+  MenuMainHook_Data_V1_0 data;                                         \
+  memset(&data, 0, sizeof(data));                                      \
+  data.Function = function;                                            \
+  if (!cPluginManager::CallFirstService("MenuMainHook-V1.0", &data))   \
+    menu = new cMenuMain(function);                                    \
+  else                                                                 \
+    menu = data.pResultMenu;                                           \
+}
+
 
 class cMenuMain : public cOsdMenu {
+protected:
+  cMenuMain(const char *Title):cOsdMenu(Title){}; // Allow custom constructor
 private:
   bool replaying;
   cOsdItem *stopReplayItem;
diff -urN vdr-1.7.38/osdbase.h vdr-1.7.38-pa/osdbase.h
--- vdr-1.7.38/osdbase.h	2013-02-21 22:26:57.326776693 +0100
+++ vdr-1.7.38-pa/osdbase.h	2013-02-21 22:24:13.258773875 +0100
@@ -34,6 +34,10 @@
                 osSwitchDvb,
                 osBack,
                 osEnd,
+                osBouquets,
+                osActiveBouquet,
+                osFavourites,
+                osAddFavourite,
                 os_User, // the following values can be used locally
                 osUser1,
                 osUser2,
diff -urN vdr-1.7.38/po/it_IT.po vdr-1.7.38-pa/po/it_IT.po
--- vdr-1.7.38/po/it_IT.po	2013-02-21 22:26:57.330776693 +0100
+++ vdr-1.7.38-pa/po/it_IT.po	2013-02-21 22:24:13.258773875 +0100
@@ -25,6 +25,9 @@
 
 msgid "*** Invalid Channel ***"
 msgstr "*** Canale NON valido ***"
+ 
+msgid "File already exists - overwrite?"
+msgstr ""
 
 msgid "Channel not available!"
 msgstr "Canale non disponibile!"
@@ -489,6 +492,15 @@
 msgid "Key$Commands"
 msgstr "Comandi"
 
+msgid "Key$Greater"
+msgstr ""
+
+msgid "Key$Less"
+msgstr ""
+
+msgid "Key$2digit"
+msgstr ""
+
 msgid "Key$User0"
 msgstr "Utente0"
 
@@ -738,6 +750,9 @@
 
 msgid "Button$Rewind"
 msgstr "Riavvolgi"
+ 
+msgid "Edit recording"
+msgstr ""
 
 msgid "Recordings"
 msgstr "Registrazioni"
@@ -1201,6 +1216,10 @@
 msgid " Cancel editing"
 msgstr " Annulla modifiche"
 
+#. TRANSLATORS: note the leading blank!
+msgid " Cancel file transfer"
+msgstr ""
+
 msgid "Stop recording?"
 msgstr "Fermare la registrazione?"
 
@@ -1289,6 +1308,9 @@
 msgid "Editing - shut down anyway?"
 msgstr "Modifica in corso - spegnere comunque?"
 
+msgid "Transfering file - shut down anyway?"
+msgstr ""
+
 msgid "Recording - shut down anyway?"
 msgstr "Registrazione in corso - spegnere comunque?"
 
@@ -1393,6 +1415,12 @@
 msgid "Editing process finished"
 msgstr "Processo di modifica terminato"
 
+msgid "File transfer failed!"
+msgstr ""
+
+msgid "File transfer finished"
+msgstr ""
+
 msgid "Press any key to cancel restart"
 msgstr "Premi un tasto per annullare il riavvio"
 
diff -urN vdr-1.7.38/recording.h.orig vdr-1.7.38-pa/recording.h.orig
--- vdr-1.7.38/recording.h.orig	2013-02-21 22:26:57.326776693 +0100
+++ vdr-1.7.38-pa/recording.h.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,369 +0,0 @@
-/*
- * recording.h: Recording file handling
- *
- * See the main source file 'vdr.c' for copyright information and
- * how to reach the author.
- *
- * $Id: recording.h 2.44 2013/02/14 15:13:14 kls Exp $
- */
-
-#ifndef __RECORDING_H
-#define __RECORDING_H
-
-#include <time.h>
-#include "channels.h"
-#include "config.h"
-#include "epg.h"
-#include "thread.h"
-#include "timers.h"
-#include "tools.h"
-
-#define FOLDERDELIMCHAR '~'
-
-extern int DirectoryPathMax;
-extern int DirectoryNameMax;
-extern bool DirectoryEncoding;
-extern int InstanceId;
-
-void RemoveDeletedRecordings(void);
-void AssertFreeDiskSpace(int Priority = 0, bool Force = false);
-     ///< The special Priority value -1 means that we shall get rid of any
-     ///< deleted recordings faster than normal (because we're cutting).
-     ///< If Force is true, the check will be done even if the timeout
-     ///< hasn't expired yet.
-
-class cResumeFile {
-private:
-  char *fileName;
-  bool isPesRecording;
-public:
-  cResumeFile(const char *FileName, bool IsPesRecording);
-  ~cResumeFile();
-  int Read(void);
-  bool Save(int Index);
-  void Delete(void);
-  };
-
-class cRecordingInfo {
-  friend class cRecording;
-private:
-  tChannelID channelID;
-  char *channelName;
-  const cEvent *event;
-  cEvent *ownEvent;
-  char *aux;
-  double framesPerSecond;
-  int priority;
-  int lifetime;
-  char *fileName;
-  cRecordingInfo(const cChannel *Channel = NULL, const cEvent *Event = NULL);
-  bool Read(FILE *f);
-  void SetData(const char *Title, const char *ShortText, const char *Description);
-  void SetAux(const char *Aux);
-public:
-  cRecordingInfo(const char *FileName);
-  ~cRecordingInfo();
-  tChannelID ChannelID(void) const { return channelID; }
-  const char *ChannelName(void) const { return channelName; }
-  const cEvent *GetEvent(void) const { return event; }
-  const char *Title(void) const { return event->Title(); }
-  const char *ShortText(void) const { return event->ShortText(); }
-  const char *Description(void) const { return event->Description(); }
-  const cComponents *Components(void) const { return event->Components(); }
-  const char *Aux(void) const { return aux; }
-  double FramesPerSecond(void) const { return framesPerSecond; }
-  void SetFramesPerSecond(double FramesPerSecond);
-  bool Write(FILE *f, const char *Prefix = "") const;
-  bool Read(void);
-  bool Write(void) const;
-  };
-
-class cRecording : public cListObject {
-  friend class cRecordings;
-private:
-  mutable int resume;
-  mutable char *titleBuffer;
-  mutable char *sortBufferName;
-  mutable char *sortBufferTime;
-  mutable char *fileName;
-  mutable char *name;
-  mutable int fileSizeMB;
-  mutable int numFrames;
-  int channel;
-  int instanceId;
-  bool isPesRecording;
-  mutable int isOnVideoDirectoryFileSystem; // -1 = unknown, 0 = no, 1 = yes
-  double framesPerSecond;
-  cRecordingInfo *info;
-  cRecording(const cRecording&); // can't copy cRecording
-  cRecording &operator=(const cRecording &); // can't assign cRecording
-  static char *StripEpisodeName(char *s);
-  char *SortName(void) const;
-  int GetResume(void) const;
-  time_t start;
-  int priority;
-  int lifetime;
-  time_t deleted;
-public:
-  cRecording(cTimer *Timer, const cEvent *Event);
-  cRecording(const char *FileName);
-  virtual ~cRecording();
-  time_t Start(void) const { return start; }
-  int Priority(void) const { return priority; }
-  int Lifetime(void) const { return lifetime; }
-  time_t Deleted(void) const { return deleted; }
-  virtual int Compare(const cListObject &ListObject) const;
-  const char *Name(void) const { return name; }
-  const char *FileName(void) const;
-  const char *Title(char Delimiter = ' ', bool NewIndicator = false, int Level = -1) const;
-  const cRecordingInfo *Info(void) const { return info; }
-  const char *PrefixFileName(char Prefix);
-  const char *UpdateFileName(const char *FileName);
-  int HierarchyLevels(void) const;
-  void ResetResume(void) const;
-  double FramesPerSecond(void) const { return framesPerSecond; }
-  int NumFrames(void) const;
-       ///< Returns the number of frames in this recording.
-       ///< If the number of frames is unknown, -1 will be returned.
-  int LengthInSeconds(void) const;
-       ///< Returns the length (in seconds) of this recording, or -1 in case of error.
-  int FileSizeMB(void) const;
-       ///< Returns the total file size of this recording (in MB), or -1 if the file
-       ///< size is unknown.
-  bool IsNew(void) const { return GetResume() < 0; }
-  bool IsEdited(void) const;
-  bool IsPesRecording(void) const { return isPesRecording; }
-  bool IsOnVideoDirectoryFileSystem(void) const;
-  void ReadInfo(void);
-  bool WriteInfo(void);
-  void SetStartTime(time_t Start);
-       ///< Sets the start time of this recording to the given value.
-       ///< If a filename has already been set for this recording, it will be
-       ///< deleted and a new one will be generated (using the new start time)
-       ///< at the next call to FileName().
-       ///< Use this function with care - it does not check whether a recording with
-       ///< this new name already exists, and if there is one, results may be
-       ///< unexpected!
-  bool Delete(void);
-       ///< Changes the file name so that it will no longer be visible in the "Recordings" menu
-       ///< Returns false in case of error
-  bool Remove(void);
-       ///< Actually removes the file from the disk
-       ///< Returns false in case of error
-  bool Undelete(void);
-       ///< Changes the file name so that it will be visible in the "Recordings" menu again and
-       ///< not processed by cRemoveDeletedRecordingsThread.
-       ///< Returns false in case of error
-  };
-
-class cRecordings : public cList<cRecording>, public cThread {
-private:
-  static char *updateFileName;
-  bool deleted;
-  time_t lastUpdate;
-  int state;
-  const char *UpdateFileName(void);
-  void Refresh(bool Foreground = false);
-  void ScanVideoDir(const char *DirName, bool Foreground = false, int LinkLevel = 0);
-protected:
-  void Action(void);
-public:
-  cRecordings(bool Deleted = false);
-  virtual ~cRecordings();
-  bool Load(void) { return Update(true); }
-       ///< Loads the current list of recordings and returns true if there
-       ///< is anything in it (for compatibility with older plugins - use
-       ///< Update(true) instead).
-  bool Update(bool Wait = false);
-       ///< Triggers an update of the list of recordings, which will run
-       ///< as a separate thread if Wait is false. If Wait is true, the
-       ///< function returns only after the update has completed.
-       ///< Returns true if Wait is true and there is anything in the list
-       ///< of recordings, false otherwise.
-  void TouchUpdate(void);
-       ///< Touches the '.update' file in the video directory, so that other
-       ///< instances of VDR that access the same video directory can be triggered
-       ///< to update their recordings list.
-  bool NeedsUpdate(void);
-  void ChangeState(void) { state++; }
-  bool StateChanged(int &State);
-  void ResetResume(const char *ResumeFileName = NULL);
-  cRecording *GetByName(const char *FileName);
-  void AddByName(const char *FileName, bool TriggerUpdate = true);
-  void DelByName(const char *FileName, bool RemoveRecording = true);
-  void UpdateByName(const char *FileName);
-  int TotalFileSizeMB(void);
-  double MBperMinute(void);
-       ///< Returns the average data rate (in MB/min) of all recordings, or -1 if
-       ///< this value is unknown.
-  };
-
-extern cRecordings Recordings;
-extern cRecordings DeletedRecordings;
-
-#define DEFAULTFRAMESPERSECOND 25.0
-
-class cMark : public cListObject {
-  friend class cMarks; // for sorting
-private:
-  double framesPerSecond;
-  int position;
-  cString comment;
-public:
-  cMark(int Position = 0, const char *Comment = NULL, double FramesPerSecond = DEFAULTFRAMESPERSECOND);
-  virtual ~cMark();
-  int Position(void) const { return position; }
-  const char *Comment(void) const { return comment; }
-  void SetPosition(int Position) { position = Position; }
-  void SetComment(const char *Comment) { comment = Comment; }
-  cString ToText(void);
-  bool Parse(const char *s);
-  bool Save(FILE *f);
-  };
-
-class cMarks : public cConfig<cMark> {
-private:
-  cString recordingFileName;
-  cString fileName;
-  double framesPerSecond;
-  bool isPesRecording;
-  time_t nextUpdate;
-  time_t lastFileTime;
-  time_t lastChange;
-public:
-  bool Load(const char *RecordingFileName, double FramesPerSecond = DEFAULTFRAMESPERSECOND, bool IsPesRecording = false);
-  bool Update(void);
-  bool Save(void);
-  void Align(void);
-  void Sort(void);
-  void Add(int Position);
-  cMark *Get(int Position);
-  cMark *GetPrev(int Position);
-  cMark *GetNext(int Position);
-  cMark *GetNextBegin(cMark *EndMark = NULL);
-       ///< Returns the next "begin" mark after EndMark, skipping any marks at the
-       ///< same position as EndMark. If EndMark is NULL, the first actual "begin"
-       ///< will be returned (if any).
-  cMark *GetNextEnd(cMark *BeginMark);
-       ///< Returns the next "end" mark after BeginMark, skipping any marks at the
-       ///< same position as BeginMark.
-  int GetNumSequences(void);
-       ///< Returns the actual number of sequences to be cut from the recording.
-       ///< If there is only one actual "begin" mark, and it is positioned at index
-       ///< 0 (the beginning of the recording), and there is no "end" mark, the
-       ///< return value is 0, which means that the result is the same as the original
-       ///< recording.
-  };
-
-#define RUC_BEFORERECORDING "before"
-#define RUC_AFTERRECORDING  "after"
-#define RUC_EDITEDRECORDING "edited"
-#define RUC_DELETERECORDING "deleted"
-
-class cRecordingUserCommand {
-private:
-  static const char *command;
-public:
-  static void SetCommand(const char *Command) { command = Command; }
-  static void InvokeCommand(const char *State, const char *RecordingFileName, const char *SourceFileName = NULL);
-  };
-
-// The maximum size of a single frame (up to HDTV 1920x1080):
-#define MAXFRAMESIZE  (KILOBYTE(1024) / TS_SIZE * TS_SIZE) // multiple of TS_SIZE to avoid breaking up TS packets
-
-// The maximum file size is limited by the range that can be covered
-// with a 40 bit 'unsigned int', which is 1TB. The actual maximum value
-// used is 6MB below the theoretical maximum, to have some safety (the
-// actual file size may be slightly higher because we stop recording only
-// before the next independent frame, to have a complete Group Of Pictures):
-#define MAXVIDEOFILESIZETS  1048570 // MB
-#define MAXVIDEOFILESIZEPES    2000 // MB
-#define MINVIDEOFILESIZE        100 // MB
-#define MAXVIDEOFILESIZEDEFAULT MAXVIDEOFILESIZEPES
-
-struct tIndexTs;
-class cIndexFileGenerator;
-
-class cIndexFile {
-private:
-  int f;
-  cString fileName;
-  int size, last;
-  tIndexTs *index;
-  bool isPesRecording;
-  cResumeFile resumeFile;
-  cIndexFileGenerator *indexFileGenerator;
-  cMutex mutex;
-  void ConvertFromPes(tIndexTs *IndexTs, int Count);
-  void ConvertToPes(tIndexTs *IndexTs, int Count);
-  bool CatchUp(int Index = -1);
-public:
-  cIndexFile(const char *FileName, bool Record, bool IsPesRecording = false, bool PauseLive = false);
-  ~cIndexFile();
-  bool Ok(void) { return index != NULL; }
-  bool Write(bool Independent, uint16_t FileNumber, off_t FileOffset);
-  bool Get(int Index, uint16_t *FileNumber, off_t *FileOffset, bool *Independent = NULL, int *Length = NULL);
-  int GetNextIFrame(int Index, bool Forward, uint16_t *FileNumber = NULL, off_t *FileOffset = NULL, int *Length = NULL);
-  int GetClosestIFrame(int Index);
-       ///< Returns the index of the I-frame that is closest to the given Index (or Index itself,
-       ///< if it already points to an I-frame). Index may be any value, even outside the current
-       ///< range of frame indexes.
-       ///< If there is no actual index data available, 0 is returned.
-  int Get(uint16_t FileNumber, off_t FileOffset);
-  int Last(void) { CatchUp(); return last; }
-       ///< Returns the index of the last entry in this file, or -1 if the file is empty.
-  int GetResume(void) { return resumeFile.Read(); }
-  bool StoreResume(int Index) { return resumeFile.Save(Index); }
-  bool IsStillRecording(void);
-  void Delete(void);
-  static int GetLength(const char *FileName, bool IsPesRecording = false);
-       ///< Calculates the recording length (number of frames) without actually reading the index file.
-       ///< Returns -1 in case of error.
-  static cString IndexFileName(const char *FileName, bool IsPesRecording);
-  };
-
-class cFileName {
-private:
-  cUnbufferedFile *file;
-  uint16_t fileNumber;
-  char *fileName, *pFileNumber;
-  bool record;
-  bool blocking;
-  bool isPesRecording;
-public:
-  cFileName(const char *FileName, bool Record, bool Blocking = false, bool IsPesRecording = false);
-  ~cFileName();
-  const char *Name(void) { return fileName; }
-  uint16_t Number(void) { return fileNumber; }
-  bool GetLastPatPmtVersions(int &PatVersion, int &PmtVersion);
-  cUnbufferedFile *Open(void);
-  void Close(void);
-  cUnbufferedFile *SetOffset(int Number, off_t Offset = 0); // yes, Number is int for easier internal calculating
-  cUnbufferedFile *NextFile(void);
-  };
-
-cString IndexToHMSF(int Index, bool WithFrame = false, double FramesPerSecond = DEFAULTFRAMESPERSECOND);
-      // Converts the given index to a string, optionally containing the frame number.
-int HMSFToIndex(const char *HMSF, double FramesPerSecond = DEFAULTFRAMESPERSECOND);
-      // Converts the given string (format: "hh:mm:ss.ff") to an index.
-int SecondsToFrames(int Seconds, double FramesPerSecond = DEFAULTFRAMESPERSECOND);
-      // Returns the number of frames corresponding to the given number of seconds.
-
-int ReadFrame(cUnbufferedFile *f, uchar *b, int Length, int Max);
-
-char *ExchangeChars(char *s, bool ToFileSystem);
-      // Exchanges the characters in the given string to or from a file system
-      // specific representation (depending on ToFileSystem). The given string will
-      // be modified and may be reallocated if more space is needed. The return
-      // value points to the resulting string, which may be different from s.
-
-bool GenerateIndex(const char *FileName);
-
-enum eRecordingsSortMode { rsmName, rsmTime };
-extern eRecordingsSortMode RecordingsSortMode;
-bool HasRecordingsSortMode(const char *Directory);
-void GetRecordingsSortMode(const char *Directory);
-void SetRecordingsSortMode(const char *Directory, eRecordingsSortMode SortMode);
-void IncRecordingsSortMode(const char *Directory);
-
-#endif //__RECORDING_H
diff -urN vdr-1.7.38/vdr.c vdr-1.7.38-pa/vdr.c
--- vdr-1.7.38/vdr.c	2013-02-21 22:26:57.330776693 +0100
+++ vdr-1.7.38-pa/vdr.c	2013-02-21 22:24:13.258773875 +0100
@@ -1101,6 +1101,28 @@
           case kChanUp:
           case kChanDn|k_Repeat:
           case kChanDn:
+
+               if (Setup.ChannelUpDownKeyMode == 1 && (!Menu || cDisplayChannel::IsOpen()))
+               // only if a menu is not open
+               //  and user has opted for a different key behavior
+               {
+                   if (cDisplayChannel::IsOpen() || cControl::Control())
+                   {
+                       DELETE_MENU;
+                   }
+                   if (key == kChanDn)
+                   {
+                       DirectMainFunction(osBouquets);
+                   }
+                   else
+                   {
+                       DirectMainFunction(osActiveBouquet);
+                   }
+                   key = kNone; // nobody else sees these keys
+                   break;
+               }
+               else
+
                if (!Interact)
                   Menu = new cDisplayChannel(NORMALKEY(key));
                else if (cDisplayChannel::IsOpen() || cControl::Control()) {
@@ -1144,6 +1166,7 @@
                break;
           // Subtitle track control:
           case kSubtitles:
+         case kGreater:
                if (cControl::Control())
                   cControl::Control()->Hide();
                if (!cDisplaySubtitleTracks::IsOpen()) {
@@ -1298,7 +1321,19 @@
                   Menu = new cDisplayChannel(NORMALKEY(key));
                   break;
              // Viewing Control:
-             case kOk:   LastChannel = -1; break; // forces channel display
+             case kInfo:
+             case kOk:  if ((Setup.WantChListOnOk && (key == kOk)) 
+                            || (!Setup.WantChListOnOk && (key == kInfo)) )
+                        {
+                            DirectMainFunction(osChannels);
+                        }
+                        else 
+                        {
+                            LastChannel = -1;
+                        }
+                        break;
+
+
              // Instant resume of the last viewed recording:
              case kPlay:
                   if (cReplayControl::LastReplayed()) {
diff -urN vdr-1.7.38/vdr.c.orig vdr-1.7.38-pa/vdr.c.orig
--- vdr-1.7.38/vdr.c.orig	2013-02-21 22:26:57.326776693 +0100
+++ vdr-1.7.38-pa/vdr.c.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,1421 +0,0 @@
-/*
- * vdr.c: Video Disk Recorder main program
- *
- * Copyright (C) 2000, 2003, 2006, 2008 Klaus Schmidinger
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- * Or, point your browser to http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
- *
- * The author can be reached at kls@tvdr.de
- *
- * The project's page is at http://www.tvdr.de
- *
- * $Id: vdr.c 2.49 2013/02/14 10:49:06 kls Exp $
- */
-
-#include <getopt.h>
-#include <grp.h>
-#include <langinfo.h>
-#include <locale.h>
-#include <pwd.h>
-#include <signal.h>
-#include <stdlib.h>
-#include <sys/capability.h>
-#include <sys/prctl.h>
-#include <termios.h>
-#include <unistd.h>
-#include "audio.h"
-#include "channels.h"
-#include "config.h"
-#include "cutter.h"
-#include "device.h"
-#include "diseqc.h"
-#include "dvbdevice.h"
-#include "eitscan.h"
-#include "epg.h"
-#include "filetransfer.h"
-#include "i18n.h"
-#include "interface.h"
-#include "keys.h"
-#include "libsi/si.h"
-#include "lirc.h"
-#include "menu.h"
-#include "osdbase.h"
-#include "plugin.h"
-#include "recording.h"
-#include "shutdown.h"
-#include "skinclassic.h"
-#include "skinlcars.h"
-#include "skinsttng.h"
-#include "sourceparams.h"
-#include "sources.h"
-#include "themes.h"
-#include "timers.h"
-#include "tools.h"
-#include "transfer.h"
-#include "videodir.h"
-
-#define MINCHANNELWAIT        10 // seconds to wait between failed channel switchings
-#define ACTIVITYTIMEOUT       60 // seconds before starting housekeeping
-#define SHUTDOWNWAIT         300 // seconds to wait in user prompt before automatic shutdown
-#define SHUTDOWNRETRY        360 // seconds before trying again to shut down
-#define SHUTDOWNFORCEPROMPT    5 // seconds to wait in user prompt to allow forcing shutdown
-#define SHUTDOWNCANCELPROMPT   5 // seconds to wait in user prompt to allow canceling shutdown
-#define RESTARTCANCELPROMPT    5 // seconds to wait in user prompt before restarting on SIGHUP
-#define MANUALSTART          600 // seconds the next timer must be in the future to assume manual start
-#define CHANNELSAVEDELTA     600 // seconds before saving channels.conf after automatic modifications
-#define DEVICEREADYTIMEOUT    30 // seconds to wait until all devices are ready
-#define MENUTIMEOUT          120 // seconds of user inactivity after which an OSD display is closed
-#define TIMERCHECKDELTA       10 // seconds between checks for timers that need to see their channel
-#define TIMERDEVICETIMEOUT     8 // seconds before a device used for timer check may be reused
-#define TIMERLOOKAHEADTIME    60 // seconds before a non-VPS timer starts and the channel is switched if possible
-#define VPSLOOKAHEADTIME      24 // hours within which VPS timers will make sure their events are up to date
-#define VPSUPTODATETIME     3600 // seconds before the event or schedule of a VPS timer needs to be refreshed
-
-#define EXIT(v) { ShutdownHandler.Exit(v); goto Exit; }
-
-static int LastSignal = 0;
-
-static bool SetUser(const char *UserName, bool UserDump)//XXX name?
-{
-  if (UserName) {
-     struct passwd *user = getpwnam(UserName);
-     if (!user) {
-        fprintf(stderr, "vdr: unknown user: '%s'\n", UserName);
-        return false;
-        }
-     if (setgid(user->pw_gid) < 0) {
-        fprintf(stderr, "vdr: cannot set group id %u: %s\n", (unsigned int)user->pw_gid, strerror(errno));
-        return false;
-        }
-     if (initgroups(user->pw_name, user->pw_gid) < 0) {
-        fprintf(stderr, "vdr: cannot set supplemental group ids for user %s: %s\n", user->pw_name, strerror(errno));
-        return false;
-        }
-     if (setuid(user->pw_uid) < 0) {
-        fprintf(stderr, "vdr: cannot set user id %u: %s\n", (unsigned int)user->pw_uid, strerror(errno));
-        return false;
-        }
-     if (UserDump && prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) < 0)
-        fprintf(stderr, "vdr: warning - cannot set dumpable: %s\n", strerror(errno));
-     }
-  return true;
-}
-
-static bool DropCaps(void)
-{
-  // drop all capabilities except selected ones
-  cap_t caps = cap_from_text("= cap_sys_nice,cap_sys_time,cap_net_raw=ep");
-  if (!caps) {
-     fprintf(stderr, "vdr: cap_from_text failed: %s\n", strerror(errno));
-     return false;
-     }
-  if (cap_set_proc(caps) == -1) {
-     fprintf(stderr, "vdr: cap_set_proc failed: %s\n", strerror(errno));
-     cap_free(caps);
-     return false;
-     }
-  cap_free(caps);
-  return true;
-}
-
-static bool SetKeepCaps(bool On)
-{
-  // set keeping capabilities during setuid() on/off
-  if (prctl(PR_SET_KEEPCAPS, On ? 1 : 0, 0, 0, 0) != 0) {
-     fprintf(stderr, "vdr: prctl failed\n");
-     return false;
-     }
-  return true;
-}
-
-static void SignalHandler(int signum)
-{
-  switch (signum) {
-    case SIGPIPE:
-         break;
-    case SIGHUP:
-         LastSignal = signum;
-         break;
-    default:
-         LastSignal = signum;
-         Interface->Interrupt();
-         ShutdownHandler.Exit(0);
-    }
-  signal(signum, SignalHandler);
-}
-
-static void Watchdog(int signum)
-{
-  // Something terrible must have happened that prevented the 'alarm()' from
-  // being called in time, so let's get out of here:
-  esyslog("PANIC: watchdog timer expired - exiting!");
-  exit(1);
-}
-
-int main(int argc, char *argv[])
-{
-  // Save terminal settings:
-
-  struct termios savedTm;
-  bool HasStdin = (tcgetpgrp(STDIN_FILENO) == getpid() || getppid() != (pid_t)1) && tcgetattr(STDIN_FILENO, &savedTm) == 0;
-
-  // Initiate locale:
-
-  setlocale(LC_ALL, "");
-
-  // Command line options:
-
-#define dd(a, b) (*a ? a : b)
-#define DEFAULTSVDRPPORT 6419
-#define DEFAULTWATCHDOG     0 // seconds
-#define DEFAULTVIDEODIR VIDEODIR
-#define DEFAULTCONFDIR dd(CONFDIR, VideoDirectory)
-#define DEFAULTCACHEDIR dd(CACHEDIR, VideoDirectory)
-#define DEFAULTRESDIR dd(RESDIR, ConfigDirectory)
-#define DEFAULTPLUGINDIR PLUGINDIR
-#define DEFAULTLOCDIR LOCDIR
-#define DEFAULTEPGDATAFILENAME "epg.data"
-
-  bool StartedAsRoot = false;
-  const char *VdrUser = NULL;
-  bool UserDump = false;
-  int SVDRPport = DEFAULTSVDRPPORT;
-  const char *AudioCommand = NULL;
-  const char *VideoDirectory = DEFAULTVIDEODIR;
-  const char *ConfigDirectory = NULL;
-  const char *CacheDirectory = NULL;
-  const char *ResourceDirectory = NULL;
-  const char *LocaleDirectory = DEFAULTLOCDIR;
-  const char *EpgDataFileName = DEFAULTEPGDATAFILENAME;
-  bool DisplayHelp = false;
-  bool DisplayVersion = false;
-  bool DaemonMode = false;
-  int SysLogTarget = LOG_USER;
-  bool MuteAudio = false;
-  int WatchdogTimeout = DEFAULTWATCHDOG;
-  const char *Terminal = NULL;
-
-  bool UseKbd = true;
-  const char *LircDevice = NULL;
-#if !defined(REMOTE_KBD)
-  UseKbd = false;
-#endif
-#if defined(REMOTE_LIRC)
-  LircDevice = LIRC_DEVICE;
-#endif
-#if defined(VDR_USER)
-  VdrUser = VDR_USER;
-#endif
-
-  cPluginManager PluginManager(DEFAULTPLUGINDIR);
-
-  static struct option long_options[] = {
-      { "audio",    required_argument, NULL, 'a' },
-      { "cachedir", required_argument, NULL, 'c' | 0x100 },
-      { "config",   required_argument, NULL, 'c' },
-      { "daemon",   no_argument,       NULL, 'd' },
-      { "device",   required_argument, NULL, 'D' },
-      { "dirnames", required_argument, NULL, 'd' | 0x100 },
-      { "edit",     required_argument, NULL, 'e' | 0x100 },
-      { "epgfile",  required_argument, NULL, 'E' },
-      { "filesize", required_argument, NULL, 'f' | 0x100 },
-      { "genindex", required_argument, NULL, 'g' | 0x100 },
-      { "grab",     required_argument, NULL, 'g' },
-      { "help",     no_argument,       NULL, 'h' },
-      { "instance", required_argument, NULL, 'i' },
-#ifdef VDRDEBUG
-      { "keep-plugins", no_argument,   NULL, 'k' },
-#endif
-      { "lib",      required_argument, NULL, 'L' },
-      { "lirc",     optional_argument, NULL, 'l' | 0x100 },
-      { "localedir",required_argument, NULL, 'l' | 0x200 },
-      { "log",      required_argument, NULL, 'l' },
-      { "mute",     no_argument,       NULL, 'm' },
-      { "no-kbd",   no_argument,       NULL, 'n' | 0x100 },
-      { "plugin",   required_argument, NULL, 'P' },
-      { "port",     required_argument, NULL, 'p' },
-      { "record",   required_argument, NULL, 'r' },
-      { "resdir",   required_argument, NULL, 'r' | 0x100 },
-      { "shutdown", required_argument, NULL, 's' },
-      { "split",    no_argument,       NULL, 's' | 0x100 },
-      { "terminal", required_argument, NULL, 't' },
-      { "user",     required_argument, NULL, 'u' },
-      { "userdump", no_argument,       NULL, 'u' | 0x100 },
-      { "version",  no_argument,       NULL, 'V' },
-      { "vfat",     no_argument,       NULL, 'v' | 0x100 },
-      { "video",    required_argument, NULL, 'v' },
-      { "watchdog", required_argument, NULL, 'w' },
-      { NULL,       no_argument,       NULL,  0  }
-    };
-
-  int c;
-  while ((c = getopt_long(argc, argv, "a:c:dD:e:E:g:hi:kl:L:mp:P:r:s:t:u:v:Vw:", long_options, NULL)) != -1) {
-        switch (c) {
-          case 'a': AudioCommand = optarg;
-                    break;
-          case 'c' | 0x100:
-                    CacheDirectory = optarg;
-                    break;
-          case 'c': ConfigDirectory = optarg;
-                    break;
-          case 'd': DaemonMode = true;
-                    break;
-          case 'D': if (isnumber(optarg)) {
-                       int n = atoi(optarg);
-                       if (0 <= n && n < MAXDEVICES) {
-                          cDevice::SetUseDevice(n);
-                          break;
-                          }
-                       }
-                    fprintf(stderr, "vdr: invalid DVB device number: %s\n", optarg);
-                    return 2;
-          case 'd' | 0x100: {
-                    char *s = optarg;
-                    int n = strtol(s, &s, 10);
-                    if (n <= 0 || n >= PATH_MAX) {
-                       fprintf(stderr, "vdr: invalid directory path length: %s\n", optarg);
-                       return 2;
-                       }
-                    DirectoryPathMax = n;
-                    if (!*s)
-                       break;
-                    if (*s++ != ',') {
-                       fprintf(stderr, "vdr: invalid delimiter: %s\n", optarg);
-                       return 2;
-                       }
-                    n = strtol(s, &s, 10);
-                    if (n <= 0 || n >= NAME_MAX) {
-                       fprintf(stderr, "vdr: invalid directory name length: %s\n", optarg);
-                       return 2;
-                       }
-                    DirectoryNameMax = n;
-                    if (!*s)
-                       break;
-                    if (*s++ != ',') {
-                       fprintf(stderr, "vdr: invalid delimiter: %s\n", optarg);
-                       return 2;
-                       }
-                    n = strtol(s, &s, 10);
-                    if (n != 0 && n != 1) {
-                       fprintf(stderr, "vdr: invalid directory encoding: %s\n", optarg);
-                       return 2;
-                       }
-                    DirectoryEncoding = n;
-                    if (*s) {
-                       fprintf(stderr, "vdr: unexpected data: %s\n", optarg);
-                       return 2;
-                       }
-                    }
-                    break;
-          case 'e' | 0x100:
-                    return CutRecording(optarg) ? 0 : 2;
-          case 'E': EpgDataFileName = (*optarg != '-' ? optarg : NULL);
-                    break;
-          case 'f' | 0x100:
-                    Setup.MaxVideoFileSize = StrToNum(optarg) / MEGABYTE(1);
-                    if (Setup.MaxVideoFileSize < MINVIDEOFILESIZE)
-                       Setup.MaxVideoFileSize = MINVIDEOFILESIZE;
-                    if (Setup.MaxVideoFileSize > MAXVIDEOFILESIZETS)
-                       Setup.MaxVideoFileSize = MAXVIDEOFILESIZETS;
-                    break;
-          case 'g' | 0x100:
-                    return GenerateIndex(optarg) ? 0 : 2;
-          case 'g': cSVDRP::SetGrabImageDir(*optarg != '-' ? optarg : NULL);
-                    break;
-          case 'h': DisplayHelp = true;
-                    break;
-          case 'i': if (isnumber(optarg)) {
-                       InstanceId = atoi(optarg);
-                       if (InstanceId >= 0)
-                          break;
-                       }
-                    fprintf(stderr, "vdr: invalid instance id: %s\n", optarg);
-                    return 2;
-#ifdef VDRDEBUG
-          case 'k': cDll::keepPlugins = true;
-                    break;
-#endif
-          case 'l': {
-                    char *p = strchr(optarg, '.');
-                    if (p)
-                       *p = 0;
-                    if (isnumber(optarg)) {
-                       int l = atoi(optarg);
-                       if (0 <= l && l <= 3) {
-                          SysLogLevel = l;
-                          if (!p)
-                             break;
-                          if (isnumber(p + 1)) {
-                             int l = atoi(p + 1);
-                             if (0 <= l && l <= 7) {
-                                int targets[] = { LOG_LOCAL0, LOG_LOCAL1, LOG_LOCAL2, LOG_LOCAL3, LOG_LOCAL4, LOG_LOCAL5, LOG_LOCAL6, LOG_LOCAL7 };
-                                SysLogTarget = targets[l];
-                                break;
-                                }
-                             }
-                          }
-                       }
-                    if (p)
-                       *p = '.';
-                    fprintf(stderr, "vdr: invalid log level: %s\n", optarg);
-                    return 2;
-                    }
-          case 'L': if (access(optarg, R_OK | X_OK) == 0)
-                       PluginManager.SetDirectory(optarg);
-                    else {
-                       fprintf(stderr, "vdr: can't access plugin directory: %s\n", optarg);
-                       return 2;
-                       }
-                    break;
-          case 'l' | 0x100:
-                    LircDevice = optarg ? optarg : LIRC_DEVICE;
-                    break;
-          case 'l' | 0x200:
-                    if (access(optarg, R_OK | X_OK) == 0)
-                       LocaleDirectory = optarg;
-                    else {
-                       fprintf(stderr, "vdr: can't access locale directory: %s\n", optarg);
-                       return 2;
-                       }
-                    break;
-          case 'm': MuteAudio = true;
-                    break;
-          case 'n' | 0x100:
-                    UseKbd = false;
-                    break;
-          case 'p': if (isnumber(optarg))
-                       SVDRPport = atoi(optarg);
-                    else {
-                       fprintf(stderr, "vdr: invalid port number: %s\n", optarg);
-                       return 2;
-                       }
-                    break;
-          case 'P': PluginManager.AddPlugin(optarg);
-                    break;
-          case 'r': cRecordingUserCommand::SetCommand(optarg);
-                    break;
-          case 'r' | 0x100:
-                    ResourceDirectory = optarg;
-                    break;
-          case 's': ShutdownHandler.SetShutdownCommand(optarg);
-                    break;
-          case 's' | 0x100:
-                    Setup.SplitEditedFiles = 1;
-                    break;
-          case 't': Terminal = optarg;
-                    if (access(Terminal, R_OK | W_OK) < 0) {
-                       fprintf(stderr, "vdr: can't access terminal: %s\n", Terminal);
-                       return 2;
-                       }
-                    break;
-          case 'u': if (*optarg)
-                       VdrUser = optarg;
-                    break;
-          case 'u' | 0x100:
-                    UserDump = true;
-                    break;
-          case 'V': DisplayVersion = true;
-                    break;
-          case 'v' | 0x100:
-                    DirectoryPathMax = 250;
-                    DirectoryNameMax = 40;
-                    DirectoryEncoding = true;
-                    break;
-          case 'v': VideoDirectory = optarg;
-                    while (optarg && *optarg && optarg[strlen(optarg) - 1] == '/')
-                          optarg[strlen(optarg) - 1] = 0;
-                    break;
-          case 'w': if (isnumber(optarg)) {
-                       int t = atoi(optarg);
-                       if (t >= 0) {
-                          WatchdogTimeout = t;
-                          break;
-                          }
-                       }
-                    fprintf(stderr, "vdr: invalid watchdog timeout: %s\n", optarg);
-                    return 2;
-          default:  return 2;
-          }
-        }
-
-  // Set user id in case we were started as root:
-
-  if (VdrUser && geteuid() == 0) {
-     StartedAsRoot = true;
-     if (strcmp(VdrUser, "root")) {
-        if (!SetKeepCaps(true))
-           return 2;
-        if (!SetUser(VdrUser, UserDump))
-           return 2;
-        if (!SetKeepCaps(false))
-           return 2;
-        if (!DropCaps())
-           return 2;
-        }
-     }
-
-  // Help and version info:
-
-  if (DisplayHelp || DisplayVersion) {
-     if (!PluginManager.HasPlugins())
-        PluginManager.AddPlugin("*"); // adds all available plugins
-     PluginManager.LoadPlugins();
-     if (DisplayHelp) {
-        printf("Usage: vdr [OPTIONS]\n\n"          // for easier orientation, this is column 80|
-               "  -a CMD,   --audio=CMD    send Dolby Digital audio to stdin of command CMD\n"
-               "            --cachedir=DIR save cache files in DIR (default: %s)\n"
-               "  -c DIR,   --config=DIR   read config files from DIR (default: %s)\n"
-               "  -d,       --daemon       run in daemon mode\n"
-               "  -D NUM,   --device=NUM   use only the given DVB device (NUM = 0, 1, 2...)\n"
-               "                           there may be several -D options (default: all DVB\n"
-               "                           devices will be used)\n"
-               "            --dirnames=PATH[,NAME[,ENC]]\n"
-               "                           set the maximum directory path length to PATH\n"
-               "                           (default: %d); if NAME is also given, it defines\n"
-               "                           the maximum directory name length (default: %d);\n"
-               "                           the optional ENC can be 0 or 1, and controls whether\n"
-               "                           special characters in directory names are encoded as\n"
-               "                           hex values (default: 0)\n"
-               "            --edit=REC     cut recording REC and exit\n"
-               "  -E FILE,  --epgfile=FILE write the EPG data into the given FILE (default is\n"
-               "                           '%s' in the video directory)\n"
-               "                           '-E-' disables this\n"
-               "                           if FILE is a directory, the default EPG file will be\n"
-               "                           created in that directory\n"
-               "            --filesize=SIZE limit video files to SIZE bytes (default is %dM)\n"
-               "                           only useful in conjunction with --edit\n"
-               "            --genindex=REC generate index for recording REC and exit\n"
-               "  -g DIR,   --grab=DIR     write images from the SVDRP command GRAB into the\n"
-               "                           given DIR; DIR must be the full path name of an\n"
-               "                           existing directory, without any \"..\", double '/'\n"
-               "                           or symlinks (default: none, same as -g-)\n"
-               "  -h,       --help         print this help and exit\n"
-               "  -i ID,    --instance=ID  use ID as the id of this VDR instance (default: 0)\n"
-#ifdef VDRDEBUG
-               "  -k        --keep-plugins Support valgrind by not unloading plugins\n"
-#endif
-               "  -l LEVEL, --log=LEVEL    set log level (default: 3)\n"
-               "                           0 = no logging, 1 = errors only,\n"
-               "                           2 = errors and info, 3 = errors, info and debug\n"
-               "                           if logging should be done to LOG_LOCALn instead of\n"
-               "                           LOG_USER, add '.n' to LEVEL, as in 3.7 (n=0..7)\n"
-               "  -L DIR,   --lib=DIR      search for plugins in DIR (default is %s)\n"
-               "            --lirc[=PATH]  use a LIRC remote control device, attached to PATH\n"
-               "                           (default: %s)\n"
-               "            --localedir=DIR search for locale files in DIR (default is\n"
-               "                           %s)\n"
-               "  -m,       --mute         mute audio of the primary DVB device at startup\n"
-               "            --no-kbd       don't use the keyboard as an input device\n"
-               "  -p PORT,  --port=PORT    use PORT for SVDRP (default: %d)\n"
-               "                           0 turns off SVDRP\n"
-               "  -P OPT,   --plugin=OPT   load a plugin defined by the given options\n"
-               "  -r CMD,   --record=CMD   call CMD before and after a recording, and after\n"
-               "                           a recording has been edited or deleted\n"
-               "            --resdir=DIR   read resource files from DIR (default: %s)\n"
-               "  -s CMD,   --shutdown=CMD call CMD to shutdown the computer\n"
-               "            --split        split edited files at the editing marks (only\n"
-               "                           useful in conjunction with --edit)\n"
-               "  -t TTY,   --terminal=TTY controlling tty\n"
-               "  -u USER,  --user=USER    run as user USER; only applicable if started as\n"
-               "                           root\n"
-               "            --userdump     allow coredumps if -u is given (debugging)\n"
-               "  -v DIR,   --video=DIR    use DIR as video directory (default: %s)\n"
-               "  -V,       --version      print version information and exit\n"
-               "            --vfat         for backwards compatibility (same as\n"
-               "                           --dirnames=250,40,1\n"
-               "  -w SEC,   --watchdog=SEC activate the watchdog timer with a timeout of SEC\n"
-               "                           seconds (default: %d); '0' disables the watchdog\n"
-               "\n",
-               DEFAULTCACHEDIR,
-               DEFAULTCONFDIR,
-               PATH_MAX,
-               NAME_MAX,
-               DEFAULTEPGDATAFILENAME,
-               MAXVIDEOFILESIZEDEFAULT,
-               DEFAULTPLUGINDIR,
-               LIRC_DEVICE,
-               DEFAULTLOCDIR,
-               DEFAULTSVDRPPORT,
-               DEFAULTRESDIR,
-               DEFAULTVIDEODIR,
-               DEFAULTWATCHDOG
-               );
-        }
-     if (DisplayVersion)
-        printf("vdr (%s/%s) - The Video Disk Recorder\n", VDRVERSION, APIVERSION);
-     if (PluginManager.HasPlugins()) {
-        if (DisplayHelp)
-           printf("Plugins: vdr -P\"name [OPTIONS]\"\n\n");
-        for (int i = 0; ; i++) {
-            cPlugin *p = PluginManager.GetPlugin(i);
-            if (p) {
-               const char *help = p->CommandLineHelp();
-               printf("%s (%s) - %s\n", p->Name(), p->Version(), p->Description());
-               if (DisplayHelp && help) {
-                  printf("\n");
-                  puts(help);
-                  }
-               }
-            else
-               break;
-            }
-        }
-     return 0;
-     }
-
-  // Log file:
-
-  if (SysLogLevel > 0)
-     openlog("vdr", LOG_CONS, SysLogTarget); // LOG_PID doesn't work as expected under NPTL
-
-  // Check the video directory:
-
-  if (!DirectoryOk(VideoDirectory, true)) {
-     fprintf(stderr, "vdr: can't access video directory %s\n", VideoDirectory);
-     return 2;
-     }
-
-  // Daemon mode:
-
-  if (DaemonMode) {
-     if (daemon(1, 0) == -1) {
-        fprintf(stderr, "vdr: %m\n");
-        esyslog("ERROR: %m");
-        return 2;
-        }
-     }
-  else if (Terminal) {
-     // Claim new controlling terminal
-     stdin  = freopen(Terminal, "r", stdin);
-     stdout = freopen(Terminal, "w", stdout);
-     stderr = freopen(Terminal, "w", stderr);
-     HasStdin = true;
-     tcgetattr(STDIN_FILENO, &savedTm);
-     }
-
-  isyslog("VDR version %s started", VDRVERSION);
-  if (StartedAsRoot && VdrUser)
-     isyslog("switched to user '%s'", VdrUser);
-  if (DaemonMode)
-     dsyslog("running as daemon (tid=%d)", cThread::ThreadId());
-  cThread::SetMainThreadId();
-
-  // Set the system character table:
-
-  char *CodeSet = NULL;
-  if (setlocale(LC_CTYPE, ""))
-     CodeSet = nl_langinfo(CODESET);
-  else {
-     char *LangEnv = getenv("LANG"); // last resort in case locale stuff isn't installed
-     if (LangEnv) {
-        CodeSet = strchr(LangEnv, '.');
-        if (CodeSet)
-           CodeSet++; // skip the dot
-        }
-     }
-  if (CodeSet) {
-     bool known = SI::SetSystemCharacterTable(CodeSet);
-     isyslog("codeset is '%s' - %s", CodeSet, known ? "known" : "unknown");
-     cCharSetConv::SetSystemCharacterTable(CodeSet);
-     }
-
-  // Initialize internationalization:
-
-  I18nInitialize(LocaleDirectory);
-
-  // Main program loop variables - need to be here to have them initialized before any EXIT():
-
-  cEpgDataReader EpgDataReader;
-  cOsdObject *Menu = NULL;
-  int LastChannel = 0;
-  int LastTimerChannel = -1;
-  int PreviousChannel[2] = { 1, 1 };
-  int PreviousChannelIndex = 0;
-  time_t LastChannelChanged = time(NULL);
-  time_t LastInteract = 0;
-  int MaxLatencyTime = 0;
-  bool InhibitEpgScan = false;
-  bool IsInfoMenu = false;
-  cSkin *CurrentSkin = NULL;
-
-  // Load plugins:
-
-  if (!PluginManager.LoadPlugins(true))
-     EXIT(2);
-
-  // Directories:
-
-  SetVideoDirectory(VideoDirectory);
-  if (!ConfigDirectory)
-     ConfigDirectory = DEFAULTCONFDIR;
-  cPlugin::SetConfigDirectory(ConfigDirectory);
-  if (!CacheDirectory)
-     CacheDirectory = DEFAULTCACHEDIR;
-  cPlugin::SetCacheDirectory(CacheDirectory);
-  if (!ResourceDirectory)
-     ResourceDirectory = DEFAULTRESDIR;
-  cPlugin::SetResourceDirectory(ResourceDirectory);
-  cThemes::SetThemesDirectory(AddDirectory(ConfigDirectory, "themes"));
-
-  // Configuration data:
-
-  Setup.Load(AddDirectory(ConfigDirectory, "setup.conf"));
-  Sources.Load(AddDirectory(ConfigDirectory, "sources.conf"), true, true);
-  Diseqcs.Load(AddDirectory(ConfigDirectory, "diseqc.conf"), true, Setup.DiSEqC);
-  Scrs.Load(AddDirectory(ConfigDirectory, "scr.conf"), true);
-  Channels.Load(AddDirectory(ConfigDirectory, "channels.conf"), false, true);
-  Timers.Load(AddDirectory(ConfigDirectory, "timers.conf"));
-  Commands.Load(AddDirectory(ConfigDirectory, "commands.conf"));
-  RecordingCommands.Load(AddDirectory(ConfigDirectory, "reccmds.conf"));
-  SVDRPhosts.Load(AddDirectory(ConfigDirectory, "svdrphosts.conf"), true);
-  Keys.Load(AddDirectory(ConfigDirectory, "remote.conf"));
-  KeyMacros.Load(AddDirectory(ConfigDirectory, "keymacros.conf"), true);
-  Folders.Load(AddDirectory(ConfigDirectory, "folders.conf"));
-
-  if (!*cFont::GetFontFileName(Setup.FontOsd)) {
-     const char *msg = "no fonts available - OSD will not show any text!";
-     fprintf(stderr, "vdr: %s\n", msg);
-     esyslog("ERROR: %s", msg);
-     }
-
-  // Recordings:
-
-  Recordings.Update();
-  DeletedRecordings.Update();
-
-  // EPG data:
-
-  if (EpgDataFileName) {
-     const char *EpgDirectory = NULL;
-     if (DirectoryOk(EpgDataFileName)) {
-        EpgDirectory = EpgDataFileName;
-        EpgDataFileName = DEFAULTEPGDATAFILENAME;
-        }
-     else if (*EpgDataFileName != '/' && *EpgDataFileName != '.')
-        EpgDirectory = CacheDirectory;
-     if (EpgDirectory)
-        cSchedules::SetEpgDataFileName(AddDirectory(EpgDirectory, EpgDataFileName));
-     else
-        cSchedules::SetEpgDataFileName(EpgDataFileName);
-     EpgDataReader.Start();
-     }
-
-  // DVB interfaces:
-
-  cDvbDevice::Initialize();
-  cDvbDevice::BondDevices(Setup.DeviceBondings);
-
-  // Initialize plugins:
-
-  if (!PluginManager.InitializePlugins())
-     EXIT(2);
-
-  // Primary device:
-
-  cDevice::SetPrimaryDevice(Setup.PrimaryDVB);
-  if (!cDevice::PrimaryDevice() || !cDevice::PrimaryDevice()->HasDecoder()) {
-     if (cDevice::PrimaryDevice() && !cDevice::PrimaryDevice()->HasDecoder())
-        isyslog("device %d has no MPEG decoder", cDevice::PrimaryDevice()->DeviceNumber() + 1);
-     for (int i = 0; i < cDevice::NumDevices(); i++) {
-         cDevice *d = cDevice::GetDevice(i);
-         if (d && d->HasDecoder()) {
-            isyslog("trying device number %d instead", i + 1);
-            if (cDevice::SetPrimaryDevice(i + 1)) {
-               Setup.PrimaryDVB = i + 1;
-               break;
-               }
-            }
-         }
-     if (!cDevice::PrimaryDevice()) {
-        const char *msg = "no primary device found - using first device!";
-        fprintf(stderr, "vdr: %s\n", msg);
-        esyslog("ERROR: %s", msg);
-        if (!cDevice::SetPrimaryDevice(1))
-           EXIT(2);
-        if (!cDevice::PrimaryDevice()) {
-           const char *msg = "no primary device found - giving up!";
-           fprintf(stderr, "vdr: %s\n", msg);
-           esyslog("ERROR: %s", msg);
-           EXIT(2);
-           }
-        }
-     }
-
-  // Check for timers in automatic start time window:
-
-  ShutdownHandler.CheckManualStart(MANUALSTART);
-
-  // User interface:
-
-  Interface = new cInterface(SVDRPport);
-
-  // Default skins:
-
-  new cSkinLCARS;
-  new cSkinSTTNG;
-  new cSkinClassic;
-  Skins.SetCurrent(Setup.OSDSkin);
-  cThemes::Load(Skins.Current()->Name(), Setup.OSDTheme, Skins.Current()->Theme());
-  CurrentSkin = Skins.Current();
-
-  // Start plugins:
-
-  if (!PluginManager.StartPlugins())
-     EXIT(2);
-
-  // Set skin and theme in case they're implemented by a plugin:
-
-  if (!CurrentSkin || CurrentSkin == Skins.Current() && strcmp(Skins.Current()->Name(), Setup.OSDSkin) != 0) {
-     Skins.SetCurrent(Setup.OSDSkin);
-     cThemes::Load(Skins.Current()->Name(), Setup.OSDTheme, Skins.Current()->Theme());
-     }
-
-  // Remote Controls:
-  if (LircDevice)
-     new cLircRemote(LircDevice);
-  if (!DaemonMode && HasStdin && UseKbd)
-     new cKbdRemote;
-  Interface->LearnKeys();
-
-  // External audio:
-
-  if (AudioCommand)
-     new cExternalAudio(AudioCommand);
-
-  // Channel:
-
-  if (!cDevice::WaitForAllDevicesReady(DEVICEREADYTIMEOUT))
-     dsyslog("not all devices ready after %d seconds", DEVICEREADYTIMEOUT);
-  if (*Setup.InitialChannel) {
-     if (isnumber(Setup.InitialChannel)) { // for compatibility with old setup.conf files
-        if (cChannel *Channel = Channels.GetByNumber(atoi(Setup.InitialChannel)))
-           Setup.InitialChannel = Channel->GetChannelID().ToString();
-        }
-     if (cChannel *Channel = Channels.GetByChannelID(tChannelID::FromString(Setup.InitialChannel)))
-        Setup.CurrentChannel = Channel->Number();
-     }
-  if (Setup.InitialVolume >= 0)
-     Setup.CurrentVolume = Setup.InitialVolume;
-  Channels.SwitchTo(Setup.CurrentChannel);
-  if (MuteAudio)
-     cDevice::PrimaryDevice()->ToggleMute();
-  else
-     cDevice::PrimaryDevice()->SetVolume(Setup.CurrentVolume, true);
-
-  // Signal handlers:
-
-  if (signal(SIGHUP,  SignalHandler) == SIG_IGN) signal(SIGHUP,  SIG_IGN);
-  if (signal(SIGINT,  SignalHandler) == SIG_IGN) signal(SIGINT,  SIG_IGN);
-  if (signal(SIGTERM, SignalHandler) == SIG_IGN) signal(SIGTERM, SIG_IGN);
-  if (signal(SIGPIPE, SignalHandler) == SIG_IGN) signal(SIGPIPE, SIG_IGN);
-  if (WatchdogTimeout > 0)
-     if (signal(SIGALRM, Watchdog)   == SIG_IGN) signal(SIGALRM, SIG_IGN);
-
-  // Watchdog:
-
-  if (WatchdogTimeout > 0) {
-     dsyslog("setting watchdog timer to %d seconds", WatchdogTimeout);
-     alarm(WatchdogTimeout); // Initial watchdog timer start
-     }
-
-  // Main program loop:
-
-#define DELETE_MENU ((IsInfoMenu &= (Menu == NULL)), delete Menu, Menu = NULL)
-
-  while (!ShutdownHandler.DoExit()) {
-#ifdef DEBUGRINGBUFFERS
-        cRingBufferLinear::PrintDebugRBL();
-#endif
-        // Attach launched player control:
-        cControl::Attach();
-
-        time_t Now = time(NULL);
-
-        // Make sure we have a visible programme in case device usage has changed:
-        if (!EITScanner.Active() && cDevice::PrimaryDevice()->HasDecoder()) {
-           static time_t lastTime = 0;
-           if (!cDevice::PrimaryDevice()->HasProgramme()) {
-              if (!CamMenuActive() && Now - lastTime > MINCHANNELWAIT) { // !CamMenuActive() to avoid interfering with the CAM if a CAM menu is open
-                 cChannel *Channel = Channels.GetByNumber(cDevice::CurrentChannel());
-                 if (Channel && (Channel->Vpid() || Channel->Apid(0) || Channel->Dpid(0))) {
-                    if (cDevice::GetDeviceForTransponder(Channel, LIVEPRIORITY) && Channels.SwitchTo(Channel->Number())) // try to switch to the original channel...
-                       ;
-                    else if (LastTimerChannel > 0) {
-                       Channel = Channels.GetByNumber(LastTimerChannel);
-                       if (Channel && cDevice::GetDeviceForTransponder(Channel, LIVEPRIORITY) && Channels.SwitchTo(LastTimerChannel)) // ...or the one used by the last timer
-                          ;
-                       }
-                    }
-                 lastTime = Now; // don't do this too often
-                 LastTimerChannel = -1;
-                 }
-              }
-           else
-              lastTime = 0; // makes sure we immediately try again next time
-           }
-        // Update the OSD size:
-        {
-          static time_t lastOsdSizeUpdate = 0;
-          if (Now != lastOsdSizeUpdate) { // once per second
-             cOsdProvider::UpdateOsdSize();
-             lastOsdSizeUpdate = Now;
-             }
-        }
-        // Restart the Watchdog timer:
-        if (WatchdogTimeout > 0) {
-           int LatencyTime = WatchdogTimeout - alarm(WatchdogTimeout);
-           if (LatencyTime > MaxLatencyTime) {
-              MaxLatencyTime = LatencyTime;
-              dsyslog("max. latency time %d seconds", MaxLatencyTime);
-              }
-           }
-        // Handle channel and timer modifications:
-        if (!Channels.BeingEdited() && !Timers.BeingEdited()) {
-           int modified = Channels.Modified();
-           static time_t ChannelSaveTimeout = 0;
-           static int TimerState = 0;
-           // Channels and timers need to be stored in a consistent manner,
-           // therefore if one of them is changed, we save both.
-           if (modified == CHANNELSMOD_USER || Timers.Modified(TimerState))
-              ChannelSaveTimeout = 1; // triggers an immediate save
-           else if (modified && !ChannelSaveTimeout)
-              ChannelSaveTimeout = Now + CHANNELSAVEDELTA;
-           bool timeout = ChannelSaveTimeout == 1 || ChannelSaveTimeout && Now > ChannelSaveTimeout && !cRecordControls::Active();
-           if ((modified || timeout) && Channels.Lock(false, 100)) {
-              if (timeout) {
-                 Channels.Save();
-                 Timers.Save();
-                 ChannelSaveTimeout = 0;
-                 }
-              for (cChannel *Channel = Channels.First(); Channel; Channel = Channels.Next(Channel)) {
-                  if (Channel->Modification(CHANNELMOD_RETUNE)) {
-                     cRecordControls::ChannelDataModified(Channel);
-                     if (Channel->Number() == cDevice::CurrentChannel()) {
-                        if (!cDevice::PrimaryDevice()->Replaying() || cDevice::PrimaryDevice()->Transferring()) {
-                           if (cDevice::ActualDevice()->ProvidesTransponder(Channel)) { // avoids retune on devices that don't really access the transponder
-                              isyslog("retuning due to modification of channel %d", Channel->Number());
-                              Channels.SwitchTo(Channel->Number());
-                              }
-                           }
-                        }
-                     }
-                  }
-              Channels.Unlock();
-              }
-           }
-        // Channel display:
-        if (!EITScanner.Active() && cDevice::CurrentChannel() != LastChannel) {
-           if (!Menu)
-              Menu = new cDisplayChannel(cDevice::CurrentChannel(), LastChannel >= 0);
-           LastChannel = cDevice::CurrentChannel();
-           LastChannelChanged = Now;
-           }
-        if (Now - LastChannelChanged >= Setup.ZapTimeout && LastChannel != PreviousChannel[PreviousChannelIndex])
-           PreviousChannel[PreviousChannelIndex ^= 1] = LastChannel;
-        // Timers and Recordings:
-        if (!Timers.BeingEdited()) {
-           // Assign events to timers:
-           Timers.SetEvents();
-           // Must do all following calls with the exact same time!
-           // Process ongoing recordings:
-           cRecordControls::Process(Now);
-           // Start new recordings:
-           cTimer *Timer = Timers.GetMatch(Now);
-           if (Timer) {
-              if (!cRecordControls::Start(Timer))
-                 Timer->SetPending(true);
-              else
-                 LastTimerChannel = Timer->Channel()->Number();
-              }
-           // Make sure timers "see" their channel early enough:
-           static time_t LastTimerCheck = 0;
-           if (Now - LastTimerCheck > TIMERCHECKDELTA) { // don't do this too often
-              InhibitEpgScan = false;
-              for (cTimer *Timer = Timers.First(); Timer; Timer = Timers.Next(Timer)) {
-                  bool InVpsMargin = false;
-                  bool NeedsTransponder = false;
-                  if (Timer->HasFlags(tfActive) && !Timer->Recording()) {
-                     if (Timer->HasFlags(tfVps)) {
-                        if (Timer->Matches(Now, true, Setup.VpsMargin)) {
-                           InVpsMargin = true;
-                           Timer->SetInVpsMargin(InVpsMargin);
-                           }
-                        else if (Timer->Event()) {
-                           InVpsMargin = Timer->Event()->StartTime() <= Now && Now < Timer->Event()->EndTime();
-                           NeedsTransponder = Timer->Event()->StartTime() - Now < VPSLOOKAHEADTIME * 3600 && !Timer->Event()->SeenWithin(VPSUPTODATETIME);
-                           }
-                        else {
-                           cSchedulesLock SchedulesLock;
-                           const cSchedules *Schedules = cSchedules::Schedules(SchedulesLock);
-                           if (Schedules) {
-                              const cSchedule *Schedule = Schedules->GetSchedule(Timer->Channel());
-                              InVpsMargin = !Schedule; // we must make sure we have the schedule
-                              NeedsTransponder = Schedule && !Schedule->PresentSeenWithin(VPSUPTODATETIME);
-                              }
-                           }
-                        InhibitEpgScan |= InVpsMargin | NeedsTransponder;
-                        }
-                     else
-                        NeedsTransponder = Timer->Matches(Now, true, TIMERLOOKAHEADTIME);
-                     }
-                  if (NeedsTransponder || InVpsMargin) {
-                     // Find a device that provides the required transponder:
-                     cDevice *Device = cDevice::GetDeviceForTransponder(Timer->Channel(), MINPRIORITY);
-                     if (!Device && InVpsMargin)
-                        Device = cDevice::GetDeviceForTransponder(Timer->Channel(), LIVEPRIORITY);
-                     // Switch the device to the transponder:
-                     if (Device) {
-                        bool HadProgramme = cDevice::PrimaryDevice()->HasProgramme();
-                        if (!Device->IsTunedToTransponder(Timer->Channel())) {
-                           if (Device == cDevice::ActualDevice() && !Device->IsPrimaryDevice())
-                              cDevice::PrimaryDevice()->StopReplay(); // stop transfer mode
-                           dsyslog("switching device %d to channel %d", Device->DeviceNumber() + 1, Timer->Channel()->Number());
-                           if (Device->SwitchChannel(Timer->Channel(), false))
-                              Device->SetOccupied(TIMERDEVICETIMEOUT);
-                           }
-                        if (cDevice::PrimaryDevice()->HasDecoder() && HadProgramme && !cDevice::PrimaryDevice()->HasProgramme())
-                           Skins.QueueMessage(mtInfo, tr("Upcoming recording!")); // the previous SwitchChannel() has switched away the current live channel
-                        }
-                     }
-                  }
-              LastTimerCheck = Now;
-              }
-           // Delete expired timers:
-           Timers.DeleteExpired();
-           }
-        if (!Menu && Recordings.NeedsUpdate()) {
-           Recordings.Update();
-           DeletedRecordings.Update();
-           }
-        // CAM control:
-        if (!Menu && !cOsd::IsOpen())
-           Menu = CamControl();
-        // Queued messages:
-        if (!Skins.IsOpen())
-           Skins.ProcessQueuedMessages();
-        // User Input:
-        cOsdObject *Interact = Menu ? Menu : cControl::Control();
-        eKeys key = Interface->GetKey(!Interact || !Interact->NeedsFastResponse());
-        if (ISREALKEY(key)) {
-           EITScanner.Activity();
-           // Cancel shutdown countdown:
-           if (ShutdownHandler.countdown)
-              ShutdownHandler.countdown.Cancel();
-           // Set user active for MinUserInactivity time in the future:
-           ShutdownHandler.SetUserInactiveTimeout();
-           }
-        // Keys that must work independent of any interactive mode:
-        switch (int(key)) {
-          // Menu control:
-          case kMenu: {
-               key = kNone; // nobody else needs to see this key
-               bool WasOpen = Interact != NULL;
-               bool WasMenu = Interact && Interact->IsMenu();
-               if (Menu)
-                  DELETE_MENU;
-               else if (cControl::Control()) {
-                  if (cOsd::IsOpen())
-                     cControl::Control()->Hide();
-                  else
-                     WasOpen = false;
-                  }
-               if (!WasOpen || !WasMenu && !Setup.MenuKeyCloses)
-                  Menu = new cMenuMain;
-               }
-               break;
-          // Info:
-          case kInfo: {
-               if (IsInfoMenu) {
-                  key = kNone; // nobody else needs to see this key
-                  DELETE_MENU;
-                  }
-               else if (!Menu) {
-                  IsInfoMenu = true;
-                  if (cControl::Control()) {
-                     cControl::Control()->Hide();
-                     Menu = cControl::Control()->GetInfo();
-                     if (Menu)
-                        Menu->Show();
-                     else
-                        IsInfoMenu = false;
-                     }
-                  else {
-                     cRemote::Put(kOk, true);
-                     cRemote::Put(kSchedule, true);
-                     }
-                  key = kNone; // nobody else needs to see this key
-                  }
-               }
-               break;
-          // Direct main menu functions:
-          #define DirectMainFunction(function)\
-            { DELETE_MENU;\
-            if (cControl::Control())\
-               cControl::Control()->Hide();\
-            Menu = new cMenuMain(function);\
-            key = kNone; } // nobody else needs to see this key
-          case kSchedule:   DirectMainFunction(osSchedule); break;
-          case kChannels:   DirectMainFunction(osChannels); break;
-          case kTimers:     DirectMainFunction(osTimers); break;
-          case kRecordings: DirectMainFunction(osRecordings); break;
-          case kSetup:      DirectMainFunction(osSetup); break;
-          case kCommands:   DirectMainFunction(osCommands); break;
-          case kUser0 ... kUser9: cRemote::PutMacro(key); key = kNone; break;
-          case k_Plugin: {
-               const char *PluginName = cRemote::GetPlugin();
-               if (PluginName) {
-                  DELETE_MENU;
-                  if (cControl::Control())
-                     cControl::Control()->Hide();
-                  cPlugin *plugin = cPluginManager::GetPlugin(PluginName);
-                  if (plugin) {
-                     Menu = plugin->MainMenuAction();
-                     if (Menu)
-                        Menu->Show();
-                     }
-                  else
-                     esyslog("ERROR: unknown plugin '%s'", PluginName);
-                  }
-               key = kNone; // nobody else needs to see these keys
-               }
-               break;
-          // Channel up/down:
-          case kChanUp|k_Repeat:
-          case kChanUp:
-          case kChanDn|k_Repeat:
-          case kChanDn:
-               if (!Interact)
-                  Menu = new cDisplayChannel(NORMALKEY(key));
-               else if (cDisplayChannel::IsOpen() || cControl::Control()) {
-                  Interact->ProcessKey(key);
-                  continue;
-                  }
-               else
-                  cDevice::SwitchChannel(NORMALKEY(key) == kChanUp ? 1 : -1);
-               key = kNone; // nobody else needs to see these keys
-               break;
-          // Volume control:
-          case kVolUp|k_Repeat:
-          case kVolUp:
-          case kVolDn|k_Repeat:
-          case kVolDn:
-          case kMute:
-               if (key == kMute) {
-                  if (!cDevice::PrimaryDevice()->ToggleMute() && !Menu) {
-                     key = kNone; // nobody else needs to see these keys
-                     break; // no need to display "mute off"
-                     }
-                  }
-               else
-                  cDevice::PrimaryDevice()->SetVolume(NORMALKEY(key) == kVolDn ? -VOLUMEDELTA : VOLUMEDELTA);
-               if (!Menu && !cOsd::IsOpen())
-                  Menu = cDisplayVolume::Create();
-               cDisplayVolume::Process(key);
-               key = kNone; // nobody else needs to see these keys
-               break;
-          // Audio track control:
-          case kAudio:
-               if (cControl::Control())
-                  cControl::Control()->Hide();
-               if (!cDisplayTracks::IsOpen()) {
-                  DELETE_MENU;
-                  Menu = cDisplayTracks::Create();
-                  }
-               else
-                  cDisplayTracks::Process(key);
-               key = kNone;
-               break;
-          // Subtitle track control:
-          case kSubtitles:
-               if (cControl::Control())
-                  cControl::Control()->Hide();
-               if (!cDisplaySubtitleTracks::IsOpen()) {
-                  DELETE_MENU;
-                  Menu = cDisplaySubtitleTracks::Create();
-                  }
-               else
-                  cDisplaySubtitleTracks::Process(key);
-               key = kNone;
-               break;
-          // Pausing live video:
-          case kPlayPause:
-          case kPause:
-               if (!cControl::Control()) {
-                  DELETE_MENU;
-                  if (Setup.PauseKeyHandling) {
-                     if (Setup.PauseKeyHandling > 1 || Interface->Confirm(tr("Pause live video?"))) {
-                        if (!cRecordControls::PauseLiveVideo())
-                           Skins.QueueMessage(mtError, tr("No free DVB device to record!"));
-                        }
-                     }
-                  key = kNone; // nobody else needs to see this key
-                  }
-               break;
-          // Instant recording:
-          case kRecord:
-               if (!cControl::Control()) {
-                  if (cRecordControls::Start())
-                     Skins.QueueMessage(mtInfo, tr("Recording started"));
-                  key = kNone; // nobody else needs to see this key
-                  }
-               break;
-          // Power off:
-          case kPower:
-               isyslog("Power button pressed");
-               DELETE_MENU;
-               // Check for activity, request power button again if active:
-               if (!ShutdownHandler.ConfirmShutdown(false) && Skins.Message(mtWarning, tr("VDR will shut down later - press Power to force"), SHUTDOWNFORCEPROMPT) != kPower) {
-                  // Not pressed power - set VDR to be non-interactive and power down later:
-                  ShutdownHandler.SetUserInactive();
-                  break;
-                  }
-               // No activity or power button pressed twice - ask for confirmation:
-               if (!ShutdownHandler.ConfirmShutdown(true)) {
-                  // Non-confirmed background activity - set VDR to be non-interactive and power down later:
-                  ShutdownHandler.SetUserInactive();
-                  break;
-                  }
-               // Ask the final question:
-               if (!Interface->Confirm(tr("Press any key to cancel shutdown"), SHUTDOWNCANCELPROMPT, true))
-                  // If final question was canceled, continue to be active:
-                  break;
-               // Ok, now call the shutdown script:
-               ShutdownHandler.DoShutdown(true);
-               // Set VDR to be non-interactive and power down again later:
-               ShutdownHandler.SetUserInactive();
-               // Do not attempt to automatically shut down for a while:
-               ShutdownHandler.SetRetry(SHUTDOWNRETRY);
-               break;
-          default: break;
-          }
-        Interact = Menu ? Menu : cControl::Control(); // might have been closed in the mean time
-        if (Interact) {
-           LastInteract = Now;
-           eOSState state = Interact->ProcessKey(key);
-           if (state == osUnknown && Interact != cControl::Control()) {
-              if (ISMODELESSKEY(key) && cControl::Control()) {
-                 state = cControl::Control()->ProcessKey(key);
-                 if (state == osEnd) {
-                    // let's not close a menu when replay ends:
-                    cControl::Shutdown();
-                    continue;
-                    }
-                 }
-              else if (Now - cRemote::LastActivity() > MENUTIMEOUT)
-                 state = osEnd;
-              }
-           switch (state) {
-             case osPause:  DELETE_MENU;
-                            if (!cRecordControls::PauseLiveVideo())
-                               Skins.QueueMessage(mtError, tr("No free DVB device to record!"));
-                            break;
-             case osRecord: DELETE_MENU;
-                            if (cRecordControls::Start())
-                               Skins.QueueMessage(mtInfo, tr("Recording started"));
-                            break;
-             case osRecordings:
-                            DELETE_MENU;
-                            cControl::Shutdown();
-                            Menu = new cMenuMain(osRecordings);
-                            break;
-             case osReplay: DELETE_MENU;
-                            cControl::Shutdown();
-                            cControl::Launch(new cReplayControl);
-                            break;
-             case osStopReplay:
-                            DELETE_MENU;
-                            cControl::Shutdown();
-                            break;
-             case osSwitchDvb:
-                            DELETE_MENU;
-                            cControl::Shutdown();
-                            Skins.QueueMessage(mtInfo, tr("Switching primary DVB..."));
-                            cDevice::SetPrimaryDevice(Setup.PrimaryDVB);
-                            break;
-             case osPlugin: DELETE_MENU;
-                            Menu = cMenuMain::PluginOsdObject();
-                            if (Menu)
-                               Menu->Show();
-                            break;
-             case osBack:
-             case osEnd:    if (Interact == Menu)
-                               DELETE_MENU;
-                            else
-                               cControl::Shutdown();
-                            break;
-             default:       ;
-             }
-           }
-        else {
-           // Key functions in "normal" viewing mode:
-           if (key != kNone && KeyMacros.Get(key)) {
-              cRemote::PutMacro(key);
-              key = kNone;
-              }
-           switch (int(key)) {
-             // Toggle channels:
-             case kChanPrev:
-             case k0: {
-                  if (PreviousChannel[PreviousChannelIndex ^ 1] == LastChannel || LastChannel != PreviousChannel[0] && LastChannel != PreviousChannel[1])
-                     PreviousChannelIndex ^= 1;
-                  Channels.SwitchTo(PreviousChannel[PreviousChannelIndex ^= 1]);
-                  break;
-                  }
-             // Direct Channel Select:
-             case k1 ... k9:
-             // Left/Right rotates through channel groups:
-             case kLeft|k_Repeat:
-             case kLeft:
-             case kRight|k_Repeat:
-             case kRight:
-             // Previous/Next rotates through channel groups:
-             case kPrev|k_Repeat:
-             case kPrev:
-             case kNext|k_Repeat:
-             case kNext:
-             // Up/Down Channel Select:
-             case kUp|k_Repeat:
-             case kUp:
-             case kDown|k_Repeat:
-             case kDown:
-                  Menu = new cDisplayChannel(NORMALKEY(key));
-                  break;
-             // Viewing Control:
-             case kOk:   LastChannel = -1; break; // forces channel display
-             // Instant resume of the last viewed recording:
-             case kPlay:
-                  if (cReplayControl::LastReplayed()) {
-                     cControl::Shutdown();
-                     cControl::Launch(new cReplayControl);
-                     }
-                  else
-                     DirectMainFunction(osRecordings); // no last viewed recording, so enter the Recordings menu
-                  break;
-             default:    break;
-             }
-           }
-        if (!Menu) {
-           if (!InhibitEpgScan)
-              EITScanner.Process();
-           if (!cCutter::Active() && cCutter::Ended()) {
-              if (cCutter::Error())
-                 Skins.QueueMessage(mtError, tr("Editing process failed!"));
-              else
-                 Skins.QueueMessage(mtInfo, tr("Editing process finished"));
-              }
-           if (!cFileTransfer::Active() && cFileTransfer::Ended()) {
-              if (cFileTransfer::Error())
-                 Skins.QueueMessage(mtError, tr("File transfer failed!"));
-              else
-                 Skins.QueueMessage(mtInfo, tr("File transfer finished"));
-              }
-           }
-
-        // SIGHUP shall cause a restart:
-        if (LastSignal == SIGHUP) {
-           if (ShutdownHandler.ConfirmRestart(true) && Interface->Confirm(tr("Press any key to cancel restart"), RESTARTCANCELPROMPT, true))
-              EXIT(1);
-           LastSignal = 0;
-           }
-
-        // Update the shutdown countdown:
-        if (ShutdownHandler.countdown && ShutdownHandler.countdown.Update()) {
-           if (!ShutdownHandler.ConfirmShutdown(false))
-              ShutdownHandler.countdown.Cancel();
-           }
-
-        if ((Now - LastInteract) > ACTIVITYTIMEOUT && !cRecordControls::Active() && !cCutter::Active() && !cFileTransfer::Active() && !Interface->HasSVDRPConnection() && (Now - cRemote::LastActivity()) > ACTIVITYTIMEOUT) {
-           // Handle housekeeping tasks
-
-           // Shutdown:
-           // Check whether VDR will be ready for shutdown in SHUTDOWNWAIT seconds:
-           time_t Soon = Now + SHUTDOWNWAIT;
-           if (ShutdownHandler.IsUserInactive(Soon) && ShutdownHandler.Retry(Soon) && !ShutdownHandler.countdown) {
-              if (ShutdownHandler.ConfirmShutdown(false))
-                 // Time to shut down - start final countdown:
-                 ShutdownHandler.countdown.Start(tr("VDR will shut down in %s minutes"), SHUTDOWNWAIT); // the placeholder is really %s!
-              // Dont try to shut down again for a while:
-              ShutdownHandler.SetRetry(SHUTDOWNRETRY);
-              }
-           // Countdown run down to 0?
-           if (ShutdownHandler.countdown.Done()) {
-              // Timed out, now do a final check:
-              if (ShutdownHandler.IsUserInactive() && ShutdownHandler.ConfirmShutdown(false))
-                 ShutdownHandler.DoShutdown(false);
-              // Do this again a bit later:
-              ShutdownHandler.SetRetry(SHUTDOWNRETRY);
-              }
-
-           // Disk housekeeping:
-           RemoveDeletedRecordings();
-           cSchedules::Cleanup();
-           // Plugins housekeeping:
-           PluginManager.Housekeeping();
-           }
-
-        ReportEpgBugFixStats();
-
-        // Main thread hooks of plugins:
-        PluginManager.MainThreadHook();
-        }
-
-  if (ShutdownHandler.EmergencyExitRequested())
-     esyslog("emergency exit requested - shutting down");
-
-Exit:
-
-  // Reset all signal handlers to default before Interface gets deleted:
-  signal(SIGHUP,  SIG_DFL);
-  signal(SIGINT,  SIG_DFL);
-  signal(SIGTERM, SIG_DFL);
-  signal(SIGPIPE, SIG_DFL);
-  signal(SIGALRM, SIG_DFL);
-
-  PluginManager.StopPlugins();
-  cRecordControls::Shutdown();
-  cFileTransfer::Stop();
-  cCutter::Stop();
-  delete Menu;
-  cControl::Shutdown();
-  delete Interface;
-  cOsdProvider::Shutdown();
-  Remotes.Clear();
-  Audios.Clear();
-  Skins.Clear();
-  SourceParams.Clear();
-  if (ShutdownHandler.GetExitCode() != 2) {
-     Setup.CurrentChannel = cDevice::CurrentChannel();
-     Setup.CurrentVolume  = cDevice::CurrentVolume();
-     Setup.Save();
-     }
-  cDevice::Shutdown();
-  EpgHandlers.Clear();
-  PluginManager.Shutdown(true);
-  cSchedules::Cleanup(true);
-  ReportEpgBugFixStats(true);
-  if (WatchdogTimeout > 0)
-     dsyslog("max. latency time %d seconds", MaxLatencyTime);
-  if (LastSignal)
-     isyslog("caught signal %d", LastSignal);
-  if (ShutdownHandler.EmergencyExitRequested())
-     esyslog("emergency exit!");
-  isyslog("exiting, exit code %d", ShutdownHandler.GetExitCode());
-  if (SysLogLevel > 0)
-     closelog();
-  if (HasStdin)
-     tcsetattr(STDIN_FILENO, TCSANOW, &savedTm);
-  return ShutdownHandler.GetExitCode();
-}
